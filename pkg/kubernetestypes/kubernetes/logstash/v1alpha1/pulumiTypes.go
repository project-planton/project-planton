// Code generated by crd2pulumi DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package v1alpha1

import (
	"context"
	"reflect"

	metav1 "github.com/pulumi/pulumi-kubernetes/sdk/v4/go/kubernetes/meta/v1"
	"github.com/pulumi/pulumi-kubernetes/sdk/v4/go/kubernetes/utilities"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

var _ = utilities.GetEnvOrDefault

// Logstash is the Schema for the logstashes API
type LogstashType struct {
	ApiVersion *string            `pulumi:"apiVersion"`
	Kind       *string            `pulumi:"kind"`
	Metadata   *metav1.ObjectMeta `pulumi:"metadata"`
	// LogstashSpec defines the desired state of Logstash
	Spec *LogstashSpec `pulumi:"spec"`
	// LogstashStatus defines the observed state of Logstash
	Status *LogstashStatus `pulumi:"status"`
}

type LogstashMetadata struct {
}

// LogstashSpec defines the desired state of Logstash
type LogstashSpec struct {
	// Config holds the Logstash configuration. At most one of [`Config`, `ConfigRef`] can be specified.
	Config map[string]interface{} `pulumi:"config"`
	// ConfigRef contains a reference to an existing Kubernetes Secret holding the Logstash configuration.
	// Logstash settings must be specified as yaml, under a single "logstash.yml" entry. At most one of [`Config`, `ConfigRef`]
	// can be specified.
	ConfigRef *LogstashSpecConfigRef `pulumi:"configRef"`
	Count     *int                   `pulumi:"count"`
	// ElasticsearchRefs are references to Elasticsearch clusters running in the same Kubernetes cluster.
	ElasticsearchRefs []LogstashSpecElasticsearchRefs `pulumi:"elasticsearchRefs"`
	// Image is the Logstash Docker image to deploy. Version and Type have to match the Logstash in the image.
	Image *string `pulumi:"image"`
	// Monitoring enables you to collect and ship log and monitoring data of this Logstash.
	// Metricbeat and Filebeat are deployed in the same Pod as sidecars and each one sends data to one or two different
	// Elasticsearch monitoring clusters running in the same Kubernetes cluster.
	Monitoring *LogstashSpecMonitoring `pulumi:"monitoring"`
	// Pipelines holds the Logstash Pipelines. At most one of [`Pipelines`, `PipelinesRef`] can be specified.
	Pipelines map[string]interface{} `pulumi:"pipelines"`
	// PipelinesRef contains a reference to an existing Kubernetes Secret holding the Logstash Pipelines.
	// Logstash pipelines must be specified as yaml, under a single "pipelines.yml" entry. At most one of [`Pipelines`, `PipelinesRef`]
	// can be specified.
	PipelinesRef *LogstashSpecPipelinesRef `pulumi:"pipelinesRef"`
	// PodTemplate provides customisation options for the Logstash pods.
	PodTemplate map[string]interface{} `pulumi:"podTemplate"`
	// RevisionHistoryLimit is the number of revisions to retain to allow rollback in the underlying StatefulSet.
	RevisionHistoryLimit *int `pulumi:"revisionHistoryLimit"`
	// SecureSettings is a list of references to Kubernetes Secrets containing sensitive configuration options for the Logstash.
	// Secrets data can be then referenced in the Logstash config using the Secret's keys or as specified in `Entries` field of
	// each SecureSetting.
	SecureSettings []LogstashSpecSecureSettings `pulumi:"secureSettings"`
	// ServiceAccountName is used to check access from the current resource to Elasticsearch resource in a different namespace.
	// Can only be used if ECK is enforcing RBAC on references.
	ServiceAccountName *string `pulumi:"serviceAccountName"`
	// Services contains details of services that Logstash should expose - similar to the HTTP layer configuration for the
	// rest of the stack, but also applicable for more use cases than the metrics API, as logstash may need to
	// be opened up for other services: Beats, TCP, UDP, etc, inputs.
	Services []LogstashSpecServices `pulumi:"services"`
	// UpdateStrategy is a StatefulSetUpdateStrategy. The default type is "RollingUpdate".
	UpdateStrategy *LogstashSpecUpdateStrategy `pulumi:"updateStrategy"`
	// Version of the Logstash.
	Version string `pulumi:"version"`
	// VolumeClaimTemplates is a list of persistent volume claims to be used by each Pod.
	// Every claim in this list must have a matching volumeMount in one of the containers defined in the PodTemplate.
	// Items defined here take precedence over any default claims added by the operator with the same name.
	VolumeClaimTemplates []LogstashSpecVolumeClaimTemplates `pulumi:"volumeClaimTemplates"`
}

// LogstashSpecInput is an input type that accepts LogstashSpecArgs and LogstashSpecOutput values.
// You can construct a concrete instance of `LogstashSpecInput` via:
//
//	LogstashSpecArgs{...}
type LogstashSpecInput interface {
	pulumi.Input

	ToLogstashSpecOutput() LogstashSpecOutput
	ToLogstashSpecOutputWithContext(context.Context) LogstashSpecOutput
}

// LogstashSpec defines the desired state of Logstash
type LogstashSpecArgs struct {
	// Config holds the Logstash configuration. At most one of [`Config`, `ConfigRef`] can be specified.
	Config pulumi.MapInput `pulumi:"config"`
	// ConfigRef contains a reference to an existing Kubernetes Secret holding the Logstash configuration.
	// Logstash settings must be specified as yaml, under a single "logstash.yml" entry. At most one of [`Config`, `ConfigRef`]
	// can be specified.
	ConfigRef LogstashSpecConfigRefPtrInput `pulumi:"configRef"`
	Count     pulumi.IntPtrInput            `pulumi:"count"`
	// ElasticsearchRefs are references to Elasticsearch clusters running in the same Kubernetes cluster.
	ElasticsearchRefs LogstashSpecElasticsearchRefsArrayInput `pulumi:"elasticsearchRefs"`
	// Image is the Logstash Docker image to deploy. Version and Type have to match the Logstash in the image.
	Image pulumi.StringPtrInput `pulumi:"image"`
	// Monitoring enables you to collect and ship log and monitoring data of this Logstash.
	// Metricbeat and Filebeat are deployed in the same Pod as sidecars and each one sends data to one or two different
	// Elasticsearch monitoring clusters running in the same Kubernetes cluster.
	Monitoring LogstashSpecMonitoringPtrInput `pulumi:"monitoring"`
	// Pipelines holds the Logstash Pipelines. At most one of [`Pipelines`, `PipelinesRef`] can be specified.
	Pipelines pulumi.MapInput `pulumi:"pipelines"`
	// PipelinesRef contains a reference to an existing Kubernetes Secret holding the Logstash Pipelines.
	// Logstash pipelines must be specified as yaml, under a single "pipelines.yml" entry. At most one of [`Pipelines`, `PipelinesRef`]
	// can be specified.
	PipelinesRef LogstashSpecPipelinesRefPtrInput `pulumi:"pipelinesRef"`
	// PodTemplate provides customisation options for the Logstash pods.
	PodTemplate pulumi.MapInput `pulumi:"podTemplate"`
	// RevisionHistoryLimit is the number of revisions to retain to allow rollback in the underlying StatefulSet.
	RevisionHistoryLimit pulumi.IntPtrInput `pulumi:"revisionHistoryLimit"`
	// SecureSettings is a list of references to Kubernetes Secrets containing sensitive configuration options for the Logstash.
	// Secrets data can be then referenced in the Logstash config using the Secret's keys or as specified in `Entries` field of
	// each SecureSetting.
	SecureSettings LogstashSpecSecureSettingsArrayInput `pulumi:"secureSettings"`
	// ServiceAccountName is used to check access from the current resource to Elasticsearch resource in a different namespace.
	// Can only be used if ECK is enforcing RBAC on references.
	ServiceAccountName pulumi.StringPtrInput `pulumi:"serviceAccountName"`
	// Services contains details of services that Logstash should expose - similar to the HTTP layer configuration for the
	// rest of the stack, but also applicable for more use cases than the metrics API, as logstash may need to
	// be opened up for other services: Beats, TCP, UDP, etc, inputs.
	Services LogstashSpecServicesArrayInput `pulumi:"services"`
	// UpdateStrategy is a StatefulSetUpdateStrategy. The default type is "RollingUpdate".
	UpdateStrategy LogstashSpecUpdateStrategyPtrInput `pulumi:"updateStrategy"`
	// Version of the Logstash.
	Version pulumi.StringInput `pulumi:"version"`
	// VolumeClaimTemplates is a list of persistent volume claims to be used by each Pod.
	// Every claim in this list must have a matching volumeMount in one of the containers defined in the PodTemplate.
	// Items defined here take precedence over any default claims added by the operator with the same name.
	VolumeClaimTemplates LogstashSpecVolumeClaimTemplatesArrayInput `pulumi:"volumeClaimTemplates"`
}

func (LogstashSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpec)(nil)).Elem()
}

func (i LogstashSpecArgs) ToLogstashSpecOutput() LogstashSpecOutput {
	return i.ToLogstashSpecOutputWithContext(context.Background())
}

func (i LogstashSpecArgs) ToLogstashSpecOutputWithContext(ctx context.Context) LogstashSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecOutput)
}

func (i LogstashSpecArgs) ToLogstashSpecPtrOutput() LogstashSpecPtrOutput {
	return i.ToLogstashSpecPtrOutputWithContext(context.Background())
}

func (i LogstashSpecArgs) ToLogstashSpecPtrOutputWithContext(ctx context.Context) LogstashSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecOutput).ToLogstashSpecPtrOutputWithContext(ctx)
}

// LogstashSpecPtrInput is an input type that accepts LogstashSpecArgs, LogstashSpecPtr and LogstashSpecPtrOutput values.
// You can construct a concrete instance of `LogstashSpecPtrInput` via:
//
//	        LogstashSpecArgs{...}
//
//	or:
//
//	        nil
type LogstashSpecPtrInput interface {
	pulumi.Input

	ToLogstashSpecPtrOutput() LogstashSpecPtrOutput
	ToLogstashSpecPtrOutputWithContext(context.Context) LogstashSpecPtrOutput
}

type logstashSpecPtrType LogstashSpecArgs

func LogstashSpecPtr(v *LogstashSpecArgs) LogstashSpecPtrInput {
	return (*logstashSpecPtrType)(v)
}

func (*logstashSpecPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpec)(nil)).Elem()
}

func (i *logstashSpecPtrType) ToLogstashSpecPtrOutput() LogstashSpecPtrOutput {
	return i.ToLogstashSpecPtrOutputWithContext(context.Background())
}

func (i *logstashSpecPtrType) ToLogstashSpecPtrOutputWithContext(ctx context.Context) LogstashSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecPtrOutput)
}

// LogstashSpec defines the desired state of Logstash
type LogstashSpecOutput struct{ *pulumi.OutputState }

func (LogstashSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpec)(nil)).Elem()
}

func (o LogstashSpecOutput) ToLogstashSpecOutput() LogstashSpecOutput {
	return o
}

func (o LogstashSpecOutput) ToLogstashSpecOutputWithContext(ctx context.Context) LogstashSpecOutput {
	return o
}

func (o LogstashSpecOutput) ToLogstashSpecPtrOutput() LogstashSpecPtrOutput {
	return o.ToLogstashSpecPtrOutputWithContext(context.Background())
}

func (o LogstashSpecOutput) ToLogstashSpecPtrOutputWithContext(ctx context.Context) LogstashSpecPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LogstashSpec) *LogstashSpec {
		return &v
	}).(LogstashSpecPtrOutput)
}

// Config holds the Logstash configuration. At most one of [`Config`, `ConfigRef`] can be specified.
func (o LogstashSpecOutput) Config() pulumi.MapOutput {
	return o.ApplyT(func(v LogstashSpec) map[string]interface{} { return v.Config }).(pulumi.MapOutput)
}

// ConfigRef contains a reference to an existing Kubernetes Secret holding the Logstash configuration.
// Logstash settings must be specified as yaml, under a single "logstash.yml" entry. At most one of [`Config`, `ConfigRef`]
// can be specified.
func (o LogstashSpecOutput) ConfigRef() LogstashSpecConfigRefPtrOutput {
	return o.ApplyT(func(v LogstashSpec) *LogstashSpecConfigRef { return v.ConfigRef }).(LogstashSpecConfigRefPtrOutput)
}

func (o LogstashSpecOutput) Count() pulumi.IntPtrOutput {
	return o.ApplyT(func(v LogstashSpec) *int { return v.Count }).(pulumi.IntPtrOutput)
}

// ElasticsearchRefs are references to Elasticsearch clusters running in the same Kubernetes cluster.
func (o LogstashSpecOutput) ElasticsearchRefs() LogstashSpecElasticsearchRefsArrayOutput {
	return o.ApplyT(func(v LogstashSpec) []LogstashSpecElasticsearchRefs { return v.ElasticsearchRefs }).(LogstashSpecElasticsearchRefsArrayOutput)
}

// Image is the Logstash Docker image to deploy. Version and Type have to match the Logstash in the image.
func (o LogstashSpecOutput) Image() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpec) *string { return v.Image }).(pulumi.StringPtrOutput)
}

// Monitoring enables you to collect and ship log and monitoring data of this Logstash.
// Metricbeat and Filebeat are deployed in the same Pod as sidecars and each one sends data to one or two different
// Elasticsearch monitoring clusters running in the same Kubernetes cluster.
func (o LogstashSpecOutput) Monitoring() LogstashSpecMonitoringPtrOutput {
	return o.ApplyT(func(v LogstashSpec) *LogstashSpecMonitoring { return v.Monitoring }).(LogstashSpecMonitoringPtrOutput)
}

// Pipelines holds the Logstash Pipelines. At most one of [`Pipelines`, `PipelinesRef`] can be specified.
func (o LogstashSpecOutput) Pipelines() pulumi.MapOutput {
	return o.ApplyT(func(v LogstashSpec) map[string]interface{} { return v.Pipelines }).(pulumi.MapOutput)
}

// PipelinesRef contains a reference to an existing Kubernetes Secret holding the Logstash Pipelines.
// Logstash pipelines must be specified as yaml, under a single "pipelines.yml" entry. At most one of [`Pipelines`, `PipelinesRef`]
// can be specified.
func (o LogstashSpecOutput) PipelinesRef() LogstashSpecPipelinesRefPtrOutput {
	return o.ApplyT(func(v LogstashSpec) *LogstashSpecPipelinesRef { return v.PipelinesRef }).(LogstashSpecPipelinesRefPtrOutput)
}

// PodTemplate provides customisation options for the Logstash pods.
func (o LogstashSpecOutput) PodTemplate() pulumi.MapOutput {
	return o.ApplyT(func(v LogstashSpec) map[string]interface{} { return v.PodTemplate }).(pulumi.MapOutput)
}

// RevisionHistoryLimit is the number of revisions to retain to allow rollback in the underlying StatefulSet.
func (o LogstashSpecOutput) RevisionHistoryLimit() pulumi.IntPtrOutput {
	return o.ApplyT(func(v LogstashSpec) *int { return v.RevisionHistoryLimit }).(pulumi.IntPtrOutput)
}

// SecureSettings is a list of references to Kubernetes Secrets containing sensitive configuration options for the Logstash.
// Secrets data can be then referenced in the Logstash config using the Secret's keys or as specified in `Entries` field of
// each SecureSetting.
func (o LogstashSpecOutput) SecureSettings() LogstashSpecSecureSettingsArrayOutput {
	return o.ApplyT(func(v LogstashSpec) []LogstashSpecSecureSettings { return v.SecureSettings }).(LogstashSpecSecureSettingsArrayOutput)
}

// ServiceAccountName is used to check access from the current resource to Elasticsearch resource in a different namespace.
// Can only be used if ECK is enforcing RBAC on references.
func (o LogstashSpecOutput) ServiceAccountName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpec) *string { return v.ServiceAccountName }).(pulumi.StringPtrOutput)
}

// Services contains details of services that Logstash should expose - similar to the HTTP layer configuration for the
// rest of the stack, but also applicable for more use cases than the metrics API, as logstash may need to
// be opened up for other services: Beats, TCP, UDP, etc, inputs.
func (o LogstashSpecOutput) Services() LogstashSpecServicesArrayOutput {
	return o.ApplyT(func(v LogstashSpec) []LogstashSpecServices { return v.Services }).(LogstashSpecServicesArrayOutput)
}

// UpdateStrategy is a StatefulSetUpdateStrategy. The default type is "RollingUpdate".
func (o LogstashSpecOutput) UpdateStrategy() LogstashSpecUpdateStrategyPtrOutput {
	return o.ApplyT(func(v LogstashSpec) *LogstashSpecUpdateStrategy { return v.UpdateStrategy }).(LogstashSpecUpdateStrategyPtrOutput)
}

// Version of the Logstash.
func (o LogstashSpecOutput) Version() pulumi.StringOutput {
	return o.ApplyT(func(v LogstashSpec) string { return v.Version }).(pulumi.StringOutput)
}

// VolumeClaimTemplates is a list of persistent volume claims to be used by each Pod.
// Every claim in this list must have a matching volumeMount in one of the containers defined in the PodTemplate.
// Items defined here take precedence over any default claims added by the operator with the same name.
func (o LogstashSpecOutput) VolumeClaimTemplates() LogstashSpecVolumeClaimTemplatesArrayOutput {
	return o.ApplyT(func(v LogstashSpec) []LogstashSpecVolumeClaimTemplates { return v.VolumeClaimTemplates }).(LogstashSpecVolumeClaimTemplatesArrayOutput)
}

type LogstashSpecPtrOutput struct{ *pulumi.OutputState }

func (LogstashSpecPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpec)(nil)).Elem()
}

func (o LogstashSpecPtrOutput) ToLogstashSpecPtrOutput() LogstashSpecPtrOutput {
	return o
}

func (o LogstashSpecPtrOutput) ToLogstashSpecPtrOutputWithContext(ctx context.Context) LogstashSpecPtrOutput {
	return o
}

func (o LogstashSpecPtrOutput) Elem() LogstashSpecOutput {
	return o.ApplyT(func(v *LogstashSpec) LogstashSpec {
		if v != nil {
			return *v
		}
		var ret LogstashSpec
		return ret
	}).(LogstashSpecOutput)
}

// Config holds the Logstash configuration. At most one of [`Config`, `ConfigRef`] can be specified.
func (o LogstashSpecPtrOutput) Config() pulumi.MapOutput {
	return o.ApplyT(func(v *LogstashSpec) map[string]interface{} {
		if v == nil {
			return nil
		}
		return v.Config
	}).(pulumi.MapOutput)
}

// ConfigRef contains a reference to an existing Kubernetes Secret holding the Logstash configuration.
// Logstash settings must be specified as yaml, under a single "logstash.yml" entry. At most one of [`Config`, `ConfigRef`]
// can be specified.
func (o LogstashSpecPtrOutput) ConfigRef() LogstashSpecConfigRefPtrOutput {
	return o.ApplyT(func(v *LogstashSpec) *LogstashSpecConfigRef {
		if v == nil {
			return nil
		}
		return v.ConfigRef
	}).(LogstashSpecConfigRefPtrOutput)
}

func (o LogstashSpecPtrOutput) Count() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *LogstashSpec) *int {
		if v == nil {
			return nil
		}
		return v.Count
	}).(pulumi.IntPtrOutput)
}

// ElasticsearchRefs are references to Elasticsearch clusters running in the same Kubernetes cluster.
func (o LogstashSpecPtrOutput) ElasticsearchRefs() LogstashSpecElasticsearchRefsArrayOutput {
	return o.ApplyT(func(v *LogstashSpec) []LogstashSpecElasticsearchRefs {
		if v == nil {
			return nil
		}
		return v.ElasticsearchRefs
	}).(LogstashSpecElasticsearchRefsArrayOutput)
}

// Image is the Logstash Docker image to deploy. Version and Type have to match the Logstash in the image.
func (o LogstashSpecPtrOutput) Image() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpec) *string {
		if v == nil {
			return nil
		}
		return v.Image
	}).(pulumi.StringPtrOutput)
}

// Monitoring enables you to collect and ship log and monitoring data of this Logstash.
// Metricbeat and Filebeat are deployed in the same Pod as sidecars and each one sends data to one or two different
// Elasticsearch monitoring clusters running in the same Kubernetes cluster.
func (o LogstashSpecPtrOutput) Monitoring() LogstashSpecMonitoringPtrOutput {
	return o.ApplyT(func(v *LogstashSpec) *LogstashSpecMonitoring {
		if v == nil {
			return nil
		}
		return v.Monitoring
	}).(LogstashSpecMonitoringPtrOutput)
}

// Pipelines holds the Logstash Pipelines. At most one of [`Pipelines`, `PipelinesRef`] can be specified.
func (o LogstashSpecPtrOutput) Pipelines() pulumi.MapOutput {
	return o.ApplyT(func(v *LogstashSpec) map[string]interface{} {
		if v == nil {
			return nil
		}
		return v.Pipelines
	}).(pulumi.MapOutput)
}

// PipelinesRef contains a reference to an existing Kubernetes Secret holding the Logstash Pipelines.
// Logstash pipelines must be specified as yaml, under a single "pipelines.yml" entry. At most one of [`Pipelines`, `PipelinesRef`]
// can be specified.
func (o LogstashSpecPtrOutput) PipelinesRef() LogstashSpecPipelinesRefPtrOutput {
	return o.ApplyT(func(v *LogstashSpec) *LogstashSpecPipelinesRef {
		if v == nil {
			return nil
		}
		return v.PipelinesRef
	}).(LogstashSpecPipelinesRefPtrOutput)
}

// PodTemplate provides customisation options for the Logstash pods.
func (o LogstashSpecPtrOutput) PodTemplate() pulumi.MapOutput {
	return o.ApplyT(func(v *LogstashSpec) map[string]interface{} {
		if v == nil {
			return nil
		}
		return v.PodTemplate
	}).(pulumi.MapOutput)
}

// RevisionHistoryLimit is the number of revisions to retain to allow rollback in the underlying StatefulSet.
func (o LogstashSpecPtrOutput) RevisionHistoryLimit() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *LogstashSpec) *int {
		if v == nil {
			return nil
		}
		return v.RevisionHistoryLimit
	}).(pulumi.IntPtrOutput)
}

// SecureSettings is a list of references to Kubernetes Secrets containing sensitive configuration options for the Logstash.
// Secrets data can be then referenced in the Logstash config using the Secret's keys or as specified in `Entries` field of
// each SecureSetting.
func (o LogstashSpecPtrOutput) SecureSettings() LogstashSpecSecureSettingsArrayOutput {
	return o.ApplyT(func(v *LogstashSpec) []LogstashSpecSecureSettings {
		if v == nil {
			return nil
		}
		return v.SecureSettings
	}).(LogstashSpecSecureSettingsArrayOutput)
}

// ServiceAccountName is used to check access from the current resource to Elasticsearch resource in a different namespace.
// Can only be used if ECK is enforcing RBAC on references.
func (o LogstashSpecPtrOutput) ServiceAccountName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpec) *string {
		if v == nil {
			return nil
		}
		return v.ServiceAccountName
	}).(pulumi.StringPtrOutput)
}

// Services contains details of services that Logstash should expose - similar to the HTTP layer configuration for the
// rest of the stack, but also applicable for more use cases than the metrics API, as logstash may need to
// be opened up for other services: Beats, TCP, UDP, etc, inputs.
func (o LogstashSpecPtrOutput) Services() LogstashSpecServicesArrayOutput {
	return o.ApplyT(func(v *LogstashSpec) []LogstashSpecServices {
		if v == nil {
			return nil
		}
		return v.Services
	}).(LogstashSpecServicesArrayOutput)
}

// UpdateStrategy is a StatefulSetUpdateStrategy. The default type is "RollingUpdate".
func (o LogstashSpecPtrOutput) UpdateStrategy() LogstashSpecUpdateStrategyPtrOutput {
	return o.ApplyT(func(v *LogstashSpec) *LogstashSpecUpdateStrategy {
		if v == nil {
			return nil
		}
		return v.UpdateStrategy
	}).(LogstashSpecUpdateStrategyPtrOutput)
}

// Version of the Logstash.
func (o LogstashSpecPtrOutput) Version() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpec) *string {
		if v == nil {
			return nil
		}
		return &v.Version
	}).(pulumi.StringPtrOutput)
}

// VolumeClaimTemplates is a list of persistent volume claims to be used by each Pod.
// Every claim in this list must have a matching volumeMount in one of the containers defined in the PodTemplate.
// Items defined here take precedence over any default claims added by the operator with the same name.
func (o LogstashSpecPtrOutput) VolumeClaimTemplates() LogstashSpecVolumeClaimTemplatesArrayOutput {
	return o.ApplyT(func(v *LogstashSpec) []LogstashSpecVolumeClaimTemplates {
		if v == nil {
			return nil
		}
		return v.VolumeClaimTemplates
	}).(LogstashSpecVolumeClaimTemplatesArrayOutput)
}

// ConfigRef contains a reference to an existing Kubernetes Secret holding the Logstash configuration.
// Logstash settings must be specified as yaml, under a single "logstash.yml" entry. At most one of [`Config`, `ConfigRef`]
// can be specified.
type LogstashSpecConfigRef struct {
	// SecretName is the name of the secret.
	SecretName *string `pulumi:"secretName"`
}

// LogstashSpecConfigRefInput is an input type that accepts LogstashSpecConfigRefArgs and LogstashSpecConfigRefOutput values.
// You can construct a concrete instance of `LogstashSpecConfigRefInput` via:
//
//	LogstashSpecConfigRefArgs{...}
type LogstashSpecConfigRefInput interface {
	pulumi.Input

	ToLogstashSpecConfigRefOutput() LogstashSpecConfigRefOutput
	ToLogstashSpecConfigRefOutputWithContext(context.Context) LogstashSpecConfigRefOutput
}

// ConfigRef contains a reference to an existing Kubernetes Secret holding the Logstash configuration.
// Logstash settings must be specified as yaml, under a single "logstash.yml" entry. At most one of [`Config`, `ConfigRef`]
// can be specified.
type LogstashSpecConfigRefArgs struct {
	// SecretName is the name of the secret.
	SecretName pulumi.StringPtrInput `pulumi:"secretName"`
}

func (LogstashSpecConfigRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecConfigRef)(nil)).Elem()
}

func (i LogstashSpecConfigRefArgs) ToLogstashSpecConfigRefOutput() LogstashSpecConfigRefOutput {
	return i.ToLogstashSpecConfigRefOutputWithContext(context.Background())
}

func (i LogstashSpecConfigRefArgs) ToLogstashSpecConfigRefOutputWithContext(ctx context.Context) LogstashSpecConfigRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecConfigRefOutput)
}

func (i LogstashSpecConfigRefArgs) ToLogstashSpecConfigRefPtrOutput() LogstashSpecConfigRefPtrOutput {
	return i.ToLogstashSpecConfigRefPtrOutputWithContext(context.Background())
}

func (i LogstashSpecConfigRefArgs) ToLogstashSpecConfigRefPtrOutputWithContext(ctx context.Context) LogstashSpecConfigRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecConfigRefOutput).ToLogstashSpecConfigRefPtrOutputWithContext(ctx)
}

// LogstashSpecConfigRefPtrInput is an input type that accepts LogstashSpecConfigRefArgs, LogstashSpecConfigRefPtr and LogstashSpecConfigRefPtrOutput values.
// You can construct a concrete instance of `LogstashSpecConfigRefPtrInput` via:
//
//	        LogstashSpecConfigRefArgs{...}
//
//	or:
//
//	        nil
type LogstashSpecConfigRefPtrInput interface {
	pulumi.Input

	ToLogstashSpecConfigRefPtrOutput() LogstashSpecConfigRefPtrOutput
	ToLogstashSpecConfigRefPtrOutputWithContext(context.Context) LogstashSpecConfigRefPtrOutput
}

type logstashSpecConfigRefPtrType LogstashSpecConfigRefArgs

func LogstashSpecConfigRefPtr(v *LogstashSpecConfigRefArgs) LogstashSpecConfigRefPtrInput {
	return (*logstashSpecConfigRefPtrType)(v)
}

func (*logstashSpecConfigRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecConfigRef)(nil)).Elem()
}

func (i *logstashSpecConfigRefPtrType) ToLogstashSpecConfigRefPtrOutput() LogstashSpecConfigRefPtrOutput {
	return i.ToLogstashSpecConfigRefPtrOutputWithContext(context.Background())
}

func (i *logstashSpecConfigRefPtrType) ToLogstashSpecConfigRefPtrOutputWithContext(ctx context.Context) LogstashSpecConfigRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecConfigRefPtrOutput)
}

// ConfigRef contains a reference to an existing Kubernetes Secret holding the Logstash configuration.
// Logstash settings must be specified as yaml, under a single "logstash.yml" entry. At most one of [`Config`, `ConfigRef`]
// can be specified.
type LogstashSpecConfigRefOutput struct{ *pulumi.OutputState }

func (LogstashSpecConfigRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecConfigRef)(nil)).Elem()
}

func (o LogstashSpecConfigRefOutput) ToLogstashSpecConfigRefOutput() LogstashSpecConfigRefOutput {
	return o
}

func (o LogstashSpecConfigRefOutput) ToLogstashSpecConfigRefOutputWithContext(ctx context.Context) LogstashSpecConfigRefOutput {
	return o
}

func (o LogstashSpecConfigRefOutput) ToLogstashSpecConfigRefPtrOutput() LogstashSpecConfigRefPtrOutput {
	return o.ToLogstashSpecConfigRefPtrOutputWithContext(context.Background())
}

func (o LogstashSpecConfigRefOutput) ToLogstashSpecConfigRefPtrOutputWithContext(ctx context.Context) LogstashSpecConfigRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LogstashSpecConfigRef) *LogstashSpecConfigRef {
		return &v
	}).(LogstashSpecConfigRefPtrOutput)
}

// SecretName is the name of the secret.
func (o LogstashSpecConfigRefOutput) SecretName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecConfigRef) *string { return v.SecretName }).(pulumi.StringPtrOutput)
}

type LogstashSpecConfigRefPtrOutput struct{ *pulumi.OutputState }

func (LogstashSpecConfigRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecConfigRef)(nil)).Elem()
}

func (o LogstashSpecConfigRefPtrOutput) ToLogstashSpecConfigRefPtrOutput() LogstashSpecConfigRefPtrOutput {
	return o
}

func (o LogstashSpecConfigRefPtrOutput) ToLogstashSpecConfigRefPtrOutputWithContext(ctx context.Context) LogstashSpecConfigRefPtrOutput {
	return o
}

func (o LogstashSpecConfigRefPtrOutput) Elem() LogstashSpecConfigRefOutput {
	return o.ApplyT(func(v *LogstashSpecConfigRef) LogstashSpecConfigRef {
		if v != nil {
			return *v
		}
		var ret LogstashSpecConfigRef
		return ret
	}).(LogstashSpecConfigRefOutput)
}

// SecretName is the name of the secret.
func (o LogstashSpecConfigRefPtrOutput) SecretName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecConfigRef) *string {
		if v == nil {
			return nil
		}
		return v.SecretName
	}).(pulumi.StringPtrOutput)
}

// ElasticsearchCluster is a named reference to an Elasticsearch cluster which can be used in a Logstash pipeline.
type LogstashSpecElasticsearchRefs struct {
	// ClusterName is an alias for the cluster to be used to refer to the Elasticsearch cluster in Logstash
	// configuration files, and will be used to identify "named clusters" in Logstash
	ClusterName *string `pulumi:"clusterName"`
	// Name of an existing Kubernetes object corresponding to an Elastic resource managed by ECK.
	Name *string `pulumi:"name"`
	// Namespace of the Kubernetes object. If empty, defaults to the current namespace.
	Namespace *string `pulumi:"namespace"`
	// SecretName is the name of an existing Kubernetes secret that contains connection information for associating an
	// Elastic resource not managed by the operator. The referenced secret must contain the following:
	// - `url`: the URL to reach the Elastic resource
	// - `username`: the username of the user to be authenticated to the Elastic resource
	// - `password`: the password of the user to be authenticated to the Elastic resource
	// - `ca.crt`: the CA certificate in PEM format (optional)
	// - `api-key`: the key to authenticate against the Elastic resource instead of a username and password (supported only for `elasticsearchRefs` in AgentSpec and in BeatSpec)
	//   This field cannot be used in combination with the other fields name, namespace or serviceName.
	SecretName *string `pulumi:"secretName"`
	// ServiceName is the name of an existing Kubernetes service which is used to make requests to the referenced
	// object. It has to be in the same namespace as the referenced resource. If left empty, the default HTTP service of
	// the referenced resource is used.
	ServiceName *string `pulumi:"serviceName"`
}

// LogstashSpecElasticsearchRefsInput is an input type that accepts LogstashSpecElasticsearchRefsArgs and LogstashSpecElasticsearchRefsOutput values.
// You can construct a concrete instance of `LogstashSpecElasticsearchRefsInput` via:
//
//	LogstashSpecElasticsearchRefsArgs{...}
type LogstashSpecElasticsearchRefsInput interface {
	pulumi.Input

	ToLogstashSpecElasticsearchRefsOutput() LogstashSpecElasticsearchRefsOutput
	ToLogstashSpecElasticsearchRefsOutputWithContext(context.Context) LogstashSpecElasticsearchRefsOutput
}

// ElasticsearchCluster is a named reference to an Elasticsearch cluster which can be used in a Logstash pipeline.
type LogstashSpecElasticsearchRefsArgs struct {
	// ClusterName is an alias for the cluster to be used to refer to the Elasticsearch cluster in Logstash
	// configuration files, and will be used to identify "named clusters" in Logstash
	ClusterName pulumi.StringPtrInput `pulumi:"clusterName"`
	// Name of an existing Kubernetes object corresponding to an Elastic resource managed by ECK.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace of the Kubernetes object. If empty, defaults to the current namespace.
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// SecretName is the name of an existing Kubernetes secret that contains connection information for associating an
	// Elastic resource not managed by the operator. The referenced secret must contain the following:
	// - `url`: the URL to reach the Elastic resource
	// - `username`: the username of the user to be authenticated to the Elastic resource
	// - `password`: the password of the user to be authenticated to the Elastic resource
	// - `ca.crt`: the CA certificate in PEM format (optional)
	// - `api-key`: the key to authenticate against the Elastic resource instead of a username and password (supported only for `elasticsearchRefs` in AgentSpec and in BeatSpec)
	//   This field cannot be used in combination with the other fields name, namespace or serviceName.
	SecretName pulumi.StringPtrInput `pulumi:"secretName"`
	// ServiceName is the name of an existing Kubernetes service which is used to make requests to the referenced
	// object. It has to be in the same namespace as the referenced resource. If left empty, the default HTTP service of
	// the referenced resource is used.
	ServiceName pulumi.StringPtrInput `pulumi:"serviceName"`
}

func (LogstashSpecElasticsearchRefsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecElasticsearchRefs)(nil)).Elem()
}

func (i LogstashSpecElasticsearchRefsArgs) ToLogstashSpecElasticsearchRefsOutput() LogstashSpecElasticsearchRefsOutput {
	return i.ToLogstashSpecElasticsearchRefsOutputWithContext(context.Background())
}

func (i LogstashSpecElasticsearchRefsArgs) ToLogstashSpecElasticsearchRefsOutputWithContext(ctx context.Context) LogstashSpecElasticsearchRefsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecElasticsearchRefsOutput)
}

// LogstashSpecElasticsearchRefsArrayInput is an input type that accepts LogstashSpecElasticsearchRefsArray and LogstashSpecElasticsearchRefsArrayOutput values.
// You can construct a concrete instance of `LogstashSpecElasticsearchRefsArrayInput` via:
//
//	LogstashSpecElasticsearchRefsArray{ LogstashSpecElasticsearchRefsArgs{...} }
type LogstashSpecElasticsearchRefsArrayInput interface {
	pulumi.Input

	ToLogstashSpecElasticsearchRefsArrayOutput() LogstashSpecElasticsearchRefsArrayOutput
	ToLogstashSpecElasticsearchRefsArrayOutputWithContext(context.Context) LogstashSpecElasticsearchRefsArrayOutput
}

type LogstashSpecElasticsearchRefsArray []LogstashSpecElasticsearchRefsInput

func (LogstashSpecElasticsearchRefsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LogstashSpecElasticsearchRefs)(nil)).Elem()
}

func (i LogstashSpecElasticsearchRefsArray) ToLogstashSpecElasticsearchRefsArrayOutput() LogstashSpecElasticsearchRefsArrayOutput {
	return i.ToLogstashSpecElasticsearchRefsArrayOutputWithContext(context.Background())
}

func (i LogstashSpecElasticsearchRefsArray) ToLogstashSpecElasticsearchRefsArrayOutputWithContext(ctx context.Context) LogstashSpecElasticsearchRefsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecElasticsearchRefsArrayOutput)
}

// ElasticsearchCluster is a named reference to an Elasticsearch cluster which can be used in a Logstash pipeline.
type LogstashSpecElasticsearchRefsOutput struct{ *pulumi.OutputState }

func (LogstashSpecElasticsearchRefsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecElasticsearchRefs)(nil)).Elem()
}

func (o LogstashSpecElasticsearchRefsOutput) ToLogstashSpecElasticsearchRefsOutput() LogstashSpecElasticsearchRefsOutput {
	return o
}

func (o LogstashSpecElasticsearchRefsOutput) ToLogstashSpecElasticsearchRefsOutputWithContext(ctx context.Context) LogstashSpecElasticsearchRefsOutput {
	return o
}

// ClusterName is an alias for the cluster to be used to refer to the Elasticsearch cluster in Logstash
// configuration files, and will be used to identify "named clusters" in Logstash
func (o LogstashSpecElasticsearchRefsOutput) ClusterName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecElasticsearchRefs) *string { return v.ClusterName }).(pulumi.StringPtrOutput)
}

// Name of an existing Kubernetes object corresponding to an Elastic resource managed by ECK.
func (o LogstashSpecElasticsearchRefsOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecElasticsearchRefs) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace of the Kubernetes object. If empty, defaults to the current namespace.
func (o LogstashSpecElasticsearchRefsOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecElasticsearchRefs) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// SecretName is the name of an existing Kubernetes secret that contains connection information for associating an
// Elastic resource not managed by the operator. The referenced secret must contain the following:
//   - `url`: the URL to reach the Elastic resource
//   - `username`: the username of the user to be authenticated to the Elastic resource
//   - `password`: the password of the user to be authenticated to the Elastic resource
//   - `ca.crt`: the CA certificate in PEM format (optional)
//   - `api-key`: the key to authenticate against the Elastic resource instead of a username and password (supported only for `elasticsearchRefs` in AgentSpec and in BeatSpec)
//     This field cannot be used in combination with the other fields name, namespace or serviceName.
func (o LogstashSpecElasticsearchRefsOutput) SecretName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecElasticsearchRefs) *string { return v.SecretName }).(pulumi.StringPtrOutput)
}

// ServiceName is the name of an existing Kubernetes service which is used to make requests to the referenced
// object. It has to be in the same namespace as the referenced resource. If left empty, the default HTTP service of
// the referenced resource is used.
func (o LogstashSpecElasticsearchRefsOutput) ServiceName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecElasticsearchRefs) *string { return v.ServiceName }).(pulumi.StringPtrOutput)
}

type LogstashSpecElasticsearchRefsArrayOutput struct{ *pulumi.OutputState }

func (LogstashSpecElasticsearchRefsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LogstashSpecElasticsearchRefs)(nil)).Elem()
}

func (o LogstashSpecElasticsearchRefsArrayOutput) ToLogstashSpecElasticsearchRefsArrayOutput() LogstashSpecElasticsearchRefsArrayOutput {
	return o
}

func (o LogstashSpecElasticsearchRefsArrayOutput) ToLogstashSpecElasticsearchRefsArrayOutputWithContext(ctx context.Context) LogstashSpecElasticsearchRefsArrayOutput {
	return o
}

func (o LogstashSpecElasticsearchRefsArrayOutput) Index(i pulumi.IntInput) LogstashSpecElasticsearchRefsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LogstashSpecElasticsearchRefs {
		return vs[0].([]LogstashSpecElasticsearchRefs)[vs[1].(int)]
	}).(LogstashSpecElasticsearchRefsOutput)
}

// Monitoring enables you to collect and ship log and monitoring data of this Logstash.
// Metricbeat and Filebeat are deployed in the same Pod as sidecars and each one sends data to one or two different
// Elasticsearch monitoring clusters running in the same Kubernetes cluster.
type LogstashSpecMonitoring struct {
	// Logs holds references to Elasticsearch clusters which receive log data from an associated resource.
	Logs *LogstashSpecMonitoringLogs `pulumi:"logs"`
	// Metrics holds references to Elasticsearch clusters which receive monitoring data from this resource.
	Metrics *LogstashSpecMonitoringMetrics `pulumi:"metrics"`
}

// LogstashSpecMonitoringInput is an input type that accepts LogstashSpecMonitoringArgs and LogstashSpecMonitoringOutput values.
// You can construct a concrete instance of `LogstashSpecMonitoringInput` via:
//
//	LogstashSpecMonitoringArgs{...}
type LogstashSpecMonitoringInput interface {
	pulumi.Input

	ToLogstashSpecMonitoringOutput() LogstashSpecMonitoringOutput
	ToLogstashSpecMonitoringOutputWithContext(context.Context) LogstashSpecMonitoringOutput
}

// Monitoring enables you to collect and ship log and monitoring data of this Logstash.
// Metricbeat and Filebeat are deployed in the same Pod as sidecars and each one sends data to one or two different
// Elasticsearch monitoring clusters running in the same Kubernetes cluster.
type LogstashSpecMonitoringArgs struct {
	// Logs holds references to Elasticsearch clusters which receive log data from an associated resource.
	Logs LogstashSpecMonitoringLogsPtrInput `pulumi:"logs"`
	// Metrics holds references to Elasticsearch clusters which receive monitoring data from this resource.
	Metrics LogstashSpecMonitoringMetricsPtrInput `pulumi:"metrics"`
}

func (LogstashSpecMonitoringArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecMonitoring)(nil)).Elem()
}

func (i LogstashSpecMonitoringArgs) ToLogstashSpecMonitoringOutput() LogstashSpecMonitoringOutput {
	return i.ToLogstashSpecMonitoringOutputWithContext(context.Background())
}

func (i LogstashSpecMonitoringArgs) ToLogstashSpecMonitoringOutputWithContext(ctx context.Context) LogstashSpecMonitoringOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecMonitoringOutput)
}

func (i LogstashSpecMonitoringArgs) ToLogstashSpecMonitoringPtrOutput() LogstashSpecMonitoringPtrOutput {
	return i.ToLogstashSpecMonitoringPtrOutputWithContext(context.Background())
}

func (i LogstashSpecMonitoringArgs) ToLogstashSpecMonitoringPtrOutputWithContext(ctx context.Context) LogstashSpecMonitoringPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecMonitoringOutput).ToLogstashSpecMonitoringPtrOutputWithContext(ctx)
}

// LogstashSpecMonitoringPtrInput is an input type that accepts LogstashSpecMonitoringArgs, LogstashSpecMonitoringPtr and LogstashSpecMonitoringPtrOutput values.
// You can construct a concrete instance of `LogstashSpecMonitoringPtrInput` via:
//
//	        LogstashSpecMonitoringArgs{...}
//
//	or:
//
//	        nil
type LogstashSpecMonitoringPtrInput interface {
	pulumi.Input

	ToLogstashSpecMonitoringPtrOutput() LogstashSpecMonitoringPtrOutput
	ToLogstashSpecMonitoringPtrOutputWithContext(context.Context) LogstashSpecMonitoringPtrOutput
}

type logstashSpecMonitoringPtrType LogstashSpecMonitoringArgs

func LogstashSpecMonitoringPtr(v *LogstashSpecMonitoringArgs) LogstashSpecMonitoringPtrInput {
	return (*logstashSpecMonitoringPtrType)(v)
}

func (*logstashSpecMonitoringPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecMonitoring)(nil)).Elem()
}

func (i *logstashSpecMonitoringPtrType) ToLogstashSpecMonitoringPtrOutput() LogstashSpecMonitoringPtrOutput {
	return i.ToLogstashSpecMonitoringPtrOutputWithContext(context.Background())
}

func (i *logstashSpecMonitoringPtrType) ToLogstashSpecMonitoringPtrOutputWithContext(ctx context.Context) LogstashSpecMonitoringPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecMonitoringPtrOutput)
}

// Monitoring enables you to collect and ship log and monitoring data of this Logstash.
// Metricbeat and Filebeat are deployed in the same Pod as sidecars and each one sends data to one or two different
// Elasticsearch monitoring clusters running in the same Kubernetes cluster.
type LogstashSpecMonitoringOutput struct{ *pulumi.OutputState }

func (LogstashSpecMonitoringOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecMonitoring)(nil)).Elem()
}

func (o LogstashSpecMonitoringOutput) ToLogstashSpecMonitoringOutput() LogstashSpecMonitoringOutput {
	return o
}

func (o LogstashSpecMonitoringOutput) ToLogstashSpecMonitoringOutputWithContext(ctx context.Context) LogstashSpecMonitoringOutput {
	return o
}

func (o LogstashSpecMonitoringOutput) ToLogstashSpecMonitoringPtrOutput() LogstashSpecMonitoringPtrOutput {
	return o.ToLogstashSpecMonitoringPtrOutputWithContext(context.Background())
}

func (o LogstashSpecMonitoringOutput) ToLogstashSpecMonitoringPtrOutputWithContext(ctx context.Context) LogstashSpecMonitoringPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LogstashSpecMonitoring) *LogstashSpecMonitoring {
		return &v
	}).(LogstashSpecMonitoringPtrOutput)
}

// Logs holds references to Elasticsearch clusters which receive log data from an associated resource.
func (o LogstashSpecMonitoringOutput) Logs() LogstashSpecMonitoringLogsPtrOutput {
	return o.ApplyT(func(v LogstashSpecMonitoring) *LogstashSpecMonitoringLogs { return v.Logs }).(LogstashSpecMonitoringLogsPtrOutput)
}

// Metrics holds references to Elasticsearch clusters which receive monitoring data from this resource.
func (o LogstashSpecMonitoringOutput) Metrics() LogstashSpecMonitoringMetricsPtrOutput {
	return o.ApplyT(func(v LogstashSpecMonitoring) *LogstashSpecMonitoringMetrics { return v.Metrics }).(LogstashSpecMonitoringMetricsPtrOutput)
}

type LogstashSpecMonitoringPtrOutput struct{ *pulumi.OutputState }

func (LogstashSpecMonitoringPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecMonitoring)(nil)).Elem()
}

func (o LogstashSpecMonitoringPtrOutput) ToLogstashSpecMonitoringPtrOutput() LogstashSpecMonitoringPtrOutput {
	return o
}

func (o LogstashSpecMonitoringPtrOutput) ToLogstashSpecMonitoringPtrOutputWithContext(ctx context.Context) LogstashSpecMonitoringPtrOutput {
	return o
}

func (o LogstashSpecMonitoringPtrOutput) Elem() LogstashSpecMonitoringOutput {
	return o.ApplyT(func(v *LogstashSpecMonitoring) LogstashSpecMonitoring {
		if v != nil {
			return *v
		}
		var ret LogstashSpecMonitoring
		return ret
	}).(LogstashSpecMonitoringOutput)
}

// Logs holds references to Elasticsearch clusters which receive log data from an associated resource.
func (o LogstashSpecMonitoringPtrOutput) Logs() LogstashSpecMonitoringLogsPtrOutput {
	return o.ApplyT(func(v *LogstashSpecMonitoring) *LogstashSpecMonitoringLogs {
		if v == nil {
			return nil
		}
		return v.Logs
	}).(LogstashSpecMonitoringLogsPtrOutput)
}

// Metrics holds references to Elasticsearch clusters which receive monitoring data from this resource.
func (o LogstashSpecMonitoringPtrOutput) Metrics() LogstashSpecMonitoringMetricsPtrOutput {
	return o.ApplyT(func(v *LogstashSpecMonitoring) *LogstashSpecMonitoringMetrics {
		if v == nil {
			return nil
		}
		return v.Metrics
	}).(LogstashSpecMonitoringMetricsPtrOutput)
}

// Logs holds references to Elasticsearch clusters which receive log data from an associated resource.
type LogstashSpecMonitoringLogs struct {
	// ElasticsearchRefs is a reference to a list of monitoring Elasticsearch clusters running in the same Kubernetes cluster.
	// Due to existing limitations, only a single Elasticsearch cluster is currently supported.
	ElasticsearchRefs []LogstashSpecMonitoringLogsElasticsearchRefs `pulumi:"elasticsearchRefs"`
}

// LogstashSpecMonitoringLogsInput is an input type that accepts LogstashSpecMonitoringLogsArgs and LogstashSpecMonitoringLogsOutput values.
// You can construct a concrete instance of `LogstashSpecMonitoringLogsInput` via:
//
//	LogstashSpecMonitoringLogsArgs{...}
type LogstashSpecMonitoringLogsInput interface {
	pulumi.Input

	ToLogstashSpecMonitoringLogsOutput() LogstashSpecMonitoringLogsOutput
	ToLogstashSpecMonitoringLogsOutputWithContext(context.Context) LogstashSpecMonitoringLogsOutput
}

// Logs holds references to Elasticsearch clusters which receive log data from an associated resource.
type LogstashSpecMonitoringLogsArgs struct {
	// ElasticsearchRefs is a reference to a list of monitoring Elasticsearch clusters running in the same Kubernetes cluster.
	// Due to existing limitations, only a single Elasticsearch cluster is currently supported.
	ElasticsearchRefs LogstashSpecMonitoringLogsElasticsearchRefsArrayInput `pulumi:"elasticsearchRefs"`
}

func (LogstashSpecMonitoringLogsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecMonitoringLogs)(nil)).Elem()
}

func (i LogstashSpecMonitoringLogsArgs) ToLogstashSpecMonitoringLogsOutput() LogstashSpecMonitoringLogsOutput {
	return i.ToLogstashSpecMonitoringLogsOutputWithContext(context.Background())
}

func (i LogstashSpecMonitoringLogsArgs) ToLogstashSpecMonitoringLogsOutputWithContext(ctx context.Context) LogstashSpecMonitoringLogsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecMonitoringLogsOutput)
}

func (i LogstashSpecMonitoringLogsArgs) ToLogstashSpecMonitoringLogsPtrOutput() LogstashSpecMonitoringLogsPtrOutput {
	return i.ToLogstashSpecMonitoringLogsPtrOutputWithContext(context.Background())
}

func (i LogstashSpecMonitoringLogsArgs) ToLogstashSpecMonitoringLogsPtrOutputWithContext(ctx context.Context) LogstashSpecMonitoringLogsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecMonitoringLogsOutput).ToLogstashSpecMonitoringLogsPtrOutputWithContext(ctx)
}

// LogstashSpecMonitoringLogsPtrInput is an input type that accepts LogstashSpecMonitoringLogsArgs, LogstashSpecMonitoringLogsPtr and LogstashSpecMonitoringLogsPtrOutput values.
// You can construct a concrete instance of `LogstashSpecMonitoringLogsPtrInput` via:
//
//	        LogstashSpecMonitoringLogsArgs{...}
//
//	or:
//
//	        nil
type LogstashSpecMonitoringLogsPtrInput interface {
	pulumi.Input

	ToLogstashSpecMonitoringLogsPtrOutput() LogstashSpecMonitoringLogsPtrOutput
	ToLogstashSpecMonitoringLogsPtrOutputWithContext(context.Context) LogstashSpecMonitoringLogsPtrOutput
}

type logstashSpecMonitoringLogsPtrType LogstashSpecMonitoringLogsArgs

func LogstashSpecMonitoringLogsPtr(v *LogstashSpecMonitoringLogsArgs) LogstashSpecMonitoringLogsPtrInput {
	return (*logstashSpecMonitoringLogsPtrType)(v)
}

func (*logstashSpecMonitoringLogsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecMonitoringLogs)(nil)).Elem()
}

func (i *logstashSpecMonitoringLogsPtrType) ToLogstashSpecMonitoringLogsPtrOutput() LogstashSpecMonitoringLogsPtrOutput {
	return i.ToLogstashSpecMonitoringLogsPtrOutputWithContext(context.Background())
}

func (i *logstashSpecMonitoringLogsPtrType) ToLogstashSpecMonitoringLogsPtrOutputWithContext(ctx context.Context) LogstashSpecMonitoringLogsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecMonitoringLogsPtrOutput)
}

// Logs holds references to Elasticsearch clusters which receive log data from an associated resource.
type LogstashSpecMonitoringLogsOutput struct{ *pulumi.OutputState }

func (LogstashSpecMonitoringLogsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecMonitoringLogs)(nil)).Elem()
}

func (o LogstashSpecMonitoringLogsOutput) ToLogstashSpecMonitoringLogsOutput() LogstashSpecMonitoringLogsOutput {
	return o
}

func (o LogstashSpecMonitoringLogsOutput) ToLogstashSpecMonitoringLogsOutputWithContext(ctx context.Context) LogstashSpecMonitoringLogsOutput {
	return o
}

func (o LogstashSpecMonitoringLogsOutput) ToLogstashSpecMonitoringLogsPtrOutput() LogstashSpecMonitoringLogsPtrOutput {
	return o.ToLogstashSpecMonitoringLogsPtrOutputWithContext(context.Background())
}

func (o LogstashSpecMonitoringLogsOutput) ToLogstashSpecMonitoringLogsPtrOutputWithContext(ctx context.Context) LogstashSpecMonitoringLogsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LogstashSpecMonitoringLogs) *LogstashSpecMonitoringLogs {
		return &v
	}).(LogstashSpecMonitoringLogsPtrOutput)
}

// ElasticsearchRefs is a reference to a list of monitoring Elasticsearch clusters running in the same Kubernetes cluster.
// Due to existing limitations, only a single Elasticsearch cluster is currently supported.
func (o LogstashSpecMonitoringLogsOutput) ElasticsearchRefs() LogstashSpecMonitoringLogsElasticsearchRefsArrayOutput {
	return o.ApplyT(func(v LogstashSpecMonitoringLogs) []LogstashSpecMonitoringLogsElasticsearchRefs {
		return v.ElasticsearchRefs
	}).(LogstashSpecMonitoringLogsElasticsearchRefsArrayOutput)
}

type LogstashSpecMonitoringLogsPtrOutput struct{ *pulumi.OutputState }

func (LogstashSpecMonitoringLogsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecMonitoringLogs)(nil)).Elem()
}

func (o LogstashSpecMonitoringLogsPtrOutput) ToLogstashSpecMonitoringLogsPtrOutput() LogstashSpecMonitoringLogsPtrOutput {
	return o
}

func (o LogstashSpecMonitoringLogsPtrOutput) ToLogstashSpecMonitoringLogsPtrOutputWithContext(ctx context.Context) LogstashSpecMonitoringLogsPtrOutput {
	return o
}

func (o LogstashSpecMonitoringLogsPtrOutput) Elem() LogstashSpecMonitoringLogsOutput {
	return o.ApplyT(func(v *LogstashSpecMonitoringLogs) LogstashSpecMonitoringLogs {
		if v != nil {
			return *v
		}
		var ret LogstashSpecMonitoringLogs
		return ret
	}).(LogstashSpecMonitoringLogsOutput)
}

// ElasticsearchRefs is a reference to a list of monitoring Elasticsearch clusters running in the same Kubernetes cluster.
// Due to existing limitations, only a single Elasticsearch cluster is currently supported.
func (o LogstashSpecMonitoringLogsPtrOutput) ElasticsearchRefs() LogstashSpecMonitoringLogsElasticsearchRefsArrayOutput {
	return o.ApplyT(func(v *LogstashSpecMonitoringLogs) []LogstashSpecMonitoringLogsElasticsearchRefs {
		if v == nil {
			return nil
		}
		return v.ElasticsearchRefs
	}).(LogstashSpecMonitoringLogsElasticsearchRefsArrayOutput)
}

// ObjectSelector defines a reference to a Kubernetes object which can be an Elastic resource managed by the operator
// or a Secret describing an external Elastic resource not managed by the operator.
type LogstashSpecMonitoringLogsElasticsearchRefs struct {
	// Name of an existing Kubernetes object corresponding to an Elastic resource managed by ECK.
	Name *string `pulumi:"name"`
	// Namespace of the Kubernetes object. If empty, defaults to the current namespace.
	Namespace *string `pulumi:"namespace"`
	// SecretName is the name of an existing Kubernetes secret that contains connection information for associating an
	// Elastic resource not managed by the operator. The referenced secret must contain the following:
	// - `url`: the URL to reach the Elastic resource
	// - `username`: the username of the user to be authenticated to the Elastic resource
	// - `password`: the password of the user to be authenticated to the Elastic resource
	// - `ca.crt`: the CA certificate in PEM format (optional)
	// - `api-key`: the key to authenticate against the Elastic resource instead of a username and password (supported only for `elasticsearchRefs` in AgentSpec and in BeatSpec)
	//   This field cannot be used in combination with the other fields name, namespace or serviceName.
	SecretName *string `pulumi:"secretName"`
	// ServiceName is the name of an existing Kubernetes service which is used to make requests to the referenced
	// object. It has to be in the same namespace as the referenced resource. If left empty, the default HTTP service of
	// the referenced resource is used.
	ServiceName *string `pulumi:"serviceName"`
}

// LogstashSpecMonitoringLogsElasticsearchRefsInput is an input type that accepts LogstashSpecMonitoringLogsElasticsearchRefsArgs and LogstashSpecMonitoringLogsElasticsearchRefsOutput values.
// You can construct a concrete instance of `LogstashSpecMonitoringLogsElasticsearchRefsInput` via:
//
//	LogstashSpecMonitoringLogsElasticsearchRefsArgs{...}
type LogstashSpecMonitoringLogsElasticsearchRefsInput interface {
	pulumi.Input

	ToLogstashSpecMonitoringLogsElasticsearchRefsOutput() LogstashSpecMonitoringLogsElasticsearchRefsOutput
	ToLogstashSpecMonitoringLogsElasticsearchRefsOutputWithContext(context.Context) LogstashSpecMonitoringLogsElasticsearchRefsOutput
}

// ObjectSelector defines a reference to a Kubernetes object which can be an Elastic resource managed by the operator
// or a Secret describing an external Elastic resource not managed by the operator.
type LogstashSpecMonitoringLogsElasticsearchRefsArgs struct {
	// Name of an existing Kubernetes object corresponding to an Elastic resource managed by ECK.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace of the Kubernetes object. If empty, defaults to the current namespace.
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// SecretName is the name of an existing Kubernetes secret that contains connection information for associating an
	// Elastic resource not managed by the operator. The referenced secret must contain the following:
	// - `url`: the URL to reach the Elastic resource
	// - `username`: the username of the user to be authenticated to the Elastic resource
	// - `password`: the password of the user to be authenticated to the Elastic resource
	// - `ca.crt`: the CA certificate in PEM format (optional)
	// - `api-key`: the key to authenticate against the Elastic resource instead of a username and password (supported only for `elasticsearchRefs` in AgentSpec and in BeatSpec)
	//   This field cannot be used in combination with the other fields name, namespace or serviceName.
	SecretName pulumi.StringPtrInput `pulumi:"secretName"`
	// ServiceName is the name of an existing Kubernetes service which is used to make requests to the referenced
	// object. It has to be in the same namespace as the referenced resource. If left empty, the default HTTP service of
	// the referenced resource is used.
	ServiceName pulumi.StringPtrInput `pulumi:"serviceName"`
}

func (LogstashSpecMonitoringLogsElasticsearchRefsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecMonitoringLogsElasticsearchRefs)(nil)).Elem()
}

func (i LogstashSpecMonitoringLogsElasticsearchRefsArgs) ToLogstashSpecMonitoringLogsElasticsearchRefsOutput() LogstashSpecMonitoringLogsElasticsearchRefsOutput {
	return i.ToLogstashSpecMonitoringLogsElasticsearchRefsOutputWithContext(context.Background())
}

func (i LogstashSpecMonitoringLogsElasticsearchRefsArgs) ToLogstashSpecMonitoringLogsElasticsearchRefsOutputWithContext(ctx context.Context) LogstashSpecMonitoringLogsElasticsearchRefsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecMonitoringLogsElasticsearchRefsOutput)
}

// LogstashSpecMonitoringLogsElasticsearchRefsArrayInput is an input type that accepts LogstashSpecMonitoringLogsElasticsearchRefsArray and LogstashSpecMonitoringLogsElasticsearchRefsArrayOutput values.
// You can construct a concrete instance of `LogstashSpecMonitoringLogsElasticsearchRefsArrayInput` via:
//
//	LogstashSpecMonitoringLogsElasticsearchRefsArray{ LogstashSpecMonitoringLogsElasticsearchRefsArgs{...} }
type LogstashSpecMonitoringLogsElasticsearchRefsArrayInput interface {
	pulumi.Input

	ToLogstashSpecMonitoringLogsElasticsearchRefsArrayOutput() LogstashSpecMonitoringLogsElasticsearchRefsArrayOutput
	ToLogstashSpecMonitoringLogsElasticsearchRefsArrayOutputWithContext(context.Context) LogstashSpecMonitoringLogsElasticsearchRefsArrayOutput
}

type LogstashSpecMonitoringLogsElasticsearchRefsArray []LogstashSpecMonitoringLogsElasticsearchRefsInput

func (LogstashSpecMonitoringLogsElasticsearchRefsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LogstashSpecMonitoringLogsElasticsearchRefs)(nil)).Elem()
}

func (i LogstashSpecMonitoringLogsElasticsearchRefsArray) ToLogstashSpecMonitoringLogsElasticsearchRefsArrayOutput() LogstashSpecMonitoringLogsElasticsearchRefsArrayOutput {
	return i.ToLogstashSpecMonitoringLogsElasticsearchRefsArrayOutputWithContext(context.Background())
}

func (i LogstashSpecMonitoringLogsElasticsearchRefsArray) ToLogstashSpecMonitoringLogsElasticsearchRefsArrayOutputWithContext(ctx context.Context) LogstashSpecMonitoringLogsElasticsearchRefsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecMonitoringLogsElasticsearchRefsArrayOutput)
}

// ObjectSelector defines a reference to a Kubernetes object which can be an Elastic resource managed by the operator
// or a Secret describing an external Elastic resource not managed by the operator.
type LogstashSpecMonitoringLogsElasticsearchRefsOutput struct{ *pulumi.OutputState }

func (LogstashSpecMonitoringLogsElasticsearchRefsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecMonitoringLogsElasticsearchRefs)(nil)).Elem()
}

func (o LogstashSpecMonitoringLogsElasticsearchRefsOutput) ToLogstashSpecMonitoringLogsElasticsearchRefsOutput() LogstashSpecMonitoringLogsElasticsearchRefsOutput {
	return o
}

func (o LogstashSpecMonitoringLogsElasticsearchRefsOutput) ToLogstashSpecMonitoringLogsElasticsearchRefsOutputWithContext(ctx context.Context) LogstashSpecMonitoringLogsElasticsearchRefsOutput {
	return o
}

// Name of an existing Kubernetes object corresponding to an Elastic resource managed by ECK.
func (o LogstashSpecMonitoringLogsElasticsearchRefsOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecMonitoringLogsElasticsearchRefs) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace of the Kubernetes object. If empty, defaults to the current namespace.
func (o LogstashSpecMonitoringLogsElasticsearchRefsOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecMonitoringLogsElasticsearchRefs) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// SecretName is the name of an existing Kubernetes secret that contains connection information for associating an
// Elastic resource not managed by the operator. The referenced secret must contain the following:
//   - `url`: the URL to reach the Elastic resource
//   - `username`: the username of the user to be authenticated to the Elastic resource
//   - `password`: the password of the user to be authenticated to the Elastic resource
//   - `ca.crt`: the CA certificate in PEM format (optional)
//   - `api-key`: the key to authenticate against the Elastic resource instead of a username and password (supported only for `elasticsearchRefs` in AgentSpec and in BeatSpec)
//     This field cannot be used in combination with the other fields name, namespace or serviceName.
func (o LogstashSpecMonitoringLogsElasticsearchRefsOutput) SecretName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecMonitoringLogsElasticsearchRefs) *string { return v.SecretName }).(pulumi.StringPtrOutput)
}

// ServiceName is the name of an existing Kubernetes service which is used to make requests to the referenced
// object. It has to be in the same namespace as the referenced resource. If left empty, the default HTTP service of
// the referenced resource is used.
func (o LogstashSpecMonitoringLogsElasticsearchRefsOutput) ServiceName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecMonitoringLogsElasticsearchRefs) *string { return v.ServiceName }).(pulumi.StringPtrOutput)
}

type LogstashSpecMonitoringLogsElasticsearchRefsArrayOutput struct{ *pulumi.OutputState }

func (LogstashSpecMonitoringLogsElasticsearchRefsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LogstashSpecMonitoringLogsElasticsearchRefs)(nil)).Elem()
}

func (o LogstashSpecMonitoringLogsElasticsearchRefsArrayOutput) ToLogstashSpecMonitoringLogsElasticsearchRefsArrayOutput() LogstashSpecMonitoringLogsElasticsearchRefsArrayOutput {
	return o
}

func (o LogstashSpecMonitoringLogsElasticsearchRefsArrayOutput) ToLogstashSpecMonitoringLogsElasticsearchRefsArrayOutputWithContext(ctx context.Context) LogstashSpecMonitoringLogsElasticsearchRefsArrayOutput {
	return o
}

func (o LogstashSpecMonitoringLogsElasticsearchRefsArrayOutput) Index(i pulumi.IntInput) LogstashSpecMonitoringLogsElasticsearchRefsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LogstashSpecMonitoringLogsElasticsearchRefs {
		return vs[0].([]LogstashSpecMonitoringLogsElasticsearchRefs)[vs[1].(int)]
	}).(LogstashSpecMonitoringLogsElasticsearchRefsOutput)
}

// Metrics holds references to Elasticsearch clusters which receive monitoring data from this resource.
type LogstashSpecMonitoringMetrics struct {
	// ElasticsearchRefs is a reference to a list of monitoring Elasticsearch clusters running in the same Kubernetes cluster.
	// Due to existing limitations, only a single Elasticsearch cluster is currently supported.
	ElasticsearchRefs []LogstashSpecMonitoringMetricsElasticsearchRefs `pulumi:"elasticsearchRefs"`
}

// LogstashSpecMonitoringMetricsInput is an input type that accepts LogstashSpecMonitoringMetricsArgs and LogstashSpecMonitoringMetricsOutput values.
// You can construct a concrete instance of `LogstashSpecMonitoringMetricsInput` via:
//
//	LogstashSpecMonitoringMetricsArgs{...}
type LogstashSpecMonitoringMetricsInput interface {
	pulumi.Input

	ToLogstashSpecMonitoringMetricsOutput() LogstashSpecMonitoringMetricsOutput
	ToLogstashSpecMonitoringMetricsOutputWithContext(context.Context) LogstashSpecMonitoringMetricsOutput
}

// Metrics holds references to Elasticsearch clusters which receive monitoring data from this resource.
type LogstashSpecMonitoringMetricsArgs struct {
	// ElasticsearchRefs is a reference to a list of monitoring Elasticsearch clusters running in the same Kubernetes cluster.
	// Due to existing limitations, only a single Elasticsearch cluster is currently supported.
	ElasticsearchRefs LogstashSpecMonitoringMetricsElasticsearchRefsArrayInput `pulumi:"elasticsearchRefs"`
}

func (LogstashSpecMonitoringMetricsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecMonitoringMetrics)(nil)).Elem()
}

func (i LogstashSpecMonitoringMetricsArgs) ToLogstashSpecMonitoringMetricsOutput() LogstashSpecMonitoringMetricsOutput {
	return i.ToLogstashSpecMonitoringMetricsOutputWithContext(context.Background())
}

func (i LogstashSpecMonitoringMetricsArgs) ToLogstashSpecMonitoringMetricsOutputWithContext(ctx context.Context) LogstashSpecMonitoringMetricsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecMonitoringMetricsOutput)
}

func (i LogstashSpecMonitoringMetricsArgs) ToLogstashSpecMonitoringMetricsPtrOutput() LogstashSpecMonitoringMetricsPtrOutput {
	return i.ToLogstashSpecMonitoringMetricsPtrOutputWithContext(context.Background())
}

func (i LogstashSpecMonitoringMetricsArgs) ToLogstashSpecMonitoringMetricsPtrOutputWithContext(ctx context.Context) LogstashSpecMonitoringMetricsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecMonitoringMetricsOutput).ToLogstashSpecMonitoringMetricsPtrOutputWithContext(ctx)
}

// LogstashSpecMonitoringMetricsPtrInput is an input type that accepts LogstashSpecMonitoringMetricsArgs, LogstashSpecMonitoringMetricsPtr and LogstashSpecMonitoringMetricsPtrOutput values.
// You can construct a concrete instance of `LogstashSpecMonitoringMetricsPtrInput` via:
//
//	        LogstashSpecMonitoringMetricsArgs{...}
//
//	or:
//
//	        nil
type LogstashSpecMonitoringMetricsPtrInput interface {
	pulumi.Input

	ToLogstashSpecMonitoringMetricsPtrOutput() LogstashSpecMonitoringMetricsPtrOutput
	ToLogstashSpecMonitoringMetricsPtrOutputWithContext(context.Context) LogstashSpecMonitoringMetricsPtrOutput
}

type logstashSpecMonitoringMetricsPtrType LogstashSpecMonitoringMetricsArgs

func LogstashSpecMonitoringMetricsPtr(v *LogstashSpecMonitoringMetricsArgs) LogstashSpecMonitoringMetricsPtrInput {
	return (*logstashSpecMonitoringMetricsPtrType)(v)
}

func (*logstashSpecMonitoringMetricsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecMonitoringMetrics)(nil)).Elem()
}

func (i *logstashSpecMonitoringMetricsPtrType) ToLogstashSpecMonitoringMetricsPtrOutput() LogstashSpecMonitoringMetricsPtrOutput {
	return i.ToLogstashSpecMonitoringMetricsPtrOutputWithContext(context.Background())
}

func (i *logstashSpecMonitoringMetricsPtrType) ToLogstashSpecMonitoringMetricsPtrOutputWithContext(ctx context.Context) LogstashSpecMonitoringMetricsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecMonitoringMetricsPtrOutput)
}

// Metrics holds references to Elasticsearch clusters which receive monitoring data from this resource.
type LogstashSpecMonitoringMetricsOutput struct{ *pulumi.OutputState }

func (LogstashSpecMonitoringMetricsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecMonitoringMetrics)(nil)).Elem()
}

func (o LogstashSpecMonitoringMetricsOutput) ToLogstashSpecMonitoringMetricsOutput() LogstashSpecMonitoringMetricsOutput {
	return o
}

func (o LogstashSpecMonitoringMetricsOutput) ToLogstashSpecMonitoringMetricsOutputWithContext(ctx context.Context) LogstashSpecMonitoringMetricsOutput {
	return o
}

func (o LogstashSpecMonitoringMetricsOutput) ToLogstashSpecMonitoringMetricsPtrOutput() LogstashSpecMonitoringMetricsPtrOutput {
	return o.ToLogstashSpecMonitoringMetricsPtrOutputWithContext(context.Background())
}

func (o LogstashSpecMonitoringMetricsOutput) ToLogstashSpecMonitoringMetricsPtrOutputWithContext(ctx context.Context) LogstashSpecMonitoringMetricsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LogstashSpecMonitoringMetrics) *LogstashSpecMonitoringMetrics {
		return &v
	}).(LogstashSpecMonitoringMetricsPtrOutput)
}

// ElasticsearchRefs is a reference to a list of monitoring Elasticsearch clusters running in the same Kubernetes cluster.
// Due to existing limitations, only a single Elasticsearch cluster is currently supported.
func (o LogstashSpecMonitoringMetricsOutput) ElasticsearchRefs() LogstashSpecMonitoringMetricsElasticsearchRefsArrayOutput {
	return o.ApplyT(func(v LogstashSpecMonitoringMetrics) []LogstashSpecMonitoringMetricsElasticsearchRefs {
		return v.ElasticsearchRefs
	}).(LogstashSpecMonitoringMetricsElasticsearchRefsArrayOutput)
}

type LogstashSpecMonitoringMetricsPtrOutput struct{ *pulumi.OutputState }

func (LogstashSpecMonitoringMetricsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecMonitoringMetrics)(nil)).Elem()
}

func (o LogstashSpecMonitoringMetricsPtrOutput) ToLogstashSpecMonitoringMetricsPtrOutput() LogstashSpecMonitoringMetricsPtrOutput {
	return o
}

func (o LogstashSpecMonitoringMetricsPtrOutput) ToLogstashSpecMonitoringMetricsPtrOutputWithContext(ctx context.Context) LogstashSpecMonitoringMetricsPtrOutput {
	return o
}

func (o LogstashSpecMonitoringMetricsPtrOutput) Elem() LogstashSpecMonitoringMetricsOutput {
	return o.ApplyT(func(v *LogstashSpecMonitoringMetrics) LogstashSpecMonitoringMetrics {
		if v != nil {
			return *v
		}
		var ret LogstashSpecMonitoringMetrics
		return ret
	}).(LogstashSpecMonitoringMetricsOutput)
}

// ElasticsearchRefs is a reference to a list of monitoring Elasticsearch clusters running in the same Kubernetes cluster.
// Due to existing limitations, only a single Elasticsearch cluster is currently supported.
func (o LogstashSpecMonitoringMetricsPtrOutput) ElasticsearchRefs() LogstashSpecMonitoringMetricsElasticsearchRefsArrayOutput {
	return o.ApplyT(func(v *LogstashSpecMonitoringMetrics) []LogstashSpecMonitoringMetricsElasticsearchRefs {
		if v == nil {
			return nil
		}
		return v.ElasticsearchRefs
	}).(LogstashSpecMonitoringMetricsElasticsearchRefsArrayOutput)
}

// ObjectSelector defines a reference to a Kubernetes object which can be an Elastic resource managed by the operator
// or a Secret describing an external Elastic resource not managed by the operator.
type LogstashSpecMonitoringMetricsElasticsearchRefs struct {
	// Name of an existing Kubernetes object corresponding to an Elastic resource managed by ECK.
	Name *string `pulumi:"name"`
	// Namespace of the Kubernetes object. If empty, defaults to the current namespace.
	Namespace *string `pulumi:"namespace"`
	// SecretName is the name of an existing Kubernetes secret that contains connection information for associating an
	// Elastic resource not managed by the operator. The referenced secret must contain the following:
	// - `url`: the URL to reach the Elastic resource
	// - `username`: the username of the user to be authenticated to the Elastic resource
	// - `password`: the password of the user to be authenticated to the Elastic resource
	// - `ca.crt`: the CA certificate in PEM format (optional)
	// - `api-key`: the key to authenticate against the Elastic resource instead of a username and password (supported only for `elasticsearchRefs` in AgentSpec and in BeatSpec)
	//   This field cannot be used in combination with the other fields name, namespace or serviceName.
	SecretName *string `pulumi:"secretName"`
	// ServiceName is the name of an existing Kubernetes service which is used to make requests to the referenced
	// object. It has to be in the same namespace as the referenced resource. If left empty, the default HTTP service of
	// the referenced resource is used.
	ServiceName *string `pulumi:"serviceName"`
}

// LogstashSpecMonitoringMetricsElasticsearchRefsInput is an input type that accepts LogstashSpecMonitoringMetricsElasticsearchRefsArgs and LogstashSpecMonitoringMetricsElasticsearchRefsOutput values.
// You can construct a concrete instance of `LogstashSpecMonitoringMetricsElasticsearchRefsInput` via:
//
//	LogstashSpecMonitoringMetricsElasticsearchRefsArgs{...}
type LogstashSpecMonitoringMetricsElasticsearchRefsInput interface {
	pulumi.Input

	ToLogstashSpecMonitoringMetricsElasticsearchRefsOutput() LogstashSpecMonitoringMetricsElasticsearchRefsOutput
	ToLogstashSpecMonitoringMetricsElasticsearchRefsOutputWithContext(context.Context) LogstashSpecMonitoringMetricsElasticsearchRefsOutput
}

// ObjectSelector defines a reference to a Kubernetes object which can be an Elastic resource managed by the operator
// or a Secret describing an external Elastic resource not managed by the operator.
type LogstashSpecMonitoringMetricsElasticsearchRefsArgs struct {
	// Name of an existing Kubernetes object corresponding to an Elastic resource managed by ECK.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace of the Kubernetes object. If empty, defaults to the current namespace.
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// SecretName is the name of an existing Kubernetes secret that contains connection information for associating an
	// Elastic resource not managed by the operator. The referenced secret must contain the following:
	// - `url`: the URL to reach the Elastic resource
	// - `username`: the username of the user to be authenticated to the Elastic resource
	// - `password`: the password of the user to be authenticated to the Elastic resource
	// - `ca.crt`: the CA certificate in PEM format (optional)
	// - `api-key`: the key to authenticate against the Elastic resource instead of a username and password (supported only for `elasticsearchRefs` in AgentSpec and in BeatSpec)
	//   This field cannot be used in combination with the other fields name, namespace or serviceName.
	SecretName pulumi.StringPtrInput `pulumi:"secretName"`
	// ServiceName is the name of an existing Kubernetes service which is used to make requests to the referenced
	// object. It has to be in the same namespace as the referenced resource. If left empty, the default HTTP service of
	// the referenced resource is used.
	ServiceName pulumi.StringPtrInput `pulumi:"serviceName"`
}

func (LogstashSpecMonitoringMetricsElasticsearchRefsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecMonitoringMetricsElasticsearchRefs)(nil)).Elem()
}

func (i LogstashSpecMonitoringMetricsElasticsearchRefsArgs) ToLogstashSpecMonitoringMetricsElasticsearchRefsOutput() LogstashSpecMonitoringMetricsElasticsearchRefsOutput {
	return i.ToLogstashSpecMonitoringMetricsElasticsearchRefsOutputWithContext(context.Background())
}

func (i LogstashSpecMonitoringMetricsElasticsearchRefsArgs) ToLogstashSpecMonitoringMetricsElasticsearchRefsOutputWithContext(ctx context.Context) LogstashSpecMonitoringMetricsElasticsearchRefsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecMonitoringMetricsElasticsearchRefsOutput)
}

// LogstashSpecMonitoringMetricsElasticsearchRefsArrayInput is an input type that accepts LogstashSpecMonitoringMetricsElasticsearchRefsArray and LogstashSpecMonitoringMetricsElasticsearchRefsArrayOutput values.
// You can construct a concrete instance of `LogstashSpecMonitoringMetricsElasticsearchRefsArrayInput` via:
//
//	LogstashSpecMonitoringMetricsElasticsearchRefsArray{ LogstashSpecMonitoringMetricsElasticsearchRefsArgs{...} }
type LogstashSpecMonitoringMetricsElasticsearchRefsArrayInput interface {
	pulumi.Input

	ToLogstashSpecMonitoringMetricsElasticsearchRefsArrayOutput() LogstashSpecMonitoringMetricsElasticsearchRefsArrayOutput
	ToLogstashSpecMonitoringMetricsElasticsearchRefsArrayOutputWithContext(context.Context) LogstashSpecMonitoringMetricsElasticsearchRefsArrayOutput
}

type LogstashSpecMonitoringMetricsElasticsearchRefsArray []LogstashSpecMonitoringMetricsElasticsearchRefsInput

func (LogstashSpecMonitoringMetricsElasticsearchRefsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LogstashSpecMonitoringMetricsElasticsearchRefs)(nil)).Elem()
}

func (i LogstashSpecMonitoringMetricsElasticsearchRefsArray) ToLogstashSpecMonitoringMetricsElasticsearchRefsArrayOutput() LogstashSpecMonitoringMetricsElasticsearchRefsArrayOutput {
	return i.ToLogstashSpecMonitoringMetricsElasticsearchRefsArrayOutputWithContext(context.Background())
}

func (i LogstashSpecMonitoringMetricsElasticsearchRefsArray) ToLogstashSpecMonitoringMetricsElasticsearchRefsArrayOutputWithContext(ctx context.Context) LogstashSpecMonitoringMetricsElasticsearchRefsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecMonitoringMetricsElasticsearchRefsArrayOutput)
}

// ObjectSelector defines a reference to a Kubernetes object which can be an Elastic resource managed by the operator
// or a Secret describing an external Elastic resource not managed by the operator.
type LogstashSpecMonitoringMetricsElasticsearchRefsOutput struct{ *pulumi.OutputState }

func (LogstashSpecMonitoringMetricsElasticsearchRefsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecMonitoringMetricsElasticsearchRefs)(nil)).Elem()
}

func (o LogstashSpecMonitoringMetricsElasticsearchRefsOutput) ToLogstashSpecMonitoringMetricsElasticsearchRefsOutput() LogstashSpecMonitoringMetricsElasticsearchRefsOutput {
	return o
}

func (o LogstashSpecMonitoringMetricsElasticsearchRefsOutput) ToLogstashSpecMonitoringMetricsElasticsearchRefsOutputWithContext(ctx context.Context) LogstashSpecMonitoringMetricsElasticsearchRefsOutput {
	return o
}

// Name of an existing Kubernetes object corresponding to an Elastic resource managed by ECK.
func (o LogstashSpecMonitoringMetricsElasticsearchRefsOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecMonitoringMetricsElasticsearchRefs) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace of the Kubernetes object. If empty, defaults to the current namespace.
func (o LogstashSpecMonitoringMetricsElasticsearchRefsOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecMonitoringMetricsElasticsearchRefs) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// SecretName is the name of an existing Kubernetes secret that contains connection information for associating an
// Elastic resource not managed by the operator. The referenced secret must contain the following:
//   - `url`: the URL to reach the Elastic resource
//   - `username`: the username of the user to be authenticated to the Elastic resource
//   - `password`: the password of the user to be authenticated to the Elastic resource
//   - `ca.crt`: the CA certificate in PEM format (optional)
//   - `api-key`: the key to authenticate against the Elastic resource instead of a username and password (supported only for `elasticsearchRefs` in AgentSpec and in BeatSpec)
//     This field cannot be used in combination with the other fields name, namespace or serviceName.
func (o LogstashSpecMonitoringMetricsElasticsearchRefsOutput) SecretName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecMonitoringMetricsElasticsearchRefs) *string { return v.SecretName }).(pulumi.StringPtrOutput)
}

// ServiceName is the name of an existing Kubernetes service which is used to make requests to the referenced
// object. It has to be in the same namespace as the referenced resource. If left empty, the default HTTP service of
// the referenced resource is used.
func (o LogstashSpecMonitoringMetricsElasticsearchRefsOutput) ServiceName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecMonitoringMetricsElasticsearchRefs) *string { return v.ServiceName }).(pulumi.StringPtrOutput)
}

type LogstashSpecMonitoringMetricsElasticsearchRefsArrayOutput struct{ *pulumi.OutputState }

func (LogstashSpecMonitoringMetricsElasticsearchRefsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LogstashSpecMonitoringMetricsElasticsearchRefs)(nil)).Elem()
}

func (o LogstashSpecMonitoringMetricsElasticsearchRefsArrayOutput) ToLogstashSpecMonitoringMetricsElasticsearchRefsArrayOutput() LogstashSpecMonitoringMetricsElasticsearchRefsArrayOutput {
	return o
}

func (o LogstashSpecMonitoringMetricsElasticsearchRefsArrayOutput) ToLogstashSpecMonitoringMetricsElasticsearchRefsArrayOutputWithContext(ctx context.Context) LogstashSpecMonitoringMetricsElasticsearchRefsArrayOutput {
	return o
}

func (o LogstashSpecMonitoringMetricsElasticsearchRefsArrayOutput) Index(i pulumi.IntInput) LogstashSpecMonitoringMetricsElasticsearchRefsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LogstashSpecMonitoringMetricsElasticsearchRefs {
		return vs[0].([]LogstashSpecMonitoringMetricsElasticsearchRefs)[vs[1].(int)]
	}).(LogstashSpecMonitoringMetricsElasticsearchRefsOutput)
}

// PipelinesRef contains a reference to an existing Kubernetes Secret holding the Logstash Pipelines.
// Logstash pipelines must be specified as yaml, under a single "pipelines.yml" entry. At most one of [`Pipelines`, `PipelinesRef`]
// can be specified.
type LogstashSpecPipelinesRef struct {
	// SecretName is the name of the secret.
	SecretName *string `pulumi:"secretName"`
}

// LogstashSpecPipelinesRefInput is an input type that accepts LogstashSpecPipelinesRefArgs and LogstashSpecPipelinesRefOutput values.
// You can construct a concrete instance of `LogstashSpecPipelinesRefInput` via:
//
//	LogstashSpecPipelinesRefArgs{...}
type LogstashSpecPipelinesRefInput interface {
	pulumi.Input

	ToLogstashSpecPipelinesRefOutput() LogstashSpecPipelinesRefOutput
	ToLogstashSpecPipelinesRefOutputWithContext(context.Context) LogstashSpecPipelinesRefOutput
}

// PipelinesRef contains a reference to an existing Kubernetes Secret holding the Logstash Pipelines.
// Logstash pipelines must be specified as yaml, under a single "pipelines.yml" entry. At most one of [`Pipelines`, `PipelinesRef`]
// can be specified.
type LogstashSpecPipelinesRefArgs struct {
	// SecretName is the name of the secret.
	SecretName pulumi.StringPtrInput `pulumi:"secretName"`
}

func (LogstashSpecPipelinesRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecPipelinesRef)(nil)).Elem()
}

func (i LogstashSpecPipelinesRefArgs) ToLogstashSpecPipelinesRefOutput() LogstashSpecPipelinesRefOutput {
	return i.ToLogstashSpecPipelinesRefOutputWithContext(context.Background())
}

func (i LogstashSpecPipelinesRefArgs) ToLogstashSpecPipelinesRefOutputWithContext(ctx context.Context) LogstashSpecPipelinesRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecPipelinesRefOutput)
}

func (i LogstashSpecPipelinesRefArgs) ToLogstashSpecPipelinesRefPtrOutput() LogstashSpecPipelinesRefPtrOutput {
	return i.ToLogstashSpecPipelinesRefPtrOutputWithContext(context.Background())
}

func (i LogstashSpecPipelinesRefArgs) ToLogstashSpecPipelinesRefPtrOutputWithContext(ctx context.Context) LogstashSpecPipelinesRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecPipelinesRefOutput).ToLogstashSpecPipelinesRefPtrOutputWithContext(ctx)
}

// LogstashSpecPipelinesRefPtrInput is an input type that accepts LogstashSpecPipelinesRefArgs, LogstashSpecPipelinesRefPtr and LogstashSpecPipelinesRefPtrOutput values.
// You can construct a concrete instance of `LogstashSpecPipelinesRefPtrInput` via:
//
//	        LogstashSpecPipelinesRefArgs{...}
//
//	or:
//
//	        nil
type LogstashSpecPipelinesRefPtrInput interface {
	pulumi.Input

	ToLogstashSpecPipelinesRefPtrOutput() LogstashSpecPipelinesRefPtrOutput
	ToLogstashSpecPipelinesRefPtrOutputWithContext(context.Context) LogstashSpecPipelinesRefPtrOutput
}

type logstashSpecPipelinesRefPtrType LogstashSpecPipelinesRefArgs

func LogstashSpecPipelinesRefPtr(v *LogstashSpecPipelinesRefArgs) LogstashSpecPipelinesRefPtrInput {
	return (*logstashSpecPipelinesRefPtrType)(v)
}

func (*logstashSpecPipelinesRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecPipelinesRef)(nil)).Elem()
}

func (i *logstashSpecPipelinesRefPtrType) ToLogstashSpecPipelinesRefPtrOutput() LogstashSpecPipelinesRefPtrOutput {
	return i.ToLogstashSpecPipelinesRefPtrOutputWithContext(context.Background())
}

func (i *logstashSpecPipelinesRefPtrType) ToLogstashSpecPipelinesRefPtrOutputWithContext(ctx context.Context) LogstashSpecPipelinesRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecPipelinesRefPtrOutput)
}

// PipelinesRef contains a reference to an existing Kubernetes Secret holding the Logstash Pipelines.
// Logstash pipelines must be specified as yaml, under a single "pipelines.yml" entry. At most one of [`Pipelines`, `PipelinesRef`]
// can be specified.
type LogstashSpecPipelinesRefOutput struct{ *pulumi.OutputState }

func (LogstashSpecPipelinesRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecPipelinesRef)(nil)).Elem()
}

func (o LogstashSpecPipelinesRefOutput) ToLogstashSpecPipelinesRefOutput() LogstashSpecPipelinesRefOutput {
	return o
}

func (o LogstashSpecPipelinesRefOutput) ToLogstashSpecPipelinesRefOutputWithContext(ctx context.Context) LogstashSpecPipelinesRefOutput {
	return o
}

func (o LogstashSpecPipelinesRefOutput) ToLogstashSpecPipelinesRefPtrOutput() LogstashSpecPipelinesRefPtrOutput {
	return o.ToLogstashSpecPipelinesRefPtrOutputWithContext(context.Background())
}

func (o LogstashSpecPipelinesRefOutput) ToLogstashSpecPipelinesRefPtrOutputWithContext(ctx context.Context) LogstashSpecPipelinesRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LogstashSpecPipelinesRef) *LogstashSpecPipelinesRef {
		return &v
	}).(LogstashSpecPipelinesRefPtrOutput)
}

// SecretName is the name of the secret.
func (o LogstashSpecPipelinesRefOutput) SecretName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecPipelinesRef) *string { return v.SecretName }).(pulumi.StringPtrOutput)
}

type LogstashSpecPipelinesRefPtrOutput struct{ *pulumi.OutputState }

func (LogstashSpecPipelinesRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecPipelinesRef)(nil)).Elem()
}

func (o LogstashSpecPipelinesRefPtrOutput) ToLogstashSpecPipelinesRefPtrOutput() LogstashSpecPipelinesRefPtrOutput {
	return o
}

func (o LogstashSpecPipelinesRefPtrOutput) ToLogstashSpecPipelinesRefPtrOutputWithContext(ctx context.Context) LogstashSpecPipelinesRefPtrOutput {
	return o
}

func (o LogstashSpecPipelinesRefPtrOutput) Elem() LogstashSpecPipelinesRefOutput {
	return o.ApplyT(func(v *LogstashSpecPipelinesRef) LogstashSpecPipelinesRef {
		if v != nil {
			return *v
		}
		var ret LogstashSpecPipelinesRef
		return ret
	}).(LogstashSpecPipelinesRefOutput)
}

// SecretName is the name of the secret.
func (o LogstashSpecPipelinesRefPtrOutput) SecretName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecPipelinesRef) *string {
		if v == nil {
			return nil
		}
		return v.SecretName
	}).(pulumi.StringPtrOutput)
}

// SecretSource defines a data source based on a Kubernetes Secret.
type LogstashSpecSecureSettings struct {
	// Entries define how to project each key-value pair in the secret to filesystem paths.
	// If not defined, all keys will be projected to similarly named paths in the filesystem.
	// If defined, only the specified keys will be projected to the corresponding paths.
	Entries []LogstashSpecSecureSettingsEntries `pulumi:"entries"`
	// SecretName is the name of the secret.
	SecretName string `pulumi:"secretName"`
}

// LogstashSpecSecureSettingsInput is an input type that accepts LogstashSpecSecureSettingsArgs and LogstashSpecSecureSettingsOutput values.
// You can construct a concrete instance of `LogstashSpecSecureSettingsInput` via:
//
//	LogstashSpecSecureSettingsArgs{...}
type LogstashSpecSecureSettingsInput interface {
	pulumi.Input

	ToLogstashSpecSecureSettingsOutput() LogstashSpecSecureSettingsOutput
	ToLogstashSpecSecureSettingsOutputWithContext(context.Context) LogstashSpecSecureSettingsOutput
}

// SecretSource defines a data source based on a Kubernetes Secret.
type LogstashSpecSecureSettingsArgs struct {
	// Entries define how to project each key-value pair in the secret to filesystem paths.
	// If not defined, all keys will be projected to similarly named paths in the filesystem.
	// If defined, only the specified keys will be projected to the corresponding paths.
	Entries LogstashSpecSecureSettingsEntriesArrayInput `pulumi:"entries"`
	// SecretName is the name of the secret.
	SecretName pulumi.StringInput `pulumi:"secretName"`
}

func (LogstashSpecSecureSettingsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecSecureSettings)(nil)).Elem()
}

func (i LogstashSpecSecureSettingsArgs) ToLogstashSpecSecureSettingsOutput() LogstashSpecSecureSettingsOutput {
	return i.ToLogstashSpecSecureSettingsOutputWithContext(context.Background())
}

func (i LogstashSpecSecureSettingsArgs) ToLogstashSpecSecureSettingsOutputWithContext(ctx context.Context) LogstashSpecSecureSettingsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecSecureSettingsOutput)
}

// LogstashSpecSecureSettingsArrayInput is an input type that accepts LogstashSpecSecureSettingsArray and LogstashSpecSecureSettingsArrayOutput values.
// You can construct a concrete instance of `LogstashSpecSecureSettingsArrayInput` via:
//
//	LogstashSpecSecureSettingsArray{ LogstashSpecSecureSettingsArgs{...} }
type LogstashSpecSecureSettingsArrayInput interface {
	pulumi.Input

	ToLogstashSpecSecureSettingsArrayOutput() LogstashSpecSecureSettingsArrayOutput
	ToLogstashSpecSecureSettingsArrayOutputWithContext(context.Context) LogstashSpecSecureSettingsArrayOutput
}

type LogstashSpecSecureSettingsArray []LogstashSpecSecureSettingsInput

func (LogstashSpecSecureSettingsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LogstashSpecSecureSettings)(nil)).Elem()
}

func (i LogstashSpecSecureSettingsArray) ToLogstashSpecSecureSettingsArrayOutput() LogstashSpecSecureSettingsArrayOutput {
	return i.ToLogstashSpecSecureSettingsArrayOutputWithContext(context.Background())
}

func (i LogstashSpecSecureSettingsArray) ToLogstashSpecSecureSettingsArrayOutputWithContext(ctx context.Context) LogstashSpecSecureSettingsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecSecureSettingsArrayOutput)
}

// SecretSource defines a data source based on a Kubernetes Secret.
type LogstashSpecSecureSettingsOutput struct{ *pulumi.OutputState }

func (LogstashSpecSecureSettingsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecSecureSettings)(nil)).Elem()
}

func (o LogstashSpecSecureSettingsOutput) ToLogstashSpecSecureSettingsOutput() LogstashSpecSecureSettingsOutput {
	return o
}

func (o LogstashSpecSecureSettingsOutput) ToLogstashSpecSecureSettingsOutputWithContext(ctx context.Context) LogstashSpecSecureSettingsOutput {
	return o
}

// Entries define how to project each key-value pair in the secret to filesystem paths.
// If not defined, all keys will be projected to similarly named paths in the filesystem.
// If defined, only the specified keys will be projected to the corresponding paths.
func (o LogstashSpecSecureSettingsOutput) Entries() LogstashSpecSecureSettingsEntriesArrayOutput {
	return o.ApplyT(func(v LogstashSpecSecureSettings) []LogstashSpecSecureSettingsEntries { return v.Entries }).(LogstashSpecSecureSettingsEntriesArrayOutput)
}

// SecretName is the name of the secret.
func (o LogstashSpecSecureSettingsOutput) SecretName() pulumi.StringOutput {
	return o.ApplyT(func(v LogstashSpecSecureSettings) string { return v.SecretName }).(pulumi.StringOutput)
}

type LogstashSpecSecureSettingsArrayOutput struct{ *pulumi.OutputState }

func (LogstashSpecSecureSettingsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LogstashSpecSecureSettings)(nil)).Elem()
}

func (o LogstashSpecSecureSettingsArrayOutput) ToLogstashSpecSecureSettingsArrayOutput() LogstashSpecSecureSettingsArrayOutput {
	return o
}

func (o LogstashSpecSecureSettingsArrayOutput) ToLogstashSpecSecureSettingsArrayOutputWithContext(ctx context.Context) LogstashSpecSecureSettingsArrayOutput {
	return o
}

func (o LogstashSpecSecureSettingsArrayOutput) Index(i pulumi.IntInput) LogstashSpecSecureSettingsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LogstashSpecSecureSettings {
		return vs[0].([]LogstashSpecSecureSettings)[vs[1].(int)]
	}).(LogstashSpecSecureSettingsOutput)
}

// KeyToPath defines how to map a key in a Secret object to a filesystem path.
type LogstashSpecSecureSettingsEntries struct {
	// Key is the key contained in the secret.
	Key string `pulumi:"key"`
	// Path is the relative file path to map the key to.
	// Path must not be an absolute file path and must not contain any ".." components.
	Path *string `pulumi:"path"`
}

// LogstashSpecSecureSettingsEntriesInput is an input type that accepts LogstashSpecSecureSettingsEntriesArgs and LogstashSpecSecureSettingsEntriesOutput values.
// You can construct a concrete instance of `LogstashSpecSecureSettingsEntriesInput` via:
//
//	LogstashSpecSecureSettingsEntriesArgs{...}
type LogstashSpecSecureSettingsEntriesInput interface {
	pulumi.Input

	ToLogstashSpecSecureSettingsEntriesOutput() LogstashSpecSecureSettingsEntriesOutput
	ToLogstashSpecSecureSettingsEntriesOutputWithContext(context.Context) LogstashSpecSecureSettingsEntriesOutput
}

// KeyToPath defines how to map a key in a Secret object to a filesystem path.
type LogstashSpecSecureSettingsEntriesArgs struct {
	// Key is the key contained in the secret.
	Key pulumi.StringInput `pulumi:"key"`
	// Path is the relative file path to map the key to.
	// Path must not be an absolute file path and must not contain any ".." components.
	Path pulumi.StringPtrInput `pulumi:"path"`
}

func (LogstashSpecSecureSettingsEntriesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecSecureSettingsEntries)(nil)).Elem()
}

func (i LogstashSpecSecureSettingsEntriesArgs) ToLogstashSpecSecureSettingsEntriesOutput() LogstashSpecSecureSettingsEntriesOutput {
	return i.ToLogstashSpecSecureSettingsEntriesOutputWithContext(context.Background())
}

func (i LogstashSpecSecureSettingsEntriesArgs) ToLogstashSpecSecureSettingsEntriesOutputWithContext(ctx context.Context) LogstashSpecSecureSettingsEntriesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecSecureSettingsEntriesOutput)
}

// LogstashSpecSecureSettingsEntriesArrayInput is an input type that accepts LogstashSpecSecureSettingsEntriesArray and LogstashSpecSecureSettingsEntriesArrayOutput values.
// You can construct a concrete instance of `LogstashSpecSecureSettingsEntriesArrayInput` via:
//
//	LogstashSpecSecureSettingsEntriesArray{ LogstashSpecSecureSettingsEntriesArgs{...} }
type LogstashSpecSecureSettingsEntriesArrayInput interface {
	pulumi.Input

	ToLogstashSpecSecureSettingsEntriesArrayOutput() LogstashSpecSecureSettingsEntriesArrayOutput
	ToLogstashSpecSecureSettingsEntriesArrayOutputWithContext(context.Context) LogstashSpecSecureSettingsEntriesArrayOutput
}

type LogstashSpecSecureSettingsEntriesArray []LogstashSpecSecureSettingsEntriesInput

func (LogstashSpecSecureSettingsEntriesArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LogstashSpecSecureSettingsEntries)(nil)).Elem()
}

func (i LogstashSpecSecureSettingsEntriesArray) ToLogstashSpecSecureSettingsEntriesArrayOutput() LogstashSpecSecureSettingsEntriesArrayOutput {
	return i.ToLogstashSpecSecureSettingsEntriesArrayOutputWithContext(context.Background())
}

func (i LogstashSpecSecureSettingsEntriesArray) ToLogstashSpecSecureSettingsEntriesArrayOutputWithContext(ctx context.Context) LogstashSpecSecureSettingsEntriesArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecSecureSettingsEntriesArrayOutput)
}

// KeyToPath defines how to map a key in a Secret object to a filesystem path.
type LogstashSpecSecureSettingsEntriesOutput struct{ *pulumi.OutputState }

func (LogstashSpecSecureSettingsEntriesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecSecureSettingsEntries)(nil)).Elem()
}

func (o LogstashSpecSecureSettingsEntriesOutput) ToLogstashSpecSecureSettingsEntriesOutput() LogstashSpecSecureSettingsEntriesOutput {
	return o
}

func (o LogstashSpecSecureSettingsEntriesOutput) ToLogstashSpecSecureSettingsEntriesOutputWithContext(ctx context.Context) LogstashSpecSecureSettingsEntriesOutput {
	return o
}

// Key is the key contained in the secret.
func (o LogstashSpecSecureSettingsEntriesOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v LogstashSpecSecureSettingsEntries) string { return v.Key }).(pulumi.StringOutput)
}

// Path is the relative file path to map the key to.
// Path must not be an absolute file path and must not contain any ".." components.
func (o LogstashSpecSecureSettingsEntriesOutput) Path() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecSecureSettingsEntries) *string { return v.Path }).(pulumi.StringPtrOutput)
}

type LogstashSpecSecureSettingsEntriesArrayOutput struct{ *pulumi.OutputState }

func (LogstashSpecSecureSettingsEntriesArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LogstashSpecSecureSettingsEntries)(nil)).Elem()
}

func (o LogstashSpecSecureSettingsEntriesArrayOutput) ToLogstashSpecSecureSettingsEntriesArrayOutput() LogstashSpecSecureSettingsEntriesArrayOutput {
	return o
}

func (o LogstashSpecSecureSettingsEntriesArrayOutput) ToLogstashSpecSecureSettingsEntriesArrayOutputWithContext(ctx context.Context) LogstashSpecSecureSettingsEntriesArrayOutput {
	return o
}

func (o LogstashSpecSecureSettingsEntriesArrayOutput) Index(i pulumi.IntInput) LogstashSpecSecureSettingsEntriesOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LogstashSpecSecureSettingsEntries {
		return vs[0].([]LogstashSpecSecureSettingsEntries)[vs[1].(int)]
	}).(LogstashSpecSecureSettingsEntriesOutput)
}

type LogstashSpecServices struct {
	Name *string `pulumi:"name"`
	// Service defines the template for the associated Kubernetes Service object.
	Service *LogstashSpecServicesService `pulumi:"service"`
	// TLS defines options for configuring TLS for HTTP.
	Tls *LogstashSpecServicesTls `pulumi:"tls"`
}

// LogstashSpecServicesInput is an input type that accepts LogstashSpecServicesArgs and LogstashSpecServicesOutput values.
// You can construct a concrete instance of `LogstashSpecServicesInput` via:
//
//	LogstashSpecServicesArgs{...}
type LogstashSpecServicesInput interface {
	pulumi.Input

	ToLogstashSpecServicesOutput() LogstashSpecServicesOutput
	ToLogstashSpecServicesOutputWithContext(context.Context) LogstashSpecServicesOutput
}

type LogstashSpecServicesArgs struct {
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Service defines the template for the associated Kubernetes Service object.
	Service LogstashSpecServicesServicePtrInput `pulumi:"service"`
	// TLS defines options for configuring TLS for HTTP.
	Tls LogstashSpecServicesTlsPtrInput `pulumi:"tls"`
}

func (LogstashSpecServicesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecServices)(nil)).Elem()
}

func (i LogstashSpecServicesArgs) ToLogstashSpecServicesOutput() LogstashSpecServicesOutput {
	return i.ToLogstashSpecServicesOutputWithContext(context.Background())
}

func (i LogstashSpecServicesArgs) ToLogstashSpecServicesOutputWithContext(ctx context.Context) LogstashSpecServicesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesOutput)
}

// LogstashSpecServicesArrayInput is an input type that accepts LogstashSpecServicesArray and LogstashSpecServicesArrayOutput values.
// You can construct a concrete instance of `LogstashSpecServicesArrayInput` via:
//
//	LogstashSpecServicesArray{ LogstashSpecServicesArgs{...} }
type LogstashSpecServicesArrayInput interface {
	pulumi.Input

	ToLogstashSpecServicesArrayOutput() LogstashSpecServicesArrayOutput
	ToLogstashSpecServicesArrayOutputWithContext(context.Context) LogstashSpecServicesArrayOutput
}

type LogstashSpecServicesArray []LogstashSpecServicesInput

func (LogstashSpecServicesArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LogstashSpecServices)(nil)).Elem()
}

func (i LogstashSpecServicesArray) ToLogstashSpecServicesArrayOutput() LogstashSpecServicesArrayOutput {
	return i.ToLogstashSpecServicesArrayOutputWithContext(context.Background())
}

func (i LogstashSpecServicesArray) ToLogstashSpecServicesArrayOutputWithContext(ctx context.Context) LogstashSpecServicesArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesArrayOutput)
}

type LogstashSpecServicesOutput struct{ *pulumi.OutputState }

func (LogstashSpecServicesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecServices)(nil)).Elem()
}

func (o LogstashSpecServicesOutput) ToLogstashSpecServicesOutput() LogstashSpecServicesOutput {
	return o
}

func (o LogstashSpecServicesOutput) ToLogstashSpecServicesOutputWithContext(ctx context.Context) LogstashSpecServicesOutput {
	return o
}

func (o LogstashSpecServicesOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecServices) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Service defines the template for the associated Kubernetes Service object.
func (o LogstashSpecServicesOutput) Service() LogstashSpecServicesServicePtrOutput {
	return o.ApplyT(func(v LogstashSpecServices) *LogstashSpecServicesService { return v.Service }).(LogstashSpecServicesServicePtrOutput)
}

// TLS defines options for configuring TLS for HTTP.
func (o LogstashSpecServicesOutput) Tls() LogstashSpecServicesTlsPtrOutput {
	return o.ApplyT(func(v LogstashSpecServices) *LogstashSpecServicesTls { return v.Tls }).(LogstashSpecServicesTlsPtrOutput)
}

type LogstashSpecServicesArrayOutput struct{ *pulumi.OutputState }

func (LogstashSpecServicesArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LogstashSpecServices)(nil)).Elem()
}

func (o LogstashSpecServicesArrayOutput) ToLogstashSpecServicesArrayOutput() LogstashSpecServicesArrayOutput {
	return o
}

func (o LogstashSpecServicesArrayOutput) ToLogstashSpecServicesArrayOutputWithContext(ctx context.Context) LogstashSpecServicesArrayOutput {
	return o
}

func (o LogstashSpecServicesArrayOutput) Index(i pulumi.IntInput) LogstashSpecServicesOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LogstashSpecServices {
		return vs[0].([]LogstashSpecServices)[vs[1].(int)]
	}).(LogstashSpecServicesOutput)
}

// Service defines the template for the associated Kubernetes Service object.
type LogstashSpecServicesService struct {
	// ObjectMeta is the metadata of the service.
	// The name and namespace provided here are managed by ECK and will be ignored.
	Metadata *LogstashSpecServicesServiceMetadata `pulumi:"metadata"`
	// Spec is the specification of the service.
	Spec *LogstashSpecServicesServiceSpec `pulumi:"spec"`
}

// LogstashSpecServicesServiceInput is an input type that accepts LogstashSpecServicesServiceArgs and LogstashSpecServicesServiceOutput values.
// You can construct a concrete instance of `LogstashSpecServicesServiceInput` via:
//
//	LogstashSpecServicesServiceArgs{...}
type LogstashSpecServicesServiceInput interface {
	pulumi.Input

	ToLogstashSpecServicesServiceOutput() LogstashSpecServicesServiceOutput
	ToLogstashSpecServicesServiceOutputWithContext(context.Context) LogstashSpecServicesServiceOutput
}

// Service defines the template for the associated Kubernetes Service object.
type LogstashSpecServicesServiceArgs struct {
	// ObjectMeta is the metadata of the service.
	// The name and namespace provided here are managed by ECK and will be ignored.
	Metadata LogstashSpecServicesServiceMetadataPtrInput `pulumi:"metadata"`
	// Spec is the specification of the service.
	Spec LogstashSpecServicesServiceSpecPtrInput `pulumi:"spec"`
}

func (LogstashSpecServicesServiceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecServicesService)(nil)).Elem()
}

func (i LogstashSpecServicesServiceArgs) ToLogstashSpecServicesServiceOutput() LogstashSpecServicesServiceOutput {
	return i.ToLogstashSpecServicesServiceOutputWithContext(context.Background())
}

func (i LogstashSpecServicesServiceArgs) ToLogstashSpecServicesServiceOutputWithContext(ctx context.Context) LogstashSpecServicesServiceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesServiceOutput)
}

func (i LogstashSpecServicesServiceArgs) ToLogstashSpecServicesServicePtrOutput() LogstashSpecServicesServicePtrOutput {
	return i.ToLogstashSpecServicesServicePtrOutputWithContext(context.Background())
}

func (i LogstashSpecServicesServiceArgs) ToLogstashSpecServicesServicePtrOutputWithContext(ctx context.Context) LogstashSpecServicesServicePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesServiceOutput).ToLogstashSpecServicesServicePtrOutputWithContext(ctx)
}

// LogstashSpecServicesServicePtrInput is an input type that accepts LogstashSpecServicesServiceArgs, LogstashSpecServicesServicePtr and LogstashSpecServicesServicePtrOutput values.
// You can construct a concrete instance of `LogstashSpecServicesServicePtrInput` via:
//
//	        LogstashSpecServicesServiceArgs{...}
//
//	or:
//
//	        nil
type LogstashSpecServicesServicePtrInput interface {
	pulumi.Input

	ToLogstashSpecServicesServicePtrOutput() LogstashSpecServicesServicePtrOutput
	ToLogstashSpecServicesServicePtrOutputWithContext(context.Context) LogstashSpecServicesServicePtrOutput
}

type logstashSpecServicesServicePtrType LogstashSpecServicesServiceArgs

func LogstashSpecServicesServicePtr(v *LogstashSpecServicesServiceArgs) LogstashSpecServicesServicePtrInput {
	return (*logstashSpecServicesServicePtrType)(v)
}

func (*logstashSpecServicesServicePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecServicesService)(nil)).Elem()
}

func (i *logstashSpecServicesServicePtrType) ToLogstashSpecServicesServicePtrOutput() LogstashSpecServicesServicePtrOutput {
	return i.ToLogstashSpecServicesServicePtrOutputWithContext(context.Background())
}

func (i *logstashSpecServicesServicePtrType) ToLogstashSpecServicesServicePtrOutputWithContext(ctx context.Context) LogstashSpecServicesServicePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesServicePtrOutput)
}

// Service defines the template for the associated Kubernetes Service object.
type LogstashSpecServicesServiceOutput struct{ *pulumi.OutputState }

func (LogstashSpecServicesServiceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecServicesService)(nil)).Elem()
}

func (o LogstashSpecServicesServiceOutput) ToLogstashSpecServicesServiceOutput() LogstashSpecServicesServiceOutput {
	return o
}

func (o LogstashSpecServicesServiceOutput) ToLogstashSpecServicesServiceOutputWithContext(ctx context.Context) LogstashSpecServicesServiceOutput {
	return o
}

func (o LogstashSpecServicesServiceOutput) ToLogstashSpecServicesServicePtrOutput() LogstashSpecServicesServicePtrOutput {
	return o.ToLogstashSpecServicesServicePtrOutputWithContext(context.Background())
}

func (o LogstashSpecServicesServiceOutput) ToLogstashSpecServicesServicePtrOutputWithContext(ctx context.Context) LogstashSpecServicesServicePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LogstashSpecServicesService) *LogstashSpecServicesService {
		return &v
	}).(LogstashSpecServicesServicePtrOutput)
}

// ObjectMeta is the metadata of the service.
// The name and namespace provided here are managed by ECK and will be ignored.
func (o LogstashSpecServicesServiceOutput) Metadata() LogstashSpecServicesServiceMetadataPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesService) *LogstashSpecServicesServiceMetadata { return v.Metadata }).(LogstashSpecServicesServiceMetadataPtrOutput)
}

// Spec is the specification of the service.
func (o LogstashSpecServicesServiceOutput) Spec() LogstashSpecServicesServiceSpecPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesService) *LogstashSpecServicesServiceSpec { return v.Spec }).(LogstashSpecServicesServiceSpecPtrOutput)
}

type LogstashSpecServicesServicePtrOutput struct{ *pulumi.OutputState }

func (LogstashSpecServicesServicePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecServicesService)(nil)).Elem()
}

func (o LogstashSpecServicesServicePtrOutput) ToLogstashSpecServicesServicePtrOutput() LogstashSpecServicesServicePtrOutput {
	return o
}

func (o LogstashSpecServicesServicePtrOutput) ToLogstashSpecServicesServicePtrOutputWithContext(ctx context.Context) LogstashSpecServicesServicePtrOutput {
	return o
}

func (o LogstashSpecServicesServicePtrOutput) Elem() LogstashSpecServicesServiceOutput {
	return o.ApplyT(func(v *LogstashSpecServicesService) LogstashSpecServicesService {
		if v != nil {
			return *v
		}
		var ret LogstashSpecServicesService
		return ret
	}).(LogstashSpecServicesServiceOutput)
}

// ObjectMeta is the metadata of the service.
// The name and namespace provided here are managed by ECK and will be ignored.
func (o LogstashSpecServicesServicePtrOutput) Metadata() LogstashSpecServicesServiceMetadataPtrOutput {
	return o.ApplyT(func(v *LogstashSpecServicesService) *LogstashSpecServicesServiceMetadata {
		if v == nil {
			return nil
		}
		return v.Metadata
	}).(LogstashSpecServicesServiceMetadataPtrOutput)
}

// Spec is the specification of the service.
func (o LogstashSpecServicesServicePtrOutput) Spec() LogstashSpecServicesServiceSpecPtrOutput {
	return o.ApplyT(func(v *LogstashSpecServicesService) *LogstashSpecServicesServiceSpec {
		if v == nil {
			return nil
		}
		return v.Spec
	}).(LogstashSpecServicesServiceSpecPtrOutput)
}

// ObjectMeta is the metadata of the service.
// The name and namespace provided here are managed by ECK and will be ignored.
type LogstashSpecServicesServiceMetadata struct {
	Annotations map[string]string `pulumi:"annotations"`
	Finalizers  []string          `pulumi:"finalizers"`
	Labels      map[string]string `pulumi:"labels"`
	Name        *string           `pulumi:"name"`
	Namespace   *string           `pulumi:"namespace"`
}

// LogstashSpecServicesServiceMetadataInput is an input type that accepts LogstashSpecServicesServiceMetadataArgs and LogstashSpecServicesServiceMetadataOutput values.
// You can construct a concrete instance of `LogstashSpecServicesServiceMetadataInput` via:
//
//	LogstashSpecServicesServiceMetadataArgs{...}
type LogstashSpecServicesServiceMetadataInput interface {
	pulumi.Input

	ToLogstashSpecServicesServiceMetadataOutput() LogstashSpecServicesServiceMetadataOutput
	ToLogstashSpecServicesServiceMetadataOutputWithContext(context.Context) LogstashSpecServicesServiceMetadataOutput
}

// ObjectMeta is the metadata of the service.
// The name and namespace provided here are managed by ECK and will be ignored.
type LogstashSpecServicesServiceMetadataArgs struct {
	Annotations pulumi.StringMapInput   `pulumi:"annotations"`
	Finalizers  pulumi.StringArrayInput `pulumi:"finalizers"`
	Labels      pulumi.StringMapInput   `pulumi:"labels"`
	Name        pulumi.StringPtrInput   `pulumi:"name"`
	Namespace   pulumi.StringPtrInput   `pulumi:"namespace"`
}

func (LogstashSpecServicesServiceMetadataArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecServicesServiceMetadata)(nil)).Elem()
}

func (i LogstashSpecServicesServiceMetadataArgs) ToLogstashSpecServicesServiceMetadataOutput() LogstashSpecServicesServiceMetadataOutput {
	return i.ToLogstashSpecServicesServiceMetadataOutputWithContext(context.Background())
}

func (i LogstashSpecServicesServiceMetadataArgs) ToLogstashSpecServicesServiceMetadataOutputWithContext(ctx context.Context) LogstashSpecServicesServiceMetadataOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesServiceMetadataOutput)
}

func (i LogstashSpecServicesServiceMetadataArgs) ToLogstashSpecServicesServiceMetadataPtrOutput() LogstashSpecServicesServiceMetadataPtrOutput {
	return i.ToLogstashSpecServicesServiceMetadataPtrOutputWithContext(context.Background())
}

func (i LogstashSpecServicesServiceMetadataArgs) ToLogstashSpecServicesServiceMetadataPtrOutputWithContext(ctx context.Context) LogstashSpecServicesServiceMetadataPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesServiceMetadataOutput).ToLogstashSpecServicesServiceMetadataPtrOutputWithContext(ctx)
}

// LogstashSpecServicesServiceMetadataPtrInput is an input type that accepts LogstashSpecServicesServiceMetadataArgs, LogstashSpecServicesServiceMetadataPtr and LogstashSpecServicesServiceMetadataPtrOutput values.
// You can construct a concrete instance of `LogstashSpecServicesServiceMetadataPtrInput` via:
//
//	        LogstashSpecServicesServiceMetadataArgs{...}
//
//	or:
//
//	        nil
type LogstashSpecServicesServiceMetadataPtrInput interface {
	pulumi.Input

	ToLogstashSpecServicesServiceMetadataPtrOutput() LogstashSpecServicesServiceMetadataPtrOutput
	ToLogstashSpecServicesServiceMetadataPtrOutputWithContext(context.Context) LogstashSpecServicesServiceMetadataPtrOutput
}

type logstashSpecServicesServiceMetadataPtrType LogstashSpecServicesServiceMetadataArgs

func LogstashSpecServicesServiceMetadataPtr(v *LogstashSpecServicesServiceMetadataArgs) LogstashSpecServicesServiceMetadataPtrInput {
	return (*logstashSpecServicesServiceMetadataPtrType)(v)
}

func (*logstashSpecServicesServiceMetadataPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecServicesServiceMetadata)(nil)).Elem()
}

func (i *logstashSpecServicesServiceMetadataPtrType) ToLogstashSpecServicesServiceMetadataPtrOutput() LogstashSpecServicesServiceMetadataPtrOutput {
	return i.ToLogstashSpecServicesServiceMetadataPtrOutputWithContext(context.Background())
}

func (i *logstashSpecServicesServiceMetadataPtrType) ToLogstashSpecServicesServiceMetadataPtrOutputWithContext(ctx context.Context) LogstashSpecServicesServiceMetadataPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesServiceMetadataPtrOutput)
}

// ObjectMeta is the metadata of the service.
// The name and namespace provided here are managed by ECK and will be ignored.
type LogstashSpecServicesServiceMetadataOutput struct{ *pulumi.OutputState }

func (LogstashSpecServicesServiceMetadataOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecServicesServiceMetadata)(nil)).Elem()
}

func (o LogstashSpecServicesServiceMetadataOutput) ToLogstashSpecServicesServiceMetadataOutput() LogstashSpecServicesServiceMetadataOutput {
	return o
}

func (o LogstashSpecServicesServiceMetadataOutput) ToLogstashSpecServicesServiceMetadataOutputWithContext(ctx context.Context) LogstashSpecServicesServiceMetadataOutput {
	return o
}

func (o LogstashSpecServicesServiceMetadataOutput) ToLogstashSpecServicesServiceMetadataPtrOutput() LogstashSpecServicesServiceMetadataPtrOutput {
	return o.ToLogstashSpecServicesServiceMetadataPtrOutputWithContext(context.Background())
}

func (o LogstashSpecServicesServiceMetadataOutput) ToLogstashSpecServicesServiceMetadataPtrOutputWithContext(ctx context.Context) LogstashSpecServicesServiceMetadataPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LogstashSpecServicesServiceMetadata) *LogstashSpecServicesServiceMetadata {
		return &v
	}).(LogstashSpecServicesServiceMetadataPtrOutput)
}

func (o LogstashSpecServicesServiceMetadataOutput) Annotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceMetadata) map[string]string { return v.Annotations }).(pulumi.StringMapOutput)
}

func (o LogstashSpecServicesServiceMetadataOutput) Finalizers() pulumi.StringArrayOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceMetadata) []string { return v.Finalizers }).(pulumi.StringArrayOutput)
}

func (o LogstashSpecServicesServiceMetadataOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceMetadata) map[string]string { return v.Labels }).(pulumi.StringMapOutput)
}

func (o LogstashSpecServicesServiceMetadataOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceMetadata) *string { return v.Name }).(pulumi.StringPtrOutput)
}

func (o LogstashSpecServicesServiceMetadataOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceMetadata) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

type LogstashSpecServicesServiceMetadataPtrOutput struct{ *pulumi.OutputState }

func (LogstashSpecServicesServiceMetadataPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecServicesServiceMetadata)(nil)).Elem()
}

func (o LogstashSpecServicesServiceMetadataPtrOutput) ToLogstashSpecServicesServiceMetadataPtrOutput() LogstashSpecServicesServiceMetadataPtrOutput {
	return o
}

func (o LogstashSpecServicesServiceMetadataPtrOutput) ToLogstashSpecServicesServiceMetadataPtrOutputWithContext(ctx context.Context) LogstashSpecServicesServiceMetadataPtrOutput {
	return o
}

func (o LogstashSpecServicesServiceMetadataPtrOutput) Elem() LogstashSpecServicesServiceMetadataOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceMetadata) LogstashSpecServicesServiceMetadata {
		if v != nil {
			return *v
		}
		var ret LogstashSpecServicesServiceMetadata
		return ret
	}).(LogstashSpecServicesServiceMetadataOutput)
}

func (o LogstashSpecServicesServiceMetadataPtrOutput) Annotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceMetadata) map[string]string {
		if v == nil {
			return nil
		}
		return v.Annotations
	}).(pulumi.StringMapOutput)
}

func (o LogstashSpecServicesServiceMetadataPtrOutput) Finalizers() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceMetadata) []string {
		if v == nil {
			return nil
		}
		return v.Finalizers
	}).(pulumi.StringArrayOutput)
}

func (o LogstashSpecServicesServiceMetadataPtrOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceMetadata) map[string]string {
		if v == nil {
			return nil
		}
		return v.Labels
	}).(pulumi.StringMapOutput)
}

func (o LogstashSpecServicesServiceMetadataPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceMetadata) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

func (o LogstashSpecServicesServiceMetadataPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceMetadata) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

type LogstashSpecServicesServiceMetadataAnnotations struct {
}

type LogstashSpecServicesServiceMetadataLabels struct {
}

// Spec is the specification of the service.
type LogstashSpecServicesServiceSpec struct {
	// allocateLoadBalancerNodePorts defines if NodePorts will be automatically
	// allocated for services with type LoadBalancer.  Default is "true". It
	// may be set to "false" if the cluster load-balancer does not rely on
	// NodePorts.  If the caller requests specific NodePorts (by specifying a
	// value), those requests will be respected, regardless of this field.
	// This field may only be set for services with type LoadBalancer and will
	// be cleared if the type is changed to any other type.
	AllocateLoadBalancerNodePorts *bool `pulumi:"allocateLoadBalancerNodePorts"`
	// clusterIP is the IP address of the service and is usually assigned
	// randomly. If an address is specified manually, is in-range (as per
	// system configuration), and is not in use, it will be allocated to the
	// service; otherwise creation of the service will fail. This field may not
	// be changed through updates unless the type field is also being changed
	// to ExternalName (which requires this field to be blank) or the type
	// field is being changed from ExternalName (in which case this field may
	// optionally be specified, as describe above).  Valid values are "None",
	// empty string (""), or a valid IP address. Setting this to "None" makes a
	// "headless service" (no virtual IP), which is useful when direct endpoint
	// connections are preferred and proxying is not required.  Only applies to
	// types ClusterIP, NodePort, and LoadBalancer. If this field is specified
	// when creating a Service of type ExternalName, creation will fail. This
	// field will be wiped when updating a Service to type ExternalName.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	ClusterIP *string `pulumi:"clusterIP"`
	// ClusterIPs is a list of IP addresses assigned to this service, and are
	// usually assigned randomly.  If an address is specified manually, is
	// in-range (as per system configuration), and is not in use, it will be
	// allocated to the service; otherwise creation of the service will fail.
	// This field may not be changed through updates unless the type field is
	// also being changed to ExternalName (which requires this field to be
	// empty) or the type field is being changed from ExternalName (in which
	// case this field may optionally be specified, as describe above).  Valid
	// values are "None", empty string (""), or a valid IP address.  Setting
	// this to "None" makes a "headless service" (no virtual IP), which is
	// useful when direct endpoint connections are preferred and proxying is
	// not required.  Only applies to types ClusterIP, NodePort, and
	// LoadBalancer. If this field is specified when creating a Service of type
	// ExternalName, creation will fail. This field will be wiped when updating
	// a Service to type ExternalName.  If this field is not specified, it will
	// be initialized from the clusterIP field.  If this field is specified,
	// clients must ensure that clusterIPs[0] and clusterIP have the same
	// value.
	//
	// This field may hold a maximum of two entries (dual-stack IPs, in either order).
	// These IPs must correspond to the values of the ipFamilies field. Both
	// clusterIPs and ipFamilies are governed by the ipFamilyPolicy field.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	ClusterIPs []string `pulumi:"clusterIPs"`
	// externalIPs is a list of IP addresses for which nodes in the cluster
	// will also accept traffic for this service.  These IPs are not managed by
	// Kubernetes.  The user is responsible for ensuring that traffic arrives
	// at a node with this IP.  A common example is external load-balancers
	// that are not part of the Kubernetes system.
	ExternalIPs []string `pulumi:"externalIPs"`
	// externalName is the external reference that discovery mechanisms will
	// return as an alias for this service (e.g. a DNS CNAME record). No
	// proxying will be involved.  Must be a lowercase RFC-1123 hostname
	// (https://tools.ietf.org/html/rfc1123) and requires `type` to be "ExternalName".
	ExternalName *string `pulumi:"externalName"`
	// externalTrafficPolicy describes how nodes distribute service traffic they
	// receive on one of the Service's "externally-facing" addresses (NodePorts,
	// ExternalIPs, and LoadBalancer IPs). If set to "Local", the proxy will configure
	// the service in a way that assumes that external load balancers will take care
	// of balancing the service traffic between nodes, and so each node will deliver
	// traffic only to the node-local endpoints of the service, without masquerading
	// the client source IP. (Traffic mistakenly sent to a node with no endpoints will
	// be dropped.) The default value, "Cluster", uses the standard behavior of
	// routing to all endpoints evenly (possibly modified by topology and other
	// features). Note that traffic sent to an External IP or LoadBalancer IP from
	// within the cluster will always get "Cluster" semantics, but clients sending to
	// a NodePort from within the cluster may need to take traffic policy into account
	// when picking a node.
	ExternalTrafficPolicy *string `pulumi:"externalTrafficPolicy"`
	// healthCheckNodePort specifies the healthcheck nodePort for the service.
	// This only applies when type is set to LoadBalancer and
	// externalTrafficPolicy is set to Local. If a value is specified, is
	// in-range, and is not in use, it will be used.  If not specified, a value
	// will be automatically allocated.  External systems (e.g. load-balancers)
	// can use this port to determine if a given node holds endpoints for this
	// service or not.  If this field is specified when creating a Service
	// which does not need it, creation will fail. This field will be wiped
	// when updating a Service to no longer need it (e.g. changing type).
	// This field cannot be updated once set.
	HealthCheckNodePort *int `pulumi:"healthCheckNodePort"`
	// InternalTrafficPolicy describes how nodes distribute service traffic they
	// receive on the ClusterIP. If set to "Local", the proxy will assume that pods
	// only want to talk to endpoints of the service on the same node as the pod,
	// dropping the traffic if there are no local endpoints. The default value,
	// "Cluster", uses the standard behavior of routing to all endpoints evenly
	// (possibly modified by topology and other features).
	InternalTrafficPolicy *string `pulumi:"internalTrafficPolicy"`
	// IPFamilies is a list of IP families (e.g. IPv4, IPv6) assigned to this
	// service. This field is usually assigned automatically based on cluster
	// configuration and the ipFamilyPolicy field. If this field is specified
	// manually, the requested family is available in the cluster,
	// and ipFamilyPolicy allows it, it will be used; otherwise creation of
	// the service will fail. This field is conditionally mutable: it allows
	// for adding or removing a secondary IP family, but it does not allow
	// changing the primary IP family of the Service. Valid values are "IPv4"
	// and "IPv6".  This field only applies to Services of types ClusterIP,
	// NodePort, and LoadBalancer, and does apply to "headless" services.
	// This field will be wiped when updating a Service to type ExternalName.
	//
	// This field may hold a maximum of two entries (dual-stack families, in
	// either order).  These families must correspond to the values of the
	// clusterIPs field, if specified. Both clusterIPs and ipFamilies are
	// governed by the ipFamilyPolicy field.
	IpFamilies []string `pulumi:"ipFamilies"`
	// IPFamilyPolicy represents the dual-stack-ness requested or required by
	// this Service. If there is no value provided, then this field will be set
	// to SingleStack. Services can be "SingleStack" (a single IP family),
	// "PreferDualStack" (two IP families on dual-stack configured clusters or
	// a single IP family on single-stack clusters), or "RequireDualStack"
	// (two IP families on dual-stack configured clusters, otherwise fail). The
	// ipFamilies and clusterIPs fields depend on the value of this field. This
	// field will be wiped when updating a service to type ExternalName.
	IpFamilyPolicy *string `pulumi:"ipFamilyPolicy"`
	// loadBalancerClass is the class of the load balancer implementation this Service belongs to.
	// If specified, the value of this field must be a label-style identifier, with an optional prefix,
	// e.g. "internal-vip" or "example.com/internal-vip". Unprefixed names are reserved for end-users.
	// This field can only be set when the Service type is 'LoadBalancer'. If not set, the default load
	// balancer implementation is used, today this is typically done through the cloud provider integration,
	// but should apply for any default implementation. If set, it is assumed that a load balancer
	// implementation is watching for Services with a matching class. Any default load balancer
	// implementation (e.g. cloud providers) should ignore Services that set this field.
	// This field can only be set when creating or updating a Service to type 'LoadBalancer'.
	// Once set, it can not be changed. This field will be wiped when a service is updated to a non 'LoadBalancer' type.
	LoadBalancerClass *string `pulumi:"loadBalancerClass"`
	// Only applies to Service Type: LoadBalancer.
	// This feature depends on whether the underlying cloud-provider supports specifying
	// the loadBalancerIP when a load balancer is created.
	// This field will be ignored if the cloud-provider does not support the feature.
	// Deprecated: This field was under-specified and its meaning varies across implementations.
	// Using it is non-portable and it may not support dual-stack.
	// Users are encouraged to use implementation-specific annotations when available.
	LoadBalancerIP *string `pulumi:"loadBalancerIP"`
	// If specified and supported by the platform, this will restrict traffic through the cloud-provider
	// load-balancer will be restricted to the specified client IPs. This field will be ignored if the
	// cloud-provider does not support the feature."
	// More info: https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/
	LoadBalancerSourceRanges []string `pulumi:"loadBalancerSourceRanges"`
	// The list of ports that are exposed by this service.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	Ports []LogstashSpecServicesServiceSpecPorts `pulumi:"ports"`
	// publishNotReadyAddresses indicates that any agent which deals with endpoints for this
	// Service should disregard any indications of ready/not-ready.
	// The primary use case for setting this field is for a StatefulSet's Headless Service to
	// propagate SRV DNS records for its Pods for the purpose of peer discovery.
	// The Kubernetes controllers that generate Endpoints and EndpointSlice resources for
	// Services interpret this to mean that all endpoints are considered "ready" even if the
	// Pods themselves are not. Agents which consume only Kubernetes generated endpoints
	// through the Endpoints or EndpointSlice resources can safely assume this behavior.
	PublishNotReadyAddresses *bool `pulumi:"publishNotReadyAddresses"`
	// Route service traffic to pods with label keys and values matching this
	// selector. If empty or not present, the service is assumed to have an
	// external process managing its endpoints, which Kubernetes will not
	// modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
	// Ignored if type is ExternalName.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/
	Selector map[string]string `pulumi:"selector"`
	// Supports "ClientIP" and "None". Used to maintain session affinity.
	// Enable client IP based session affinity.
	// Must be ClientIP or None.
	// Defaults to None.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	SessionAffinity *string `pulumi:"sessionAffinity"`
	// sessionAffinityConfig contains the configurations of session affinity.
	SessionAffinityConfig *LogstashSpecServicesServiceSpecSessionAffinityConfig `pulumi:"sessionAffinityConfig"`
	// TrafficDistribution offers a way to express preferences for how traffic is
	// distributed to Service endpoints. Implementations can use this field as a
	// hint, but are not required to guarantee strict adherence. If the field is
	// not set, the implementation will apply its default routing strategy. If set
	// to "PreferClose", implementations should prioritize endpoints that are
	// topologically close (e.g., same zone).
	// This is an alpha field and requires enabling ServiceTrafficDistribution feature.
	TrafficDistribution *string `pulumi:"trafficDistribution"`
	// type determines how the Service is exposed. Defaults to ClusterIP. Valid
	// options are ExternalName, ClusterIP, NodePort, and LoadBalancer.
	// "ClusterIP" allocates a cluster-internal IP address for load-balancing
	// to endpoints. Endpoints are determined by the selector or if that is not
	// specified, by manual construction of an Endpoints object or
	// EndpointSlice objects. If clusterIP is "None", no virtual IP is
	// allocated and the endpoints are published as a set of endpoints rather
	// than a virtual IP.
	// "NodePort" builds on ClusterIP and allocates a port on every node which
	// routes to the same endpoints as the clusterIP.
	// "LoadBalancer" builds on NodePort and creates an external load-balancer
	// (if supported in the current cloud) which routes to the same endpoints
	// as the clusterIP.
	// "ExternalName" aliases this service to the specified externalName.
	// Several other fields do not apply to ExternalName services.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
	Type *string `pulumi:"type"`
}

// LogstashSpecServicesServiceSpecInput is an input type that accepts LogstashSpecServicesServiceSpecArgs and LogstashSpecServicesServiceSpecOutput values.
// You can construct a concrete instance of `LogstashSpecServicesServiceSpecInput` via:
//
//	LogstashSpecServicesServiceSpecArgs{...}
type LogstashSpecServicesServiceSpecInput interface {
	pulumi.Input

	ToLogstashSpecServicesServiceSpecOutput() LogstashSpecServicesServiceSpecOutput
	ToLogstashSpecServicesServiceSpecOutputWithContext(context.Context) LogstashSpecServicesServiceSpecOutput
}

// Spec is the specification of the service.
type LogstashSpecServicesServiceSpecArgs struct {
	// allocateLoadBalancerNodePorts defines if NodePorts will be automatically
	// allocated for services with type LoadBalancer.  Default is "true". It
	// may be set to "false" if the cluster load-balancer does not rely on
	// NodePorts.  If the caller requests specific NodePorts (by specifying a
	// value), those requests will be respected, regardless of this field.
	// This field may only be set for services with type LoadBalancer and will
	// be cleared if the type is changed to any other type.
	AllocateLoadBalancerNodePorts pulumi.BoolPtrInput `pulumi:"allocateLoadBalancerNodePorts"`
	// clusterIP is the IP address of the service and is usually assigned
	// randomly. If an address is specified manually, is in-range (as per
	// system configuration), and is not in use, it will be allocated to the
	// service; otherwise creation of the service will fail. This field may not
	// be changed through updates unless the type field is also being changed
	// to ExternalName (which requires this field to be blank) or the type
	// field is being changed from ExternalName (in which case this field may
	// optionally be specified, as describe above).  Valid values are "None",
	// empty string (""), or a valid IP address. Setting this to "None" makes a
	// "headless service" (no virtual IP), which is useful when direct endpoint
	// connections are preferred and proxying is not required.  Only applies to
	// types ClusterIP, NodePort, and LoadBalancer. If this field is specified
	// when creating a Service of type ExternalName, creation will fail. This
	// field will be wiped when updating a Service to type ExternalName.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	ClusterIP pulumi.StringPtrInput `pulumi:"clusterIP"`
	// ClusterIPs is a list of IP addresses assigned to this service, and are
	// usually assigned randomly.  If an address is specified manually, is
	// in-range (as per system configuration), and is not in use, it will be
	// allocated to the service; otherwise creation of the service will fail.
	// This field may not be changed through updates unless the type field is
	// also being changed to ExternalName (which requires this field to be
	// empty) or the type field is being changed from ExternalName (in which
	// case this field may optionally be specified, as describe above).  Valid
	// values are "None", empty string (""), or a valid IP address.  Setting
	// this to "None" makes a "headless service" (no virtual IP), which is
	// useful when direct endpoint connections are preferred and proxying is
	// not required.  Only applies to types ClusterIP, NodePort, and
	// LoadBalancer. If this field is specified when creating a Service of type
	// ExternalName, creation will fail. This field will be wiped when updating
	// a Service to type ExternalName.  If this field is not specified, it will
	// be initialized from the clusterIP field.  If this field is specified,
	// clients must ensure that clusterIPs[0] and clusterIP have the same
	// value.
	//
	// This field may hold a maximum of two entries (dual-stack IPs, in either order).
	// These IPs must correspond to the values of the ipFamilies field. Both
	// clusterIPs and ipFamilies are governed by the ipFamilyPolicy field.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	ClusterIPs pulumi.StringArrayInput `pulumi:"clusterIPs"`
	// externalIPs is a list of IP addresses for which nodes in the cluster
	// will also accept traffic for this service.  These IPs are not managed by
	// Kubernetes.  The user is responsible for ensuring that traffic arrives
	// at a node with this IP.  A common example is external load-balancers
	// that are not part of the Kubernetes system.
	ExternalIPs pulumi.StringArrayInput `pulumi:"externalIPs"`
	// externalName is the external reference that discovery mechanisms will
	// return as an alias for this service (e.g. a DNS CNAME record). No
	// proxying will be involved.  Must be a lowercase RFC-1123 hostname
	// (https://tools.ietf.org/html/rfc1123) and requires `type` to be "ExternalName".
	ExternalName pulumi.StringPtrInput `pulumi:"externalName"`
	// externalTrafficPolicy describes how nodes distribute service traffic they
	// receive on one of the Service's "externally-facing" addresses (NodePorts,
	// ExternalIPs, and LoadBalancer IPs). If set to "Local", the proxy will configure
	// the service in a way that assumes that external load balancers will take care
	// of balancing the service traffic between nodes, and so each node will deliver
	// traffic only to the node-local endpoints of the service, without masquerading
	// the client source IP. (Traffic mistakenly sent to a node with no endpoints will
	// be dropped.) The default value, "Cluster", uses the standard behavior of
	// routing to all endpoints evenly (possibly modified by topology and other
	// features). Note that traffic sent to an External IP or LoadBalancer IP from
	// within the cluster will always get "Cluster" semantics, but clients sending to
	// a NodePort from within the cluster may need to take traffic policy into account
	// when picking a node.
	ExternalTrafficPolicy pulumi.StringPtrInput `pulumi:"externalTrafficPolicy"`
	// healthCheckNodePort specifies the healthcheck nodePort for the service.
	// This only applies when type is set to LoadBalancer and
	// externalTrafficPolicy is set to Local. If a value is specified, is
	// in-range, and is not in use, it will be used.  If not specified, a value
	// will be automatically allocated.  External systems (e.g. load-balancers)
	// can use this port to determine if a given node holds endpoints for this
	// service or not.  If this field is specified when creating a Service
	// which does not need it, creation will fail. This field will be wiped
	// when updating a Service to no longer need it (e.g. changing type).
	// This field cannot be updated once set.
	HealthCheckNodePort pulumi.IntPtrInput `pulumi:"healthCheckNodePort"`
	// InternalTrafficPolicy describes how nodes distribute service traffic they
	// receive on the ClusterIP. If set to "Local", the proxy will assume that pods
	// only want to talk to endpoints of the service on the same node as the pod,
	// dropping the traffic if there are no local endpoints. The default value,
	// "Cluster", uses the standard behavior of routing to all endpoints evenly
	// (possibly modified by topology and other features).
	InternalTrafficPolicy pulumi.StringPtrInput `pulumi:"internalTrafficPolicy"`
	// IPFamilies is a list of IP families (e.g. IPv4, IPv6) assigned to this
	// service. This field is usually assigned automatically based on cluster
	// configuration and the ipFamilyPolicy field. If this field is specified
	// manually, the requested family is available in the cluster,
	// and ipFamilyPolicy allows it, it will be used; otherwise creation of
	// the service will fail. This field is conditionally mutable: it allows
	// for adding or removing a secondary IP family, but it does not allow
	// changing the primary IP family of the Service. Valid values are "IPv4"
	// and "IPv6".  This field only applies to Services of types ClusterIP,
	// NodePort, and LoadBalancer, and does apply to "headless" services.
	// This field will be wiped when updating a Service to type ExternalName.
	//
	// This field may hold a maximum of two entries (dual-stack families, in
	// either order).  These families must correspond to the values of the
	// clusterIPs field, if specified. Both clusterIPs and ipFamilies are
	// governed by the ipFamilyPolicy field.
	IpFamilies pulumi.StringArrayInput `pulumi:"ipFamilies"`
	// IPFamilyPolicy represents the dual-stack-ness requested or required by
	// this Service. If there is no value provided, then this field will be set
	// to SingleStack. Services can be "SingleStack" (a single IP family),
	// "PreferDualStack" (two IP families on dual-stack configured clusters or
	// a single IP family on single-stack clusters), or "RequireDualStack"
	// (two IP families on dual-stack configured clusters, otherwise fail). The
	// ipFamilies and clusterIPs fields depend on the value of this field. This
	// field will be wiped when updating a service to type ExternalName.
	IpFamilyPolicy pulumi.StringPtrInput `pulumi:"ipFamilyPolicy"`
	// loadBalancerClass is the class of the load balancer implementation this Service belongs to.
	// If specified, the value of this field must be a label-style identifier, with an optional prefix,
	// e.g. "internal-vip" or "example.com/internal-vip". Unprefixed names are reserved for end-users.
	// This field can only be set when the Service type is 'LoadBalancer'. If not set, the default load
	// balancer implementation is used, today this is typically done through the cloud provider integration,
	// but should apply for any default implementation. If set, it is assumed that a load balancer
	// implementation is watching for Services with a matching class. Any default load balancer
	// implementation (e.g. cloud providers) should ignore Services that set this field.
	// This field can only be set when creating or updating a Service to type 'LoadBalancer'.
	// Once set, it can not be changed. This field will be wiped when a service is updated to a non 'LoadBalancer' type.
	LoadBalancerClass pulumi.StringPtrInput `pulumi:"loadBalancerClass"`
	// Only applies to Service Type: LoadBalancer.
	// This feature depends on whether the underlying cloud-provider supports specifying
	// the loadBalancerIP when a load balancer is created.
	// This field will be ignored if the cloud-provider does not support the feature.
	// Deprecated: This field was under-specified and its meaning varies across implementations.
	// Using it is non-portable and it may not support dual-stack.
	// Users are encouraged to use implementation-specific annotations when available.
	LoadBalancerIP pulumi.StringPtrInput `pulumi:"loadBalancerIP"`
	// If specified and supported by the platform, this will restrict traffic through the cloud-provider
	// load-balancer will be restricted to the specified client IPs. This field will be ignored if the
	// cloud-provider does not support the feature."
	// More info: https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/
	LoadBalancerSourceRanges pulumi.StringArrayInput `pulumi:"loadBalancerSourceRanges"`
	// The list of ports that are exposed by this service.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	Ports LogstashSpecServicesServiceSpecPortsArrayInput `pulumi:"ports"`
	// publishNotReadyAddresses indicates that any agent which deals with endpoints for this
	// Service should disregard any indications of ready/not-ready.
	// The primary use case for setting this field is for a StatefulSet's Headless Service to
	// propagate SRV DNS records for its Pods for the purpose of peer discovery.
	// The Kubernetes controllers that generate Endpoints and EndpointSlice resources for
	// Services interpret this to mean that all endpoints are considered "ready" even if the
	// Pods themselves are not. Agents which consume only Kubernetes generated endpoints
	// through the Endpoints or EndpointSlice resources can safely assume this behavior.
	PublishNotReadyAddresses pulumi.BoolPtrInput `pulumi:"publishNotReadyAddresses"`
	// Route service traffic to pods with label keys and values matching this
	// selector. If empty or not present, the service is assumed to have an
	// external process managing its endpoints, which Kubernetes will not
	// modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
	// Ignored if type is ExternalName.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/
	Selector pulumi.StringMapInput `pulumi:"selector"`
	// Supports "ClientIP" and "None". Used to maintain session affinity.
	// Enable client IP based session affinity.
	// Must be ClientIP or None.
	// Defaults to None.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	SessionAffinity pulumi.StringPtrInput `pulumi:"sessionAffinity"`
	// sessionAffinityConfig contains the configurations of session affinity.
	SessionAffinityConfig LogstashSpecServicesServiceSpecSessionAffinityConfigPtrInput `pulumi:"sessionAffinityConfig"`
	// TrafficDistribution offers a way to express preferences for how traffic is
	// distributed to Service endpoints. Implementations can use this field as a
	// hint, but are not required to guarantee strict adherence. If the field is
	// not set, the implementation will apply its default routing strategy. If set
	// to "PreferClose", implementations should prioritize endpoints that are
	// topologically close (e.g., same zone).
	// This is an alpha field and requires enabling ServiceTrafficDistribution feature.
	TrafficDistribution pulumi.StringPtrInput `pulumi:"trafficDistribution"`
	// type determines how the Service is exposed. Defaults to ClusterIP. Valid
	// options are ExternalName, ClusterIP, NodePort, and LoadBalancer.
	// "ClusterIP" allocates a cluster-internal IP address for load-balancing
	// to endpoints. Endpoints are determined by the selector or if that is not
	// specified, by manual construction of an Endpoints object or
	// EndpointSlice objects. If clusterIP is "None", no virtual IP is
	// allocated and the endpoints are published as a set of endpoints rather
	// than a virtual IP.
	// "NodePort" builds on ClusterIP and allocates a port on every node which
	// routes to the same endpoints as the clusterIP.
	// "LoadBalancer" builds on NodePort and creates an external load-balancer
	// (if supported in the current cloud) which routes to the same endpoints
	// as the clusterIP.
	// "ExternalName" aliases this service to the specified externalName.
	// Several other fields do not apply to ExternalName services.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (LogstashSpecServicesServiceSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecServicesServiceSpec)(nil)).Elem()
}

func (i LogstashSpecServicesServiceSpecArgs) ToLogstashSpecServicesServiceSpecOutput() LogstashSpecServicesServiceSpecOutput {
	return i.ToLogstashSpecServicesServiceSpecOutputWithContext(context.Background())
}

func (i LogstashSpecServicesServiceSpecArgs) ToLogstashSpecServicesServiceSpecOutputWithContext(ctx context.Context) LogstashSpecServicesServiceSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesServiceSpecOutput)
}

func (i LogstashSpecServicesServiceSpecArgs) ToLogstashSpecServicesServiceSpecPtrOutput() LogstashSpecServicesServiceSpecPtrOutput {
	return i.ToLogstashSpecServicesServiceSpecPtrOutputWithContext(context.Background())
}

func (i LogstashSpecServicesServiceSpecArgs) ToLogstashSpecServicesServiceSpecPtrOutputWithContext(ctx context.Context) LogstashSpecServicesServiceSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesServiceSpecOutput).ToLogstashSpecServicesServiceSpecPtrOutputWithContext(ctx)
}

// LogstashSpecServicesServiceSpecPtrInput is an input type that accepts LogstashSpecServicesServiceSpecArgs, LogstashSpecServicesServiceSpecPtr and LogstashSpecServicesServiceSpecPtrOutput values.
// You can construct a concrete instance of `LogstashSpecServicesServiceSpecPtrInput` via:
//
//	        LogstashSpecServicesServiceSpecArgs{...}
//
//	or:
//
//	        nil
type LogstashSpecServicesServiceSpecPtrInput interface {
	pulumi.Input

	ToLogstashSpecServicesServiceSpecPtrOutput() LogstashSpecServicesServiceSpecPtrOutput
	ToLogstashSpecServicesServiceSpecPtrOutputWithContext(context.Context) LogstashSpecServicesServiceSpecPtrOutput
}

type logstashSpecServicesServiceSpecPtrType LogstashSpecServicesServiceSpecArgs

func LogstashSpecServicesServiceSpecPtr(v *LogstashSpecServicesServiceSpecArgs) LogstashSpecServicesServiceSpecPtrInput {
	return (*logstashSpecServicesServiceSpecPtrType)(v)
}

func (*logstashSpecServicesServiceSpecPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecServicesServiceSpec)(nil)).Elem()
}

func (i *logstashSpecServicesServiceSpecPtrType) ToLogstashSpecServicesServiceSpecPtrOutput() LogstashSpecServicesServiceSpecPtrOutput {
	return i.ToLogstashSpecServicesServiceSpecPtrOutputWithContext(context.Background())
}

func (i *logstashSpecServicesServiceSpecPtrType) ToLogstashSpecServicesServiceSpecPtrOutputWithContext(ctx context.Context) LogstashSpecServicesServiceSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesServiceSpecPtrOutput)
}

// Spec is the specification of the service.
type LogstashSpecServicesServiceSpecOutput struct{ *pulumi.OutputState }

func (LogstashSpecServicesServiceSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecServicesServiceSpec)(nil)).Elem()
}

func (o LogstashSpecServicesServiceSpecOutput) ToLogstashSpecServicesServiceSpecOutput() LogstashSpecServicesServiceSpecOutput {
	return o
}

func (o LogstashSpecServicesServiceSpecOutput) ToLogstashSpecServicesServiceSpecOutputWithContext(ctx context.Context) LogstashSpecServicesServiceSpecOutput {
	return o
}

func (o LogstashSpecServicesServiceSpecOutput) ToLogstashSpecServicesServiceSpecPtrOutput() LogstashSpecServicesServiceSpecPtrOutput {
	return o.ToLogstashSpecServicesServiceSpecPtrOutputWithContext(context.Background())
}

func (o LogstashSpecServicesServiceSpecOutput) ToLogstashSpecServicesServiceSpecPtrOutputWithContext(ctx context.Context) LogstashSpecServicesServiceSpecPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LogstashSpecServicesServiceSpec) *LogstashSpecServicesServiceSpec {
		return &v
	}).(LogstashSpecServicesServiceSpecPtrOutput)
}

// allocateLoadBalancerNodePorts defines if NodePorts will be automatically
// allocated for services with type LoadBalancer.  Default is "true". It
// may be set to "false" if the cluster load-balancer does not rely on
// NodePorts.  If the caller requests specific NodePorts (by specifying a
// value), those requests will be respected, regardless of this field.
// This field may only be set for services with type LoadBalancer and will
// be cleared if the type is changed to any other type.
func (o LogstashSpecServicesServiceSpecOutput) AllocateLoadBalancerNodePorts() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpec) *bool { return v.AllocateLoadBalancerNodePorts }).(pulumi.BoolPtrOutput)
}

// clusterIP is the IP address of the service and is usually assigned
// randomly. If an address is specified manually, is in-range (as per
// system configuration), and is not in use, it will be allocated to the
// service; otherwise creation of the service will fail. This field may not
// be changed through updates unless the type field is also being changed
// to ExternalName (which requires this field to be blank) or the type
// field is being changed from ExternalName (in which case this field may
// optionally be specified, as describe above).  Valid values are "None",
// empty string (""), or a valid IP address. Setting this to "None" makes a
// "headless service" (no virtual IP), which is useful when direct endpoint
// connections are preferred and proxying is not required.  Only applies to
// types ClusterIP, NodePort, and LoadBalancer. If this field is specified
// when creating a Service of type ExternalName, creation will fail. This
// field will be wiped when updating a Service to type ExternalName.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
func (o LogstashSpecServicesServiceSpecOutput) ClusterIP() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpec) *string { return v.ClusterIP }).(pulumi.StringPtrOutput)
}

// ClusterIPs is a list of IP addresses assigned to this service, and are
// usually assigned randomly.  If an address is specified manually, is
// in-range (as per system configuration), and is not in use, it will be
// allocated to the service; otherwise creation of the service will fail.
// This field may not be changed through updates unless the type field is
// also being changed to ExternalName (which requires this field to be
// empty) or the type field is being changed from ExternalName (in which
// case this field may optionally be specified, as describe above).  Valid
// values are "None", empty string (""), or a valid IP address.  Setting
// this to "None" makes a "headless service" (no virtual IP), which is
// useful when direct endpoint connections are preferred and proxying is
// not required.  Only applies to types ClusterIP, NodePort, and
// LoadBalancer. If this field is specified when creating a Service of type
// ExternalName, creation will fail. This field will be wiped when updating
// a Service to type ExternalName.  If this field is not specified, it will
// be initialized from the clusterIP field.  If this field is specified,
// clients must ensure that clusterIPs[0] and clusterIP have the same
// value.
//
// This field may hold a maximum of two entries (dual-stack IPs, in either order).
// These IPs must correspond to the values of the ipFamilies field. Both
// clusterIPs and ipFamilies are governed by the ipFamilyPolicy field.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
func (o LogstashSpecServicesServiceSpecOutput) ClusterIPs() pulumi.StringArrayOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpec) []string { return v.ClusterIPs }).(pulumi.StringArrayOutput)
}

// externalIPs is a list of IP addresses for which nodes in the cluster
// will also accept traffic for this service.  These IPs are not managed by
// Kubernetes.  The user is responsible for ensuring that traffic arrives
// at a node with this IP.  A common example is external load-balancers
// that are not part of the Kubernetes system.
func (o LogstashSpecServicesServiceSpecOutput) ExternalIPs() pulumi.StringArrayOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpec) []string { return v.ExternalIPs }).(pulumi.StringArrayOutput)
}

// externalName is the external reference that discovery mechanisms will
// return as an alias for this service (e.g. a DNS CNAME record). No
// proxying will be involved.  Must be a lowercase RFC-1123 hostname
// (https://tools.ietf.org/html/rfc1123) and requires `type` to be "ExternalName".
func (o LogstashSpecServicesServiceSpecOutput) ExternalName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpec) *string { return v.ExternalName }).(pulumi.StringPtrOutput)
}

// externalTrafficPolicy describes how nodes distribute service traffic they
// receive on one of the Service's "externally-facing" addresses (NodePorts,
// ExternalIPs, and LoadBalancer IPs). If set to "Local", the proxy will configure
// the service in a way that assumes that external load balancers will take care
// of balancing the service traffic between nodes, and so each node will deliver
// traffic only to the node-local endpoints of the service, without masquerading
// the client source IP. (Traffic mistakenly sent to a node with no endpoints will
// be dropped.) The default value, "Cluster", uses the standard behavior of
// routing to all endpoints evenly (possibly modified by topology and other
// features). Note that traffic sent to an External IP or LoadBalancer IP from
// within the cluster will always get "Cluster" semantics, but clients sending to
// a NodePort from within the cluster may need to take traffic policy into account
// when picking a node.
func (o LogstashSpecServicesServiceSpecOutput) ExternalTrafficPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpec) *string { return v.ExternalTrafficPolicy }).(pulumi.StringPtrOutput)
}

// healthCheckNodePort specifies the healthcheck nodePort for the service.
// This only applies when type is set to LoadBalancer and
// externalTrafficPolicy is set to Local. If a value is specified, is
// in-range, and is not in use, it will be used.  If not specified, a value
// will be automatically allocated.  External systems (e.g. load-balancers)
// can use this port to determine if a given node holds endpoints for this
// service or not.  If this field is specified when creating a Service
// which does not need it, creation will fail. This field will be wiped
// when updating a Service to no longer need it (e.g. changing type).
// This field cannot be updated once set.
func (o LogstashSpecServicesServiceSpecOutput) HealthCheckNodePort() pulumi.IntPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpec) *int { return v.HealthCheckNodePort }).(pulumi.IntPtrOutput)
}

// InternalTrafficPolicy describes how nodes distribute service traffic they
// receive on the ClusterIP. If set to "Local", the proxy will assume that pods
// only want to talk to endpoints of the service on the same node as the pod,
// dropping the traffic if there are no local endpoints. The default value,
// "Cluster", uses the standard behavior of routing to all endpoints evenly
// (possibly modified by topology and other features).
func (o LogstashSpecServicesServiceSpecOutput) InternalTrafficPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpec) *string { return v.InternalTrafficPolicy }).(pulumi.StringPtrOutput)
}

// IPFamilies is a list of IP families (e.g. IPv4, IPv6) assigned to this
// service. This field is usually assigned automatically based on cluster
// configuration and the ipFamilyPolicy field. If this field is specified
// manually, the requested family is available in the cluster,
// and ipFamilyPolicy allows it, it will be used; otherwise creation of
// the service will fail. This field is conditionally mutable: it allows
// for adding or removing a secondary IP family, but it does not allow
// changing the primary IP family of the Service. Valid values are "IPv4"
// and "IPv6".  This field only applies to Services of types ClusterIP,
// NodePort, and LoadBalancer, and does apply to "headless" services.
// This field will be wiped when updating a Service to type ExternalName.
//
// This field may hold a maximum of two entries (dual-stack families, in
// either order).  These families must correspond to the values of the
// clusterIPs field, if specified. Both clusterIPs and ipFamilies are
// governed by the ipFamilyPolicy field.
func (o LogstashSpecServicesServiceSpecOutput) IpFamilies() pulumi.StringArrayOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpec) []string { return v.IpFamilies }).(pulumi.StringArrayOutput)
}

// IPFamilyPolicy represents the dual-stack-ness requested or required by
// this Service. If there is no value provided, then this field will be set
// to SingleStack. Services can be "SingleStack" (a single IP family),
// "PreferDualStack" (two IP families on dual-stack configured clusters or
// a single IP family on single-stack clusters), or "RequireDualStack"
// (two IP families on dual-stack configured clusters, otherwise fail). The
// ipFamilies and clusterIPs fields depend on the value of this field. This
// field will be wiped when updating a service to type ExternalName.
func (o LogstashSpecServicesServiceSpecOutput) IpFamilyPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpec) *string { return v.IpFamilyPolicy }).(pulumi.StringPtrOutput)
}

// loadBalancerClass is the class of the load balancer implementation this Service belongs to.
// If specified, the value of this field must be a label-style identifier, with an optional prefix,
// e.g. "internal-vip" or "example.com/internal-vip". Unprefixed names are reserved for end-users.
// This field can only be set when the Service type is 'LoadBalancer'. If not set, the default load
// balancer implementation is used, today this is typically done through the cloud provider integration,
// but should apply for any default implementation. If set, it is assumed that a load balancer
// implementation is watching for Services with a matching class. Any default load balancer
// implementation (e.g. cloud providers) should ignore Services that set this field.
// This field can only be set when creating or updating a Service to type 'LoadBalancer'.
// Once set, it can not be changed. This field will be wiped when a service is updated to a non 'LoadBalancer' type.
func (o LogstashSpecServicesServiceSpecOutput) LoadBalancerClass() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpec) *string { return v.LoadBalancerClass }).(pulumi.StringPtrOutput)
}

// Only applies to Service Type: LoadBalancer.
// This feature depends on whether the underlying cloud-provider supports specifying
// the loadBalancerIP when a load balancer is created.
// This field will be ignored if the cloud-provider does not support the feature.
// Deprecated: This field was under-specified and its meaning varies across implementations.
// Using it is non-portable and it may not support dual-stack.
// Users are encouraged to use implementation-specific annotations when available.
func (o LogstashSpecServicesServiceSpecOutput) LoadBalancerIP() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpec) *string { return v.LoadBalancerIP }).(pulumi.StringPtrOutput)
}

// If specified and supported by the platform, this will restrict traffic through the cloud-provider
// load-balancer will be restricted to the specified client IPs. This field will be ignored if the
// cloud-provider does not support the feature."
// More info: https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/
func (o LogstashSpecServicesServiceSpecOutput) LoadBalancerSourceRanges() pulumi.StringArrayOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpec) []string { return v.LoadBalancerSourceRanges }).(pulumi.StringArrayOutput)
}

// The list of ports that are exposed by this service.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
func (o LogstashSpecServicesServiceSpecOutput) Ports() LogstashSpecServicesServiceSpecPortsArrayOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpec) []LogstashSpecServicesServiceSpecPorts { return v.Ports }).(LogstashSpecServicesServiceSpecPortsArrayOutput)
}

// publishNotReadyAddresses indicates that any agent which deals with endpoints for this
// Service should disregard any indications of ready/not-ready.
// The primary use case for setting this field is for a StatefulSet's Headless Service to
// propagate SRV DNS records for its Pods for the purpose of peer discovery.
// The Kubernetes controllers that generate Endpoints and EndpointSlice resources for
// Services interpret this to mean that all endpoints are considered "ready" even if the
// Pods themselves are not. Agents which consume only Kubernetes generated endpoints
// through the Endpoints or EndpointSlice resources can safely assume this behavior.
func (o LogstashSpecServicesServiceSpecOutput) PublishNotReadyAddresses() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpec) *bool { return v.PublishNotReadyAddresses }).(pulumi.BoolPtrOutput)
}

// Route service traffic to pods with label keys and values matching this
// selector. If empty or not present, the service is assumed to have an
// external process managing its endpoints, which Kubernetes will not
// modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
// Ignored if type is ExternalName.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/
func (o LogstashSpecServicesServiceSpecOutput) Selector() pulumi.StringMapOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpec) map[string]string { return v.Selector }).(pulumi.StringMapOutput)
}

// Supports "ClientIP" and "None". Used to maintain session affinity.
// Enable client IP based session affinity.
// Must be ClientIP or None.
// Defaults to None.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
func (o LogstashSpecServicesServiceSpecOutput) SessionAffinity() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpec) *string { return v.SessionAffinity }).(pulumi.StringPtrOutput)
}

// sessionAffinityConfig contains the configurations of session affinity.
func (o LogstashSpecServicesServiceSpecOutput) SessionAffinityConfig() LogstashSpecServicesServiceSpecSessionAffinityConfigPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpec) *LogstashSpecServicesServiceSpecSessionAffinityConfig {
		return v.SessionAffinityConfig
	}).(LogstashSpecServicesServiceSpecSessionAffinityConfigPtrOutput)
}

// TrafficDistribution offers a way to express preferences for how traffic is
// distributed to Service endpoints. Implementations can use this field as a
// hint, but are not required to guarantee strict adherence. If the field is
// not set, the implementation will apply its default routing strategy. If set
// to "PreferClose", implementations should prioritize endpoints that are
// topologically close (e.g., same zone).
// This is an alpha field and requires enabling ServiceTrafficDistribution feature.
func (o LogstashSpecServicesServiceSpecOutput) TrafficDistribution() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpec) *string { return v.TrafficDistribution }).(pulumi.StringPtrOutput)
}

// type determines how the Service is exposed. Defaults to ClusterIP. Valid
// options are ExternalName, ClusterIP, NodePort, and LoadBalancer.
// "ClusterIP" allocates a cluster-internal IP address for load-balancing
// to endpoints. Endpoints are determined by the selector or if that is not
// specified, by manual construction of an Endpoints object or
// EndpointSlice objects. If clusterIP is "None", no virtual IP is
// allocated and the endpoints are published as a set of endpoints rather
// than a virtual IP.
// "NodePort" builds on ClusterIP and allocates a port on every node which
// routes to the same endpoints as the clusterIP.
// "LoadBalancer" builds on NodePort and creates an external load-balancer
// (if supported in the current cloud) which routes to the same endpoints
// as the clusterIP.
// "ExternalName" aliases this service to the specified externalName.
// Several other fields do not apply to ExternalName services.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
func (o LogstashSpecServicesServiceSpecOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpec) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type LogstashSpecServicesServiceSpecPtrOutput struct{ *pulumi.OutputState }

func (LogstashSpecServicesServiceSpecPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecServicesServiceSpec)(nil)).Elem()
}

func (o LogstashSpecServicesServiceSpecPtrOutput) ToLogstashSpecServicesServiceSpecPtrOutput() LogstashSpecServicesServiceSpecPtrOutput {
	return o
}

func (o LogstashSpecServicesServiceSpecPtrOutput) ToLogstashSpecServicesServiceSpecPtrOutputWithContext(ctx context.Context) LogstashSpecServicesServiceSpecPtrOutput {
	return o
}

func (o LogstashSpecServicesServiceSpecPtrOutput) Elem() LogstashSpecServicesServiceSpecOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceSpec) LogstashSpecServicesServiceSpec {
		if v != nil {
			return *v
		}
		var ret LogstashSpecServicesServiceSpec
		return ret
	}).(LogstashSpecServicesServiceSpecOutput)
}

// allocateLoadBalancerNodePorts defines if NodePorts will be automatically
// allocated for services with type LoadBalancer.  Default is "true". It
// may be set to "false" if the cluster load-balancer does not rely on
// NodePorts.  If the caller requests specific NodePorts (by specifying a
// value), those requests will be respected, regardless of this field.
// This field may only be set for services with type LoadBalancer and will
// be cleared if the type is changed to any other type.
func (o LogstashSpecServicesServiceSpecPtrOutput) AllocateLoadBalancerNodePorts() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceSpec) *bool {
		if v == nil {
			return nil
		}
		return v.AllocateLoadBalancerNodePorts
	}).(pulumi.BoolPtrOutput)
}

// clusterIP is the IP address of the service and is usually assigned
// randomly. If an address is specified manually, is in-range (as per
// system configuration), and is not in use, it will be allocated to the
// service; otherwise creation of the service will fail. This field may not
// be changed through updates unless the type field is also being changed
// to ExternalName (which requires this field to be blank) or the type
// field is being changed from ExternalName (in which case this field may
// optionally be specified, as describe above).  Valid values are "None",
// empty string (""), or a valid IP address. Setting this to "None" makes a
// "headless service" (no virtual IP), which is useful when direct endpoint
// connections are preferred and proxying is not required.  Only applies to
// types ClusterIP, NodePort, and LoadBalancer. If this field is specified
// when creating a Service of type ExternalName, creation will fail. This
// field will be wiped when updating a Service to type ExternalName.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
func (o LogstashSpecServicesServiceSpecPtrOutput) ClusterIP() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceSpec) *string {
		if v == nil {
			return nil
		}
		return v.ClusterIP
	}).(pulumi.StringPtrOutput)
}

// ClusterIPs is a list of IP addresses assigned to this service, and are
// usually assigned randomly.  If an address is specified manually, is
// in-range (as per system configuration), and is not in use, it will be
// allocated to the service; otherwise creation of the service will fail.
// This field may not be changed through updates unless the type field is
// also being changed to ExternalName (which requires this field to be
// empty) or the type field is being changed from ExternalName (in which
// case this field may optionally be specified, as describe above).  Valid
// values are "None", empty string (""), or a valid IP address.  Setting
// this to "None" makes a "headless service" (no virtual IP), which is
// useful when direct endpoint connections are preferred and proxying is
// not required.  Only applies to types ClusterIP, NodePort, and
// LoadBalancer. If this field is specified when creating a Service of type
// ExternalName, creation will fail. This field will be wiped when updating
// a Service to type ExternalName.  If this field is not specified, it will
// be initialized from the clusterIP field.  If this field is specified,
// clients must ensure that clusterIPs[0] and clusterIP have the same
// value.
//
// This field may hold a maximum of two entries (dual-stack IPs, in either order).
// These IPs must correspond to the values of the ipFamilies field. Both
// clusterIPs and ipFamilies are governed by the ipFamilyPolicy field.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
func (o LogstashSpecServicesServiceSpecPtrOutput) ClusterIPs() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceSpec) []string {
		if v == nil {
			return nil
		}
		return v.ClusterIPs
	}).(pulumi.StringArrayOutput)
}

// externalIPs is a list of IP addresses for which nodes in the cluster
// will also accept traffic for this service.  These IPs are not managed by
// Kubernetes.  The user is responsible for ensuring that traffic arrives
// at a node with this IP.  A common example is external load-balancers
// that are not part of the Kubernetes system.
func (o LogstashSpecServicesServiceSpecPtrOutput) ExternalIPs() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceSpec) []string {
		if v == nil {
			return nil
		}
		return v.ExternalIPs
	}).(pulumi.StringArrayOutput)
}

// externalName is the external reference that discovery mechanisms will
// return as an alias for this service (e.g. a DNS CNAME record). No
// proxying will be involved.  Must be a lowercase RFC-1123 hostname
// (https://tools.ietf.org/html/rfc1123) and requires `type` to be "ExternalName".
func (o LogstashSpecServicesServiceSpecPtrOutput) ExternalName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceSpec) *string {
		if v == nil {
			return nil
		}
		return v.ExternalName
	}).(pulumi.StringPtrOutput)
}

// externalTrafficPolicy describes how nodes distribute service traffic they
// receive on one of the Service's "externally-facing" addresses (NodePorts,
// ExternalIPs, and LoadBalancer IPs). If set to "Local", the proxy will configure
// the service in a way that assumes that external load balancers will take care
// of balancing the service traffic between nodes, and so each node will deliver
// traffic only to the node-local endpoints of the service, without masquerading
// the client source IP. (Traffic mistakenly sent to a node with no endpoints will
// be dropped.) The default value, "Cluster", uses the standard behavior of
// routing to all endpoints evenly (possibly modified by topology and other
// features). Note that traffic sent to an External IP or LoadBalancer IP from
// within the cluster will always get "Cluster" semantics, but clients sending to
// a NodePort from within the cluster may need to take traffic policy into account
// when picking a node.
func (o LogstashSpecServicesServiceSpecPtrOutput) ExternalTrafficPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceSpec) *string {
		if v == nil {
			return nil
		}
		return v.ExternalTrafficPolicy
	}).(pulumi.StringPtrOutput)
}

// healthCheckNodePort specifies the healthcheck nodePort for the service.
// This only applies when type is set to LoadBalancer and
// externalTrafficPolicy is set to Local. If a value is specified, is
// in-range, and is not in use, it will be used.  If not specified, a value
// will be automatically allocated.  External systems (e.g. load-balancers)
// can use this port to determine if a given node holds endpoints for this
// service or not.  If this field is specified when creating a Service
// which does not need it, creation will fail. This field will be wiped
// when updating a Service to no longer need it (e.g. changing type).
// This field cannot be updated once set.
func (o LogstashSpecServicesServiceSpecPtrOutput) HealthCheckNodePort() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceSpec) *int {
		if v == nil {
			return nil
		}
		return v.HealthCheckNodePort
	}).(pulumi.IntPtrOutput)
}

// InternalTrafficPolicy describes how nodes distribute service traffic they
// receive on the ClusterIP. If set to "Local", the proxy will assume that pods
// only want to talk to endpoints of the service on the same node as the pod,
// dropping the traffic if there are no local endpoints. The default value,
// "Cluster", uses the standard behavior of routing to all endpoints evenly
// (possibly modified by topology and other features).
func (o LogstashSpecServicesServiceSpecPtrOutput) InternalTrafficPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceSpec) *string {
		if v == nil {
			return nil
		}
		return v.InternalTrafficPolicy
	}).(pulumi.StringPtrOutput)
}

// IPFamilies is a list of IP families (e.g. IPv4, IPv6) assigned to this
// service. This field is usually assigned automatically based on cluster
// configuration and the ipFamilyPolicy field. If this field is specified
// manually, the requested family is available in the cluster,
// and ipFamilyPolicy allows it, it will be used; otherwise creation of
// the service will fail. This field is conditionally mutable: it allows
// for adding or removing a secondary IP family, but it does not allow
// changing the primary IP family of the Service. Valid values are "IPv4"
// and "IPv6".  This field only applies to Services of types ClusterIP,
// NodePort, and LoadBalancer, and does apply to "headless" services.
// This field will be wiped when updating a Service to type ExternalName.
//
// This field may hold a maximum of two entries (dual-stack families, in
// either order).  These families must correspond to the values of the
// clusterIPs field, if specified. Both clusterIPs and ipFamilies are
// governed by the ipFamilyPolicy field.
func (o LogstashSpecServicesServiceSpecPtrOutput) IpFamilies() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceSpec) []string {
		if v == nil {
			return nil
		}
		return v.IpFamilies
	}).(pulumi.StringArrayOutput)
}

// IPFamilyPolicy represents the dual-stack-ness requested or required by
// this Service. If there is no value provided, then this field will be set
// to SingleStack. Services can be "SingleStack" (a single IP family),
// "PreferDualStack" (two IP families on dual-stack configured clusters or
// a single IP family on single-stack clusters), or "RequireDualStack"
// (two IP families on dual-stack configured clusters, otherwise fail). The
// ipFamilies and clusterIPs fields depend on the value of this field. This
// field will be wiped when updating a service to type ExternalName.
func (o LogstashSpecServicesServiceSpecPtrOutput) IpFamilyPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceSpec) *string {
		if v == nil {
			return nil
		}
		return v.IpFamilyPolicy
	}).(pulumi.StringPtrOutput)
}

// loadBalancerClass is the class of the load balancer implementation this Service belongs to.
// If specified, the value of this field must be a label-style identifier, with an optional prefix,
// e.g. "internal-vip" or "example.com/internal-vip". Unprefixed names are reserved for end-users.
// This field can only be set when the Service type is 'LoadBalancer'. If not set, the default load
// balancer implementation is used, today this is typically done through the cloud provider integration,
// but should apply for any default implementation. If set, it is assumed that a load balancer
// implementation is watching for Services with a matching class. Any default load balancer
// implementation (e.g. cloud providers) should ignore Services that set this field.
// This field can only be set when creating or updating a Service to type 'LoadBalancer'.
// Once set, it can not be changed. This field will be wiped when a service is updated to a non 'LoadBalancer' type.
func (o LogstashSpecServicesServiceSpecPtrOutput) LoadBalancerClass() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceSpec) *string {
		if v == nil {
			return nil
		}
		return v.LoadBalancerClass
	}).(pulumi.StringPtrOutput)
}

// Only applies to Service Type: LoadBalancer.
// This feature depends on whether the underlying cloud-provider supports specifying
// the loadBalancerIP when a load balancer is created.
// This field will be ignored if the cloud-provider does not support the feature.
// Deprecated: This field was under-specified and its meaning varies across implementations.
// Using it is non-portable and it may not support dual-stack.
// Users are encouraged to use implementation-specific annotations when available.
func (o LogstashSpecServicesServiceSpecPtrOutput) LoadBalancerIP() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceSpec) *string {
		if v == nil {
			return nil
		}
		return v.LoadBalancerIP
	}).(pulumi.StringPtrOutput)
}

// If specified and supported by the platform, this will restrict traffic through the cloud-provider
// load-balancer will be restricted to the specified client IPs. This field will be ignored if the
// cloud-provider does not support the feature."
// More info: https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/
func (o LogstashSpecServicesServiceSpecPtrOutput) LoadBalancerSourceRanges() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceSpec) []string {
		if v == nil {
			return nil
		}
		return v.LoadBalancerSourceRanges
	}).(pulumi.StringArrayOutput)
}

// The list of ports that are exposed by this service.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
func (o LogstashSpecServicesServiceSpecPtrOutput) Ports() LogstashSpecServicesServiceSpecPortsArrayOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceSpec) []LogstashSpecServicesServiceSpecPorts {
		if v == nil {
			return nil
		}
		return v.Ports
	}).(LogstashSpecServicesServiceSpecPortsArrayOutput)
}

// publishNotReadyAddresses indicates that any agent which deals with endpoints for this
// Service should disregard any indications of ready/not-ready.
// The primary use case for setting this field is for a StatefulSet's Headless Service to
// propagate SRV DNS records for its Pods for the purpose of peer discovery.
// The Kubernetes controllers that generate Endpoints and EndpointSlice resources for
// Services interpret this to mean that all endpoints are considered "ready" even if the
// Pods themselves are not. Agents which consume only Kubernetes generated endpoints
// through the Endpoints or EndpointSlice resources can safely assume this behavior.
func (o LogstashSpecServicesServiceSpecPtrOutput) PublishNotReadyAddresses() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceSpec) *bool {
		if v == nil {
			return nil
		}
		return v.PublishNotReadyAddresses
	}).(pulumi.BoolPtrOutput)
}

// Route service traffic to pods with label keys and values matching this
// selector. If empty or not present, the service is assumed to have an
// external process managing its endpoints, which Kubernetes will not
// modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
// Ignored if type is ExternalName.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/
func (o LogstashSpecServicesServiceSpecPtrOutput) Selector() pulumi.StringMapOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceSpec) map[string]string {
		if v == nil {
			return nil
		}
		return v.Selector
	}).(pulumi.StringMapOutput)
}

// Supports "ClientIP" and "None". Used to maintain session affinity.
// Enable client IP based session affinity.
// Must be ClientIP or None.
// Defaults to None.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
func (o LogstashSpecServicesServiceSpecPtrOutput) SessionAffinity() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceSpec) *string {
		if v == nil {
			return nil
		}
		return v.SessionAffinity
	}).(pulumi.StringPtrOutput)
}

// sessionAffinityConfig contains the configurations of session affinity.
func (o LogstashSpecServicesServiceSpecPtrOutput) SessionAffinityConfig() LogstashSpecServicesServiceSpecSessionAffinityConfigPtrOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceSpec) *LogstashSpecServicesServiceSpecSessionAffinityConfig {
		if v == nil {
			return nil
		}
		return v.SessionAffinityConfig
	}).(LogstashSpecServicesServiceSpecSessionAffinityConfigPtrOutput)
}

// TrafficDistribution offers a way to express preferences for how traffic is
// distributed to Service endpoints. Implementations can use this field as a
// hint, but are not required to guarantee strict adherence. If the field is
// not set, the implementation will apply its default routing strategy. If set
// to "PreferClose", implementations should prioritize endpoints that are
// topologically close (e.g., same zone).
// This is an alpha field and requires enabling ServiceTrafficDistribution feature.
func (o LogstashSpecServicesServiceSpecPtrOutput) TrafficDistribution() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceSpec) *string {
		if v == nil {
			return nil
		}
		return v.TrafficDistribution
	}).(pulumi.StringPtrOutput)
}

// type determines how the Service is exposed. Defaults to ClusterIP. Valid
// options are ExternalName, ClusterIP, NodePort, and LoadBalancer.
// "ClusterIP" allocates a cluster-internal IP address for load-balancing
// to endpoints. Endpoints are determined by the selector or if that is not
// specified, by manual construction of an Endpoints object or
// EndpointSlice objects. If clusterIP is "None", no virtual IP is
// allocated and the endpoints are published as a set of endpoints rather
// than a virtual IP.
// "NodePort" builds on ClusterIP and allocates a port on every node which
// routes to the same endpoints as the clusterIP.
// "LoadBalancer" builds on NodePort and creates an external load-balancer
// (if supported in the current cloud) which routes to the same endpoints
// as the clusterIP.
// "ExternalName" aliases this service to the specified externalName.
// Several other fields do not apply to ExternalName services.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
func (o LogstashSpecServicesServiceSpecPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceSpec) *string {
		if v == nil {
			return nil
		}
		return v.Type
	}).(pulumi.StringPtrOutput)
}

// ServicePort contains information on service's port.
type LogstashSpecServicesServiceSpecPorts struct {
	// The application protocol for this port.
	// This is used as a hint for implementations to offer richer behavior for protocols that they understand.
	// This field follows standard Kubernetes label syntax.
	// Valid values are either:
	//
	// * Un-prefixed protocol names - reserved for IANA standard service names (as per
	// RFC-6335 and https://www.iana.org/assignments/service-names).
	//
	// * Kubernetes-defined prefixed names:
	//   * 'kubernetes.io/h2c' - HTTP/2 prior knowledge over cleartext as described in https://www.rfc-editor.org/rfc/rfc9113.html#name-starting-http-2-with-prior-
	//   * 'kubernetes.io/ws'  - WebSocket over cleartext as described in https://www.rfc-editor.org/rfc/rfc6455
	//   * 'kubernetes.io/wss' - WebSocket over TLS as described in https://www.rfc-editor.org/rfc/rfc6455
	//
	// * Other protocols should use implementation-defined prefixed names such as
	// mycompany.com/my-custom-protocol.
	AppProtocol *string `pulumi:"appProtocol"`
	// The name of this port within the service. This must be a DNS_LABEL.
	// All ports within a ServiceSpec must have unique names. When considering
	// the endpoints for a Service, this must match the 'name' field in the
	// EndpointPort.
	// Optional if only one ServicePort is defined on this service.
	Name *string `pulumi:"name"`
	// The port on each node on which this service is exposed when type is
	// NodePort or LoadBalancer.  Usually assigned by the system. If a value is
	// specified, in-range, and not in use it will be used, otherwise the
	// operation will fail.  If not specified, a port will be allocated if this
	// Service requires one.  If this field is specified when creating a
	// Service which does not need it, creation will fail. This field will be
	// wiped when updating a Service to no longer need it (e.g. changing type
	// from NodePort to ClusterIP).
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
	NodePort *int `pulumi:"nodePort"`
	// The port that will be exposed by this service.
	Port int `pulumi:"port"`
	// The IP protocol for this port. Supports "TCP", "UDP", and "SCTP".
	// Default is TCP.
	Protocol *string `pulumi:"protocol"`
	// Number or name of the port to access on the pods targeted by the service.
	// Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
	// If this is a string, it will be looked up as a named port in the
	// target Pod's container ports. If this is not specified, the value
	// of the 'port' field is used (an identity map).
	// This field is ignored for services with clusterIP=None, and should be
	// omitted or set equal to the 'port' field.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service
	TargetPort interface{} `pulumi:"targetPort"`
}

// Defaults sets the appropriate defaults for LogstashSpecServicesServiceSpecPorts
func (val *LogstashSpecServicesServiceSpecPorts) Defaults() *LogstashSpecServicesServiceSpecPorts {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Protocol == nil {
		protocol_ := "TCP"
		tmp.Protocol = &protocol_
	}
	return &tmp
}

// LogstashSpecServicesServiceSpecPortsInput is an input type that accepts LogstashSpecServicesServiceSpecPortsArgs and LogstashSpecServicesServiceSpecPortsOutput values.
// You can construct a concrete instance of `LogstashSpecServicesServiceSpecPortsInput` via:
//
//	LogstashSpecServicesServiceSpecPortsArgs{...}
type LogstashSpecServicesServiceSpecPortsInput interface {
	pulumi.Input

	ToLogstashSpecServicesServiceSpecPortsOutput() LogstashSpecServicesServiceSpecPortsOutput
	ToLogstashSpecServicesServiceSpecPortsOutputWithContext(context.Context) LogstashSpecServicesServiceSpecPortsOutput
}

// ServicePort contains information on service's port.
type LogstashSpecServicesServiceSpecPortsArgs struct {
	// The application protocol for this port.
	// This is used as a hint for implementations to offer richer behavior for protocols that they understand.
	// This field follows standard Kubernetes label syntax.
	// Valid values are either:
	//
	// * Un-prefixed protocol names - reserved for IANA standard service names (as per
	// RFC-6335 and https://www.iana.org/assignments/service-names).
	//
	// * Kubernetes-defined prefixed names:
	//   * 'kubernetes.io/h2c' - HTTP/2 prior knowledge over cleartext as described in https://www.rfc-editor.org/rfc/rfc9113.html#name-starting-http-2-with-prior-
	//   * 'kubernetes.io/ws'  - WebSocket over cleartext as described in https://www.rfc-editor.org/rfc/rfc6455
	//   * 'kubernetes.io/wss' - WebSocket over TLS as described in https://www.rfc-editor.org/rfc/rfc6455
	//
	// * Other protocols should use implementation-defined prefixed names such as
	// mycompany.com/my-custom-protocol.
	AppProtocol pulumi.StringPtrInput `pulumi:"appProtocol"`
	// The name of this port within the service. This must be a DNS_LABEL.
	// All ports within a ServiceSpec must have unique names. When considering
	// the endpoints for a Service, this must match the 'name' field in the
	// EndpointPort.
	// Optional if only one ServicePort is defined on this service.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// The port on each node on which this service is exposed when type is
	// NodePort or LoadBalancer.  Usually assigned by the system. If a value is
	// specified, in-range, and not in use it will be used, otherwise the
	// operation will fail.  If not specified, a port will be allocated if this
	// Service requires one.  If this field is specified when creating a
	// Service which does not need it, creation will fail. This field will be
	// wiped when updating a Service to no longer need it (e.g. changing type
	// from NodePort to ClusterIP).
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
	NodePort pulumi.IntPtrInput `pulumi:"nodePort"`
	// The port that will be exposed by this service.
	Port pulumi.IntInput `pulumi:"port"`
	// The IP protocol for this port. Supports "TCP", "UDP", and "SCTP".
	// Default is TCP.
	Protocol pulumi.StringPtrInput `pulumi:"protocol"`
	// Number or name of the port to access on the pods targeted by the service.
	// Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
	// If this is a string, it will be looked up as a named port in the
	// target Pod's container ports. If this is not specified, the value
	// of the 'port' field is used (an identity map).
	// This field is ignored for services with clusterIP=None, and should be
	// omitted or set equal to the 'port' field.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service
	TargetPort pulumi.Input `pulumi:"targetPort"`
}

// Defaults sets the appropriate defaults for LogstashSpecServicesServiceSpecPortsArgs
func (val *LogstashSpecServicesServiceSpecPortsArgs) Defaults() *LogstashSpecServicesServiceSpecPortsArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Protocol == nil {
		tmp.Protocol = pulumi.StringPtr("TCP")
	}
	return &tmp
}
func (LogstashSpecServicesServiceSpecPortsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecServicesServiceSpecPorts)(nil)).Elem()
}

func (i LogstashSpecServicesServiceSpecPortsArgs) ToLogstashSpecServicesServiceSpecPortsOutput() LogstashSpecServicesServiceSpecPortsOutput {
	return i.ToLogstashSpecServicesServiceSpecPortsOutputWithContext(context.Background())
}

func (i LogstashSpecServicesServiceSpecPortsArgs) ToLogstashSpecServicesServiceSpecPortsOutputWithContext(ctx context.Context) LogstashSpecServicesServiceSpecPortsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesServiceSpecPortsOutput)
}

// LogstashSpecServicesServiceSpecPortsArrayInput is an input type that accepts LogstashSpecServicesServiceSpecPortsArray and LogstashSpecServicesServiceSpecPortsArrayOutput values.
// You can construct a concrete instance of `LogstashSpecServicesServiceSpecPortsArrayInput` via:
//
//	LogstashSpecServicesServiceSpecPortsArray{ LogstashSpecServicesServiceSpecPortsArgs{...} }
type LogstashSpecServicesServiceSpecPortsArrayInput interface {
	pulumi.Input

	ToLogstashSpecServicesServiceSpecPortsArrayOutput() LogstashSpecServicesServiceSpecPortsArrayOutput
	ToLogstashSpecServicesServiceSpecPortsArrayOutputWithContext(context.Context) LogstashSpecServicesServiceSpecPortsArrayOutput
}

type LogstashSpecServicesServiceSpecPortsArray []LogstashSpecServicesServiceSpecPortsInput

func (LogstashSpecServicesServiceSpecPortsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LogstashSpecServicesServiceSpecPorts)(nil)).Elem()
}

func (i LogstashSpecServicesServiceSpecPortsArray) ToLogstashSpecServicesServiceSpecPortsArrayOutput() LogstashSpecServicesServiceSpecPortsArrayOutput {
	return i.ToLogstashSpecServicesServiceSpecPortsArrayOutputWithContext(context.Background())
}

func (i LogstashSpecServicesServiceSpecPortsArray) ToLogstashSpecServicesServiceSpecPortsArrayOutputWithContext(ctx context.Context) LogstashSpecServicesServiceSpecPortsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesServiceSpecPortsArrayOutput)
}

// ServicePort contains information on service's port.
type LogstashSpecServicesServiceSpecPortsOutput struct{ *pulumi.OutputState }

func (LogstashSpecServicesServiceSpecPortsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecServicesServiceSpecPorts)(nil)).Elem()
}

func (o LogstashSpecServicesServiceSpecPortsOutput) ToLogstashSpecServicesServiceSpecPortsOutput() LogstashSpecServicesServiceSpecPortsOutput {
	return o
}

func (o LogstashSpecServicesServiceSpecPortsOutput) ToLogstashSpecServicesServiceSpecPortsOutputWithContext(ctx context.Context) LogstashSpecServicesServiceSpecPortsOutput {
	return o
}

// The application protocol for this port.
// This is used as a hint for implementations to offer richer behavior for protocols that they understand.
// This field follows standard Kubernetes label syntax.
// Valid values are either:
//
// * Un-prefixed protocol names - reserved for IANA standard service names (as per
// RFC-6335 and https://www.iana.org/assignments/service-names).
//
// * Kubernetes-defined prefixed names:
//   - 'kubernetes.io/h2c' - HTTP/2 prior knowledge over cleartext as described in https://www.rfc-editor.org/rfc/rfc9113.html#name-starting-http-2-with-prior-
//   - 'kubernetes.io/ws'  - WebSocket over cleartext as described in https://www.rfc-editor.org/rfc/rfc6455
//   - 'kubernetes.io/wss' - WebSocket over TLS as described in https://www.rfc-editor.org/rfc/rfc6455
//
// * Other protocols should use implementation-defined prefixed names such as
// mycompany.com/my-custom-protocol.
func (o LogstashSpecServicesServiceSpecPortsOutput) AppProtocol() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpecPorts) *string { return v.AppProtocol }).(pulumi.StringPtrOutput)
}

// The name of this port within the service. This must be a DNS_LABEL.
// All ports within a ServiceSpec must have unique names. When considering
// the endpoints for a Service, this must match the 'name' field in the
// EndpointPort.
// Optional if only one ServicePort is defined on this service.
func (o LogstashSpecServicesServiceSpecPortsOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpecPorts) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// The port on each node on which this service is exposed when type is
// NodePort or LoadBalancer.  Usually assigned by the system. If a value is
// specified, in-range, and not in use it will be used, otherwise the
// operation will fail.  If not specified, a port will be allocated if this
// Service requires one.  If this field is specified when creating a
// Service which does not need it, creation will fail. This field will be
// wiped when updating a Service to no longer need it (e.g. changing type
// from NodePort to ClusterIP).
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
func (o LogstashSpecServicesServiceSpecPortsOutput) NodePort() pulumi.IntPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpecPorts) *int { return v.NodePort }).(pulumi.IntPtrOutput)
}

// The port that will be exposed by this service.
func (o LogstashSpecServicesServiceSpecPortsOutput) Port() pulumi.IntOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpecPorts) int { return v.Port }).(pulumi.IntOutput)
}

// The IP protocol for this port. Supports "TCP", "UDP", and "SCTP".
// Default is TCP.
func (o LogstashSpecServicesServiceSpecPortsOutput) Protocol() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpecPorts) *string { return v.Protocol }).(pulumi.StringPtrOutput)
}

// Number or name of the port to access on the pods targeted by the service.
// Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
// If this is a string, it will be looked up as a named port in the
// target Pod's container ports. If this is not specified, the value
// of the 'port' field is used (an identity map).
// This field is ignored for services with clusterIP=None, and should be
// omitted or set equal to the 'port' field.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service
func (o LogstashSpecServicesServiceSpecPortsOutput) TargetPort() pulumi.AnyOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpecPorts) interface{} { return v.TargetPort }).(pulumi.AnyOutput)
}

type LogstashSpecServicesServiceSpecPortsArrayOutput struct{ *pulumi.OutputState }

func (LogstashSpecServicesServiceSpecPortsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LogstashSpecServicesServiceSpecPorts)(nil)).Elem()
}

func (o LogstashSpecServicesServiceSpecPortsArrayOutput) ToLogstashSpecServicesServiceSpecPortsArrayOutput() LogstashSpecServicesServiceSpecPortsArrayOutput {
	return o
}

func (o LogstashSpecServicesServiceSpecPortsArrayOutput) ToLogstashSpecServicesServiceSpecPortsArrayOutputWithContext(ctx context.Context) LogstashSpecServicesServiceSpecPortsArrayOutput {
	return o
}

func (o LogstashSpecServicesServiceSpecPortsArrayOutput) Index(i pulumi.IntInput) LogstashSpecServicesServiceSpecPortsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LogstashSpecServicesServiceSpecPorts {
		return vs[0].([]LogstashSpecServicesServiceSpecPorts)[vs[1].(int)]
	}).(LogstashSpecServicesServiceSpecPortsOutput)
}

// Route service traffic to pods with label keys and values matching this
// selector. If empty or not present, the service is assumed to have an
// external process managing its endpoints, which Kubernetes will not
// modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
// Ignored if type is ExternalName.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/
type LogstashSpecServicesServiceSpecSelector struct {
}

// sessionAffinityConfig contains the configurations of session affinity.
type LogstashSpecServicesServiceSpecSessionAffinityConfig struct {
	// clientIP contains the configurations of Client IP based session affinity.
	ClientIP *LogstashSpecServicesServiceSpecSessionAffinityConfigClientIp `pulumi:"clientIP"`
}

// LogstashSpecServicesServiceSpecSessionAffinityConfigInput is an input type that accepts LogstashSpecServicesServiceSpecSessionAffinityConfigArgs and LogstashSpecServicesServiceSpecSessionAffinityConfigOutput values.
// You can construct a concrete instance of `LogstashSpecServicesServiceSpecSessionAffinityConfigInput` via:
//
//	LogstashSpecServicesServiceSpecSessionAffinityConfigArgs{...}
type LogstashSpecServicesServiceSpecSessionAffinityConfigInput interface {
	pulumi.Input

	ToLogstashSpecServicesServiceSpecSessionAffinityConfigOutput() LogstashSpecServicesServiceSpecSessionAffinityConfigOutput
	ToLogstashSpecServicesServiceSpecSessionAffinityConfigOutputWithContext(context.Context) LogstashSpecServicesServiceSpecSessionAffinityConfigOutput
}

// sessionAffinityConfig contains the configurations of session affinity.
type LogstashSpecServicesServiceSpecSessionAffinityConfigArgs struct {
	// clientIP contains the configurations of Client IP based session affinity.
	ClientIP LogstashSpecServicesServiceSpecSessionAffinityConfigClientIpPtrInput `pulumi:"clientIP"`
}

func (LogstashSpecServicesServiceSpecSessionAffinityConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecServicesServiceSpecSessionAffinityConfig)(nil)).Elem()
}

func (i LogstashSpecServicesServiceSpecSessionAffinityConfigArgs) ToLogstashSpecServicesServiceSpecSessionAffinityConfigOutput() LogstashSpecServicesServiceSpecSessionAffinityConfigOutput {
	return i.ToLogstashSpecServicesServiceSpecSessionAffinityConfigOutputWithContext(context.Background())
}

func (i LogstashSpecServicesServiceSpecSessionAffinityConfigArgs) ToLogstashSpecServicesServiceSpecSessionAffinityConfigOutputWithContext(ctx context.Context) LogstashSpecServicesServiceSpecSessionAffinityConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesServiceSpecSessionAffinityConfigOutput)
}

func (i LogstashSpecServicesServiceSpecSessionAffinityConfigArgs) ToLogstashSpecServicesServiceSpecSessionAffinityConfigPtrOutput() LogstashSpecServicesServiceSpecSessionAffinityConfigPtrOutput {
	return i.ToLogstashSpecServicesServiceSpecSessionAffinityConfigPtrOutputWithContext(context.Background())
}

func (i LogstashSpecServicesServiceSpecSessionAffinityConfigArgs) ToLogstashSpecServicesServiceSpecSessionAffinityConfigPtrOutputWithContext(ctx context.Context) LogstashSpecServicesServiceSpecSessionAffinityConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesServiceSpecSessionAffinityConfigOutput).ToLogstashSpecServicesServiceSpecSessionAffinityConfigPtrOutputWithContext(ctx)
}

// LogstashSpecServicesServiceSpecSessionAffinityConfigPtrInput is an input type that accepts LogstashSpecServicesServiceSpecSessionAffinityConfigArgs, LogstashSpecServicesServiceSpecSessionAffinityConfigPtr and LogstashSpecServicesServiceSpecSessionAffinityConfigPtrOutput values.
// You can construct a concrete instance of `LogstashSpecServicesServiceSpecSessionAffinityConfigPtrInput` via:
//
//	        LogstashSpecServicesServiceSpecSessionAffinityConfigArgs{...}
//
//	or:
//
//	        nil
type LogstashSpecServicesServiceSpecSessionAffinityConfigPtrInput interface {
	pulumi.Input

	ToLogstashSpecServicesServiceSpecSessionAffinityConfigPtrOutput() LogstashSpecServicesServiceSpecSessionAffinityConfigPtrOutput
	ToLogstashSpecServicesServiceSpecSessionAffinityConfigPtrOutputWithContext(context.Context) LogstashSpecServicesServiceSpecSessionAffinityConfigPtrOutput
}

type logstashSpecServicesServiceSpecSessionAffinityConfigPtrType LogstashSpecServicesServiceSpecSessionAffinityConfigArgs

func LogstashSpecServicesServiceSpecSessionAffinityConfigPtr(v *LogstashSpecServicesServiceSpecSessionAffinityConfigArgs) LogstashSpecServicesServiceSpecSessionAffinityConfigPtrInput {
	return (*logstashSpecServicesServiceSpecSessionAffinityConfigPtrType)(v)
}

func (*logstashSpecServicesServiceSpecSessionAffinityConfigPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecServicesServiceSpecSessionAffinityConfig)(nil)).Elem()
}

func (i *logstashSpecServicesServiceSpecSessionAffinityConfigPtrType) ToLogstashSpecServicesServiceSpecSessionAffinityConfigPtrOutput() LogstashSpecServicesServiceSpecSessionAffinityConfigPtrOutput {
	return i.ToLogstashSpecServicesServiceSpecSessionAffinityConfigPtrOutputWithContext(context.Background())
}

func (i *logstashSpecServicesServiceSpecSessionAffinityConfigPtrType) ToLogstashSpecServicesServiceSpecSessionAffinityConfigPtrOutputWithContext(ctx context.Context) LogstashSpecServicesServiceSpecSessionAffinityConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesServiceSpecSessionAffinityConfigPtrOutput)
}

// sessionAffinityConfig contains the configurations of session affinity.
type LogstashSpecServicesServiceSpecSessionAffinityConfigOutput struct{ *pulumi.OutputState }

func (LogstashSpecServicesServiceSpecSessionAffinityConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecServicesServiceSpecSessionAffinityConfig)(nil)).Elem()
}

func (o LogstashSpecServicesServiceSpecSessionAffinityConfigOutput) ToLogstashSpecServicesServiceSpecSessionAffinityConfigOutput() LogstashSpecServicesServiceSpecSessionAffinityConfigOutput {
	return o
}

func (o LogstashSpecServicesServiceSpecSessionAffinityConfigOutput) ToLogstashSpecServicesServiceSpecSessionAffinityConfigOutputWithContext(ctx context.Context) LogstashSpecServicesServiceSpecSessionAffinityConfigOutput {
	return o
}

func (o LogstashSpecServicesServiceSpecSessionAffinityConfigOutput) ToLogstashSpecServicesServiceSpecSessionAffinityConfigPtrOutput() LogstashSpecServicesServiceSpecSessionAffinityConfigPtrOutput {
	return o.ToLogstashSpecServicesServiceSpecSessionAffinityConfigPtrOutputWithContext(context.Background())
}

func (o LogstashSpecServicesServiceSpecSessionAffinityConfigOutput) ToLogstashSpecServicesServiceSpecSessionAffinityConfigPtrOutputWithContext(ctx context.Context) LogstashSpecServicesServiceSpecSessionAffinityConfigPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LogstashSpecServicesServiceSpecSessionAffinityConfig) *LogstashSpecServicesServiceSpecSessionAffinityConfig {
		return &v
	}).(LogstashSpecServicesServiceSpecSessionAffinityConfigPtrOutput)
}

// clientIP contains the configurations of Client IP based session affinity.
func (o LogstashSpecServicesServiceSpecSessionAffinityConfigOutput) ClientIP() LogstashSpecServicesServiceSpecSessionAffinityConfigClientIpPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpecSessionAffinityConfig) *LogstashSpecServicesServiceSpecSessionAffinityConfigClientIp {
		return v.ClientIP
	}).(LogstashSpecServicesServiceSpecSessionAffinityConfigClientIpPtrOutput)
}

type LogstashSpecServicesServiceSpecSessionAffinityConfigPtrOutput struct{ *pulumi.OutputState }

func (LogstashSpecServicesServiceSpecSessionAffinityConfigPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecServicesServiceSpecSessionAffinityConfig)(nil)).Elem()
}

func (o LogstashSpecServicesServiceSpecSessionAffinityConfigPtrOutput) ToLogstashSpecServicesServiceSpecSessionAffinityConfigPtrOutput() LogstashSpecServicesServiceSpecSessionAffinityConfigPtrOutput {
	return o
}

func (o LogstashSpecServicesServiceSpecSessionAffinityConfigPtrOutput) ToLogstashSpecServicesServiceSpecSessionAffinityConfigPtrOutputWithContext(ctx context.Context) LogstashSpecServicesServiceSpecSessionAffinityConfigPtrOutput {
	return o
}

func (o LogstashSpecServicesServiceSpecSessionAffinityConfigPtrOutput) Elem() LogstashSpecServicesServiceSpecSessionAffinityConfigOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceSpecSessionAffinityConfig) LogstashSpecServicesServiceSpecSessionAffinityConfig {
		if v != nil {
			return *v
		}
		var ret LogstashSpecServicesServiceSpecSessionAffinityConfig
		return ret
	}).(LogstashSpecServicesServiceSpecSessionAffinityConfigOutput)
}

// clientIP contains the configurations of Client IP based session affinity.
func (o LogstashSpecServicesServiceSpecSessionAffinityConfigPtrOutput) ClientIP() LogstashSpecServicesServiceSpecSessionAffinityConfigClientIpPtrOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceSpecSessionAffinityConfig) *LogstashSpecServicesServiceSpecSessionAffinityConfigClientIp {
		if v == nil {
			return nil
		}
		return v.ClientIP
	}).(LogstashSpecServicesServiceSpecSessionAffinityConfigClientIpPtrOutput)
}

// clientIP contains the configurations of Client IP based session affinity.
type LogstashSpecServicesServiceSpecSessionAffinityConfigClientIp struct {
	// timeoutSeconds specifies the seconds of ClientIP type session sticky time.
	// The value must be >0 && <=86400(for 1 day) if ServiceAffinity == "ClientIP".
	// Default value is 10800(for 3 hours).
	TimeoutSeconds *int `pulumi:"timeoutSeconds"`
}

// LogstashSpecServicesServiceSpecSessionAffinityConfigClientIpInput is an input type that accepts LogstashSpecServicesServiceSpecSessionAffinityConfigClientIpArgs and LogstashSpecServicesServiceSpecSessionAffinityConfigClientIpOutput values.
// You can construct a concrete instance of `LogstashSpecServicesServiceSpecSessionAffinityConfigClientIpInput` via:
//
//	LogstashSpecServicesServiceSpecSessionAffinityConfigClientIpArgs{...}
type LogstashSpecServicesServiceSpecSessionAffinityConfigClientIpInput interface {
	pulumi.Input

	ToLogstashSpecServicesServiceSpecSessionAffinityConfigClientIpOutput() LogstashSpecServicesServiceSpecSessionAffinityConfigClientIpOutput
	ToLogstashSpecServicesServiceSpecSessionAffinityConfigClientIpOutputWithContext(context.Context) LogstashSpecServicesServiceSpecSessionAffinityConfigClientIpOutput
}

// clientIP contains the configurations of Client IP based session affinity.
type LogstashSpecServicesServiceSpecSessionAffinityConfigClientIpArgs struct {
	// timeoutSeconds specifies the seconds of ClientIP type session sticky time.
	// The value must be >0 && <=86400(for 1 day) if ServiceAffinity == "ClientIP".
	// Default value is 10800(for 3 hours).
	TimeoutSeconds pulumi.IntPtrInput `pulumi:"timeoutSeconds"`
}

func (LogstashSpecServicesServiceSpecSessionAffinityConfigClientIpArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecServicesServiceSpecSessionAffinityConfigClientIp)(nil)).Elem()
}

func (i LogstashSpecServicesServiceSpecSessionAffinityConfigClientIpArgs) ToLogstashSpecServicesServiceSpecSessionAffinityConfigClientIpOutput() LogstashSpecServicesServiceSpecSessionAffinityConfigClientIpOutput {
	return i.ToLogstashSpecServicesServiceSpecSessionAffinityConfigClientIpOutputWithContext(context.Background())
}

func (i LogstashSpecServicesServiceSpecSessionAffinityConfigClientIpArgs) ToLogstashSpecServicesServiceSpecSessionAffinityConfigClientIpOutputWithContext(ctx context.Context) LogstashSpecServicesServiceSpecSessionAffinityConfigClientIpOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesServiceSpecSessionAffinityConfigClientIpOutput)
}

func (i LogstashSpecServicesServiceSpecSessionAffinityConfigClientIpArgs) ToLogstashSpecServicesServiceSpecSessionAffinityConfigClientIpPtrOutput() LogstashSpecServicesServiceSpecSessionAffinityConfigClientIpPtrOutput {
	return i.ToLogstashSpecServicesServiceSpecSessionAffinityConfigClientIpPtrOutputWithContext(context.Background())
}

func (i LogstashSpecServicesServiceSpecSessionAffinityConfigClientIpArgs) ToLogstashSpecServicesServiceSpecSessionAffinityConfigClientIpPtrOutputWithContext(ctx context.Context) LogstashSpecServicesServiceSpecSessionAffinityConfigClientIpPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesServiceSpecSessionAffinityConfigClientIpOutput).ToLogstashSpecServicesServiceSpecSessionAffinityConfigClientIpPtrOutputWithContext(ctx)
}

// LogstashSpecServicesServiceSpecSessionAffinityConfigClientIpPtrInput is an input type that accepts LogstashSpecServicesServiceSpecSessionAffinityConfigClientIpArgs, LogstashSpecServicesServiceSpecSessionAffinityConfigClientIpPtr and LogstashSpecServicesServiceSpecSessionAffinityConfigClientIpPtrOutput values.
// You can construct a concrete instance of `LogstashSpecServicesServiceSpecSessionAffinityConfigClientIpPtrInput` via:
//
//	        LogstashSpecServicesServiceSpecSessionAffinityConfigClientIpArgs{...}
//
//	or:
//
//	        nil
type LogstashSpecServicesServiceSpecSessionAffinityConfigClientIpPtrInput interface {
	pulumi.Input

	ToLogstashSpecServicesServiceSpecSessionAffinityConfigClientIpPtrOutput() LogstashSpecServicesServiceSpecSessionAffinityConfigClientIpPtrOutput
	ToLogstashSpecServicesServiceSpecSessionAffinityConfigClientIpPtrOutputWithContext(context.Context) LogstashSpecServicesServiceSpecSessionAffinityConfigClientIpPtrOutput
}

type logstashSpecServicesServiceSpecSessionAffinityConfigClientIpPtrType LogstashSpecServicesServiceSpecSessionAffinityConfigClientIpArgs

func LogstashSpecServicesServiceSpecSessionAffinityConfigClientIpPtr(v *LogstashSpecServicesServiceSpecSessionAffinityConfigClientIpArgs) LogstashSpecServicesServiceSpecSessionAffinityConfigClientIpPtrInput {
	return (*logstashSpecServicesServiceSpecSessionAffinityConfigClientIpPtrType)(v)
}

func (*logstashSpecServicesServiceSpecSessionAffinityConfigClientIpPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecServicesServiceSpecSessionAffinityConfigClientIp)(nil)).Elem()
}

func (i *logstashSpecServicesServiceSpecSessionAffinityConfigClientIpPtrType) ToLogstashSpecServicesServiceSpecSessionAffinityConfigClientIpPtrOutput() LogstashSpecServicesServiceSpecSessionAffinityConfigClientIpPtrOutput {
	return i.ToLogstashSpecServicesServiceSpecSessionAffinityConfigClientIpPtrOutputWithContext(context.Background())
}

func (i *logstashSpecServicesServiceSpecSessionAffinityConfigClientIpPtrType) ToLogstashSpecServicesServiceSpecSessionAffinityConfigClientIpPtrOutputWithContext(ctx context.Context) LogstashSpecServicesServiceSpecSessionAffinityConfigClientIpPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesServiceSpecSessionAffinityConfigClientIpPtrOutput)
}

// clientIP contains the configurations of Client IP based session affinity.
type LogstashSpecServicesServiceSpecSessionAffinityConfigClientIpOutput struct{ *pulumi.OutputState }

func (LogstashSpecServicesServiceSpecSessionAffinityConfigClientIpOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecServicesServiceSpecSessionAffinityConfigClientIp)(nil)).Elem()
}

func (o LogstashSpecServicesServiceSpecSessionAffinityConfigClientIpOutput) ToLogstashSpecServicesServiceSpecSessionAffinityConfigClientIpOutput() LogstashSpecServicesServiceSpecSessionAffinityConfigClientIpOutput {
	return o
}

func (o LogstashSpecServicesServiceSpecSessionAffinityConfigClientIpOutput) ToLogstashSpecServicesServiceSpecSessionAffinityConfigClientIpOutputWithContext(ctx context.Context) LogstashSpecServicesServiceSpecSessionAffinityConfigClientIpOutput {
	return o
}

func (o LogstashSpecServicesServiceSpecSessionAffinityConfigClientIpOutput) ToLogstashSpecServicesServiceSpecSessionAffinityConfigClientIpPtrOutput() LogstashSpecServicesServiceSpecSessionAffinityConfigClientIpPtrOutput {
	return o.ToLogstashSpecServicesServiceSpecSessionAffinityConfigClientIpPtrOutputWithContext(context.Background())
}

func (o LogstashSpecServicesServiceSpecSessionAffinityConfigClientIpOutput) ToLogstashSpecServicesServiceSpecSessionAffinityConfigClientIpPtrOutputWithContext(ctx context.Context) LogstashSpecServicesServiceSpecSessionAffinityConfigClientIpPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LogstashSpecServicesServiceSpecSessionAffinityConfigClientIp) *LogstashSpecServicesServiceSpecSessionAffinityConfigClientIp {
		return &v
	}).(LogstashSpecServicesServiceSpecSessionAffinityConfigClientIpPtrOutput)
}

// timeoutSeconds specifies the seconds of ClientIP type session sticky time.
// The value must be >0 && <=86400(for 1 day) if ServiceAffinity == "ClientIP".
// Default value is 10800(for 3 hours).
func (o LogstashSpecServicesServiceSpecSessionAffinityConfigClientIpOutput) TimeoutSeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesServiceSpecSessionAffinityConfigClientIp) *int { return v.TimeoutSeconds }).(pulumi.IntPtrOutput)
}

type LogstashSpecServicesServiceSpecSessionAffinityConfigClientIpPtrOutput struct{ *pulumi.OutputState }

func (LogstashSpecServicesServiceSpecSessionAffinityConfigClientIpPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecServicesServiceSpecSessionAffinityConfigClientIp)(nil)).Elem()
}

func (o LogstashSpecServicesServiceSpecSessionAffinityConfigClientIpPtrOutput) ToLogstashSpecServicesServiceSpecSessionAffinityConfigClientIpPtrOutput() LogstashSpecServicesServiceSpecSessionAffinityConfigClientIpPtrOutput {
	return o
}

func (o LogstashSpecServicesServiceSpecSessionAffinityConfigClientIpPtrOutput) ToLogstashSpecServicesServiceSpecSessionAffinityConfigClientIpPtrOutputWithContext(ctx context.Context) LogstashSpecServicesServiceSpecSessionAffinityConfigClientIpPtrOutput {
	return o
}

func (o LogstashSpecServicesServiceSpecSessionAffinityConfigClientIpPtrOutput) Elem() LogstashSpecServicesServiceSpecSessionAffinityConfigClientIpOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceSpecSessionAffinityConfigClientIp) LogstashSpecServicesServiceSpecSessionAffinityConfigClientIp {
		if v != nil {
			return *v
		}
		var ret LogstashSpecServicesServiceSpecSessionAffinityConfigClientIp
		return ret
	}).(LogstashSpecServicesServiceSpecSessionAffinityConfigClientIpOutput)
}

// timeoutSeconds specifies the seconds of ClientIP type session sticky time.
// The value must be >0 && <=86400(for 1 day) if ServiceAffinity == "ClientIP".
// Default value is 10800(for 3 hours).
func (o LogstashSpecServicesServiceSpecSessionAffinityConfigClientIpPtrOutput) TimeoutSeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *LogstashSpecServicesServiceSpecSessionAffinityConfigClientIp) *int {
		if v == nil {
			return nil
		}
		return v.TimeoutSeconds
	}).(pulumi.IntPtrOutput)
}

// TLS defines options for configuring TLS for HTTP.
type LogstashSpecServicesTls struct {
	// Certificate is a reference to a Kubernetes secret that contains the certificate and private key for enabling TLS.
	// The referenced secret should contain the following:
	//
	// - `ca.crt`: The certificate authority (optional).
	// - `tls.crt`: The certificate (or a chain).
	// - `tls.key`: The private key to the first certificate in the certificate chain.
	Certificate *LogstashSpecServicesTlsCertificate `pulumi:"certificate"`
	// SelfSignedCertificate allows configuring the self-signed certificate generated by the operator.
	SelfSignedCertificate *LogstashSpecServicesTlsSelfSignedCertificate `pulumi:"selfSignedCertificate"`
}

// LogstashSpecServicesTlsInput is an input type that accepts LogstashSpecServicesTlsArgs and LogstashSpecServicesTlsOutput values.
// You can construct a concrete instance of `LogstashSpecServicesTlsInput` via:
//
//	LogstashSpecServicesTlsArgs{...}
type LogstashSpecServicesTlsInput interface {
	pulumi.Input

	ToLogstashSpecServicesTlsOutput() LogstashSpecServicesTlsOutput
	ToLogstashSpecServicesTlsOutputWithContext(context.Context) LogstashSpecServicesTlsOutput
}

// TLS defines options for configuring TLS for HTTP.
type LogstashSpecServicesTlsArgs struct {
	// Certificate is a reference to a Kubernetes secret that contains the certificate and private key for enabling TLS.
	// The referenced secret should contain the following:
	//
	// - `ca.crt`: The certificate authority (optional).
	// - `tls.crt`: The certificate (or a chain).
	// - `tls.key`: The private key to the first certificate in the certificate chain.
	Certificate LogstashSpecServicesTlsCertificatePtrInput `pulumi:"certificate"`
	// SelfSignedCertificate allows configuring the self-signed certificate generated by the operator.
	SelfSignedCertificate LogstashSpecServicesTlsSelfSignedCertificatePtrInput `pulumi:"selfSignedCertificate"`
}

func (LogstashSpecServicesTlsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecServicesTls)(nil)).Elem()
}

func (i LogstashSpecServicesTlsArgs) ToLogstashSpecServicesTlsOutput() LogstashSpecServicesTlsOutput {
	return i.ToLogstashSpecServicesTlsOutputWithContext(context.Background())
}

func (i LogstashSpecServicesTlsArgs) ToLogstashSpecServicesTlsOutputWithContext(ctx context.Context) LogstashSpecServicesTlsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesTlsOutput)
}

func (i LogstashSpecServicesTlsArgs) ToLogstashSpecServicesTlsPtrOutput() LogstashSpecServicesTlsPtrOutput {
	return i.ToLogstashSpecServicesTlsPtrOutputWithContext(context.Background())
}

func (i LogstashSpecServicesTlsArgs) ToLogstashSpecServicesTlsPtrOutputWithContext(ctx context.Context) LogstashSpecServicesTlsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesTlsOutput).ToLogstashSpecServicesTlsPtrOutputWithContext(ctx)
}

// LogstashSpecServicesTlsPtrInput is an input type that accepts LogstashSpecServicesTlsArgs, LogstashSpecServicesTlsPtr and LogstashSpecServicesTlsPtrOutput values.
// You can construct a concrete instance of `LogstashSpecServicesTlsPtrInput` via:
//
//	        LogstashSpecServicesTlsArgs{...}
//
//	or:
//
//	        nil
type LogstashSpecServicesTlsPtrInput interface {
	pulumi.Input

	ToLogstashSpecServicesTlsPtrOutput() LogstashSpecServicesTlsPtrOutput
	ToLogstashSpecServicesTlsPtrOutputWithContext(context.Context) LogstashSpecServicesTlsPtrOutput
}

type logstashSpecServicesTlsPtrType LogstashSpecServicesTlsArgs

func LogstashSpecServicesTlsPtr(v *LogstashSpecServicesTlsArgs) LogstashSpecServicesTlsPtrInput {
	return (*logstashSpecServicesTlsPtrType)(v)
}

func (*logstashSpecServicesTlsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecServicesTls)(nil)).Elem()
}

func (i *logstashSpecServicesTlsPtrType) ToLogstashSpecServicesTlsPtrOutput() LogstashSpecServicesTlsPtrOutput {
	return i.ToLogstashSpecServicesTlsPtrOutputWithContext(context.Background())
}

func (i *logstashSpecServicesTlsPtrType) ToLogstashSpecServicesTlsPtrOutputWithContext(ctx context.Context) LogstashSpecServicesTlsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesTlsPtrOutput)
}

// TLS defines options for configuring TLS for HTTP.
type LogstashSpecServicesTlsOutput struct{ *pulumi.OutputState }

func (LogstashSpecServicesTlsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecServicesTls)(nil)).Elem()
}

func (o LogstashSpecServicesTlsOutput) ToLogstashSpecServicesTlsOutput() LogstashSpecServicesTlsOutput {
	return o
}

func (o LogstashSpecServicesTlsOutput) ToLogstashSpecServicesTlsOutputWithContext(ctx context.Context) LogstashSpecServicesTlsOutput {
	return o
}

func (o LogstashSpecServicesTlsOutput) ToLogstashSpecServicesTlsPtrOutput() LogstashSpecServicesTlsPtrOutput {
	return o.ToLogstashSpecServicesTlsPtrOutputWithContext(context.Background())
}

func (o LogstashSpecServicesTlsOutput) ToLogstashSpecServicesTlsPtrOutputWithContext(ctx context.Context) LogstashSpecServicesTlsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LogstashSpecServicesTls) *LogstashSpecServicesTls {
		return &v
	}).(LogstashSpecServicesTlsPtrOutput)
}

// Certificate is a reference to a Kubernetes secret that contains the certificate and private key for enabling TLS.
// The referenced secret should contain the following:
//
// - `ca.crt`: The certificate authority (optional).
// - `tls.crt`: The certificate (or a chain).
// - `tls.key`: The private key to the first certificate in the certificate chain.
func (o LogstashSpecServicesTlsOutput) Certificate() LogstashSpecServicesTlsCertificatePtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesTls) *LogstashSpecServicesTlsCertificate { return v.Certificate }).(LogstashSpecServicesTlsCertificatePtrOutput)
}

// SelfSignedCertificate allows configuring the self-signed certificate generated by the operator.
func (o LogstashSpecServicesTlsOutput) SelfSignedCertificate() LogstashSpecServicesTlsSelfSignedCertificatePtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesTls) *LogstashSpecServicesTlsSelfSignedCertificate {
		return v.SelfSignedCertificate
	}).(LogstashSpecServicesTlsSelfSignedCertificatePtrOutput)
}

type LogstashSpecServicesTlsPtrOutput struct{ *pulumi.OutputState }

func (LogstashSpecServicesTlsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecServicesTls)(nil)).Elem()
}

func (o LogstashSpecServicesTlsPtrOutput) ToLogstashSpecServicesTlsPtrOutput() LogstashSpecServicesTlsPtrOutput {
	return o
}

func (o LogstashSpecServicesTlsPtrOutput) ToLogstashSpecServicesTlsPtrOutputWithContext(ctx context.Context) LogstashSpecServicesTlsPtrOutput {
	return o
}

func (o LogstashSpecServicesTlsPtrOutput) Elem() LogstashSpecServicesTlsOutput {
	return o.ApplyT(func(v *LogstashSpecServicesTls) LogstashSpecServicesTls {
		if v != nil {
			return *v
		}
		var ret LogstashSpecServicesTls
		return ret
	}).(LogstashSpecServicesTlsOutput)
}

// Certificate is a reference to a Kubernetes secret that contains the certificate and private key for enabling TLS.
// The referenced secret should contain the following:
//
// - `ca.crt`: The certificate authority (optional).
// - `tls.crt`: The certificate (or a chain).
// - `tls.key`: The private key to the first certificate in the certificate chain.
func (o LogstashSpecServicesTlsPtrOutput) Certificate() LogstashSpecServicesTlsCertificatePtrOutput {
	return o.ApplyT(func(v *LogstashSpecServicesTls) *LogstashSpecServicesTlsCertificate {
		if v == nil {
			return nil
		}
		return v.Certificate
	}).(LogstashSpecServicesTlsCertificatePtrOutput)
}

// SelfSignedCertificate allows configuring the self-signed certificate generated by the operator.
func (o LogstashSpecServicesTlsPtrOutput) SelfSignedCertificate() LogstashSpecServicesTlsSelfSignedCertificatePtrOutput {
	return o.ApplyT(func(v *LogstashSpecServicesTls) *LogstashSpecServicesTlsSelfSignedCertificate {
		if v == nil {
			return nil
		}
		return v.SelfSignedCertificate
	}).(LogstashSpecServicesTlsSelfSignedCertificatePtrOutput)
}

// Certificate is a reference to a Kubernetes secret that contains the certificate and private key for enabling TLS.
// The referenced secret should contain the following:
//
// - `ca.crt`: The certificate authority (optional).
// - `tls.crt`: The certificate (or a chain).
// - `tls.key`: The private key to the first certificate in the certificate chain.
type LogstashSpecServicesTlsCertificate struct {
	// SecretName is the name of the secret.
	SecretName *string `pulumi:"secretName"`
}

// LogstashSpecServicesTlsCertificateInput is an input type that accepts LogstashSpecServicesTlsCertificateArgs and LogstashSpecServicesTlsCertificateOutput values.
// You can construct a concrete instance of `LogstashSpecServicesTlsCertificateInput` via:
//
//	LogstashSpecServicesTlsCertificateArgs{...}
type LogstashSpecServicesTlsCertificateInput interface {
	pulumi.Input

	ToLogstashSpecServicesTlsCertificateOutput() LogstashSpecServicesTlsCertificateOutput
	ToLogstashSpecServicesTlsCertificateOutputWithContext(context.Context) LogstashSpecServicesTlsCertificateOutput
}

// Certificate is a reference to a Kubernetes secret that contains the certificate and private key for enabling TLS.
// The referenced secret should contain the following:
//
// - `ca.crt`: The certificate authority (optional).
// - `tls.crt`: The certificate (or a chain).
// - `tls.key`: The private key to the first certificate in the certificate chain.
type LogstashSpecServicesTlsCertificateArgs struct {
	// SecretName is the name of the secret.
	SecretName pulumi.StringPtrInput `pulumi:"secretName"`
}

func (LogstashSpecServicesTlsCertificateArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecServicesTlsCertificate)(nil)).Elem()
}

func (i LogstashSpecServicesTlsCertificateArgs) ToLogstashSpecServicesTlsCertificateOutput() LogstashSpecServicesTlsCertificateOutput {
	return i.ToLogstashSpecServicesTlsCertificateOutputWithContext(context.Background())
}

func (i LogstashSpecServicesTlsCertificateArgs) ToLogstashSpecServicesTlsCertificateOutputWithContext(ctx context.Context) LogstashSpecServicesTlsCertificateOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesTlsCertificateOutput)
}

func (i LogstashSpecServicesTlsCertificateArgs) ToLogstashSpecServicesTlsCertificatePtrOutput() LogstashSpecServicesTlsCertificatePtrOutput {
	return i.ToLogstashSpecServicesTlsCertificatePtrOutputWithContext(context.Background())
}

func (i LogstashSpecServicesTlsCertificateArgs) ToLogstashSpecServicesTlsCertificatePtrOutputWithContext(ctx context.Context) LogstashSpecServicesTlsCertificatePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesTlsCertificateOutput).ToLogstashSpecServicesTlsCertificatePtrOutputWithContext(ctx)
}

// LogstashSpecServicesTlsCertificatePtrInput is an input type that accepts LogstashSpecServicesTlsCertificateArgs, LogstashSpecServicesTlsCertificatePtr and LogstashSpecServicesTlsCertificatePtrOutput values.
// You can construct a concrete instance of `LogstashSpecServicesTlsCertificatePtrInput` via:
//
//	        LogstashSpecServicesTlsCertificateArgs{...}
//
//	or:
//
//	        nil
type LogstashSpecServicesTlsCertificatePtrInput interface {
	pulumi.Input

	ToLogstashSpecServicesTlsCertificatePtrOutput() LogstashSpecServicesTlsCertificatePtrOutput
	ToLogstashSpecServicesTlsCertificatePtrOutputWithContext(context.Context) LogstashSpecServicesTlsCertificatePtrOutput
}

type logstashSpecServicesTlsCertificatePtrType LogstashSpecServicesTlsCertificateArgs

func LogstashSpecServicesTlsCertificatePtr(v *LogstashSpecServicesTlsCertificateArgs) LogstashSpecServicesTlsCertificatePtrInput {
	return (*logstashSpecServicesTlsCertificatePtrType)(v)
}

func (*logstashSpecServicesTlsCertificatePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecServicesTlsCertificate)(nil)).Elem()
}

func (i *logstashSpecServicesTlsCertificatePtrType) ToLogstashSpecServicesTlsCertificatePtrOutput() LogstashSpecServicesTlsCertificatePtrOutput {
	return i.ToLogstashSpecServicesTlsCertificatePtrOutputWithContext(context.Background())
}

func (i *logstashSpecServicesTlsCertificatePtrType) ToLogstashSpecServicesTlsCertificatePtrOutputWithContext(ctx context.Context) LogstashSpecServicesTlsCertificatePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesTlsCertificatePtrOutput)
}

// Certificate is a reference to a Kubernetes secret that contains the certificate and private key for enabling TLS.
// The referenced secret should contain the following:
//
// - `ca.crt`: The certificate authority (optional).
// - `tls.crt`: The certificate (or a chain).
// - `tls.key`: The private key to the first certificate in the certificate chain.
type LogstashSpecServicesTlsCertificateOutput struct{ *pulumi.OutputState }

func (LogstashSpecServicesTlsCertificateOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecServicesTlsCertificate)(nil)).Elem()
}

func (o LogstashSpecServicesTlsCertificateOutput) ToLogstashSpecServicesTlsCertificateOutput() LogstashSpecServicesTlsCertificateOutput {
	return o
}

func (o LogstashSpecServicesTlsCertificateOutput) ToLogstashSpecServicesTlsCertificateOutputWithContext(ctx context.Context) LogstashSpecServicesTlsCertificateOutput {
	return o
}

func (o LogstashSpecServicesTlsCertificateOutput) ToLogstashSpecServicesTlsCertificatePtrOutput() LogstashSpecServicesTlsCertificatePtrOutput {
	return o.ToLogstashSpecServicesTlsCertificatePtrOutputWithContext(context.Background())
}

func (o LogstashSpecServicesTlsCertificateOutput) ToLogstashSpecServicesTlsCertificatePtrOutputWithContext(ctx context.Context) LogstashSpecServicesTlsCertificatePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LogstashSpecServicesTlsCertificate) *LogstashSpecServicesTlsCertificate {
		return &v
	}).(LogstashSpecServicesTlsCertificatePtrOutput)
}

// SecretName is the name of the secret.
func (o LogstashSpecServicesTlsCertificateOutput) SecretName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesTlsCertificate) *string { return v.SecretName }).(pulumi.StringPtrOutput)
}

type LogstashSpecServicesTlsCertificatePtrOutput struct{ *pulumi.OutputState }

func (LogstashSpecServicesTlsCertificatePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecServicesTlsCertificate)(nil)).Elem()
}

func (o LogstashSpecServicesTlsCertificatePtrOutput) ToLogstashSpecServicesTlsCertificatePtrOutput() LogstashSpecServicesTlsCertificatePtrOutput {
	return o
}

func (o LogstashSpecServicesTlsCertificatePtrOutput) ToLogstashSpecServicesTlsCertificatePtrOutputWithContext(ctx context.Context) LogstashSpecServicesTlsCertificatePtrOutput {
	return o
}

func (o LogstashSpecServicesTlsCertificatePtrOutput) Elem() LogstashSpecServicesTlsCertificateOutput {
	return o.ApplyT(func(v *LogstashSpecServicesTlsCertificate) LogstashSpecServicesTlsCertificate {
		if v != nil {
			return *v
		}
		var ret LogstashSpecServicesTlsCertificate
		return ret
	}).(LogstashSpecServicesTlsCertificateOutput)
}

// SecretName is the name of the secret.
func (o LogstashSpecServicesTlsCertificatePtrOutput) SecretName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecServicesTlsCertificate) *string {
		if v == nil {
			return nil
		}
		return v.SecretName
	}).(pulumi.StringPtrOutput)
}

// SelfSignedCertificate allows configuring the self-signed certificate generated by the operator.
type LogstashSpecServicesTlsSelfSignedCertificate struct {
	// Disabled indicates that the provisioning of the self-signed certifcate should be disabled.
	Disabled *bool `pulumi:"disabled"`
	// SubjectAlternativeNames is a list of SANs to include in the generated HTTP TLS certificate.
	SubjectAltNames []LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNames `pulumi:"subjectAltNames"`
}

// LogstashSpecServicesTlsSelfSignedCertificateInput is an input type that accepts LogstashSpecServicesTlsSelfSignedCertificateArgs and LogstashSpecServicesTlsSelfSignedCertificateOutput values.
// You can construct a concrete instance of `LogstashSpecServicesTlsSelfSignedCertificateInput` via:
//
//	LogstashSpecServicesTlsSelfSignedCertificateArgs{...}
type LogstashSpecServicesTlsSelfSignedCertificateInput interface {
	pulumi.Input

	ToLogstashSpecServicesTlsSelfSignedCertificateOutput() LogstashSpecServicesTlsSelfSignedCertificateOutput
	ToLogstashSpecServicesTlsSelfSignedCertificateOutputWithContext(context.Context) LogstashSpecServicesTlsSelfSignedCertificateOutput
}

// SelfSignedCertificate allows configuring the self-signed certificate generated by the operator.
type LogstashSpecServicesTlsSelfSignedCertificateArgs struct {
	// Disabled indicates that the provisioning of the self-signed certifcate should be disabled.
	Disabled pulumi.BoolPtrInput `pulumi:"disabled"`
	// SubjectAlternativeNames is a list of SANs to include in the generated HTTP TLS certificate.
	SubjectAltNames LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArrayInput `pulumi:"subjectAltNames"`
}

func (LogstashSpecServicesTlsSelfSignedCertificateArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecServicesTlsSelfSignedCertificate)(nil)).Elem()
}

func (i LogstashSpecServicesTlsSelfSignedCertificateArgs) ToLogstashSpecServicesTlsSelfSignedCertificateOutput() LogstashSpecServicesTlsSelfSignedCertificateOutput {
	return i.ToLogstashSpecServicesTlsSelfSignedCertificateOutputWithContext(context.Background())
}

func (i LogstashSpecServicesTlsSelfSignedCertificateArgs) ToLogstashSpecServicesTlsSelfSignedCertificateOutputWithContext(ctx context.Context) LogstashSpecServicesTlsSelfSignedCertificateOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesTlsSelfSignedCertificateOutput)
}

func (i LogstashSpecServicesTlsSelfSignedCertificateArgs) ToLogstashSpecServicesTlsSelfSignedCertificatePtrOutput() LogstashSpecServicesTlsSelfSignedCertificatePtrOutput {
	return i.ToLogstashSpecServicesTlsSelfSignedCertificatePtrOutputWithContext(context.Background())
}

func (i LogstashSpecServicesTlsSelfSignedCertificateArgs) ToLogstashSpecServicesTlsSelfSignedCertificatePtrOutputWithContext(ctx context.Context) LogstashSpecServicesTlsSelfSignedCertificatePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesTlsSelfSignedCertificateOutput).ToLogstashSpecServicesTlsSelfSignedCertificatePtrOutputWithContext(ctx)
}

// LogstashSpecServicesTlsSelfSignedCertificatePtrInput is an input type that accepts LogstashSpecServicesTlsSelfSignedCertificateArgs, LogstashSpecServicesTlsSelfSignedCertificatePtr and LogstashSpecServicesTlsSelfSignedCertificatePtrOutput values.
// You can construct a concrete instance of `LogstashSpecServicesTlsSelfSignedCertificatePtrInput` via:
//
//	        LogstashSpecServicesTlsSelfSignedCertificateArgs{...}
//
//	or:
//
//	        nil
type LogstashSpecServicesTlsSelfSignedCertificatePtrInput interface {
	pulumi.Input

	ToLogstashSpecServicesTlsSelfSignedCertificatePtrOutput() LogstashSpecServicesTlsSelfSignedCertificatePtrOutput
	ToLogstashSpecServicesTlsSelfSignedCertificatePtrOutputWithContext(context.Context) LogstashSpecServicesTlsSelfSignedCertificatePtrOutput
}

type logstashSpecServicesTlsSelfSignedCertificatePtrType LogstashSpecServicesTlsSelfSignedCertificateArgs

func LogstashSpecServicesTlsSelfSignedCertificatePtr(v *LogstashSpecServicesTlsSelfSignedCertificateArgs) LogstashSpecServicesTlsSelfSignedCertificatePtrInput {
	return (*logstashSpecServicesTlsSelfSignedCertificatePtrType)(v)
}

func (*logstashSpecServicesTlsSelfSignedCertificatePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecServicesTlsSelfSignedCertificate)(nil)).Elem()
}

func (i *logstashSpecServicesTlsSelfSignedCertificatePtrType) ToLogstashSpecServicesTlsSelfSignedCertificatePtrOutput() LogstashSpecServicesTlsSelfSignedCertificatePtrOutput {
	return i.ToLogstashSpecServicesTlsSelfSignedCertificatePtrOutputWithContext(context.Background())
}

func (i *logstashSpecServicesTlsSelfSignedCertificatePtrType) ToLogstashSpecServicesTlsSelfSignedCertificatePtrOutputWithContext(ctx context.Context) LogstashSpecServicesTlsSelfSignedCertificatePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesTlsSelfSignedCertificatePtrOutput)
}

// SelfSignedCertificate allows configuring the self-signed certificate generated by the operator.
type LogstashSpecServicesTlsSelfSignedCertificateOutput struct{ *pulumi.OutputState }

func (LogstashSpecServicesTlsSelfSignedCertificateOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecServicesTlsSelfSignedCertificate)(nil)).Elem()
}

func (o LogstashSpecServicesTlsSelfSignedCertificateOutput) ToLogstashSpecServicesTlsSelfSignedCertificateOutput() LogstashSpecServicesTlsSelfSignedCertificateOutput {
	return o
}

func (o LogstashSpecServicesTlsSelfSignedCertificateOutput) ToLogstashSpecServicesTlsSelfSignedCertificateOutputWithContext(ctx context.Context) LogstashSpecServicesTlsSelfSignedCertificateOutput {
	return o
}

func (o LogstashSpecServicesTlsSelfSignedCertificateOutput) ToLogstashSpecServicesTlsSelfSignedCertificatePtrOutput() LogstashSpecServicesTlsSelfSignedCertificatePtrOutput {
	return o.ToLogstashSpecServicesTlsSelfSignedCertificatePtrOutputWithContext(context.Background())
}

func (o LogstashSpecServicesTlsSelfSignedCertificateOutput) ToLogstashSpecServicesTlsSelfSignedCertificatePtrOutputWithContext(ctx context.Context) LogstashSpecServicesTlsSelfSignedCertificatePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LogstashSpecServicesTlsSelfSignedCertificate) *LogstashSpecServicesTlsSelfSignedCertificate {
		return &v
	}).(LogstashSpecServicesTlsSelfSignedCertificatePtrOutput)
}

// Disabled indicates that the provisioning of the self-signed certifcate should be disabled.
func (o LogstashSpecServicesTlsSelfSignedCertificateOutput) Disabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesTlsSelfSignedCertificate) *bool { return v.Disabled }).(pulumi.BoolPtrOutput)
}

// SubjectAlternativeNames is a list of SANs to include in the generated HTTP TLS certificate.
func (o LogstashSpecServicesTlsSelfSignedCertificateOutput) SubjectAltNames() LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArrayOutput {
	return o.ApplyT(func(v LogstashSpecServicesTlsSelfSignedCertificate) []LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNames {
		return v.SubjectAltNames
	}).(LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArrayOutput)
}

type LogstashSpecServicesTlsSelfSignedCertificatePtrOutput struct{ *pulumi.OutputState }

func (LogstashSpecServicesTlsSelfSignedCertificatePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecServicesTlsSelfSignedCertificate)(nil)).Elem()
}

func (o LogstashSpecServicesTlsSelfSignedCertificatePtrOutput) ToLogstashSpecServicesTlsSelfSignedCertificatePtrOutput() LogstashSpecServicesTlsSelfSignedCertificatePtrOutput {
	return o
}

func (o LogstashSpecServicesTlsSelfSignedCertificatePtrOutput) ToLogstashSpecServicesTlsSelfSignedCertificatePtrOutputWithContext(ctx context.Context) LogstashSpecServicesTlsSelfSignedCertificatePtrOutput {
	return o
}

func (o LogstashSpecServicesTlsSelfSignedCertificatePtrOutput) Elem() LogstashSpecServicesTlsSelfSignedCertificateOutput {
	return o.ApplyT(func(v *LogstashSpecServicesTlsSelfSignedCertificate) LogstashSpecServicesTlsSelfSignedCertificate {
		if v != nil {
			return *v
		}
		var ret LogstashSpecServicesTlsSelfSignedCertificate
		return ret
	}).(LogstashSpecServicesTlsSelfSignedCertificateOutput)
}

// Disabled indicates that the provisioning of the self-signed certifcate should be disabled.
func (o LogstashSpecServicesTlsSelfSignedCertificatePtrOutput) Disabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *LogstashSpecServicesTlsSelfSignedCertificate) *bool {
		if v == nil {
			return nil
		}
		return v.Disabled
	}).(pulumi.BoolPtrOutput)
}

// SubjectAlternativeNames is a list of SANs to include in the generated HTTP TLS certificate.
func (o LogstashSpecServicesTlsSelfSignedCertificatePtrOutput) SubjectAltNames() LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArrayOutput {
	return o.ApplyT(func(v *LogstashSpecServicesTlsSelfSignedCertificate) []LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNames {
		if v == nil {
			return nil
		}
		return v.SubjectAltNames
	}).(LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArrayOutput)
}

// SubjectAlternativeName represents a SAN entry in a x509 certificate.
type LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNames struct {
	// DNS is the DNS name of the subject.
	Dns *string `pulumi:"dns"`
	// IP is the IP address of the subject.
	Ip *string `pulumi:"ip"`
}

// LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesInput is an input type that accepts LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArgs and LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesOutput values.
// You can construct a concrete instance of `LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesInput` via:
//
//	LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArgs{...}
type LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesInput interface {
	pulumi.Input

	ToLogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesOutput() LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesOutput
	ToLogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesOutputWithContext(context.Context) LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesOutput
}

// SubjectAlternativeName represents a SAN entry in a x509 certificate.
type LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArgs struct {
	// DNS is the DNS name of the subject.
	Dns pulumi.StringPtrInput `pulumi:"dns"`
	// IP is the IP address of the subject.
	Ip pulumi.StringPtrInput `pulumi:"ip"`
}

func (LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNames)(nil)).Elem()
}

func (i LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArgs) ToLogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesOutput() LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesOutput {
	return i.ToLogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesOutputWithContext(context.Background())
}

func (i LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArgs) ToLogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesOutputWithContext(ctx context.Context) LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesOutput)
}

// LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArrayInput is an input type that accepts LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArray and LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArrayOutput values.
// You can construct a concrete instance of `LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArrayInput` via:
//
//	LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArray{ LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArgs{...} }
type LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArrayInput interface {
	pulumi.Input

	ToLogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArrayOutput() LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArrayOutput
	ToLogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArrayOutputWithContext(context.Context) LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArrayOutput
}

type LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArray []LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesInput

func (LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNames)(nil)).Elem()
}

func (i LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArray) ToLogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArrayOutput() LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArrayOutput {
	return i.ToLogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArrayOutputWithContext(context.Background())
}

func (i LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArray) ToLogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArrayOutputWithContext(ctx context.Context) LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArrayOutput)
}

// SubjectAlternativeName represents a SAN entry in a x509 certificate.
type LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesOutput struct{ *pulumi.OutputState }

func (LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNames)(nil)).Elem()
}

func (o LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesOutput) ToLogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesOutput() LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesOutput {
	return o
}

func (o LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesOutput) ToLogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesOutputWithContext(ctx context.Context) LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesOutput {
	return o
}

// DNS is the DNS name of the subject.
func (o LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesOutput) Dns() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNames) *string { return v.Dns }).(pulumi.StringPtrOutput)
}

// IP is the IP address of the subject.
func (o LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesOutput) Ip() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNames) *string { return v.Ip }).(pulumi.StringPtrOutput)
}

type LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArrayOutput struct{ *pulumi.OutputState }

func (LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNames)(nil)).Elem()
}

func (o LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArrayOutput) ToLogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArrayOutput() LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArrayOutput {
	return o
}

func (o LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArrayOutput) ToLogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArrayOutputWithContext(ctx context.Context) LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArrayOutput {
	return o
}

func (o LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArrayOutput) Index(i pulumi.IntInput) LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNames {
		return vs[0].([]LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNames)[vs[1].(int)]
	}).(LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesOutput)
}

// UpdateStrategy is a StatefulSetUpdateStrategy. The default type is "RollingUpdate".
type LogstashSpecUpdateStrategy struct {
	// RollingUpdate is used to communicate parameters when Type is RollingUpdateStatefulSetStrategyType.
	RollingUpdate *LogstashSpecUpdateStrategyRollingUpdate `pulumi:"rollingUpdate"`
	// Type indicates the type of the StatefulSetUpdateStrategy.
	// Default is RollingUpdate.
	Type *string `pulumi:"type"`
}

// LogstashSpecUpdateStrategyInput is an input type that accepts LogstashSpecUpdateStrategyArgs and LogstashSpecUpdateStrategyOutput values.
// You can construct a concrete instance of `LogstashSpecUpdateStrategyInput` via:
//
//	LogstashSpecUpdateStrategyArgs{...}
type LogstashSpecUpdateStrategyInput interface {
	pulumi.Input

	ToLogstashSpecUpdateStrategyOutput() LogstashSpecUpdateStrategyOutput
	ToLogstashSpecUpdateStrategyOutputWithContext(context.Context) LogstashSpecUpdateStrategyOutput
}

// UpdateStrategy is a StatefulSetUpdateStrategy. The default type is "RollingUpdate".
type LogstashSpecUpdateStrategyArgs struct {
	// RollingUpdate is used to communicate parameters when Type is RollingUpdateStatefulSetStrategyType.
	RollingUpdate LogstashSpecUpdateStrategyRollingUpdatePtrInput `pulumi:"rollingUpdate"`
	// Type indicates the type of the StatefulSetUpdateStrategy.
	// Default is RollingUpdate.
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (LogstashSpecUpdateStrategyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecUpdateStrategy)(nil)).Elem()
}

func (i LogstashSpecUpdateStrategyArgs) ToLogstashSpecUpdateStrategyOutput() LogstashSpecUpdateStrategyOutput {
	return i.ToLogstashSpecUpdateStrategyOutputWithContext(context.Background())
}

func (i LogstashSpecUpdateStrategyArgs) ToLogstashSpecUpdateStrategyOutputWithContext(ctx context.Context) LogstashSpecUpdateStrategyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecUpdateStrategyOutput)
}

func (i LogstashSpecUpdateStrategyArgs) ToLogstashSpecUpdateStrategyPtrOutput() LogstashSpecUpdateStrategyPtrOutput {
	return i.ToLogstashSpecUpdateStrategyPtrOutputWithContext(context.Background())
}

func (i LogstashSpecUpdateStrategyArgs) ToLogstashSpecUpdateStrategyPtrOutputWithContext(ctx context.Context) LogstashSpecUpdateStrategyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecUpdateStrategyOutput).ToLogstashSpecUpdateStrategyPtrOutputWithContext(ctx)
}

// LogstashSpecUpdateStrategyPtrInput is an input type that accepts LogstashSpecUpdateStrategyArgs, LogstashSpecUpdateStrategyPtr and LogstashSpecUpdateStrategyPtrOutput values.
// You can construct a concrete instance of `LogstashSpecUpdateStrategyPtrInput` via:
//
//	        LogstashSpecUpdateStrategyArgs{...}
//
//	or:
//
//	        nil
type LogstashSpecUpdateStrategyPtrInput interface {
	pulumi.Input

	ToLogstashSpecUpdateStrategyPtrOutput() LogstashSpecUpdateStrategyPtrOutput
	ToLogstashSpecUpdateStrategyPtrOutputWithContext(context.Context) LogstashSpecUpdateStrategyPtrOutput
}

type logstashSpecUpdateStrategyPtrType LogstashSpecUpdateStrategyArgs

func LogstashSpecUpdateStrategyPtr(v *LogstashSpecUpdateStrategyArgs) LogstashSpecUpdateStrategyPtrInput {
	return (*logstashSpecUpdateStrategyPtrType)(v)
}

func (*logstashSpecUpdateStrategyPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecUpdateStrategy)(nil)).Elem()
}

func (i *logstashSpecUpdateStrategyPtrType) ToLogstashSpecUpdateStrategyPtrOutput() LogstashSpecUpdateStrategyPtrOutput {
	return i.ToLogstashSpecUpdateStrategyPtrOutputWithContext(context.Background())
}

func (i *logstashSpecUpdateStrategyPtrType) ToLogstashSpecUpdateStrategyPtrOutputWithContext(ctx context.Context) LogstashSpecUpdateStrategyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecUpdateStrategyPtrOutput)
}

// UpdateStrategy is a StatefulSetUpdateStrategy. The default type is "RollingUpdate".
type LogstashSpecUpdateStrategyOutput struct{ *pulumi.OutputState }

func (LogstashSpecUpdateStrategyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecUpdateStrategy)(nil)).Elem()
}

func (o LogstashSpecUpdateStrategyOutput) ToLogstashSpecUpdateStrategyOutput() LogstashSpecUpdateStrategyOutput {
	return o
}

func (o LogstashSpecUpdateStrategyOutput) ToLogstashSpecUpdateStrategyOutputWithContext(ctx context.Context) LogstashSpecUpdateStrategyOutput {
	return o
}

func (o LogstashSpecUpdateStrategyOutput) ToLogstashSpecUpdateStrategyPtrOutput() LogstashSpecUpdateStrategyPtrOutput {
	return o.ToLogstashSpecUpdateStrategyPtrOutputWithContext(context.Background())
}

func (o LogstashSpecUpdateStrategyOutput) ToLogstashSpecUpdateStrategyPtrOutputWithContext(ctx context.Context) LogstashSpecUpdateStrategyPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LogstashSpecUpdateStrategy) *LogstashSpecUpdateStrategy {
		return &v
	}).(LogstashSpecUpdateStrategyPtrOutput)
}

// RollingUpdate is used to communicate parameters when Type is RollingUpdateStatefulSetStrategyType.
func (o LogstashSpecUpdateStrategyOutput) RollingUpdate() LogstashSpecUpdateStrategyRollingUpdatePtrOutput {
	return o.ApplyT(func(v LogstashSpecUpdateStrategy) *LogstashSpecUpdateStrategyRollingUpdate { return v.RollingUpdate }).(LogstashSpecUpdateStrategyRollingUpdatePtrOutput)
}

// Type indicates the type of the StatefulSetUpdateStrategy.
// Default is RollingUpdate.
func (o LogstashSpecUpdateStrategyOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecUpdateStrategy) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type LogstashSpecUpdateStrategyPtrOutput struct{ *pulumi.OutputState }

func (LogstashSpecUpdateStrategyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecUpdateStrategy)(nil)).Elem()
}

func (o LogstashSpecUpdateStrategyPtrOutput) ToLogstashSpecUpdateStrategyPtrOutput() LogstashSpecUpdateStrategyPtrOutput {
	return o
}

func (o LogstashSpecUpdateStrategyPtrOutput) ToLogstashSpecUpdateStrategyPtrOutputWithContext(ctx context.Context) LogstashSpecUpdateStrategyPtrOutput {
	return o
}

func (o LogstashSpecUpdateStrategyPtrOutput) Elem() LogstashSpecUpdateStrategyOutput {
	return o.ApplyT(func(v *LogstashSpecUpdateStrategy) LogstashSpecUpdateStrategy {
		if v != nil {
			return *v
		}
		var ret LogstashSpecUpdateStrategy
		return ret
	}).(LogstashSpecUpdateStrategyOutput)
}

// RollingUpdate is used to communicate parameters when Type is RollingUpdateStatefulSetStrategyType.
func (o LogstashSpecUpdateStrategyPtrOutput) RollingUpdate() LogstashSpecUpdateStrategyRollingUpdatePtrOutput {
	return o.ApplyT(func(v *LogstashSpecUpdateStrategy) *LogstashSpecUpdateStrategyRollingUpdate {
		if v == nil {
			return nil
		}
		return v.RollingUpdate
	}).(LogstashSpecUpdateStrategyRollingUpdatePtrOutput)
}

// Type indicates the type of the StatefulSetUpdateStrategy.
// Default is RollingUpdate.
func (o LogstashSpecUpdateStrategyPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecUpdateStrategy) *string {
		if v == nil {
			return nil
		}
		return v.Type
	}).(pulumi.StringPtrOutput)
}

// RollingUpdate is used to communicate parameters when Type is RollingUpdateStatefulSetStrategyType.
type LogstashSpecUpdateStrategyRollingUpdate struct {
	// The maximum number of pods that can be unavailable during the update.
	// Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
	// Absolute number is calculated from percentage by rounding up. This can not be 0.
	// Defaults to 1. This field is alpha-level and is only honored by servers that enable the
	// MaxUnavailableStatefulSet feature. The field applies to all pods in the range 0 to
	// Replicas-1. That means if there is any unavailable pod in the range 0 to Replicas-1, it
	// will be counted towards MaxUnavailable.
	MaxUnavailable interface{} `pulumi:"maxUnavailable"`
	// Partition indicates the ordinal at which the StatefulSet should be partitioned
	// for updates. During a rolling update, all pods from ordinal Replicas-1 to
	// Partition are updated. All pods from ordinal Partition-1 to 0 remain untouched.
	// This is helpful in being able to do a canary based deployment. The default value is 0.
	Partition *int `pulumi:"partition"`
}

// LogstashSpecUpdateStrategyRollingUpdateInput is an input type that accepts LogstashSpecUpdateStrategyRollingUpdateArgs and LogstashSpecUpdateStrategyRollingUpdateOutput values.
// You can construct a concrete instance of `LogstashSpecUpdateStrategyRollingUpdateInput` via:
//
//	LogstashSpecUpdateStrategyRollingUpdateArgs{...}
type LogstashSpecUpdateStrategyRollingUpdateInput interface {
	pulumi.Input

	ToLogstashSpecUpdateStrategyRollingUpdateOutput() LogstashSpecUpdateStrategyRollingUpdateOutput
	ToLogstashSpecUpdateStrategyRollingUpdateOutputWithContext(context.Context) LogstashSpecUpdateStrategyRollingUpdateOutput
}

// RollingUpdate is used to communicate parameters when Type is RollingUpdateStatefulSetStrategyType.
type LogstashSpecUpdateStrategyRollingUpdateArgs struct {
	// The maximum number of pods that can be unavailable during the update.
	// Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
	// Absolute number is calculated from percentage by rounding up. This can not be 0.
	// Defaults to 1. This field is alpha-level and is only honored by servers that enable the
	// MaxUnavailableStatefulSet feature. The field applies to all pods in the range 0 to
	// Replicas-1. That means if there is any unavailable pod in the range 0 to Replicas-1, it
	// will be counted towards MaxUnavailable.
	MaxUnavailable pulumi.Input `pulumi:"maxUnavailable"`
	// Partition indicates the ordinal at which the StatefulSet should be partitioned
	// for updates. During a rolling update, all pods from ordinal Replicas-1 to
	// Partition are updated. All pods from ordinal Partition-1 to 0 remain untouched.
	// This is helpful in being able to do a canary based deployment. The default value is 0.
	Partition pulumi.IntPtrInput `pulumi:"partition"`
}

func (LogstashSpecUpdateStrategyRollingUpdateArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecUpdateStrategyRollingUpdate)(nil)).Elem()
}

func (i LogstashSpecUpdateStrategyRollingUpdateArgs) ToLogstashSpecUpdateStrategyRollingUpdateOutput() LogstashSpecUpdateStrategyRollingUpdateOutput {
	return i.ToLogstashSpecUpdateStrategyRollingUpdateOutputWithContext(context.Background())
}

func (i LogstashSpecUpdateStrategyRollingUpdateArgs) ToLogstashSpecUpdateStrategyRollingUpdateOutputWithContext(ctx context.Context) LogstashSpecUpdateStrategyRollingUpdateOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecUpdateStrategyRollingUpdateOutput)
}

func (i LogstashSpecUpdateStrategyRollingUpdateArgs) ToLogstashSpecUpdateStrategyRollingUpdatePtrOutput() LogstashSpecUpdateStrategyRollingUpdatePtrOutput {
	return i.ToLogstashSpecUpdateStrategyRollingUpdatePtrOutputWithContext(context.Background())
}

func (i LogstashSpecUpdateStrategyRollingUpdateArgs) ToLogstashSpecUpdateStrategyRollingUpdatePtrOutputWithContext(ctx context.Context) LogstashSpecUpdateStrategyRollingUpdatePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecUpdateStrategyRollingUpdateOutput).ToLogstashSpecUpdateStrategyRollingUpdatePtrOutputWithContext(ctx)
}

// LogstashSpecUpdateStrategyRollingUpdatePtrInput is an input type that accepts LogstashSpecUpdateStrategyRollingUpdateArgs, LogstashSpecUpdateStrategyRollingUpdatePtr and LogstashSpecUpdateStrategyRollingUpdatePtrOutput values.
// You can construct a concrete instance of `LogstashSpecUpdateStrategyRollingUpdatePtrInput` via:
//
//	        LogstashSpecUpdateStrategyRollingUpdateArgs{...}
//
//	or:
//
//	        nil
type LogstashSpecUpdateStrategyRollingUpdatePtrInput interface {
	pulumi.Input

	ToLogstashSpecUpdateStrategyRollingUpdatePtrOutput() LogstashSpecUpdateStrategyRollingUpdatePtrOutput
	ToLogstashSpecUpdateStrategyRollingUpdatePtrOutputWithContext(context.Context) LogstashSpecUpdateStrategyRollingUpdatePtrOutput
}

type logstashSpecUpdateStrategyRollingUpdatePtrType LogstashSpecUpdateStrategyRollingUpdateArgs

func LogstashSpecUpdateStrategyRollingUpdatePtr(v *LogstashSpecUpdateStrategyRollingUpdateArgs) LogstashSpecUpdateStrategyRollingUpdatePtrInput {
	return (*logstashSpecUpdateStrategyRollingUpdatePtrType)(v)
}

func (*logstashSpecUpdateStrategyRollingUpdatePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecUpdateStrategyRollingUpdate)(nil)).Elem()
}

func (i *logstashSpecUpdateStrategyRollingUpdatePtrType) ToLogstashSpecUpdateStrategyRollingUpdatePtrOutput() LogstashSpecUpdateStrategyRollingUpdatePtrOutput {
	return i.ToLogstashSpecUpdateStrategyRollingUpdatePtrOutputWithContext(context.Background())
}

func (i *logstashSpecUpdateStrategyRollingUpdatePtrType) ToLogstashSpecUpdateStrategyRollingUpdatePtrOutputWithContext(ctx context.Context) LogstashSpecUpdateStrategyRollingUpdatePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecUpdateStrategyRollingUpdatePtrOutput)
}

// RollingUpdate is used to communicate parameters when Type is RollingUpdateStatefulSetStrategyType.
type LogstashSpecUpdateStrategyRollingUpdateOutput struct{ *pulumi.OutputState }

func (LogstashSpecUpdateStrategyRollingUpdateOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecUpdateStrategyRollingUpdate)(nil)).Elem()
}

func (o LogstashSpecUpdateStrategyRollingUpdateOutput) ToLogstashSpecUpdateStrategyRollingUpdateOutput() LogstashSpecUpdateStrategyRollingUpdateOutput {
	return o
}

func (o LogstashSpecUpdateStrategyRollingUpdateOutput) ToLogstashSpecUpdateStrategyRollingUpdateOutputWithContext(ctx context.Context) LogstashSpecUpdateStrategyRollingUpdateOutput {
	return o
}

func (o LogstashSpecUpdateStrategyRollingUpdateOutput) ToLogstashSpecUpdateStrategyRollingUpdatePtrOutput() LogstashSpecUpdateStrategyRollingUpdatePtrOutput {
	return o.ToLogstashSpecUpdateStrategyRollingUpdatePtrOutputWithContext(context.Background())
}

func (o LogstashSpecUpdateStrategyRollingUpdateOutput) ToLogstashSpecUpdateStrategyRollingUpdatePtrOutputWithContext(ctx context.Context) LogstashSpecUpdateStrategyRollingUpdatePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LogstashSpecUpdateStrategyRollingUpdate) *LogstashSpecUpdateStrategyRollingUpdate {
		return &v
	}).(LogstashSpecUpdateStrategyRollingUpdatePtrOutput)
}

// The maximum number of pods that can be unavailable during the update.
// Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
// Absolute number is calculated from percentage by rounding up. This can not be 0.
// Defaults to 1. This field is alpha-level and is only honored by servers that enable the
// MaxUnavailableStatefulSet feature. The field applies to all pods in the range 0 to
// Replicas-1. That means if there is any unavailable pod in the range 0 to Replicas-1, it
// will be counted towards MaxUnavailable.
func (o LogstashSpecUpdateStrategyRollingUpdateOutput) MaxUnavailable() pulumi.AnyOutput {
	return o.ApplyT(func(v LogstashSpecUpdateStrategyRollingUpdate) interface{} { return v.MaxUnavailable }).(pulumi.AnyOutput)
}

// Partition indicates the ordinal at which the StatefulSet should be partitioned
// for updates. During a rolling update, all pods from ordinal Replicas-1 to
// Partition are updated. All pods from ordinal Partition-1 to 0 remain untouched.
// This is helpful in being able to do a canary based deployment. The default value is 0.
func (o LogstashSpecUpdateStrategyRollingUpdateOutput) Partition() pulumi.IntPtrOutput {
	return o.ApplyT(func(v LogstashSpecUpdateStrategyRollingUpdate) *int { return v.Partition }).(pulumi.IntPtrOutput)
}

type LogstashSpecUpdateStrategyRollingUpdatePtrOutput struct{ *pulumi.OutputState }

func (LogstashSpecUpdateStrategyRollingUpdatePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecUpdateStrategyRollingUpdate)(nil)).Elem()
}

func (o LogstashSpecUpdateStrategyRollingUpdatePtrOutput) ToLogstashSpecUpdateStrategyRollingUpdatePtrOutput() LogstashSpecUpdateStrategyRollingUpdatePtrOutput {
	return o
}

func (o LogstashSpecUpdateStrategyRollingUpdatePtrOutput) ToLogstashSpecUpdateStrategyRollingUpdatePtrOutputWithContext(ctx context.Context) LogstashSpecUpdateStrategyRollingUpdatePtrOutput {
	return o
}

func (o LogstashSpecUpdateStrategyRollingUpdatePtrOutput) Elem() LogstashSpecUpdateStrategyRollingUpdateOutput {
	return o.ApplyT(func(v *LogstashSpecUpdateStrategyRollingUpdate) LogstashSpecUpdateStrategyRollingUpdate {
		if v != nil {
			return *v
		}
		var ret LogstashSpecUpdateStrategyRollingUpdate
		return ret
	}).(LogstashSpecUpdateStrategyRollingUpdateOutput)
}

// The maximum number of pods that can be unavailable during the update.
// Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
// Absolute number is calculated from percentage by rounding up. This can not be 0.
// Defaults to 1. This field is alpha-level and is only honored by servers that enable the
// MaxUnavailableStatefulSet feature. The field applies to all pods in the range 0 to
// Replicas-1. That means if there is any unavailable pod in the range 0 to Replicas-1, it
// will be counted towards MaxUnavailable.
func (o LogstashSpecUpdateStrategyRollingUpdatePtrOutput) MaxUnavailable() pulumi.AnyOutput {
	return o.ApplyT(func(v *LogstashSpecUpdateStrategyRollingUpdate) interface{} {
		if v == nil {
			return nil
		}
		return v.MaxUnavailable
	}).(pulumi.AnyOutput)
}

// Partition indicates the ordinal at which the StatefulSet should be partitioned
// for updates. During a rolling update, all pods from ordinal Replicas-1 to
// Partition are updated. All pods from ordinal Partition-1 to 0 remain untouched.
// This is helpful in being able to do a canary based deployment. The default value is 0.
func (o LogstashSpecUpdateStrategyRollingUpdatePtrOutput) Partition() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *LogstashSpecUpdateStrategyRollingUpdate) *int {
		if v == nil {
			return nil
		}
		return v.Partition
	}).(pulumi.IntPtrOutput)
}

// PersistentVolumeClaim is a user's request for and claim to a persistent volume
type LogstashSpecVolumeClaimTemplates struct {
	// APIVersion defines the versioned schema of this representation of an object.
	// Servers should convert recognized schemas to the latest internal value, and
	// may reject unrecognized values.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents.
	// Servers may infer this from the endpoint the client submits requests to.
	// Cannot be updated.
	// In CamelCase.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard object's metadata.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata *LogstashSpecVolumeClaimTemplatesMetadata `pulumi:"metadata"`
	// spec defines the desired characteristics of a volume requested by a pod author.
	// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
	Spec *LogstashSpecVolumeClaimTemplatesSpec `pulumi:"spec"`
	// status represents the current information/status of a persistent volume claim.
	// Read-only.
	// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
	Status *LogstashSpecVolumeClaimTemplatesStatus `pulumi:"status"`
}

// LogstashSpecVolumeClaimTemplatesInput is an input type that accepts LogstashSpecVolumeClaimTemplatesArgs and LogstashSpecVolumeClaimTemplatesOutput values.
// You can construct a concrete instance of `LogstashSpecVolumeClaimTemplatesInput` via:
//
//	LogstashSpecVolumeClaimTemplatesArgs{...}
type LogstashSpecVolumeClaimTemplatesInput interface {
	pulumi.Input

	ToLogstashSpecVolumeClaimTemplatesOutput() LogstashSpecVolumeClaimTemplatesOutput
	ToLogstashSpecVolumeClaimTemplatesOutputWithContext(context.Context) LogstashSpecVolumeClaimTemplatesOutput
}

// PersistentVolumeClaim is a user's request for and claim to a persistent volume
type LogstashSpecVolumeClaimTemplatesArgs struct {
	// APIVersion defines the versioned schema of this representation of an object.
	// Servers should convert recognized schemas to the latest internal value, and
	// may reject unrecognized values.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents.
	// Servers may infer this from the endpoint the client submits requests to.
	// Cannot be updated.
	// In CamelCase.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard object's metadata.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata LogstashSpecVolumeClaimTemplatesMetadataPtrInput `pulumi:"metadata"`
	// spec defines the desired characteristics of a volume requested by a pod author.
	// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
	Spec LogstashSpecVolumeClaimTemplatesSpecPtrInput `pulumi:"spec"`
	// status represents the current information/status of a persistent volume claim.
	// Read-only.
	// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
	Status LogstashSpecVolumeClaimTemplatesStatusPtrInput `pulumi:"status"`
}

func (LogstashSpecVolumeClaimTemplatesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecVolumeClaimTemplates)(nil)).Elem()
}

func (i LogstashSpecVolumeClaimTemplatesArgs) ToLogstashSpecVolumeClaimTemplatesOutput() LogstashSpecVolumeClaimTemplatesOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesOutputWithContext(context.Background())
}

func (i LogstashSpecVolumeClaimTemplatesArgs) ToLogstashSpecVolumeClaimTemplatesOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesOutput)
}

// LogstashSpecVolumeClaimTemplatesArrayInput is an input type that accepts LogstashSpecVolumeClaimTemplatesArray and LogstashSpecVolumeClaimTemplatesArrayOutput values.
// You can construct a concrete instance of `LogstashSpecVolumeClaimTemplatesArrayInput` via:
//
//	LogstashSpecVolumeClaimTemplatesArray{ LogstashSpecVolumeClaimTemplatesArgs{...} }
type LogstashSpecVolumeClaimTemplatesArrayInput interface {
	pulumi.Input

	ToLogstashSpecVolumeClaimTemplatesArrayOutput() LogstashSpecVolumeClaimTemplatesArrayOutput
	ToLogstashSpecVolumeClaimTemplatesArrayOutputWithContext(context.Context) LogstashSpecVolumeClaimTemplatesArrayOutput
}

type LogstashSpecVolumeClaimTemplatesArray []LogstashSpecVolumeClaimTemplatesInput

func (LogstashSpecVolumeClaimTemplatesArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LogstashSpecVolumeClaimTemplates)(nil)).Elem()
}

func (i LogstashSpecVolumeClaimTemplatesArray) ToLogstashSpecVolumeClaimTemplatesArrayOutput() LogstashSpecVolumeClaimTemplatesArrayOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesArrayOutputWithContext(context.Background())
}

func (i LogstashSpecVolumeClaimTemplatesArray) ToLogstashSpecVolumeClaimTemplatesArrayOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesArrayOutput)
}

// PersistentVolumeClaim is a user's request for and claim to a persistent volume
type LogstashSpecVolumeClaimTemplatesOutput struct{ *pulumi.OutputState }

func (LogstashSpecVolumeClaimTemplatesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecVolumeClaimTemplates)(nil)).Elem()
}

func (o LogstashSpecVolumeClaimTemplatesOutput) ToLogstashSpecVolumeClaimTemplatesOutput() LogstashSpecVolumeClaimTemplatesOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesOutput) ToLogstashSpecVolumeClaimTemplatesOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object.
// Servers should convert recognized schemas to the latest internal value, and
// may reject unrecognized values.
// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o LogstashSpecVolumeClaimTemplatesOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplates) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents.
// Servers may infer this from the endpoint the client submits requests to.
// Cannot be updated.
// In CamelCase.
// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o LogstashSpecVolumeClaimTemplatesOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplates) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard object's metadata.
// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
func (o LogstashSpecVolumeClaimTemplatesOutput) Metadata() LogstashSpecVolumeClaimTemplatesMetadataPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplates) *LogstashSpecVolumeClaimTemplatesMetadata { return v.Metadata }).(LogstashSpecVolumeClaimTemplatesMetadataPtrOutput)
}

// spec defines the desired characteristics of a volume requested by a pod author.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
func (o LogstashSpecVolumeClaimTemplatesOutput) Spec() LogstashSpecVolumeClaimTemplatesSpecPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplates) *LogstashSpecVolumeClaimTemplatesSpec { return v.Spec }).(LogstashSpecVolumeClaimTemplatesSpecPtrOutput)
}

// status represents the current information/status of a persistent volume claim.
// Read-only.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
func (o LogstashSpecVolumeClaimTemplatesOutput) Status() LogstashSpecVolumeClaimTemplatesStatusPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplates) *LogstashSpecVolumeClaimTemplatesStatus { return v.Status }).(LogstashSpecVolumeClaimTemplatesStatusPtrOutput)
}

type LogstashSpecVolumeClaimTemplatesArrayOutput struct{ *pulumi.OutputState }

func (LogstashSpecVolumeClaimTemplatesArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LogstashSpecVolumeClaimTemplates)(nil)).Elem()
}

func (o LogstashSpecVolumeClaimTemplatesArrayOutput) ToLogstashSpecVolumeClaimTemplatesArrayOutput() LogstashSpecVolumeClaimTemplatesArrayOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesArrayOutput) ToLogstashSpecVolumeClaimTemplatesArrayOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesArrayOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesArrayOutput) Index(i pulumi.IntInput) LogstashSpecVolumeClaimTemplatesOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LogstashSpecVolumeClaimTemplates {
		return vs[0].([]LogstashSpecVolumeClaimTemplates)[vs[1].(int)]
	}).(LogstashSpecVolumeClaimTemplatesOutput)
}

// Standard object's metadata.
// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
type LogstashSpecVolumeClaimTemplatesMetadata struct {
	Annotations map[string]string `pulumi:"annotations"`
	Finalizers  []string          `pulumi:"finalizers"`
	Labels      map[string]string `pulumi:"labels"`
	Name        *string           `pulumi:"name"`
	Namespace   *string           `pulumi:"namespace"`
}

// LogstashSpecVolumeClaimTemplatesMetadataInput is an input type that accepts LogstashSpecVolumeClaimTemplatesMetadataArgs and LogstashSpecVolumeClaimTemplatesMetadataOutput values.
// You can construct a concrete instance of `LogstashSpecVolumeClaimTemplatesMetadataInput` via:
//
//	LogstashSpecVolumeClaimTemplatesMetadataArgs{...}
type LogstashSpecVolumeClaimTemplatesMetadataInput interface {
	pulumi.Input

	ToLogstashSpecVolumeClaimTemplatesMetadataOutput() LogstashSpecVolumeClaimTemplatesMetadataOutput
	ToLogstashSpecVolumeClaimTemplatesMetadataOutputWithContext(context.Context) LogstashSpecVolumeClaimTemplatesMetadataOutput
}

// Standard object's metadata.
// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
type LogstashSpecVolumeClaimTemplatesMetadataArgs struct {
	Annotations pulumi.StringMapInput   `pulumi:"annotations"`
	Finalizers  pulumi.StringArrayInput `pulumi:"finalizers"`
	Labels      pulumi.StringMapInput   `pulumi:"labels"`
	Name        pulumi.StringPtrInput   `pulumi:"name"`
	Namespace   pulumi.StringPtrInput   `pulumi:"namespace"`
}

func (LogstashSpecVolumeClaimTemplatesMetadataArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesMetadata)(nil)).Elem()
}

func (i LogstashSpecVolumeClaimTemplatesMetadataArgs) ToLogstashSpecVolumeClaimTemplatesMetadataOutput() LogstashSpecVolumeClaimTemplatesMetadataOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesMetadataOutputWithContext(context.Background())
}

func (i LogstashSpecVolumeClaimTemplatesMetadataArgs) ToLogstashSpecVolumeClaimTemplatesMetadataOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesMetadataOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesMetadataOutput)
}

func (i LogstashSpecVolumeClaimTemplatesMetadataArgs) ToLogstashSpecVolumeClaimTemplatesMetadataPtrOutput() LogstashSpecVolumeClaimTemplatesMetadataPtrOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesMetadataPtrOutputWithContext(context.Background())
}

func (i LogstashSpecVolumeClaimTemplatesMetadataArgs) ToLogstashSpecVolumeClaimTemplatesMetadataPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesMetadataPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesMetadataOutput).ToLogstashSpecVolumeClaimTemplatesMetadataPtrOutputWithContext(ctx)
}

// LogstashSpecVolumeClaimTemplatesMetadataPtrInput is an input type that accepts LogstashSpecVolumeClaimTemplatesMetadataArgs, LogstashSpecVolumeClaimTemplatesMetadataPtr and LogstashSpecVolumeClaimTemplatesMetadataPtrOutput values.
// You can construct a concrete instance of `LogstashSpecVolumeClaimTemplatesMetadataPtrInput` via:
//
//	        LogstashSpecVolumeClaimTemplatesMetadataArgs{...}
//
//	or:
//
//	        nil
type LogstashSpecVolumeClaimTemplatesMetadataPtrInput interface {
	pulumi.Input

	ToLogstashSpecVolumeClaimTemplatesMetadataPtrOutput() LogstashSpecVolumeClaimTemplatesMetadataPtrOutput
	ToLogstashSpecVolumeClaimTemplatesMetadataPtrOutputWithContext(context.Context) LogstashSpecVolumeClaimTemplatesMetadataPtrOutput
}

type logstashSpecVolumeClaimTemplatesMetadataPtrType LogstashSpecVolumeClaimTemplatesMetadataArgs

func LogstashSpecVolumeClaimTemplatesMetadataPtr(v *LogstashSpecVolumeClaimTemplatesMetadataArgs) LogstashSpecVolumeClaimTemplatesMetadataPtrInput {
	return (*logstashSpecVolumeClaimTemplatesMetadataPtrType)(v)
}

func (*logstashSpecVolumeClaimTemplatesMetadataPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecVolumeClaimTemplatesMetadata)(nil)).Elem()
}

func (i *logstashSpecVolumeClaimTemplatesMetadataPtrType) ToLogstashSpecVolumeClaimTemplatesMetadataPtrOutput() LogstashSpecVolumeClaimTemplatesMetadataPtrOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesMetadataPtrOutputWithContext(context.Background())
}

func (i *logstashSpecVolumeClaimTemplatesMetadataPtrType) ToLogstashSpecVolumeClaimTemplatesMetadataPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesMetadataPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesMetadataPtrOutput)
}

// Standard object's metadata.
// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
type LogstashSpecVolumeClaimTemplatesMetadataOutput struct{ *pulumi.OutputState }

func (LogstashSpecVolumeClaimTemplatesMetadataOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesMetadata)(nil)).Elem()
}

func (o LogstashSpecVolumeClaimTemplatesMetadataOutput) ToLogstashSpecVolumeClaimTemplatesMetadataOutput() LogstashSpecVolumeClaimTemplatesMetadataOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesMetadataOutput) ToLogstashSpecVolumeClaimTemplatesMetadataOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesMetadataOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesMetadataOutput) ToLogstashSpecVolumeClaimTemplatesMetadataPtrOutput() LogstashSpecVolumeClaimTemplatesMetadataPtrOutput {
	return o.ToLogstashSpecVolumeClaimTemplatesMetadataPtrOutputWithContext(context.Background())
}

func (o LogstashSpecVolumeClaimTemplatesMetadataOutput) ToLogstashSpecVolumeClaimTemplatesMetadataPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesMetadataPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LogstashSpecVolumeClaimTemplatesMetadata) *LogstashSpecVolumeClaimTemplatesMetadata {
		return &v
	}).(LogstashSpecVolumeClaimTemplatesMetadataPtrOutput)
}

func (o LogstashSpecVolumeClaimTemplatesMetadataOutput) Annotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesMetadata) map[string]string { return v.Annotations }).(pulumi.StringMapOutput)
}

func (o LogstashSpecVolumeClaimTemplatesMetadataOutput) Finalizers() pulumi.StringArrayOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesMetadata) []string { return v.Finalizers }).(pulumi.StringArrayOutput)
}

func (o LogstashSpecVolumeClaimTemplatesMetadataOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesMetadata) map[string]string { return v.Labels }).(pulumi.StringMapOutput)
}

func (o LogstashSpecVolumeClaimTemplatesMetadataOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesMetadata) *string { return v.Name }).(pulumi.StringPtrOutput)
}

func (o LogstashSpecVolumeClaimTemplatesMetadataOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesMetadata) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

type LogstashSpecVolumeClaimTemplatesMetadataPtrOutput struct{ *pulumi.OutputState }

func (LogstashSpecVolumeClaimTemplatesMetadataPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecVolumeClaimTemplatesMetadata)(nil)).Elem()
}

func (o LogstashSpecVolumeClaimTemplatesMetadataPtrOutput) ToLogstashSpecVolumeClaimTemplatesMetadataPtrOutput() LogstashSpecVolumeClaimTemplatesMetadataPtrOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesMetadataPtrOutput) ToLogstashSpecVolumeClaimTemplatesMetadataPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesMetadataPtrOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesMetadataPtrOutput) Elem() LogstashSpecVolumeClaimTemplatesMetadataOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesMetadata) LogstashSpecVolumeClaimTemplatesMetadata {
		if v != nil {
			return *v
		}
		var ret LogstashSpecVolumeClaimTemplatesMetadata
		return ret
	}).(LogstashSpecVolumeClaimTemplatesMetadataOutput)
}

func (o LogstashSpecVolumeClaimTemplatesMetadataPtrOutput) Annotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesMetadata) map[string]string {
		if v == nil {
			return nil
		}
		return v.Annotations
	}).(pulumi.StringMapOutput)
}

func (o LogstashSpecVolumeClaimTemplatesMetadataPtrOutput) Finalizers() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesMetadata) []string {
		if v == nil {
			return nil
		}
		return v.Finalizers
	}).(pulumi.StringArrayOutput)
}

func (o LogstashSpecVolumeClaimTemplatesMetadataPtrOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesMetadata) map[string]string {
		if v == nil {
			return nil
		}
		return v.Labels
	}).(pulumi.StringMapOutput)
}

func (o LogstashSpecVolumeClaimTemplatesMetadataPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesMetadata) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

func (o LogstashSpecVolumeClaimTemplatesMetadataPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesMetadata) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

type LogstashSpecVolumeClaimTemplatesMetadataAnnotations struct {
}

type LogstashSpecVolumeClaimTemplatesMetadataLabels struct {
}

// spec defines the desired characteristics of a volume requested by a pod author.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
type LogstashSpecVolumeClaimTemplatesSpec struct {
	// accessModes contains the desired access modes the volume should have.
	// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
	AccessModes []string `pulumi:"accessModes"`
	// dataSource field can be used to specify either:
	// * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
	// * An existing PVC (PersistentVolumeClaim)
	//   If the provisioner or an external controller can support the specified data source,
	//   it will create a new volume based on the contents of the specified data source.
	//   When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
	//   and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
	//   If the namespace is specified, then dataSourceRef will not be copied to dataSource.
	DataSource *LogstashSpecVolumeClaimTemplatesSpecDataSource `pulumi:"dataSource"`
	// dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
	// volume is desired. This may be any object from a non-empty API group (non
	// core object) or a PersistentVolumeClaim object.
	// When this field is specified, volume binding will only succeed if the type of
	// the specified object matches some installed volume populator or dynamic
	// provisioner.
	// This field will replace the functionality of the dataSource field and as such
	// if both fields are non-empty, they must have the same value. For backwards
	// compatibility, when namespace isn't specified in dataSourceRef,
	// both fields (dataSource and dataSourceRef) will be set to the same
	// value automatically if one of them is empty and the other is non-empty.
	// When namespace is specified in dataSourceRef,
	// dataSource isn't set to the same value and must be empty.
	// There are three important differences between dataSource and dataSourceRef:
	// * While dataSource only allows two specific types of objects, dataSourceRef
	//   allows any non-core object, as well as PersistentVolumeClaim objects.
	// * While dataSource ignores disallowed values (dropping them), dataSourceRef
	//   preserves all values, and generates an error if a disallowed value is
	//   specified.
	// * While dataSource only allows local objects, dataSourceRef allows objects
	//   in any namespaces.
	//   (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
	//   (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
	DataSourceRef *LogstashSpecVolumeClaimTemplatesSpecDataSourceRef `pulumi:"dataSourceRef"`
	// resources represents the minimum resources the volume should have.
	// If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
	// that are lower than previous value but must still be higher than capacity recorded in the
	// status field of the claim.
	// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
	Resources *LogstashSpecVolumeClaimTemplatesSpecResources `pulumi:"resources"`
	// selector is a label query over volumes to consider for binding.
	Selector *LogstashSpecVolumeClaimTemplatesSpecSelector `pulumi:"selector"`
	// storageClassName is the name of the StorageClass required by the claim.
	// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
	StorageClassName *string `pulumi:"storageClassName"`
	// volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
	// If specified, the CSI driver will create or update the volume with the attributes defined
	// in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
	// it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass
	// will be applied to the claim but it's not allowed to reset this field to empty string once it is set.
	// If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass
	// will be set by the persistentvolume controller if it exists.
	// If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
	// set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
	// exists.
	// More info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/
	// (Alpha) Using this field requires the VolumeAttributesClass feature gate to be enabled.
	VolumeAttributesClassName *string `pulumi:"volumeAttributesClassName"`
	// volumeMode defines what type of volume is required by the claim.
	// Value of Filesystem is implied when not included in claim spec.
	VolumeMode *string `pulumi:"volumeMode"`
	// volumeName is the binding reference to the PersistentVolume backing this claim.
	VolumeName *string `pulumi:"volumeName"`
}

// LogstashSpecVolumeClaimTemplatesSpecInput is an input type that accepts LogstashSpecVolumeClaimTemplatesSpecArgs and LogstashSpecVolumeClaimTemplatesSpecOutput values.
// You can construct a concrete instance of `LogstashSpecVolumeClaimTemplatesSpecInput` via:
//
//	LogstashSpecVolumeClaimTemplatesSpecArgs{...}
type LogstashSpecVolumeClaimTemplatesSpecInput interface {
	pulumi.Input

	ToLogstashSpecVolumeClaimTemplatesSpecOutput() LogstashSpecVolumeClaimTemplatesSpecOutput
	ToLogstashSpecVolumeClaimTemplatesSpecOutputWithContext(context.Context) LogstashSpecVolumeClaimTemplatesSpecOutput
}

// spec defines the desired characteristics of a volume requested by a pod author.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
type LogstashSpecVolumeClaimTemplatesSpecArgs struct {
	// accessModes contains the desired access modes the volume should have.
	// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
	AccessModes pulumi.StringArrayInput `pulumi:"accessModes"`
	// dataSource field can be used to specify either:
	// * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
	// * An existing PVC (PersistentVolumeClaim)
	//   If the provisioner or an external controller can support the specified data source,
	//   it will create a new volume based on the contents of the specified data source.
	//   When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
	//   and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
	//   If the namespace is specified, then dataSourceRef will not be copied to dataSource.
	DataSource LogstashSpecVolumeClaimTemplatesSpecDataSourcePtrInput `pulumi:"dataSource"`
	// dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
	// volume is desired. This may be any object from a non-empty API group (non
	// core object) or a PersistentVolumeClaim object.
	// When this field is specified, volume binding will only succeed if the type of
	// the specified object matches some installed volume populator or dynamic
	// provisioner.
	// This field will replace the functionality of the dataSource field and as such
	// if both fields are non-empty, they must have the same value. For backwards
	// compatibility, when namespace isn't specified in dataSourceRef,
	// both fields (dataSource and dataSourceRef) will be set to the same
	// value automatically if one of them is empty and the other is non-empty.
	// When namespace is specified in dataSourceRef,
	// dataSource isn't set to the same value and must be empty.
	// There are three important differences between dataSource and dataSourceRef:
	// * While dataSource only allows two specific types of objects, dataSourceRef
	//   allows any non-core object, as well as PersistentVolumeClaim objects.
	// * While dataSource ignores disallowed values (dropping them), dataSourceRef
	//   preserves all values, and generates an error if a disallowed value is
	//   specified.
	// * While dataSource only allows local objects, dataSourceRef allows objects
	//   in any namespaces.
	//   (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
	//   (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
	DataSourceRef LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrInput `pulumi:"dataSourceRef"`
	// resources represents the minimum resources the volume should have.
	// If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
	// that are lower than previous value but must still be higher than capacity recorded in the
	// status field of the claim.
	// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
	Resources LogstashSpecVolumeClaimTemplatesSpecResourcesPtrInput `pulumi:"resources"`
	// selector is a label query over volumes to consider for binding.
	Selector LogstashSpecVolumeClaimTemplatesSpecSelectorPtrInput `pulumi:"selector"`
	// storageClassName is the name of the StorageClass required by the claim.
	// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
	StorageClassName pulumi.StringPtrInput `pulumi:"storageClassName"`
	// volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
	// If specified, the CSI driver will create or update the volume with the attributes defined
	// in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
	// it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass
	// will be applied to the claim but it's not allowed to reset this field to empty string once it is set.
	// If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass
	// will be set by the persistentvolume controller if it exists.
	// If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
	// set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
	// exists.
	// More info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/
	// (Alpha) Using this field requires the VolumeAttributesClass feature gate to be enabled.
	VolumeAttributesClassName pulumi.StringPtrInput `pulumi:"volumeAttributesClassName"`
	// volumeMode defines what type of volume is required by the claim.
	// Value of Filesystem is implied when not included in claim spec.
	VolumeMode pulumi.StringPtrInput `pulumi:"volumeMode"`
	// volumeName is the binding reference to the PersistentVolume backing this claim.
	VolumeName pulumi.StringPtrInput `pulumi:"volumeName"`
}

func (LogstashSpecVolumeClaimTemplatesSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesSpec)(nil)).Elem()
}

func (i LogstashSpecVolumeClaimTemplatesSpecArgs) ToLogstashSpecVolumeClaimTemplatesSpecOutput() LogstashSpecVolumeClaimTemplatesSpecOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesSpecOutputWithContext(context.Background())
}

func (i LogstashSpecVolumeClaimTemplatesSpecArgs) ToLogstashSpecVolumeClaimTemplatesSpecOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesSpecOutput)
}

func (i LogstashSpecVolumeClaimTemplatesSpecArgs) ToLogstashSpecVolumeClaimTemplatesSpecPtrOutput() LogstashSpecVolumeClaimTemplatesSpecPtrOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesSpecPtrOutputWithContext(context.Background())
}

func (i LogstashSpecVolumeClaimTemplatesSpecArgs) ToLogstashSpecVolumeClaimTemplatesSpecPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesSpecOutput).ToLogstashSpecVolumeClaimTemplatesSpecPtrOutputWithContext(ctx)
}

// LogstashSpecVolumeClaimTemplatesSpecPtrInput is an input type that accepts LogstashSpecVolumeClaimTemplatesSpecArgs, LogstashSpecVolumeClaimTemplatesSpecPtr and LogstashSpecVolumeClaimTemplatesSpecPtrOutput values.
// You can construct a concrete instance of `LogstashSpecVolumeClaimTemplatesSpecPtrInput` via:
//
//	        LogstashSpecVolumeClaimTemplatesSpecArgs{...}
//
//	or:
//
//	        nil
type LogstashSpecVolumeClaimTemplatesSpecPtrInput interface {
	pulumi.Input

	ToLogstashSpecVolumeClaimTemplatesSpecPtrOutput() LogstashSpecVolumeClaimTemplatesSpecPtrOutput
	ToLogstashSpecVolumeClaimTemplatesSpecPtrOutputWithContext(context.Context) LogstashSpecVolumeClaimTemplatesSpecPtrOutput
}

type logstashSpecVolumeClaimTemplatesSpecPtrType LogstashSpecVolumeClaimTemplatesSpecArgs

func LogstashSpecVolumeClaimTemplatesSpecPtr(v *LogstashSpecVolumeClaimTemplatesSpecArgs) LogstashSpecVolumeClaimTemplatesSpecPtrInput {
	return (*logstashSpecVolumeClaimTemplatesSpecPtrType)(v)
}

func (*logstashSpecVolumeClaimTemplatesSpecPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecVolumeClaimTemplatesSpec)(nil)).Elem()
}

func (i *logstashSpecVolumeClaimTemplatesSpecPtrType) ToLogstashSpecVolumeClaimTemplatesSpecPtrOutput() LogstashSpecVolumeClaimTemplatesSpecPtrOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesSpecPtrOutputWithContext(context.Background())
}

func (i *logstashSpecVolumeClaimTemplatesSpecPtrType) ToLogstashSpecVolumeClaimTemplatesSpecPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesSpecPtrOutput)
}

// spec defines the desired characteristics of a volume requested by a pod author.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
type LogstashSpecVolumeClaimTemplatesSpecOutput struct{ *pulumi.OutputState }

func (LogstashSpecVolumeClaimTemplatesSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesSpec)(nil)).Elem()
}

func (o LogstashSpecVolumeClaimTemplatesSpecOutput) ToLogstashSpecVolumeClaimTemplatesSpecOutput() LogstashSpecVolumeClaimTemplatesSpecOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesSpecOutput) ToLogstashSpecVolumeClaimTemplatesSpecOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesSpecOutput) ToLogstashSpecVolumeClaimTemplatesSpecPtrOutput() LogstashSpecVolumeClaimTemplatesSpecPtrOutput {
	return o.ToLogstashSpecVolumeClaimTemplatesSpecPtrOutputWithContext(context.Background())
}

func (o LogstashSpecVolumeClaimTemplatesSpecOutput) ToLogstashSpecVolumeClaimTemplatesSpecPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LogstashSpecVolumeClaimTemplatesSpec) *LogstashSpecVolumeClaimTemplatesSpec {
		return &v
	}).(LogstashSpecVolumeClaimTemplatesSpecPtrOutput)
}

// accessModes contains the desired access modes the volume should have.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
func (o LogstashSpecVolumeClaimTemplatesSpecOutput) AccessModes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesSpec) []string { return v.AccessModes }).(pulumi.StringArrayOutput)
}

// dataSource field can be used to specify either:
//   - An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
//   - An existing PVC (PersistentVolumeClaim)
//     If the provisioner or an external controller can support the specified data source,
//     it will create a new volume based on the contents of the specified data source.
//     When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
//     and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
//     If the namespace is specified, then dataSourceRef will not be copied to dataSource.
func (o LogstashSpecVolumeClaimTemplatesSpecOutput) DataSource() LogstashSpecVolumeClaimTemplatesSpecDataSourcePtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesSpec) *LogstashSpecVolumeClaimTemplatesSpecDataSource {
		return v.DataSource
	}).(LogstashSpecVolumeClaimTemplatesSpecDataSourcePtrOutput)
}

// dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
// volume is desired. This may be any object from a non-empty API group (non
// core object) or a PersistentVolumeClaim object.
// When this field is specified, volume binding will only succeed if the type of
// the specified object matches some installed volume populator or dynamic
// provisioner.
// This field will replace the functionality of the dataSource field and as such
// if both fields are non-empty, they must have the same value. For backwards
// compatibility, when namespace isn't specified in dataSourceRef,
// both fields (dataSource and dataSourceRef) will be set to the same
// value automatically if one of them is empty and the other is non-empty.
// When namespace is specified in dataSourceRef,
// dataSource isn't set to the same value and must be empty.
// There are three important differences between dataSource and dataSourceRef:
//   - While dataSource only allows two specific types of objects, dataSourceRef
//     allows any non-core object, as well as PersistentVolumeClaim objects.
//   - While dataSource ignores disallowed values (dropping them), dataSourceRef
//     preserves all values, and generates an error if a disallowed value is
//     specified.
//   - While dataSource only allows local objects, dataSourceRef allows objects
//     in any namespaces.
//     (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
//     (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
func (o LogstashSpecVolumeClaimTemplatesSpecOutput) DataSourceRef() LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesSpec) *LogstashSpecVolumeClaimTemplatesSpecDataSourceRef {
		return v.DataSourceRef
	}).(LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutput)
}

// resources represents the minimum resources the volume should have.
// If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
// that are lower than previous value but must still be higher than capacity recorded in the
// status field of the claim.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
func (o LogstashSpecVolumeClaimTemplatesSpecOutput) Resources() LogstashSpecVolumeClaimTemplatesSpecResourcesPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesSpec) *LogstashSpecVolumeClaimTemplatesSpecResources {
		return v.Resources
	}).(LogstashSpecVolumeClaimTemplatesSpecResourcesPtrOutput)
}

// selector is a label query over volumes to consider for binding.
func (o LogstashSpecVolumeClaimTemplatesSpecOutput) Selector() LogstashSpecVolumeClaimTemplatesSpecSelectorPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesSpec) *LogstashSpecVolumeClaimTemplatesSpecSelector {
		return v.Selector
	}).(LogstashSpecVolumeClaimTemplatesSpecSelectorPtrOutput)
}

// storageClassName is the name of the StorageClass required by the claim.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
func (o LogstashSpecVolumeClaimTemplatesSpecOutput) StorageClassName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesSpec) *string { return v.StorageClassName }).(pulumi.StringPtrOutput)
}

// volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
// If specified, the CSI driver will create or update the volume with the attributes defined
// in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
// it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass
// will be applied to the claim but it's not allowed to reset this field to empty string once it is set.
// If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass
// will be set by the persistentvolume controller if it exists.
// If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
// set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
// exists.
// More info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/
// (Alpha) Using this field requires the VolumeAttributesClass feature gate to be enabled.
func (o LogstashSpecVolumeClaimTemplatesSpecOutput) VolumeAttributesClassName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesSpec) *string { return v.VolumeAttributesClassName }).(pulumi.StringPtrOutput)
}

// volumeMode defines what type of volume is required by the claim.
// Value of Filesystem is implied when not included in claim spec.
func (o LogstashSpecVolumeClaimTemplatesSpecOutput) VolumeMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesSpec) *string { return v.VolumeMode }).(pulumi.StringPtrOutput)
}

// volumeName is the binding reference to the PersistentVolume backing this claim.
func (o LogstashSpecVolumeClaimTemplatesSpecOutput) VolumeName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesSpec) *string { return v.VolumeName }).(pulumi.StringPtrOutput)
}

type LogstashSpecVolumeClaimTemplatesSpecPtrOutput struct{ *pulumi.OutputState }

func (LogstashSpecVolumeClaimTemplatesSpecPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecVolumeClaimTemplatesSpec)(nil)).Elem()
}

func (o LogstashSpecVolumeClaimTemplatesSpecPtrOutput) ToLogstashSpecVolumeClaimTemplatesSpecPtrOutput() LogstashSpecVolumeClaimTemplatesSpecPtrOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesSpecPtrOutput) ToLogstashSpecVolumeClaimTemplatesSpecPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecPtrOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesSpecPtrOutput) Elem() LogstashSpecVolumeClaimTemplatesSpecOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesSpec) LogstashSpecVolumeClaimTemplatesSpec {
		if v != nil {
			return *v
		}
		var ret LogstashSpecVolumeClaimTemplatesSpec
		return ret
	}).(LogstashSpecVolumeClaimTemplatesSpecOutput)
}

// accessModes contains the desired access modes the volume should have.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
func (o LogstashSpecVolumeClaimTemplatesSpecPtrOutput) AccessModes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesSpec) []string {
		if v == nil {
			return nil
		}
		return v.AccessModes
	}).(pulumi.StringArrayOutput)
}

// dataSource field can be used to specify either:
//   - An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
//   - An existing PVC (PersistentVolumeClaim)
//     If the provisioner or an external controller can support the specified data source,
//     it will create a new volume based on the contents of the specified data source.
//     When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
//     and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
//     If the namespace is specified, then dataSourceRef will not be copied to dataSource.
func (o LogstashSpecVolumeClaimTemplatesSpecPtrOutput) DataSource() LogstashSpecVolumeClaimTemplatesSpecDataSourcePtrOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesSpec) *LogstashSpecVolumeClaimTemplatesSpecDataSource {
		if v == nil {
			return nil
		}
		return v.DataSource
	}).(LogstashSpecVolumeClaimTemplatesSpecDataSourcePtrOutput)
}

// dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
// volume is desired. This may be any object from a non-empty API group (non
// core object) or a PersistentVolumeClaim object.
// When this field is specified, volume binding will only succeed if the type of
// the specified object matches some installed volume populator or dynamic
// provisioner.
// This field will replace the functionality of the dataSource field and as such
// if both fields are non-empty, they must have the same value. For backwards
// compatibility, when namespace isn't specified in dataSourceRef,
// both fields (dataSource and dataSourceRef) will be set to the same
// value automatically if one of them is empty and the other is non-empty.
// When namespace is specified in dataSourceRef,
// dataSource isn't set to the same value and must be empty.
// There are three important differences between dataSource and dataSourceRef:
//   - While dataSource only allows two specific types of objects, dataSourceRef
//     allows any non-core object, as well as PersistentVolumeClaim objects.
//   - While dataSource ignores disallowed values (dropping them), dataSourceRef
//     preserves all values, and generates an error if a disallowed value is
//     specified.
//   - While dataSource only allows local objects, dataSourceRef allows objects
//     in any namespaces.
//     (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
//     (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
func (o LogstashSpecVolumeClaimTemplatesSpecPtrOutput) DataSourceRef() LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesSpec) *LogstashSpecVolumeClaimTemplatesSpecDataSourceRef {
		if v == nil {
			return nil
		}
		return v.DataSourceRef
	}).(LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutput)
}

// resources represents the minimum resources the volume should have.
// If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
// that are lower than previous value but must still be higher than capacity recorded in the
// status field of the claim.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
func (o LogstashSpecVolumeClaimTemplatesSpecPtrOutput) Resources() LogstashSpecVolumeClaimTemplatesSpecResourcesPtrOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesSpec) *LogstashSpecVolumeClaimTemplatesSpecResources {
		if v == nil {
			return nil
		}
		return v.Resources
	}).(LogstashSpecVolumeClaimTemplatesSpecResourcesPtrOutput)
}

// selector is a label query over volumes to consider for binding.
func (o LogstashSpecVolumeClaimTemplatesSpecPtrOutput) Selector() LogstashSpecVolumeClaimTemplatesSpecSelectorPtrOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesSpec) *LogstashSpecVolumeClaimTemplatesSpecSelector {
		if v == nil {
			return nil
		}
		return v.Selector
	}).(LogstashSpecVolumeClaimTemplatesSpecSelectorPtrOutput)
}

// storageClassName is the name of the StorageClass required by the claim.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
func (o LogstashSpecVolumeClaimTemplatesSpecPtrOutput) StorageClassName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesSpec) *string {
		if v == nil {
			return nil
		}
		return v.StorageClassName
	}).(pulumi.StringPtrOutput)
}

// volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
// If specified, the CSI driver will create or update the volume with the attributes defined
// in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
// it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass
// will be applied to the claim but it's not allowed to reset this field to empty string once it is set.
// If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass
// will be set by the persistentvolume controller if it exists.
// If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
// set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
// exists.
// More info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/
// (Alpha) Using this field requires the VolumeAttributesClass feature gate to be enabled.
func (o LogstashSpecVolumeClaimTemplatesSpecPtrOutput) VolumeAttributesClassName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesSpec) *string {
		if v == nil {
			return nil
		}
		return v.VolumeAttributesClassName
	}).(pulumi.StringPtrOutput)
}

// volumeMode defines what type of volume is required by the claim.
// Value of Filesystem is implied when not included in claim spec.
func (o LogstashSpecVolumeClaimTemplatesSpecPtrOutput) VolumeMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesSpec) *string {
		if v == nil {
			return nil
		}
		return v.VolumeMode
	}).(pulumi.StringPtrOutput)
}

// volumeName is the binding reference to the PersistentVolume backing this claim.
func (o LogstashSpecVolumeClaimTemplatesSpecPtrOutput) VolumeName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesSpec) *string {
		if v == nil {
			return nil
		}
		return v.VolumeName
	}).(pulumi.StringPtrOutput)
}

// dataSource field can be used to specify either:
//   - An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
//   - An existing PVC (PersistentVolumeClaim)
//     If the provisioner or an external controller can support the specified data source,
//     it will create a new volume based on the contents of the specified data source.
//     When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
//     and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
//     If the namespace is specified, then dataSourceRef will not be copied to dataSource.
type LogstashSpecVolumeClaimTemplatesSpecDataSource struct {
	// APIGroup is the group for the resource being referenced.
	// If APIGroup is not specified, the specified Kind must be in the core API group.
	// For any other third-party types, APIGroup is required.
	ApiGroup *string `pulumi:"apiGroup"`
	// Kind is the type of resource being referenced
	Kind string `pulumi:"kind"`
	// Name is the name of resource being referenced
	Name string `pulumi:"name"`
}

// LogstashSpecVolumeClaimTemplatesSpecDataSourceInput is an input type that accepts LogstashSpecVolumeClaimTemplatesSpecDataSourceArgs and LogstashSpecVolumeClaimTemplatesSpecDataSourceOutput values.
// You can construct a concrete instance of `LogstashSpecVolumeClaimTemplatesSpecDataSourceInput` via:
//
//	LogstashSpecVolumeClaimTemplatesSpecDataSourceArgs{...}
type LogstashSpecVolumeClaimTemplatesSpecDataSourceInput interface {
	pulumi.Input

	ToLogstashSpecVolumeClaimTemplatesSpecDataSourceOutput() LogstashSpecVolumeClaimTemplatesSpecDataSourceOutput
	ToLogstashSpecVolumeClaimTemplatesSpecDataSourceOutputWithContext(context.Context) LogstashSpecVolumeClaimTemplatesSpecDataSourceOutput
}

// dataSource field can be used to specify either:
//   - An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
//   - An existing PVC (PersistentVolumeClaim)
//     If the provisioner or an external controller can support the specified data source,
//     it will create a new volume based on the contents of the specified data source.
//     When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
//     and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
//     If the namespace is specified, then dataSourceRef will not be copied to dataSource.
type LogstashSpecVolumeClaimTemplatesSpecDataSourceArgs struct {
	// APIGroup is the group for the resource being referenced.
	// If APIGroup is not specified, the specified Kind must be in the core API group.
	// For any other third-party types, APIGroup is required.
	ApiGroup pulumi.StringPtrInput `pulumi:"apiGroup"`
	// Kind is the type of resource being referenced
	Kind pulumi.StringInput `pulumi:"kind"`
	// Name is the name of resource being referenced
	Name pulumi.StringInput `pulumi:"name"`
}

func (LogstashSpecVolumeClaimTemplatesSpecDataSourceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesSpecDataSource)(nil)).Elem()
}

func (i LogstashSpecVolumeClaimTemplatesSpecDataSourceArgs) ToLogstashSpecVolumeClaimTemplatesSpecDataSourceOutput() LogstashSpecVolumeClaimTemplatesSpecDataSourceOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesSpecDataSourceOutputWithContext(context.Background())
}

func (i LogstashSpecVolumeClaimTemplatesSpecDataSourceArgs) ToLogstashSpecVolumeClaimTemplatesSpecDataSourceOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecDataSourceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesSpecDataSourceOutput)
}

func (i LogstashSpecVolumeClaimTemplatesSpecDataSourceArgs) ToLogstashSpecVolumeClaimTemplatesSpecDataSourcePtrOutput() LogstashSpecVolumeClaimTemplatesSpecDataSourcePtrOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesSpecDataSourcePtrOutputWithContext(context.Background())
}

func (i LogstashSpecVolumeClaimTemplatesSpecDataSourceArgs) ToLogstashSpecVolumeClaimTemplatesSpecDataSourcePtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecDataSourcePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesSpecDataSourceOutput).ToLogstashSpecVolumeClaimTemplatesSpecDataSourcePtrOutputWithContext(ctx)
}

// LogstashSpecVolumeClaimTemplatesSpecDataSourcePtrInput is an input type that accepts LogstashSpecVolumeClaimTemplatesSpecDataSourceArgs, LogstashSpecVolumeClaimTemplatesSpecDataSourcePtr and LogstashSpecVolumeClaimTemplatesSpecDataSourcePtrOutput values.
// You can construct a concrete instance of `LogstashSpecVolumeClaimTemplatesSpecDataSourcePtrInput` via:
//
//	        LogstashSpecVolumeClaimTemplatesSpecDataSourceArgs{...}
//
//	or:
//
//	        nil
type LogstashSpecVolumeClaimTemplatesSpecDataSourcePtrInput interface {
	pulumi.Input

	ToLogstashSpecVolumeClaimTemplatesSpecDataSourcePtrOutput() LogstashSpecVolumeClaimTemplatesSpecDataSourcePtrOutput
	ToLogstashSpecVolumeClaimTemplatesSpecDataSourcePtrOutputWithContext(context.Context) LogstashSpecVolumeClaimTemplatesSpecDataSourcePtrOutput
}

type logstashSpecVolumeClaimTemplatesSpecDataSourcePtrType LogstashSpecVolumeClaimTemplatesSpecDataSourceArgs

func LogstashSpecVolumeClaimTemplatesSpecDataSourcePtr(v *LogstashSpecVolumeClaimTemplatesSpecDataSourceArgs) LogstashSpecVolumeClaimTemplatesSpecDataSourcePtrInput {
	return (*logstashSpecVolumeClaimTemplatesSpecDataSourcePtrType)(v)
}

func (*logstashSpecVolumeClaimTemplatesSpecDataSourcePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecVolumeClaimTemplatesSpecDataSource)(nil)).Elem()
}

func (i *logstashSpecVolumeClaimTemplatesSpecDataSourcePtrType) ToLogstashSpecVolumeClaimTemplatesSpecDataSourcePtrOutput() LogstashSpecVolumeClaimTemplatesSpecDataSourcePtrOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesSpecDataSourcePtrOutputWithContext(context.Background())
}

func (i *logstashSpecVolumeClaimTemplatesSpecDataSourcePtrType) ToLogstashSpecVolumeClaimTemplatesSpecDataSourcePtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecDataSourcePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesSpecDataSourcePtrOutput)
}

// dataSource field can be used to specify either:
//   - An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
//   - An existing PVC (PersistentVolumeClaim)
//     If the provisioner or an external controller can support the specified data source,
//     it will create a new volume based on the contents of the specified data source.
//     When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
//     and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
//     If the namespace is specified, then dataSourceRef will not be copied to dataSource.
type LogstashSpecVolumeClaimTemplatesSpecDataSourceOutput struct{ *pulumi.OutputState }

func (LogstashSpecVolumeClaimTemplatesSpecDataSourceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesSpecDataSource)(nil)).Elem()
}

func (o LogstashSpecVolumeClaimTemplatesSpecDataSourceOutput) ToLogstashSpecVolumeClaimTemplatesSpecDataSourceOutput() LogstashSpecVolumeClaimTemplatesSpecDataSourceOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesSpecDataSourceOutput) ToLogstashSpecVolumeClaimTemplatesSpecDataSourceOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecDataSourceOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesSpecDataSourceOutput) ToLogstashSpecVolumeClaimTemplatesSpecDataSourcePtrOutput() LogstashSpecVolumeClaimTemplatesSpecDataSourcePtrOutput {
	return o.ToLogstashSpecVolumeClaimTemplatesSpecDataSourcePtrOutputWithContext(context.Background())
}

func (o LogstashSpecVolumeClaimTemplatesSpecDataSourceOutput) ToLogstashSpecVolumeClaimTemplatesSpecDataSourcePtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecDataSourcePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LogstashSpecVolumeClaimTemplatesSpecDataSource) *LogstashSpecVolumeClaimTemplatesSpecDataSource {
		return &v
	}).(LogstashSpecVolumeClaimTemplatesSpecDataSourcePtrOutput)
}

// APIGroup is the group for the resource being referenced.
// If APIGroup is not specified, the specified Kind must be in the core API group.
// For any other third-party types, APIGroup is required.
func (o LogstashSpecVolumeClaimTemplatesSpecDataSourceOutput) ApiGroup() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesSpecDataSource) *string { return v.ApiGroup }).(pulumi.StringPtrOutput)
}

// Kind is the type of resource being referenced
func (o LogstashSpecVolumeClaimTemplatesSpecDataSourceOutput) Kind() pulumi.StringOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesSpecDataSource) string { return v.Kind }).(pulumi.StringOutput)
}

// Name is the name of resource being referenced
func (o LogstashSpecVolumeClaimTemplatesSpecDataSourceOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesSpecDataSource) string { return v.Name }).(pulumi.StringOutput)
}

type LogstashSpecVolumeClaimTemplatesSpecDataSourcePtrOutput struct{ *pulumi.OutputState }

func (LogstashSpecVolumeClaimTemplatesSpecDataSourcePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecVolumeClaimTemplatesSpecDataSource)(nil)).Elem()
}

func (o LogstashSpecVolumeClaimTemplatesSpecDataSourcePtrOutput) ToLogstashSpecVolumeClaimTemplatesSpecDataSourcePtrOutput() LogstashSpecVolumeClaimTemplatesSpecDataSourcePtrOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesSpecDataSourcePtrOutput) ToLogstashSpecVolumeClaimTemplatesSpecDataSourcePtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecDataSourcePtrOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesSpecDataSourcePtrOutput) Elem() LogstashSpecVolumeClaimTemplatesSpecDataSourceOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesSpecDataSource) LogstashSpecVolumeClaimTemplatesSpecDataSource {
		if v != nil {
			return *v
		}
		var ret LogstashSpecVolumeClaimTemplatesSpecDataSource
		return ret
	}).(LogstashSpecVolumeClaimTemplatesSpecDataSourceOutput)
}

// APIGroup is the group for the resource being referenced.
// If APIGroup is not specified, the specified Kind must be in the core API group.
// For any other third-party types, APIGroup is required.
func (o LogstashSpecVolumeClaimTemplatesSpecDataSourcePtrOutput) ApiGroup() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesSpecDataSource) *string {
		if v == nil {
			return nil
		}
		return v.ApiGroup
	}).(pulumi.StringPtrOutput)
}

// Kind is the type of resource being referenced
func (o LogstashSpecVolumeClaimTemplatesSpecDataSourcePtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesSpecDataSource) *string {
		if v == nil {
			return nil
		}
		return &v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name is the name of resource being referenced
func (o LogstashSpecVolumeClaimTemplatesSpecDataSourcePtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesSpecDataSource) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
// volume is desired. This may be any object from a non-empty API group (non
// core object) or a PersistentVolumeClaim object.
// When this field is specified, volume binding will only succeed if the type of
// the specified object matches some installed volume populator or dynamic
// provisioner.
// This field will replace the functionality of the dataSource field and as such
// if both fields are non-empty, they must have the same value. For backwards
// compatibility, when namespace isn't specified in dataSourceRef,
// both fields (dataSource and dataSourceRef) will be set to the same
// value automatically if one of them is empty and the other is non-empty.
// When namespace is specified in dataSourceRef,
// dataSource isn't set to the same value and must be empty.
// There are three important differences between dataSource and dataSourceRef:
//   - While dataSource only allows two specific types of objects, dataSourceRef
//     allows any non-core object, as well as PersistentVolumeClaim objects.
//   - While dataSource ignores disallowed values (dropping them), dataSourceRef
//     preserves all values, and generates an error if a disallowed value is
//     specified.
//   - While dataSource only allows local objects, dataSourceRef allows objects
//     in any namespaces.
//     (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
//     (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
type LogstashSpecVolumeClaimTemplatesSpecDataSourceRef struct {
	// APIGroup is the group for the resource being referenced.
	// If APIGroup is not specified, the specified Kind must be in the core API group.
	// For any other third-party types, APIGroup is required.
	ApiGroup *string `pulumi:"apiGroup"`
	// Kind is the type of resource being referenced
	Kind string `pulumi:"kind"`
	// Name is the name of resource being referenced
	Name string `pulumi:"name"`
	// Namespace is the namespace of resource being referenced
	// Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
	// (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
	Namespace *string `pulumi:"namespace"`
}

// LogstashSpecVolumeClaimTemplatesSpecDataSourceRefInput is an input type that accepts LogstashSpecVolumeClaimTemplatesSpecDataSourceRefArgs and LogstashSpecVolumeClaimTemplatesSpecDataSourceRefOutput values.
// You can construct a concrete instance of `LogstashSpecVolumeClaimTemplatesSpecDataSourceRefInput` via:
//
//	LogstashSpecVolumeClaimTemplatesSpecDataSourceRefArgs{...}
type LogstashSpecVolumeClaimTemplatesSpecDataSourceRefInput interface {
	pulumi.Input

	ToLogstashSpecVolumeClaimTemplatesSpecDataSourceRefOutput() LogstashSpecVolumeClaimTemplatesSpecDataSourceRefOutput
	ToLogstashSpecVolumeClaimTemplatesSpecDataSourceRefOutputWithContext(context.Context) LogstashSpecVolumeClaimTemplatesSpecDataSourceRefOutput
}

// dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
// volume is desired. This may be any object from a non-empty API group (non
// core object) or a PersistentVolumeClaim object.
// When this field is specified, volume binding will only succeed if the type of
// the specified object matches some installed volume populator or dynamic
// provisioner.
// This field will replace the functionality of the dataSource field and as such
// if both fields are non-empty, they must have the same value. For backwards
// compatibility, when namespace isn't specified in dataSourceRef,
// both fields (dataSource and dataSourceRef) will be set to the same
// value automatically if one of them is empty and the other is non-empty.
// When namespace is specified in dataSourceRef,
// dataSource isn't set to the same value and must be empty.
// There are three important differences between dataSource and dataSourceRef:
//   - While dataSource only allows two specific types of objects, dataSourceRef
//     allows any non-core object, as well as PersistentVolumeClaim objects.
//   - While dataSource ignores disallowed values (dropping them), dataSourceRef
//     preserves all values, and generates an error if a disallowed value is
//     specified.
//   - While dataSource only allows local objects, dataSourceRef allows objects
//     in any namespaces.
//     (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
//     (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
type LogstashSpecVolumeClaimTemplatesSpecDataSourceRefArgs struct {
	// APIGroup is the group for the resource being referenced.
	// If APIGroup is not specified, the specified Kind must be in the core API group.
	// For any other third-party types, APIGroup is required.
	ApiGroup pulumi.StringPtrInput `pulumi:"apiGroup"`
	// Kind is the type of resource being referenced
	Kind pulumi.StringInput `pulumi:"kind"`
	// Name is the name of resource being referenced
	Name pulumi.StringInput `pulumi:"name"`
	// Namespace is the namespace of resource being referenced
	// Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
	// (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
}

func (LogstashSpecVolumeClaimTemplatesSpecDataSourceRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesSpecDataSourceRef)(nil)).Elem()
}

func (i LogstashSpecVolumeClaimTemplatesSpecDataSourceRefArgs) ToLogstashSpecVolumeClaimTemplatesSpecDataSourceRefOutput() LogstashSpecVolumeClaimTemplatesSpecDataSourceRefOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesSpecDataSourceRefOutputWithContext(context.Background())
}

func (i LogstashSpecVolumeClaimTemplatesSpecDataSourceRefArgs) ToLogstashSpecVolumeClaimTemplatesSpecDataSourceRefOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecDataSourceRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesSpecDataSourceRefOutput)
}

func (i LogstashSpecVolumeClaimTemplatesSpecDataSourceRefArgs) ToLogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutput() LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutputWithContext(context.Background())
}

func (i LogstashSpecVolumeClaimTemplatesSpecDataSourceRefArgs) ToLogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesSpecDataSourceRefOutput).ToLogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutputWithContext(ctx)
}

// LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrInput is an input type that accepts LogstashSpecVolumeClaimTemplatesSpecDataSourceRefArgs, LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtr and LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutput values.
// You can construct a concrete instance of `LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrInput` via:
//
//	        LogstashSpecVolumeClaimTemplatesSpecDataSourceRefArgs{...}
//
//	or:
//
//	        nil
type LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrInput interface {
	pulumi.Input

	ToLogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutput() LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutput
	ToLogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutputWithContext(context.Context) LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutput
}

type logstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrType LogstashSpecVolumeClaimTemplatesSpecDataSourceRefArgs

func LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtr(v *LogstashSpecVolumeClaimTemplatesSpecDataSourceRefArgs) LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrInput {
	return (*logstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrType)(v)
}

func (*logstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecVolumeClaimTemplatesSpecDataSourceRef)(nil)).Elem()
}

func (i *logstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrType) ToLogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutput() LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutputWithContext(context.Background())
}

func (i *logstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrType) ToLogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutput)
}

// dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
// volume is desired. This may be any object from a non-empty API group (non
// core object) or a PersistentVolumeClaim object.
// When this field is specified, volume binding will only succeed if the type of
// the specified object matches some installed volume populator or dynamic
// provisioner.
// This field will replace the functionality of the dataSource field and as such
// if both fields are non-empty, they must have the same value. For backwards
// compatibility, when namespace isn't specified in dataSourceRef,
// both fields (dataSource and dataSourceRef) will be set to the same
// value automatically if one of them is empty and the other is non-empty.
// When namespace is specified in dataSourceRef,
// dataSource isn't set to the same value and must be empty.
// There are three important differences between dataSource and dataSourceRef:
//   - While dataSource only allows two specific types of objects, dataSourceRef
//     allows any non-core object, as well as PersistentVolumeClaim objects.
//   - While dataSource ignores disallowed values (dropping them), dataSourceRef
//     preserves all values, and generates an error if a disallowed value is
//     specified.
//   - While dataSource only allows local objects, dataSourceRef allows objects
//     in any namespaces.
//     (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
//     (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
type LogstashSpecVolumeClaimTemplatesSpecDataSourceRefOutput struct{ *pulumi.OutputState }

func (LogstashSpecVolumeClaimTemplatesSpecDataSourceRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesSpecDataSourceRef)(nil)).Elem()
}

func (o LogstashSpecVolumeClaimTemplatesSpecDataSourceRefOutput) ToLogstashSpecVolumeClaimTemplatesSpecDataSourceRefOutput() LogstashSpecVolumeClaimTemplatesSpecDataSourceRefOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesSpecDataSourceRefOutput) ToLogstashSpecVolumeClaimTemplatesSpecDataSourceRefOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecDataSourceRefOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesSpecDataSourceRefOutput) ToLogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutput() LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutput {
	return o.ToLogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutputWithContext(context.Background())
}

func (o LogstashSpecVolumeClaimTemplatesSpecDataSourceRefOutput) ToLogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LogstashSpecVolumeClaimTemplatesSpecDataSourceRef) *LogstashSpecVolumeClaimTemplatesSpecDataSourceRef {
		return &v
	}).(LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutput)
}

// APIGroup is the group for the resource being referenced.
// If APIGroup is not specified, the specified Kind must be in the core API group.
// For any other third-party types, APIGroup is required.
func (o LogstashSpecVolumeClaimTemplatesSpecDataSourceRefOutput) ApiGroup() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesSpecDataSourceRef) *string { return v.ApiGroup }).(pulumi.StringPtrOutput)
}

// Kind is the type of resource being referenced
func (o LogstashSpecVolumeClaimTemplatesSpecDataSourceRefOutput) Kind() pulumi.StringOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesSpecDataSourceRef) string { return v.Kind }).(pulumi.StringOutput)
}

// Name is the name of resource being referenced
func (o LogstashSpecVolumeClaimTemplatesSpecDataSourceRefOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesSpecDataSourceRef) string { return v.Name }).(pulumi.StringOutput)
}

// Namespace is the namespace of resource being referenced
// Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
// (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
func (o LogstashSpecVolumeClaimTemplatesSpecDataSourceRefOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesSpecDataSourceRef) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

type LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutput struct{ *pulumi.OutputState }

func (LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecVolumeClaimTemplatesSpecDataSourceRef)(nil)).Elem()
}

func (o LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutput) ToLogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutput() LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutput) ToLogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutput) Elem() LogstashSpecVolumeClaimTemplatesSpecDataSourceRefOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesSpecDataSourceRef) LogstashSpecVolumeClaimTemplatesSpecDataSourceRef {
		if v != nil {
			return *v
		}
		var ret LogstashSpecVolumeClaimTemplatesSpecDataSourceRef
		return ret
	}).(LogstashSpecVolumeClaimTemplatesSpecDataSourceRefOutput)
}

// APIGroup is the group for the resource being referenced.
// If APIGroup is not specified, the specified Kind must be in the core API group.
// For any other third-party types, APIGroup is required.
func (o LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutput) ApiGroup() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesSpecDataSourceRef) *string {
		if v == nil {
			return nil
		}
		return v.ApiGroup
	}).(pulumi.StringPtrOutput)
}

// Kind is the type of resource being referenced
func (o LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesSpecDataSourceRef) *string {
		if v == nil {
			return nil
		}
		return &v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name is the name of resource being referenced
func (o LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesSpecDataSourceRef) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of resource being referenced
// Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
// (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
func (o LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesSpecDataSourceRef) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

// resources represents the minimum resources the volume should have.
// If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
// that are lower than previous value but must still be higher than capacity recorded in the
// status field of the claim.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
type LogstashSpecVolumeClaimTemplatesSpecResources struct {
	// Limits describes the maximum amount of compute resources allowed.
	// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
	Limits map[string]interface{} `pulumi:"limits"`
	// Requests describes the minimum amount of compute resources required.
	// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
	// otherwise to an implementation-defined value. Requests cannot exceed Limits.
	// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
	Requests map[string]interface{} `pulumi:"requests"`
}

// LogstashSpecVolumeClaimTemplatesSpecResourcesInput is an input type that accepts LogstashSpecVolumeClaimTemplatesSpecResourcesArgs and LogstashSpecVolumeClaimTemplatesSpecResourcesOutput values.
// You can construct a concrete instance of `LogstashSpecVolumeClaimTemplatesSpecResourcesInput` via:
//
//	LogstashSpecVolumeClaimTemplatesSpecResourcesArgs{...}
type LogstashSpecVolumeClaimTemplatesSpecResourcesInput interface {
	pulumi.Input

	ToLogstashSpecVolumeClaimTemplatesSpecResourcesOutput() LogstashSpecVolumeClaimTemplatesSpecResourcesOutput
	ToLogstashSpecVolumeClaimTemplatesSpecResourcesOutputWithContext(context.Context) LogstashSpecVolumeClaimTemplatesSpecResourcesOutput
}

// resources represents the minimum resources the volume should have.
// If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
// that are lower than previous value but must still be higher than capacity recorded in the
// status field of the claim.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
type LogstashSpecVolumeClaimTemplatesSpecResourcesArgs struct {
	// Limits describes the maximum amount of compute resources allowed.
	// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
	Limits pulumi.MapInput `pulumi:"limits"`
	// Requests describes the minimum amount of compute resources required.
	// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
	// otherwise to an implementation-defined value. Requests cannot exceed Limits.
	// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
	Requests pulumi.MapInput `pulumi:"requests"`
}

func (LogstashSpecVolumeClaimTemplatesSpecResourcesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesSpecResources)(nil)).Elem()
}

func (i LogstashSpecVolumeClaimTemplatesSpecResourcesArgs) ToLogstashSpecVolumeClaimTemplatesSpecResourcesOutput() LogstashSpecVolumeClaimTemplatesSpecResourcesOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesSpecResourcesOutputWithContext(context.Background())
}

func (i LogstashSpecVolumeClaimTemplatesSpecResourcesArgs) ToLogstashSpecVolumeClaimTemplatesSpecResourcesOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecResourcesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesSpecResourcesOutput)
}

func (i LogstashSpecVolumeClaimTemplatesSpecResourcesArgs) ToLogstashSpecVolumeClaimTemplatesSpecResourcesPtrOutput() LogstashSpecVolumeClaimTemplatesSpecResourcesPtrOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesSpecResourcesPtrOutputWithContext(context.Background())
}

func (i LogstashSpecVolumeClaimTemplatesSpecResourcesArgs) ToLogstashSpecVolumeClaimTemplatesSpecResourcesPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecResourcesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesSpecResourcesOutput).ToLogstashSpecVolumeClaimTemplatesSpecResourcesPtrOutputWithContext(ctx)
}

// LogstashSpecVolumeClaimTemplatesSpecResourcesPtrInput is an input type that accepts LogstashSpecVolumeClaimTemplatesSpecResourcesArgs, LogstashSpecVolumeClaimTemplatesSpecResourcesPtr and LogstashSpecVolumeClaimTemplatesSpecResourcesPtrOutput values.
// You can construct a concrete instance of `LogstashSpecVolumeClaimTemplatesSpecResourcesPtrInput` via:
//
//	        LogstashSpecVolumeClaimTemplatesSpecResourcesArgs{...}
//
//	or:
//
//	        nil
type LogstashSpecVolumeClaimTemplatesSpecResourcesPtrInput interface {
	pulumi.Input

	ToLogstashSpecVolumeClaimTemplatesSpecResourcesPtrOutput() LogstashSpecVolumeClaimTemplatesSpecResourcesPtrOutput
	ToLogstashSpecVolumeClaimTemplatesSpecResourcesPtrOutputWithContext(context.Context) LogstashSpecVolumeClaimTemplatesSpecResourcesPtrOutput
}

type logstashSpecVolumeClaimTemplatesSpecResourcesPtrType LogstashSpecVolumeClaimTemplatesSpecResourcesArgs

func LogstashSpecVolumeClaimTemplatesSpecResourcesPtr(v *LogstashSpecVolumeClaimTemplatesSpecResourcesArgs) LogstashSpecVolumeClaimTemplatesSpecResourcesPtrInput {
	return (*logstashSpecVolumeClaimTemplatesSpecResourcesPtrType)(v)
}

func (*logstashSpecVolumeClaimTemplatesSpecResourcesPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecVolumeClaimTemplatesSpecResources)(nil)).Elem()
}

func (i *logstashSpecVolumeClaimTemplatesSpecResourcesPtrType) ToLogstashSpecVolumeClaimTemplatesSpecResourcesPtrOutput() LogstashSpecVolumeClaimTemplatesSpecResourcesPtrOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesSpecResourcesPtrOutputWithContext(context.Background())
}

func (i *logstashSpecVolumeClaimTemplatesSpecResourcesPtrType) ToLogstashSpecVolumeClaimTemplatesSpecResourcesPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecResourcesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesSpecResourcesPtrOutput)
}

// resources represents the minimum resources the volume should have.
// If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
// that are lower than previous value but must still be higher than capacity recorded in the
// status field of the claim.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
type LogstashSpecVolumeClaimTemplatesSpecResourcesOutput struct{ *pulumi.OutputState }

func (LogstashSpecVolumeClaimTemplatesSpecResourcesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesSpecResources)(nil)).Elem()
}

func (o LogstashSpecVolumeClaimTemplatesSpecResourcesOutput) ToLogstashSpecVolumeClaimTemplatesSpecResourcesOutput() LogstashSpecVolumeClaimTemplatesSpecResourcesOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesSpecResourcesOutput) ToLogstashSpecVolumeClaimTemplatesSpecResourcesOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecResourcesOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesSpecResourcesOutput) ToLogstashSpecVolumeClaimTemplatesSpecResourcesPtrOutput() LogstashSpecVolumeClaimTemplatesSpecResourcesPtrOutput {
	return o.ToLogstashSpecVolumeClaimTemplatesSpecResourcesPtrOutputWithContext(context.Background())
}

func (o LogstashSpecVolumeClaimTemplatesSpecResourcesOutput) ToLogstashSpecVolumeClaimTemplatesSpecResourcesPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecResourcesPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LogstashSpecVolumeClaimTemplatesSpecResources) *LogstashSpecVolumeClaimTemplatesSpecResources {
		return &v
	}).(LogstashSpecVolumeClaimTemplatesSpecResourcesPtrOutput)
}

// Limits describes the maximum amount of compute resources allowed.
// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
func (o LogstashSpecVolumeClaimTemplatesSpecResourcesOutput) Limits() pulumi.MapOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesSpecResources) map[string]interface{} { return v.Limits }).(pulumi.MapOutput)
}

// Requests describes the minimum amount of compute resources required.
// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
// otherwise to an implementation-defined value. Requests cannot exceed Limits.
// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
func (o LogstashSpecVolumeClaimTemplatesSpecResourcesOutput) Requests() pulumi.MapOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesSpecResources) map[string]interface{} { return v.Requests }).(pulumi.MapOutput)
}

type LogstashSpecVolumeClaimTemplatesSpecResourcesPtrOutput struct{ *pulumi.OutputState }

func (LogstashSpecVolumeClaimTemplatesSpecResourcesPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecVolumeClaimTemplatesSpecResources)(nil)).Elem()
}

func (o LogstashSpecVolumeClaimTemplatesSpecResourcesPtrOutput) ToLogstashSpecVolumeClaimTemplatesSpecResourcesPtrOutput() LogstashSpecVolumeClaimTemplatesSpecResourcesPtrOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesSpecResourcesPtrOutput) ToLogstashSpecVolumeClaimTemplatesSpecResourcesPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecResourcesPtrOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesSpecResourcesPtrOutput) Elem() LogstashSpecVolumeClaimTemplatesSpecResourcesOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesSpecResources) LogstashSpecVolumeClaimTemplatesSpecResources {
		if v != nil {
			return *v
		}
		var ret LogstashSpecVolumeClaimTemplatesSpecResources
		return ret
	}).(LogstashSpecVolumeClaimTemplatesSpecResourcesOutput)
}

// Limits describes the maximum amount of compute resources allowed.
// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
func (o LogstashSpecVolumeClaimTemplatesSpecResourcesPtrOutput) Limits() pulumi.MapOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesSpecResources) map[string]interface{} {
		if v == nil {
			return nil
		}
		return v.Limits
	}).(pulumi.MapOutput)
}

// Requests describes the minimum amount of compute resources required.
// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
// otherwise to an implementation-defined value. Requests cannot exceed Limits.
// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
func (o LogstashSpecVolumeClaimTemplatesSpecResourcesPtrOutput) Requests() pulumi.MapOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesSpecResources) map[string]interface{} {
		if v == nil {
			return nil
		}
		return v.Requests
	}).(pulumi.MapOutput)
}

// Limits describes the maximum amount of compute resources allowed.
// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
type LogstashSpecVolumeClaimTemplatesSpecResourcesLimits struct {
}

// Requests describes the minimum amount of compute resources required.
// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
// otherwise to an implementation-defined value. Requests cannot exceed Limits.
// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
type LogstashSpecVolumeClaimTemplatesSpecResourcesRequests struct {
}

// selector is a label query over volumes to consider for binding.
type LogstashSpecVolumeClaimTemplatesSpecSelector struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions []LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressions `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]string `pulumi:"matchLabels"`
}

// LogstashSpecVolumeClaimTemplatesSpecSelectorInput is an input type that accepts LogstashSpecVolumeClaimTemplatesSpecSelectorArgs and LogstashSpecVolumeClaimTemplatesSpecSelectorOutput values.
// You can construct a concrete instance of `LogstashSpecVolumeClaimTemplatesSpecSelectorInput` via:
//
//	LogstashSpecVolumeClaimTemplatesSpecSelectorArgs{...}
type LogstashSpecVolumeClaimTemplatesSpecSelectorInput interface {
	pulumi.Input

	ToLogstashSpecVolumeClaimTemplatesSpecSelectorOutput() LogstashSpecVolumeClaimTemplatesSpecSelectorOutput
	ToLogstashSpecVolumeClaimTemplatesSpecSelectorOutputWithContext(context.Context) LogstashSpecVolumeClaimTemplatesSpecSelectorOutput
}

// selector is a label query over volumes to consider for binding.
type LogstashSpecVolumeClaimTemplatesSpecSelectorArgs struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayInput `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels pulumi.StringMapInput `pulumi:"matchLabels"`
}

func (LogstashSpecVolumeClaimTemplatesSpecSelectorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesSpecSelector)(nil)).Elem()
}

func (i LogstashSpecVolumeClaimTemplatesSpecSelectorArgs) ToLogstashSpecVolumeClaimTemplatesSpecSelectorOutput() LogstashSpecVolumeClaimTemplatesSpecSelectorOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesSpecSelectorOutputWithContext(context.Background())
}

func (i LogstashSpecVolumeClaimTemplatesSpecSelectorArgs) ToLogstashSpecVolumeClaimTemplatesSpecSelectorOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecSelectorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesSpecSelectorOutput)
}

func (i LogstashSpecVolumeClaimTemplatesSpecSelectorArgs) ToLogstashSpecVolumeClaimTemplatesSpecSelectorPtrOutput() LogstashSpecVolumeClaimTemplatesSpecSelectorPtrOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesSpecSelectorPtrOutputWithContext(context.Background())
}

func (i LogstashSpecVolumeClaimTemplatesSpecSelectorArgs) ToLogstashSpecVolumeClaimTemplatesSpecSelectorPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesSpecSelectorOutput).ToLogstashSpecVolumeClaimTemplatesSpecSelectorPtrOutputWithContext(ctx)
}

// LogstashSpecVolumeClaimTemplatesSpecSelectorPtrInput is an input type that accepts LogstashSpecVolumeClaimTemplatesSpecSelectorArgs, LogstashSpecVolumeClaimTemplatesSpecSelectorPtr and LogstashSpecVolumeClaimTemplatesSpecSelectorPtrOutput values.
// You can construct a concrete instance of `LogstashSpecVolumeClaimTemplatesSpecSelectorPtrInput` via:
//
//	        LogstashSpecVolumeClaimTemplatesSpecSelectorArgs{...}
//
//	or:
//
//	        nil
type LogstashSpecVolumeClaimTemplatesSpecSelectorPtrInput interface {
	pulumi.Input

	ToLogstashSpecVolumeClaimTemplatesSpecSelectorPtrOutput() LogstashSpecVolumeClaimTemplatesSpecSelectorPtrOutput
	ToLogstashSpecVolumeClaimTemplatesSpecSelectorPtrOutputWithContext(context.Context) LogstashSpecVolumeClaimTemplatesSpecSelectorPtrOutput
}

type logstashSpecVolumeClaimTemplatesSpecSelectorPtrType LogstashSpecVolumeClaimTemplatesSpecSelectorArgs

func LogstashSpecVolumeClaimTemplatesSpecSelectorPtr(v *LogstashSpecVolumeClaimTemplatesSpecSelectorArgs) LogstashSpecVolumeClaimTemplatesSpecSelectorPtrInput {
	return (*logstashSpecVolumeClaimTemplatesSpecSelectorPtrType)(v)
}

func (*logstashSpecVolumeClaimTemplatesSpecSelectorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecVolumeClaimTemplatesSpecSelector)(nil)).Elem()
}

func (i *logstashSpecVolumeClaimTemplatesSpecSelectorPtrType) ToLogstashSpecVolumeClaimTemplatesSpecSelectorPtrOutput() LogstashSpecVolumeClaimTemplatesSpecSelectorPtrOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesSpecSelectorPtrOutputWithContext(context.Background())
}

func (i *logstashSpecVolumeClaimTemplatesSpecSelectorPtrType) ToLogstashSpecVolumeClaimTemplatesSpecSelectorPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesSpecSelectorPtrOutput)
}

// selector is a label query over volumes to consider for binding.
type LogstashSpecVolumeClaimTemplatesSpecSelectorOutput struct{ *pulumi.OutputState }

func (LogstashSpecVolumeClaimTemplatesSpecSelectorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesSpecSelector)(nil)).Elem()
}

func (o LogstashSpecVolumeClaimTemplatesSpecSelectorOutput) ToLogstashSpecVolumeClaimTemplatesSpecSelectorOutput() LogstashSpecVolumeClaimTemplatesSpecSelectorOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesSpecSelectorOutput) ToLogstashSpecVolumeClaimTemplatesSpecSelectorOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecSelectorOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesSpecSelectorOutput) ToLogstashSpecVolumeClaimTemplatesSpecSelectorPtrOutput() LogstashSpecVolumeClaimTemplatesSpecSelectorPtrOutput {
	return o.ToLogstashSpecVolumeClaimTemplatesSpecSelectorPtrOutputWithContext(context.Background())
}

func (o LogstashSpecVolumeClaimTemplatesSpecSelectorOutput) ToLogstashSpecVolumeClaimTemplatesSpecSelectorPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecSelectorPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LogstashSpecVolumeClaimTemplatesSpecSelector) *LogstashSpecVolumeClaimTemplatesSpecSelector {
		return &v
	}).(LogstashSpecVolumeClaimTemplatesSpecSelectorPtrOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o LogstashSpecVolumeClaimTemplatesSpecSelectorOutput) MatchExpressions() LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesSpecSelector) []LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressions {
		return v.MatchExpressions
	}).(LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o LogstashSpecVolumeClaimTemplatesSpecSelectorOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesSpecSelector) map[string]string { return v.MatchLabels }).(pulumi.StringMapOutput)
}

type LogstashSpecVolumeClaimTemplatesSpecSelectorPtrOutput struct{ *pulumi.OutputState }

func (LogstashSpecVolumeClaimTemplatesSpecSelectorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecVolumeClaimTemplatesSpecSelector)(nil)).Elem()
}

func (o LogstashSpecVolumeClaimTemplatesSpecSelectorPtrOutput) ToLogstashSpecVolumeClaimTemplatesSpecSelectorPtrOutput() LogstashSpecVolumeClaimTemplatesSpecSelectorPtrOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesSpecSelectorPtrOutput) ToLogstashSpecVolumeClaimTemplatesSpecSelectorPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecSelectorPtrOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesSpecSelectorPtrOutput) Elem() LogstashSpecVolumeClaimTemplatesSpecSelectorOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesSpecSelector) LogstashSpecVolumeClaimTemplatesSpecSelector {
		if v != nil {
			return *v
		}
		var ret LogstashSpecVolumeClaimTemplatesSpecSelector
		return ret
	}).(LogstashSpecVolumeClaimTemplatesSpecSelectorOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o LogstashSpecVolumeClaimTemplatesSpecSelectorPtrOutput) MatchExpressions() LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesSpecSelector) []LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressions {
		if v == nil {
			return nil
		}
		return v.MatchExpressions
	}).(LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o LogstashSpecVolumeClaimTemplatesSpecSelectorPtrOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesSpecSelector) map[string]string {
		if v == nil {
			return nil
		}
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressions struct {
	// key is the label key that the selector applies to.
	Key string `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator string `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values []string `pulumi:"values"`
}

// LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsInput is an input type that accepts LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArgs and LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsOutput values.
// You can construct a concrete instance of `LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsInput` via:
//
//	LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArgs{...}
type LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsInput interface {
	pulumi.Input

	ToLogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsOutput() LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsOutput
	ToLogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsOutputWithContext(context.Context) LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsOutput
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArgs struct {
	// key is the label key that the selector applies to.
	Key pulumi.StringInput `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator pulumi.StringInput `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressions)(nil)).Elem()
}

func (i LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArgs) ToLogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsOutput() LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsOutputWithContext(context.Background())
}

func (i LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArgs) ToLogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsOutput)
}

// LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayInput is an input type that accepts LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArray and LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayOutput values.
// You can construct a concrete instance of `LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayInput` via:
//
//	LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArray{ LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArgs{...} }
type LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayInput interface {
	pulumi.Input

	ToLogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayOutput() LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayOutput
	ToLogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayOutputWithContext(context.Context) LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayOutput
}

type LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArray []LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsInput

func (LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressions)(nil)).Elem()
}

func (i LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArray) ToLogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayOutput() LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayOutputWithContext(context.Background())
}

func (i LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArray) ToLogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsOutput struct{ *pulumi.OutputState }

func (LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressions)(nil)).Elem()
}

func (o LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsOutput) ToLogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsOutput() LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsOutput) ToLogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsOutput {
	return o
}

// key is the label key that the selector applies to.
func (o LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressions) string { return v.Key }).(pulumi.StringOutput)
}

// operator represents a key's relationship to a set of values.
// Valid operators are In, NotIn, Exists and DoesNotExist.
func (o LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsOutput) Operator() pulumi.StringOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressions) string { return v.Operator }).(pulumi.StringOutput)
}

// values is an array of string values. If the operator is In or NotIn,
// the values array must be non-empty. If the operator is Exists or DoesNotExist,
// the values array must be empty. This array is replaced during a strategic
// merge patch.
func (o LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressions) []string { return v.Values }).(pulumi.StringArrayOutput)
}

type LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayOutput struct{ *pulumi.OutputState }

func (LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressions)(nil)).Elem()
}

func (o LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayOutput) ToLogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayOutput() LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayOutput) ToLogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayOutput) Index(i pulumi.IntInput) LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressions {
		return vs[0].([]LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressions)[vs[1].(int)]
	}).(LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
type LogstashSpecVolumeClaimTemplatesSpecSelectorMatchLabels struct {
}

// status represents the current information/status of a persistent volume claim.
// Read-only.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
type LogstashSpecVolumeClaimTemplatesStatus struct {
	// accessModes contains the actual access modes the volume backing the PVC has.
	// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
	AccessModes []string `pulumi:"accessModes"`
	// allocatedResourceStatuses stores status of resource being resized for the given PVC.
	// Key names follow standard Kubernetes label syntax. Valid values are either:
	// 	* Un-prefixed keys:
	// 		- storage - the capacity of the volume.
	// 	* Custom resources must use implementation-defined prefixed names such as "example.com/my-custom-resource"
	// Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered
	// reserved and hence may not be used.
	//
	// ClaimResourceStatus can be in any of following states:
	// 	- ControllerResizeInProgress:
	// 		State set when resize controller starts resizing the volume in control-plane.
	// 	- ControllerResizeFailed:
	// 		State set when resize has failed in resize controller with a terminal error.
	// 	- NodeResizePending:
	// 		State set when resize controller has finished resizing the volume but further resizing of
	// 		volume is needed on the node.
	// 	- NodeResizeInProgress:
	// 		State set when kubelet starts resizing the volume.
	// 	- NodeResizeFailed:
	// 		State set when resizing has failed in kubelet with a terminal error. Transient errors don't set
	// 		NodeResizeFailed.
	// For example: if expanding a PVC for more capacity - this field can be one of the following states:
	// 	- pvc.status.allocatedResourceStatus['storage'] = "ControllerResizeInProgress"
	//      - pvc.status.allocatedResourceStatus['storage'] = "ControllerResizeFailed"
	//      - pvc.status.allocatedResourceStatus['storage'] = "NodeResizePending"
	//      - pvc.status.allocatedResourceStatus['storage'] = "NodeResizeInProgress"
	//      - pvc.status.allocatedResourceStatus['storage'] = "NodeResizeFailed"
	// When this field is not set, it means that no resize operation is in progress for the given PVC.
	//
	// A controller that receives PVC update with previously unknown resourceName or ClaimResourceStatus
	// should ignore the update for the purpose it was designed. For example - a controller that
	// only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid
	// resources associated with PVC.
	//
	// This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
	AllocatedResourceStatuses map[string]string `pulumi:"allocatedResourceStatuses"`
	// allocatedResources tracks the resources allocated to a PVC including its capacity.
	// Key names follow standard Kubernetes label syntax. Valid values are either:
	// 	* Un-prefixed keys:
	// 		- storage - the capacity of the volume.
	// 	* Custom resources must use implementation-defined prefixed names such as "example.com/my-custom-resource"
	// Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered
	// reserved and hence may not be used.
	//
	// Capacity reported here may be larger than the actual capacity when a volume expansion operation
	// is requested.
	// For storage quota, the larger value from allocatedResources and PVC.spec.resources is used.
	// If allocatedResources is not set, PVC.spec.resources alone is used for quota calculation.
	// If a volume expansion capacity request is lowered, allocatedResources is only
	// lowered if there are no expansion operations in progress and if the actual volume capacity
	// is equal or lower than the requested capacity.
	//
	// A controller that receives PVC update with previously unknown resourceName
	// should ignore the update for the purpose it was designed. For example - a controller that
	// only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid
	// resources associated with PVC.
	//
	// This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
	AllocatedResources map[string]interface{} `pulumi:"allocatedResources"`
	// capacity represents the actual resources of the underlying volume.
	Capacity map[string]interface{} `pulumi:"capacity"`
	// conditions is the current Condition of persistent volume claim. If underlying persistent volume is being
	// resized then the Condition will be set to 'Resizing'.
	Conditions []LogstashSpecVolumeClaimTemplatesStatusConditions `pulumi:"conditions"`
	// currentVolumeAttributesClassName is the current name of the VolumeAttributesClass the PVC is using.
	// When unset, there is no VolumeAttributeClass applied to this PersistentVolumeClaim
	// This is an alpha field and requires enabling VolumeAttributesClass feature.
	CurrentVolumeAttributesClassName *string `pulumi:"currentVolumeAttributesClassName"`
	// ModifyVolumeStatus represents the status object of ControllerModifyVolume operation.
	// When this is unset, there is no ModifyVolume operation being attempted.
	// This is an alpha field and requires enabling VolumeAttributesClass feature.
	ModifyVolumeStatus *LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatus `pulumi:"modifyVolumeStatus"`
	// phase represents the current phase of PersistentVolumeClaim.
	Phase *string `pulumi:"phase"`
}

// LogstashSpecVolumeClaimTemplatesStatusInput is an input type that accepts LogstashSpecVolumeClaimTemplatesStatusArgs and LogstashSpecVolumeClaimTemplatesStatusOutput values.
// You can construct a concrete instance of `LogstashSpecVolumeClaimTemplatesStatusInput` via:
//
//	LogstashSpecVolumeClaimTemplatesStatusArgs{...}
type LogstashSpecVolumeClaimTemplatesStatusInput interface {
	pulumi.Input

	ToLogstashSpecVolumeClaimTemplatesStatusOutput() LogstashSpecVolumeClaimTemplatesStatusOutput
	ToLogstashSpecVolumeClaimTemplatesStatusOutputWithContext(context.Context) LogstashSpecVolumeClaimTemplatesStatusOutput
}

// status represents the current information/status of a persistent volume claim.
// Read-only.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
type LogstashSpecVolumeClaimTemplatesStatusArgs struct {
	// accessModes contains the actual access modes the volume backing the PVC has.
	// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
	AccessModes pulumi.StringArrayInput `pulumi:"accessModes"`
	// allocatedResourceStatuses stores status of resource being resized for the given PVC.
	// Key names follow standard Kubernetes label syntax. Valid values are either:
	// 	* Un-prefixed keys:
	// 		- storage - the capacity of the volume.
	// 	* Custom resources must use implementation-defined prefixed names such as "example.com/my-custom-resource"
	// Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered
	// reserved and hence may not be used.
	//
	// ClaimResourceStatus can be in any of following states:
	// 	- ControllerResizeInProgress:
	// 		State set when resize controller starts resizing the volume in control-plane.
	// 	- ControllerResizeFailed:
	// 		State set when resize has failed in resize controller with a terminal error.
	// 	- NodeResizePending:
	// 		State set when resize controller has finished resizing the volume but further resizing of
	// 		volume is needed on the node.
	// 	- NodeResizeInProgress:
	// 		State set when kubelet starts resizing the volume.
	// 	- NodeResizeFailed:
	// 		State set when resizing has failed in kubelet with a terminal error. Transient errors don't set
	// 		NodeResizeFailed.
	// For example: if expanding a PVC for more capacity - this field can be one of the following states:
	// 	- pvc.status.allocatedResourceStatus['storage'] = "ControllerResizeInProgress"
	//      - pvc.status.allocatedResourceStatus['storage'] = "ControllerResizeFailed"
	//      - pvc.status.allocatedResourceStatus['storage'] = "NodeResizePending"
	//      - pvc.status.allocatedResourceStatus['storage'] = "NodeResizeInProgress"
	//      - pvc.status.allocatedResourceStatus['storage'] = "NodeResizeFailed"
	// When this field is not set, it means that no resize operation is in progress for the given PVC.
	//
	// A controller that receives PVC update with previously unknown resourceName or ClaimResourceStatus
	// should ignore the update for the purpose it was designed. For example - a controller that
	// only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid
	// resources associated with PVC.
	//
	// This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
	AllocatedResourceStatuses pulumi.StringMapInput `pulumi:"allocatedResourceStatuses"`
	// allocatedResources tracks the resources allocated to a PVC including its capacity.
	// Key names follow standard Kubernetes label syntax. Valid values are either:
	// 	* Un-prefixed keys:
	// 		- storage - the capacity of the volume.
	// 	* Custom resources must use implementation-defined prefixed names such as "example.com/my-custom-resource"
	// Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered
	// reserved and hence may not be used.
	//
	// Capacity reported here may be larger than the actual capacity when a volume expansion operation
	// is requested.
	// For storage quota, the larger value from allocatedResources and PVC.spec.resources is used.
	// If allocatedResources is not set, PVC.spec.resources alone is used for quota calculation.
	// If a volume expansion capacity request is lowered, allocatedResources is only
	// lowered if there are no expansion operations in progress and if the actual volume capacity
	// is equal or lower than the requested capacity.
	//
	// A controller that receives PVC update with previously unknown resourceName
	// should ignore the update for the purpose it was designed. For example - a controller that
	// only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid
	// resources associated with PVC.
	//
	// This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
	AllocatedResources pulumi.MapInput `pulumi:"allocatedResources"`
	// capacity represents the actual resources of the underlying volume.
	Capacity pulumi.MapInput `pulumi:"capacity"`
	// conditions is the current Condition of persistent volume claim. If underlying persistent volume is being
	// resized then the Condition will be set to 'Resizing'.
	Conditions LogstashSpecVolumeClaimTemplatesStatusConditionsArrayInput `pulumi:"conditions"`
	// currentVolumeAttributesClassName is the current name of the VolumeAttributesClass the PVC is using.
	// When unset, there is no VolumeAttributeClass applied to this PersistentVolumeClaim
	// This is an alpha field and requires enabling VolumeAttributesClass feature.
	CurrentVolumeAttributesClassName pulumi.StringPtrInput `pulumi:"currentVolumeAttributesClassName"`
	// ModifyVolumeStatus represents the status object of ControllerModifyVolume operation.
	// When this is unset, there is no ModifyVolume operation being attempted.
	// This is an alpha field and requires enabling VolumeAttributesClass feature.
	ModifyVolumeStatus LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrInput `pulumi:"modifyVolumeStatus"`
	// phase represents the current phase of PersistentVolumeClaim.
	Phase pulumi.StringPtrInput `pulumi:"phase"`
}

func (LogstashSpecVolumeClaimTemplatesStatusArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesStatus)(nil)).Elem()
}

func (i LogstashSpecVolumeClaimTemplatesStatusArgs) ToLogstashSpecVolumeClaimTemplatesStatusOutput() LogstashSpecVolumeClaimTemplatesStatusOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesStatusOutputWithContext(context.Background())
}

func (i LogstashSpecVolumeClaimTemplatesStatusArgs) ToLogstashSpecVolumeClaimTemplatesStatusOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesStatusOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesStatusOutput)
}

func (i LogstashSpecVolumeClaimTemplatesStatusArgs) ToLogstashSpecVolumeClaimTemplatesStatusPtrOutput() LogstashSpecVolumeClaimTemplatesStatusPtrOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesStatusPtrOutputWithContext(context.Background())
}

func (i LogstashSpecVolumeClaimTemplatesStatusArgs) ToLogstashSpecVolumeClaimTemplatesStatusPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesStatusOutput).ToLogstashSpecVolumeClaimTemplatesStatusPtrOutputWithContext(ctx)
}

// LogstashSpecVolumeClaimTemplatesStatusPtrInput is an input type that accepts LogstashSpecVolumeClaimTemplatesStatusArgs, LogstashSpecVolumeClaimTemplatesStatusPtr and LogstashSpecVolumeClaimTemplatesStatusPtrOutput values.
// You can construct a concrete instance of `LogstashSpecVolumeClaimTemplatesStatusPtrInput` via:
//
//	        LogstashSpecVolumeClaimTemplatesStatusArgs{...}
//
//	or:
//
//	        nil
type LogstashSpecVolumeClaimTemplatesStatusPtrInput interface {
	pulumi.Input

	ToLogstashSpecVolumeClaimTemplatesStatusPtrOutput() LogstashSpecVolumeClaimTemplatesStatusPtrOutput
	ToLogstashSpecVolumeClaimTemplatesStatusPtrOutputWithContext(context.Context) LogstashSpecVolumeClaimTemplatesStatusPtrOutput
}

type logstashSpecVolumeClaimTemplatesStatusPtrType LogstashSpecVolumeClaimTemplatesStatusArgs

func LogstashSpecVolumeClaimTemplatesStatusPtr(v *LogstashSpecVolumeClaimTemplatesStatusArgs) LogstashSpecVolumeClaimTemplatesStatusPtrInput {
	return (*logstashSpecVolumeClaimTemplatesStatusPtrType)(v)
}

func (*logstashSpecVolumeClaimTemplatesStatusPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecVolumeClaimTemplatesStatus)(nil)).Elem()
}

func (i *logstashSpecVolumeClaimTemplatesStatusPtrType) ToLogstashSpecVolumeClaimTemplatesStatusPtrOutput() LogstashSpecVolumeClaimTemplatesStatusPtrOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesStatusPtrOutputWithContext(context.Background())
}

func (i *logstashSpecVolumeClaimTemplatesStatusPtrType) ToLogstashSpecVolumeClaimTemplatesStatusPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesStatusPtrOutput)
}

// status represents the current information/status of a persistent volume claim.
// Read-only.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
type LogstashSpecVolumeClaimTemplatesStatusOutput struct{ *pulumi.OutputState }

func (LogstashSpecVolumeClaimTemplatesStatusOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesStatus)(nil)).Elem()
}

func (o LogstashSpecVolumeClaimTemplatesStatusOutput) ToLogstashSpecVolumeClaimTemplatesStatusOutput() LogstashSpecVolumeClaimTemplatesStatusOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesStatusOutput) ToLogstashSpecVolumeClaimTemplatesStatusOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesStatusOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesStatusOutput) ToLogstashSpecVolumeClaimTemplatesStatusPtrOutput() LogstashSpecVolumeClaimTemplatesStatusPtrOutput {
	return o.ToLogstashSpecVolumeClaimTemplatesStatusPtrOutputWithContext(context.Background())
}

func (o LogstashSpecVolumeClaimTemplatesStatusOutput) ToLogstashSpecVolumeClaimTemplatesStatusPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesStatusPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LogstashSpecVolumeClaimTemplatesStatus) *LogstashSpecVolumeClaimTemplatesStatus {
		return &v
	}).(LogstashSpecVolumeClaimTemplatesStatusPtrOutput)
}

// accessModes contains the actual access modes the volume backing the PVC has.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
func (o LogstashSpecVolumeClaimTemplatesStatusOutput) AccessModes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesStatus) []string { return v.AccessModes }).(pulumi.StringArrayOutput)
}

// allocatedResourceStatuses stores status of resource being resized for the given PVC.
// Key names follow standard Kubernetes label syntax. Valid values are either:
//   - Un-prefixed keys:
//   - storage - the capacity of the volume.
//   - Custom resources must use implementation-defined prefixed names such as "example.com/my-custom-resource"
//
// Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered
// reserved and hence may not be used.
//
// ClaimResourceStatus can be in any of following states:
//   - ControllerResizeInProgress:
//     State set when resize controller starts resizing the volume in control-plane.
//   - ControllerResizeFailed:
//     State set when resize has failed in resize controller with a terminal error.
//   - NodeResizePending:
//     State set when resize controller has finished resizing the volume but further resizing of
//     volume is needed on the node.
//   - NodeResizeInProgress:
//     State set when kubelet starts resizing the volume.
//   - NodeResizeFailed:
//     State set when resizing has failed in kubelet with a terminal error. Transient errors don't set
//     NodeResizeFailed.
//
// For example: if expanding a PVC for more capacity - this field can be one of the following states:
//   - pvc.status.allocatedResourceStatus['storage'] = "ControllerResizeInProgress"
//   - pvc.status.allocatedResourceStatus['storage'] = "ControllerResizeFailed"
//   - pvc.status.allocatedResourceStatus['storage'] = "NodeResizePending"
//   - pvc.status.allocatedResourceStatus['storage'] = "NodeResizeInProgress"
//   - pvc.status.allocatedResourceStatus['storage'] = "NodeResizeFailed"
//
// When this field is not set, it means that no resize operation is in progress for the given PVC.
//
// A controller that receives PVC update with previously unknown resourceName or ClaimResourceStatus
// should ignore the update for the purpose it was designed. For example - a controller that
// only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid
// resources associated with PVC.
//
// This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
func (o LogstashSpecVolumeClaimTemplatesStatusOutput) AllocatedResourceStatuses() pulumi.StringMapOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesStatus) map[string]string { return v.AllocatedResourceStatuses }).(pulumi.StringMapOutput)
}

// allocatedResources tracks the resources allocated to a PVC including its capacity.
// Key names follow standard Kubernetes label syntax. Valid values are either:
//   - Un-prefixed keys:
//   - storage - the capacity of the volume.
//   - Custom resources must use implementation-defined prefixed names such as "example.com/my-custom-resource"
//
// Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered
// reserved and hence may not be used.
//
// Capacity reported here may be larger than the actual capacity when a volume expansion operation
// is requested.
// For storage quota, the larger value from allocatedResources and PVC.spec.resources is used.
// If allocatedResources is not set, PVC.spec.resources alone is used for quota calculation.
// If a volume expansion capacity request is lowered, allocatedResources is only
// lowered if there are no expansion operations in progress and if the actual volume capacity
// is equal or lower than the requested capacity.
//
// A controller that receives PVC update with previously unknown resourceName
// should ignore the update for the purpose it was designed. For example - a controller that
// only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid
// resources associated with PVC.
//
// This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
func (o LogstashSpecVolumeClaimTemplatesStatusOutput) AllocatedResources() pulumi.MapOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesStatus) map[string]interface{} { return v.AllocatedResources }).(pulumi.MapOutput)
}

// capacity represents the actual resources of the underlying volume.
func (o LogstashSpecVolumeClaimTemplatesStatusOutput) Capacity() pulumi.MapOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesStatus) map[string]interface{} { return v.Capacity }).(pulumi.MapOutput)
}

// conditions is the current Condition of persistent volume claim. If underlying persistent volume is being
// resized then the Condition will be set to 'Resizing'.
func (o LogstashSpecVolumeClaimTemplatesStatusOutput) Conditions() LogstashSpecVolumeClaimTemplatesStatusConditionsArrayOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesStatus) []LogstashSpecVolumeClaimTemplatesStatusConditions {
		return v.Conditions
	}).(LogstashSpecVolumeClaimTemplatesStatusConditionsArrayOutput)
}

// currentVolumeAttributesClassName is the current name of the VolumeAttributesClass the PVC is using.
// When unset, there is no VolumeAttributeClass applied to this PersistentVolumeClaim
// This is an alpha field and requires enabling VolumeAttributesClass feature.
func (o LogstashSpecVolumeClaimTemplatesStatusOutput) CurrentVolumeAttributesClassName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesStatus) *string { return v.CurrentVolumeAttributesClassName }).(pulumi.StringPtrOutput)
}

// ModifyVolumeStatus represents the status object of ControllerModifyVolume operation.
// When this is unset, there is no ModifyVolume operation being attempted.
// This is an alpha field and requires enabling VolumeAttributesClass feature.
func (o LogstashSpecVolumeClaimTemplatesStatusOutput) ModifyVolumeStatus() LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesStatus) *LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatus {
		return v.ModifyVolumeStatus
	}).(LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrOutput)
}

// phase represents the current phase of PersistentVolumeClaim.
func (o LogstashSpecVolumeClaimTemplatesStatusOutput) Phase() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesStatus) *string { return v.Phase }).(pulumi.StringPtrOutput)
}

type LogstashSpecVolumeClaimTemplatesStatusPtrOutput struct{ *pulumi.OutputState }

func (LogstashSpecVolumeClaimTemplatesStatusPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecVolumeClaimTemplatesStatus)(nil)).Elem()
}

func (o LogstashSpecVolumeClaimTemplatesStatusPtrOutput) ToLogstashSpecVolumeClaimTemplatesStatusPtrOutput() LogstashSpecVolumeClaimTemplatesStatusPtrOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesStatusPtrOutput) ToLogstashSpecVolumeClaimTemplatesStatusPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesStatusPtrOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesStatusPtrOutput) Elem() LogstashSpecVolumeClaimTemplatesStatusOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesStatus) LogstashSpecVolumeClaimTemplatesStatus {
		if v != nil {
			return *v
		}
		var ret LogstashSpecVolumeClaimTemplatesStatus
		return ret
	}).(LogstashSpecVolumeClaimTemplatesStatusOutput)
}

// accessModes contains the actual access modes the volume backing the PVC has.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
func (o LogstashSpecVolumeClaimTemplatesStatusPtrOutput) AccessModes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesStatus) []string {
		if v == nil {
			return nil
		}
		return v.AccessModes
	}).(pulumi.StringArrayOutput)
}

// allocatedResourceStatuses stores status of resource being resized for the given PVC.
// Key names follow standard Kubernetes label syntax. Valid values are either:
//   - Un-prefixed keys:
//   - storage - the capacity of the volume.
//   - Custom resources must use implementation-defined prefixed names such as "example.com/my-custom-resource"
//
// Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered
// reserved and hence may not be used.
//
// ClaimResourceStatus can be in any of following states:
//   - ControllerResizeInProgress:
//     State set when resize controller starts resizing the volume in control-plane.
//   - ControllerResizeFailed:
//     State set when resize has failed in resize controller with a terminal error.
//   - NodeResizePending:
//     State set when resize controller has finished resizing the volume but further resizing of
//     volume is needed on the node.
//   - NodeResizeInProgress:
//     State set when kubelet starts resizing the volume.
//   - NodeResizeFailed:
//     State set when resizing has failed in kubelet with a terminal error. Transient errors don't set
//     NodeResizeFailed.
//
// For example: if expanding a PVC for more capacity - this field can be one of the following states:
//   - pvc.status.allocatedResourceStatus['storage'] = "ControllerResizeInProgress"
//   - pvc.status.allocatedResourceStatus['storage'] = "ControllerResizeFailed"
//   - pvc.status.allocatedResourceStatus['storage'] = "NodeResizePending"
//   - pvc.status.allocatedResourceStatus['storage'] = "NodeResizeInProgress"
//   - pvc.status.allocatedResourceStatus['storage'] = "NodeResizeFailed"
//
// When this field is not set, it means that no resize operation is in progress for the given PVC.
//
// A controller that receives PVC update with previously unknown resourceName or ClaimResourceStatus
// should ignore the update for the purpose it was designed. For example - a controller that
// only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid
// resources associated with PVC.
//
// This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
func (o LogstashSpecVolumeClaimTemplatesStatusPtrOutput) AllocatedResourceStatuses() pulumi.StringMapOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesStatus) map[string]string {
		if v == nil {
			return nil
		}
		return v.AllocatedResourceStatuses
	}).(pulumi.StringMapOutput)
}

// allocatedResources tracks the resources allocated to a PVC including its capacity.
// Key names follow standard Kubernetes label syntax. Valid values are either:
//   - Un-prefixed keys:
//   - storage - the capacity of the volume.
//   - Custom resources must use implementation-defined prefixed names such as "example.com/my-custom-resource"
//
// Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered
// reserved and hence may not be used.
//
// Capacity reported here may be larger than the actual capacity when a volume expansion operation
// is requested.
// For storage quota, the larger value from allocatedResources and PVC.spec.resources is used.
// If allocatedResources is not set, PVC.spec.resources alone is used for quota calculation.
// If a volume expansion capacity request is lowered, allocatedResources is only
// lowered if there are no expansion operations in progress and if the actual volume capacity
// is equal or lower than the requested capacity.
//
// A controller that receives PVC update with previously unknown resourceName
// should ignore the update for the purpose it was designed. For example - a controller that
// only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid
// resources associated with PVC.
//
// This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
func (o LogstashSpecVolumeClaimTemplatesStatusPtrOutput) AllocatedResources() pulumi.MapOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesStatus) map[string]interface{} {
		if v == nil {
			return nil
		}
		return v.AllocatedResources
	}).(pulumi.MapOutput)
}

// capacity represents the actual resources of the underlying volume.
func (o LogstashSpecVolumeClaimTemplatesStatusPtrOutput) Capacity() pulumi.MapOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesStatus) map[string]interface{} {
		if v == nil {
			return nil
		}
		return v.Capacity
	}).(pulumi.MapOutput)
}

// conditions is the current Condition of persistent volume claim. If underlying persistent volume is being
// resized then the Condition will be set to 'Resizing'.
func (o LogstashSpecVolumeClaimTemplatesStatusPtrOutput) Conditions() LogstashSpecVolumeClaimTemplatesStatusConditionsArrayOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesStatus) []LogstashSpecVolumeClaimTemplatesStatusConditions {
		if v == nil {
			return nil
		}
		return v.Conditions
	}).(LogstashSpecVolumeClaimTemplatesStatusConditionsArrayOutput)
}

// currentVolumeAttributesClassName is the current name of the VolumeAttributesClass the PVC is using.
// When unset, there is no VolumeAttributeClass applied to this PersistentVolumeClaim
// This is an alpha field and requires enabling VolumeAttributesClass feature.
func (o LogstashSpecVolumeClaimTemplatesStatusPtrOutput) CurrentVolumeAttributesClassName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesStatus) *string {
		if v == nil {
			return nil
		}
		return v.CurrentVolumeAttributesClassName
	}).(pulumi.StringPtrOutput)
}

// ModifyVolumeStatus represents the status object of ControllerModifyVolume operation.
// When this is unset, there is no ModifyVolume operation being attempted.
// This is an alpha field and requires enabling VolumeAttributesClass feature.
func (o LogstashSpecVolumeClaimTemplatesStatusPtrOutput) ModifyVolumeStatus() LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesStatus) *LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatus {
		if v == nil {
			return nil
		}
		return v.ModifyVolumeStatus
	}).(LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrOutput)
}

// phase represents the current phase of PersistentVolumeClaim.
func (o LogstashSpecVolumeClaimTemplatesStatusPtrOutput) Phase() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesStatus) *string {
		if v == nil {
			return nil
		}
		return v.Phase
	}).(pulumi.StringPtrOutput)
}

// allocatedResourceStatuses stores status of resource being resized for the given PVC.
// Key names follow standard Kubernetes label syntax. Valid values are either:
//   - Un-prefixed keys:
//   - storage - the capacity of the volume.
//   - Custom resources must use implementation-defined prefixed names such as "example.com/my-custom-resource"
//
// Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered
// reserved and hence may not be used.
//
// ClaimResourceStatus can be in any of following states:
//   - ControllerResizeInProgress:
//     State set when resize controller starts resizing the volume in control-plane.
//   - ControllerResizeFailed:
//     State set when resize has failed in resize controller with a terminal error.
//   - NodeResizePending:
//     State set when resize controller has finished resizing the volume but further resizing of
//     volume is needed on the node.
//   - NodeResizeInProgress:
//     State set when kubelet starts resizing the volume.
//   - NodeResizeFailed:
//     State set when resizing has failed in kubelet with a terminal error. Transient errors don't set
//     NodeResizeFailed.
//
// For example: if expanding a PVC for more capacity - this field can be one of the following states:
//   - pvc.status.allocatedResourceStatus['storage'] = "ControllerResizeInProgress"
//   - pvc.status.allocatedResourceStatus['storage'] = "ControllerResizeFailed"
//   - pvc.status.allocatedResourceStatus['storage'] = "NodeResizePending"
//   - pvc.status.allocatedResourceStatus['storage'] = "NodeResizeInProgress"
//   - pvc.status.allocatedResourceStatus['storage'] = "NodeResizeFailed"
//
// When this field is not set, it means that no resize operation is in progress for the given PVC.
//
// A controller that receives PVC update with previously unknown resourceName or ClaimResourceStatus
// should ignore the update for the purpose it was designed. For example - a controller that
// only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid
// resources associated with PVC.
//
// This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
type LogstashSpecVolumeClaimTemplatesStatusAllocatedResourceStatuses struct {
}

// allocatedResources tracks the resources allocated to a PVC including its capacity.
// Key names follow standard Kubernetes label syntax. Valid values are either:
//   - Un-prefixed keys:
//   - storage - the capacity of the volume.
//   - Custom resources must use implementation-defined prefixed names such as "example.com/my-custom-resource"
//
// Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered
// reserved and hence may not be used.
//
// Capacity reported here may be larger than the actual capacity when a volume expansion operation
// is requested.
// For storage quota, the larger value from allocatedResources and PVC.spec.resources is used.
// If allocatedResources is not set, PVC.spec.resources alone is used for quota calculation.
// If a volume expansion capacity request is lowered, allocatedResources is only
// lowered if there are no expansion operations in progress and if the actual volume capacity
// is equal or lower than the requested capacity.
//
// A controller that receives PVC update with previously unknown resourceName
// should ignore the update for the purpose it was designed. For example - a controller that
// only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid
// resources associated with PVC.
//
// This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
type LogstashSpecVolumeClaimTemplatesStatusAllocatedResources struct {
}

// capacity represents the actual resources of the underlying volume.
type LogstashSpecVolumeClaimTemplatesStatusCapacity struct {
}

// PersistentVolumeClaimCondition contains details about state of pvc
type LogstashSpecVolumeClaimTemplatesStatusConditions struct {
	// lastProbeTime is the time we probed the condition.
	LastProbeTime *string `pulumi:"lastProbeTime"`
	// lastTransitionTime is the time the condition transitioned from one status to another.
	LastTransitionTime *string `pulumi:"lastTransitionTime"`
	// message is the human-readable message indicating details about last transition.
	Message *string `pulumi:"message"`
	// reason is a unique, this should be a short, machine understandable string that gives the reason
	// for condition's last transition. If it reports "Resizing" that means the underlying
	// persistent volume is being resized.
	Reason *string `pulumi:"reason"`
	Status string  `pulumi:"status"`
	// PersistentVolumeClaimConditionType is a valid value of PersistentVolumeClaimCondition.Type
	Type string `pulumi:"type"`
}

// LogstashSpecVolumeClaimTemplatesStatusConditionsInput is an input type that accepts LogstashSpecVolumeClaimTemplatesStatusConditionsArgs and LogstashSpecVolumeClaimTemplatesStatusConditionsOutput values.
// You can construct a concrete instance of `LogstashSpecVolumeClaimTemplatesStatusConditionsInput` via:
//
//	LogstashSpecVolumeClaimTemplatesStatusConditionsArgs{...}
type LogstashSpecVolumeClaimTemplatesStatusConditionsInput interface {
	pulumi.Input

	ToLogstashSpecVolumeClaimTemplatesStatusConditionsOutput() LogstashSpecVolumeClaimTemplatesStatusConditionsOutput
	ToLogstashSpecVolumeClaimTemplatesStatusConditionsOutputWithContext(context.Context) LogstashSpecVolumeClaimTemplatesStatusConditionsOutput
}

// PersistentVolumeClaimCondition contains details about state of pvc
type LogstashSpecVolumeClaimTemplatesStatusConditionsArgs struct {
	// lastProbeTime is the time we probed the condition.
	LastProbeTime pulumi.StringPtrInput `pulumi:"lastProbeTime"`
	// lastTransitionTime is the time the condition transitioned from one status to another.
	LastTransitionTime pulumi.StringPtrInput `pulumi:"lastTransitionTime"`
	// message is the human-readable message indicating details about last transition.
	Message pulumi.StringPtrInput `pulumi:"message"`
	// reason is a unique, this should be a short, machine understandable string that gives the reason
	// for condition's last transition. If it reports "Resizing" that means the underlying
	// persistent volume is being resized.
	Reason pulumi.StringPtrInput `pulumi:"reason"`
	Status pulumi.StringInput    `pulumi:"status"`
	// PersistentVolumeClaimConditionType is a valid value of PersistentVolumeClaimCondition.Type
	Type pulumi.StringInput `pulumi:"type"`
}

func (LogstashSpecVolumeClaimTemplatesStatusConditionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesStatusConditions)(nil)).Elem()
}

func (i LogstashSpecVolumeClaimTemplatesStatusConditionsArgs) ToLogstashSpecVolumeClaimTemplatesStatusConditionsOutput() LogstashSpecVolumeClaimTemplatesStatusConditionsOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesStatusConditionsOutputWithContext(context.Background())
}

func (i LogstashSpecVolumeClaimTemplatesStatusConditionsArgs) ToLogstashSpecVolumeClaimTemplatesStatusConditionsOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesStatusConditionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesStatusConditionsOutput)
}

// LogstashSpecVolumeClaimTemplatesStatusConditionsArrayInput is an input type that accepts LogstashSpecVolumeClaimTemplatesStatusConditionsArray and LogstashSpecVolumeClaimTemplatesStatusConditionsArrayOutput values.
// You can construct a concrete instance of `LogstashSpecVolumeClaimTemplatesStatusConditionsArrayInput` via:
//
//	LogstashSpecVolumeClaimTemplatesStatusConditionsArray{ LogstashSpecVolumeClaimTemplatesStatusConditionsArgs{...} }
type LogstashSpecVolumeClaimTemplatesStatusConditionsArrayInput interface {
	pulumi.Input

	ToLogstashSpecVolumeClaimTemplatesStatusConditionsArrayOutput() LogstashSpecVolumeClaimTemplatesStatusConditionsArrayOutput
	ToLogstashSpecVolumeClaimTemplatesStatusConditionsArrayOutputWithContext(context.Context) LogstashSpecVolumeClaimTemplatesStatusConditionsArrayOutput
}

type LogstashSpecVolumeClaimTemplatesStatusConditionsArray []LogstashSpecVolumeClaimTemplatesStatusConditionsInput

func (LogstashSpecVolumeClaimTemplatesStatusConditionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LogstashSpecVolumeClaimTemplatesStatusConditions)(nil)).Elem()
}

func (i LogstashSpecVolumeClaimTemplatesStatusConditionsArray) ToLogstashSpecVolumeClaimTemplatesStatusConditionsArrayOutput() LogstashSpecVolumeClaimTemplatesStatusConditionsArrayOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesStatusConditionsArrayOutputWithContext(context.Background())
}

func (i LogstashSpecVolumeClaimTemplatesStatusConditionsArray) ToLogstashSpecVolumeClaimTemplatesStatusConditionsArrayOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesStatusConditionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesStatusConditionsArrayOutput)
}

// PersistentVolumeClaimCondition contains details about state of pvc
type LogstashSpecVolumeClaimTemplatesStatusConditionsOutput struct{ *pulumi.OutputState }

func (LogstashSpecVolumeClaimTemplatesStatusConditionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesStatusConditions)(nil)).Elem()
}

func (o LogstashSpecVolumeClaimTemplatesStatusConditionsOutput) ToLogstashSpecVolumeClaimTemplatesStatusConditionsOutput() LogstashSpecVolumeClaimTemplatesStatusConditionsOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesStatusConditionsOutput) ToLogstashSpecVolumeClaimTemplatesStatusConditionsOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesStatusConditionsOutput {
	return o
}

// lastProbeTime is the time we probed the condition.
func (o LogstashSpecVolumeClaimTemplatesStatusConditionsOutput) LastProbeTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesStatusConditions) *string { return v.LastProbeTime }).(pulumi.StringPtrOutput)
}

// lastTransitionTime is the time the condition transitioned from one status to another.
func (o LogstashSpecVolumeClaimTemplatesStatusConditionsOutput) LastTransitionTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesStatusConditions) *string { return v.LastTransitionTime }).(pulumi.StringPtrOutput)
}

// message is the human-readable message indicating details about last transition.
func (o LogstashSpecVolumeClaimTemplatesStatusConditionsOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesStatusConditions) *string { return v.Message }).(pulumi.StringPtrOutput)
}

// reason is a unique, this should be a short, machine understandable string that gives the reason
// for condition's last transition. If it reports "Resizing" that means the underlying
// persistent volume is being resized.
func (o LogstashSpecVolumeClaimTemplatesStatusConditionsOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesStatusConditions) *string { return v.Reason }).(pulumi.StringPtrOutput)
}

func (o LogstashSpecVolumeClaimTemplatesStatusConditionsOutput) Status() pulumi.StringOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesStatusConditions) string { return v.Status }).(pulumi.StringOutput)
}

// PersistentVolumeClaimConditionType is a valid value of PersistentVolumeClaimCondition.Type
func (o LogstashSpecVolumeClaimTemplatesStatusConditionsOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesStatusConditions) string { return v.Type }).(pulumi.StringOutput)
}

type LogstashSpecVolumeClaimTemplatesStatusConditionsArrayOutput struct{ *pulumi.OutputState }

func (LogstashSpecVolumeClaimTemplatesStatusConditionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LogstashSpecVolumeClaimTemplatesStatusConditions)(nil)).Elem()
}

func (o LogstashSpecVolumeClaimTemplatesStatusConditionsArrayOutput) ToLogstashSpecVolumeClaimTemplatesStatusConditionsArrayOutput() LogstashSpecVolumeClaimTemplatesStatusConditionsArrayOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesStatusConditionsArrayOutput) ToLogstashSpecVolumeClaimTemplatesStatusConditionsArrayOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesStatusConditionsArrayOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesStatusConditionsArrayOutput) Index(i pulumi.IntInput) LogstashSpecVolumeClaimTemplatesStatusConditionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LogstashSpecVolumeClaimTemplatesStatusConditions {
		return vs[0].([]LogstashSpecVolumeClaimTemplatesStatusConditions)[vs[1].(int)]
	}).(LogstashSpecVolumeClaimTemplatesStatusConditionsOutput)
}

// ModifyVolumeStatus represents the status object of ControllerModifyVolume operation.
// When this is unset, there is no ModifyVolume operation being attempted.
// This is an alpha field and requires enabling VolumeAttributesClass feature.
type LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatus struct {
	// status is the status of the ControllerModifyVolume operation. It can be in any of following states:
	//  - Pending
	//    Pending indicates that the PersistentVolumeClaim cannot be modified due to unmet requirements, such as
	//    the specified VolumeAttributesClass not existing.
	//  - InProgress
	//    InProgress indicates that the volume is being modified.
	//  - Infeasible
	//      Infeasible indicates that the request has been rejected as invalid by the CSI driver. To
	//       resolve the error, a valid VolumeAttributesClass needs to be specified.
	//    Note: New statuses can be added in the future. Consumers should check for unknown statuses and fail appropriately.
	Status string `pulumi:"status"`
	// targetVolumeAttributesClassName is the name of the VolumeAttributesClass the PVC currently being reconciled
	TargetVolumeAttributesClassName *string `pulumi:"targetVolumeAttributesClassName"`
}

// LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusInput is an input type that accepts LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusArgs and LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusOutput values.
// You can construct a concrete instance of `LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusInput` via:
//
//	LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusArgs{...}
type LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusInput interface {
	pulumi.Input

	ToLogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusOutput() LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusOutput
	ToLogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusOutputWithContext(context.Context) LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusOutput
}

// ModifyVolumeStatus represents the status object of ControllerModifyVolume operation.
// When this is unset, there is no ModifyVolume operation being attempted.
// This is an alpha field and requires enabling VolumeAttributesClass feature.
type LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusArgs struct {
	// status is the status of the ControllerModifyVolume operation. It can be in any of following states:
	//  - Pending
	//    Pending indicates that the PersistentVolumeClaim cannot be modified due to unmet requirements, such as
	//    the specified VolumeAttributesClass not existing.
	//  - InProgress
	//    InProgress indicates that the volume is being modified.
	//  - Infeasible
	//      Infeasible indicates that the request has been rejected as invalid by the CSI driver. To
	//       resolve the error, a valid VolumeAttributesClass needs to be specified.
	//    Note: New statuses can be added in the future. Consumers should check for unknown statuses and fail appropriately.
	Status pulumi.StringInput `pulumi:"status"`
	// targetVolumeAttributesClassName is the name of the VolumeAttributesClass the PVC currently being reconciled
	TargetVolumeAttributesClassName pulumi.StringPtrInput `pulumi:"targetVolumeAttributesClassName"`
}

func (LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatus)(nil)).Elem()
}

func (i LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusArgs) ToLogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusOutput() LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusOutputWithContext(context.Background())
}

func (i LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusArgs) ToLogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusOutput)
}

func (i LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusArgs) ToLogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrOutput() LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrOutputWithContext(context.Background())
}

func (i LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusArgs) ToLogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusOutput).ToLogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrOutputWithContext(ctx)
}

// LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrInput is an input type that accepts LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusArgs, LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtr and LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrOutput values.
// You can construct a concrete instance of `LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrInput` via:
//
//	        LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusArgs{...}
//
//	or:
//
//	        nil
type LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrInput interface {
	pulumi.Input

	ToLogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrOutput() LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrOutput
	ToLogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrOutputWithContext(context.Context) LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrOutput
}

type logstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrType LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusArgs

func LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtr(v *LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusArgs) LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrInput {
	return (*logstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrType)(v)
}

func (*logstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatus)(nil)).Elem()
}

func (i *logstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrType) ToLogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrOutput() LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrOutput {
	return i.ToLogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrOutputWithContext(context.Background())
}

func (i *logstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrType) ToLogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrOutput)
}

// ModifyVolumeStatus represents the status object of ControllerModifyVolume operation.
// When this is unset, there is no ModifyVolume operation being attempted.
// This is an alpha field and requires enabling VolumeAttributesClass feature.
type LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusOutput struct{ *pulumi.OutputState }

func (LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatus)(nil)).Elem()
}

func (o LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusOutput) ToLogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusOutput() LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusOutput) ToLogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusOutput) ToLogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrOutput() LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrOutput {
	return o.ToLogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrOutputWithContext(context.Background())
}

func (o LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusOutput) ToLogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatus) *LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatus {
		return &v
	}).(LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrOutput)
}

// status is the status of the ControllerModifyVolume operation. It can be in any of following states:
//   - Pending
//     Pending indicates that the PersistentVolumeClaim cannot be modified due to unmet requirements, such as
//     the specified VolumeAttributesClass not existing.
//   - InProgress
//     InProgress indicates that the volume is being modified.
//   - Infeasible
//     Infeasible indicates that the request has been rejected as invalid by the CSI driver. To
//     resolve the error, a valid VolumeAttributesClass needs to be specified.
//     Note: New statuses can be added in the future. Consumers should check for unknown statuses and fail appropriately.
func (o LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusOutput) Status() pulumi.StringOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatus) string { return v.Status }).(pulumi.StringOutput)
}

// targetVolumeAttributesClassName is the name of the VolumeAttributesClass the PVC currently being reconciled
func (o LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusOutput) TargetVolumeAttributesClassName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatus) *string {
		return v.TargetVolumeAttributesClassName
	}).(pulumi.StringPtrOutput)
}

type LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrOutput struct{ *pulumi.OutputState }

func (LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatus)(nil)).Elem()
}

func (o LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrOutput) ToLogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrOutput() LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrOutput) ToLogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrOutputWithContext(ctx context.Context) LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrOutput {
	return o
}

func (o LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrOutput) Elem() LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatus) LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatus {
		if v != nil {
			return *v
		}
		var ret LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatus
		return ret
	}).(LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusOutput)
}

// status is the status of the ControllerModifyVolume operation. It can be in any of following states:
//   - Pending
//     Pending indicates that the PersistentVolumeClaim cannot be modified due to unmet requirements, such as
//     the specified VolumeAttributesClass not existing.
//   - InProgress
//     InProgress indicates that the volume is being modified.
//   - Infeasible
//     Infeasible indicates that the request has been rejected as invalid by the CSI driver. To
//     resolve the error, a valid VolumeAttributesClass needs to be specified.
//     Note: New statuses can be added in the future. Consumers should check for unknown statuses and fail appropriately.
func (o LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatus) *string {
		if v == nil {
			return nil
		}
		return &v.Status
	}).(pulumi.StringPtrOutput)
}

// targetVolumeAttributesClassName is the name of the VolumeAttributesClass the PVC currently being reconciled
func (o LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrOutput) TargetVolumeAttributesClassName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatus) *string {
		if v == nil {
			return nil
		}
		return v.TargetVolumeAttributesClassName
	}).(pulumi.StringPtrOutput)
}

// LogstashStatus defines the observed state of Logstash
type LogstashStatus struct {
	AvailableNodes *int `pulumi:"availableNodes"`
	// ElasticsearchAssociationStatus is the status of any auto-linking to Elasticsearch clusters.
	ElasticsearchAssociationsStatus map[string]string `pulumi:"elasticsearchAssociationsStatus"`
	ExpectedNodes                   *int              `pulumi:"expectedNodes"`
	Health                          *string           `pulumi:"health"`
	// MonitoringAssociationStatus is the status of any auto-linking to monitoring Elasticsearch clusters.
	MonitoringAssociationStatus map[string]string `pulumi:"monitoringAssociationStatus"`
	// ObservedGeneration is the most recent generation observed for this Logstash instance.
	// It corresponds to the metadata generation, which is updated on mutation by the API Server.
	// If the generation observed in status diverges from the generation in metadata, the Logstash
	// controller has not yet processed the changes contained in the Logstash specification.
	ObservedGeneration *int   `pulumi:"observedGeneration"`
	Selector           string `pulumi:"selector"`
	// Version of the stack resource currently running. During version upgrades, multiple versions may run
	// in parallel: this value specifies the lowest version currently running.
	Version *string `pulumi:"version"`
}

// LogstashStatusInput is an input type that accepts LogstashStatusArgs and LogstashStatusOutput values.
// You can construct a concrete instance of `LogstashStatusInput` via:
//
//	LogstashStatusArgs{...}
type LogstashStatusInput interface {
	pulumi.Input

	ToLogstashStatusOutput() LogstashStatusOutput
	ToLogstashStatusOutputWithContext(context.Context) LogstashStatusOutput
}

// LogstashStatus defines the observed state of Logstash
type LogstashStatusArgs struct {
	AvailableNodes pulumi.IntPtrInput `pulumi:"availableNodes"`
	// ElasticsearchAssociationStatus is the status of any auto-linking to Elasticsearch clusters.
	ElasticsearchAssociationsStatus pulumi.StringMapInput `pulumi:"elasticsearchAssociationsStatus"`
	ExpectedNodes                   pulumi.IntPtrInput    `pulumi:"expectedNodes"`
	Health                          pulumi.StringPtrInput `pulumi:"health"`
	// MonitoringAssociationStatus is the status of any auto-linking to monitoring Elasticsearch clusters.
	MonitoringAssociationStatus pulumi.StringMapInput `pulumi:"monitoringAssociationStatus"`
	// ObservedGeneration is the most recent generation observed for this Logstash instance.
	// It corresponds to the metadata generation, which is updated on mutation by the API Server.
	// If the generation observed in status diverges from the generation in metadata, the Logstash
	// controller has not yet processed the changes contained in the Logstash specification.
	ObservedGeneration pulumi.IntPtrInput `pulumi:"observedGeneration"`
	Selector           pulumi.StringInput `pulumi:"selector"`
	// Version of the stack resource currently running. During version upgrades, multiple versions may run
	// in parallel: this value specifies the lowest version currently running.
	Version pulumi.StringPtrInput `pulumi:"version"`
}

func (LogstashStatusArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashStatus)(nil)).Elem()
}

func (i LogstashStatusArgs) ToLogstashStatusOutput() LogstashStatusOutput {
	return i.ToLogstashStatusOutputWithContext(context.Background())
}

func (i LogstashStatusArgs) ToLogstashStatusOutputWithContext(ctx context.Context) LogstashStatusOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashStatusOutput)
}

func (i LogstashStatusArgs) ToLogstashStatusPtrOutput() LogstashStatusPtrOutput {
	return i.ToLogstashStatusPtrOutputWithContext(context.Background())
}

func (i LogstashStatusArgs) ToLogstashStatusPtrOutputWithContext(ctx context.Context) LogstashStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashStatusOutput).ToLogstashStatusPtrOutputWithContext(ctx)
}

// LogstashStatusPtrInput is an input type that accepts LogstashStatusArgs, LogstashStatusPtr and LogstashStatusPtrOutput values.
// You can construct a concrete instance of `LogstashStatusPtrInput` via:
//
//	        LogstashStatusArgs{...}
//
//	or:
//
//	        nil
type LogstashStatusPtrInput interface {
	pulumi.Input

	ToLogstashStatusPtrOutput() LogstashStatusPtrOutput
	ToLogstashStatusPtrOutputWithContext(context.Context) LogstashStatusPtrOutput
}

type logstashStatusPtrType LogstashStatusArgs

func LogstashStatusPtr(v *LogstashStatusArgs) LogstashStatusPtrInput {
	return (*logstashStatusPtrType)(v)
}

func (*logstashStatusPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashStatus)(nil)).Elem()
}

func (i *logstashStatusPtrType) ToLogstashStatusPtrOutput() LogstashStatusPtrOutput {
	return i.ToLogstashStatusPtrOutputWithContext(context.Background())
}

func (i *logstashStatusPtrType) ToLogstashStatusPtrOutputWithContext(ctx context.Context) LogstashStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogstashStatusPtrOutput)
}

// LogstashStatus defines the observed state of Logstash
type LogstashStatusOutput struct{ *pulumi.OutputState }

func (LogstashStatusOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogstashStatus)(nil)).Elem()
}

func (o LogstashStatusOutput) ToLogstashStatusOutput() LogstashStatusOutput {
	return o
}

func (o LogstashStatusOutput) ToLogstashStatusOutputWithContext(ctx context.Context) LogstashStatusOutput {
	return o
}

func (o LogstashStatusOutput) ToLogstashStatusPtrOutput() LogstashStatusPtrOutput {
	return o.ToLogstashStatusPtrOutputWithContext(context.Background())
}

func (o LogstashStatusOutput) ToLogstashStatusPtrOutputWithContext(ctx context.Context) LogstashStatusPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LogstashStatus) *LogstashStatus {
		return &v
	}).(LogstashStatusPtrOutput)
}

func (o LogstashStatusOutput) AvailableNodes() pulumi.IntPtrOutput {
	return o.ApplyT(func(v LogstashStatus) *int { return v.AvailableNodes }).(pulumi.IntPtrOutput)
}

// ElasticsearchAssociationStatus is the status of any auto-linking to Elasticsearch clusters.
func (o LogstashStatusOutput) ElasticsearchAssociationsStatus() pulumi.StringMapOutput {
	return o.ApplyT(func(v LogstashStatus) map[string]string { return v.ElasticsearchAssociationsStatus }).(pulumi.StringMapOutput)
}

func (o LogstashStatusOutput) ExpectedNodes() pulumi.IntPtrOutput {
	return o.ApplyT(func(v LogstashStatus) *int { return v.ExpectedNodes }).(pulumi.IntPtrOutput)
}

func (o LogstashStatusOutput) Health() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashStatus) *string { return v.Health }).(pulumi.StringPtrOutput)
}

// MonitoringAssociationStatus is the status of any auto-linking to monitoring Elasticsearch clusters.
func (o LogstashStatusOutput) MonitoringAssociationStatus() pulumi.StringMapOutput {
	return o.ApplyT(func(v LogstashStatus) map[string]string { return v.MonitoringAssociationStatus }).(pulumi.StringMapOutput)
}

// ObservedGeneration is the most recent generation observed for this Logstash instance.
// It corresponds to the metadata generation, which is updated on mutation by the API Server.
// If the generation observed in status diverges from the generation in metadata, the Logstash
// controller has not yet processed the changes contained in the Logstash specification.
func (o LogstashStatusOutput) ObservedGeneration() pulumi.IntPtrOutput {
	return o.ApplyT(func(v LogstashStatus) *int { return v.ObservedGeneration }).(pulumi.IntPtrOutput)
}

func (o LogstashStatusOutput) Selector() pulumi.StringOutput {
	return o.ApplyT(func(v LogstashStatus) string { return v.Selector }).(pulumi.StringOutput)
}

// Version of the stack resource currently running. During version upgrades, multiple versions may run
// in parallel: this value specifies the lowest version currently running.
func (o LogstashStatusOutput) Version() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogstashStatus) *string { return v.Version }).(pulumi.StringPtrOutput)
}

type LogstashStatusPtrOutput struct{ *pulumi.OutputState }

func (LogstashStatusPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogstashStatus)(nil)).Elem()
}

func (o LogstashStatusPtrOutput) ToLogstashStatusPtrOutput() LogstashStatusPtrOutput {
	return o
}

func (o LogstashStatusPtrOutput) ToLogstashStatusPtrOutputWithContext(ctx context.Context) LogstashStatusPtrOutput {
	return o
}

func (o LogstashStatusPtrOutput) Elem() LogstashStatusOutput {
	return o.ApplyT(func(v *LogstashStatus) LogstashStatus {
		if v != nil {
			return *v
		}
		var ret LogstashStatus
		return ret
	}).(LogstashStatusOutput)
}

func (o LogstashStatusPtrOutput) AvailableNodes() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *LogstashStatus) *int {
		if v == nil {
			return nil
		}
		return v.AvailableNodes
	}).(pulumi.IntPtrOutput)
}

// ElasticsearchAssociationStatus is the status of any auto-linking to Elasticsearch clusters.
func (o LogstashStatusPtrOutput) ElasticsearchAssociationsStatus() pulumi.StringMapOutput {
	return o.ApplyT(func(v *LogstashStatus) map[string]string {
		if v == nil {
			return nil
		}
		return v.ElasticsearchAssociationsStatus
	}).(pulumi.StringMapOutput)
}

func (o LogstashStatusPtrOutput) ExpectedNodes() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *LogstashStatus) *int {
		if v == nil {
			return nil
		}
		return v.ExpectedNodes
	}).(pulumi.IntPtrOutput)
}

func (o LogstashStatusPtrOutput) Health() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashStatus) *string {
		if v == nil {
			return nil
		}
		return v.Health
	}).(pulumi.StringPtrOutput)
}

// MonitoringAssociationStatus is the status of any auto-linking to monitoring Elasticsearch clusters.
func (o LogstashStatusPtrOutput) MonitoringAssociationStatus() pulumi.StringMapOutput {
	return o.ApplyT(func(v *LogstashStatus) map[string]string {
		if v == nil {
			return nil
		}
		return v.MonitoringAssociationStatus
	}).(pulumi.StringMapOutput)
}

// ObservedGeneration is the most recent generation observed for this Logstash instance.
// It corresponds to the metadata generation, which is updated on mutation by the API Server.
// If the generation observed in status diverges from the generation in metadata, the Logstash
// controller has not yet processed the changes contained in the Logstash specification.
func (o LogstashStatusPtrOutput) ObservedGeneration() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *LogstashStatus) *int {
		if v == nil {
			return nil
		}
		return v.ObservedGeneration
	}).(pulumi.IntPtrOutput)
}

func (o LogstashStatusPtrOutput) Selector() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashStatus) *string {
		if v == nil {
			return nil
		}
		return &v.Selector
	}).(pulumi.StringPtrOutput)
}

// Version of the stack resource currently running. During version upgrades, multiple versions may run
// in parallel: this value specifies the lowest version currently running.
func (o LogstashStatusPtrOutput) Version() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogstashStatus) *string {
		if v == nil {
			return nil
		}
		return v.Version
	}).(pulumi.StringPtrOutput)
}

// ElasticsearchAssociationStatus is the status of any auto-linking to Elasticsearch clusters.
type LogstashStatusElasticsearchAssociationsStatus struct {
}

// MonitoringAssociationStatus is the status of any auto-linking to monitoring Elasticsearch clusters.
type LogstashStatusMonitoringAssociationStatus struct {
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecInput)(nil)).Elem(), LogstashSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecPtrInput)(nil)).Elem(), LogstashSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecConfigRefInput)(nil)).Elem(), LogstashSpecConfigRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecConfigRefPtrInput)(nil)).Elem(), LogstashSpecConfigRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecElasticsearchRefsInput)(nil)).Elem(), LogstashSpecElasticsearchRefsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecElasticsearchRefsArrayInput)(nil)).Elem(), LogstashSpecElasticsearchRefsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecMonitoringInput)(nil)).Elem(), LogstashSpecMonitoringArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecMonitoringPtrInput)(nil)).Elem(), LogstashSpecMonitoringArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecMonitoringLogsInput)(nil)).Elem(), LogstashSpecMonitoringLogsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecMonitoringLogsPtrInput)(nil)).Elem(), LogstashSpecMonitoringLogsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecMonitoringLogsElasticsearchRefsInput)(nil)).Elem(), LogstashSpecMonitoringLogsElasticsearchRefsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecMonitoringLogsElasticsearchRefsArrayInput)(nil)).Elem(), LogstashSpecMonitoringLogsElasticsearchRefsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecMonitoringMetricsInput)(nil)).Elem(), LogstashSpecMonitoringMetricsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecMonitoringMetricsPtrInput)(nil)).Elem(), LogstashSpecMonitoringMetricsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecMonitoringMetricsElasticsearchRefsInput)(nil)).Elem(), LogstashSpecMonitoringMetricsElasticsearchRefsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecMonitoringMetricsElasticsearchRefsArrayInput)(nil)).Elem(), LogstashSpecMonitoringMetricsElasticsearchRefsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecPipelinesRefInput)(nil)).Elem(), LogstashSpecPipelinesRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecPipelinesRefPtrInput)(nil)).Elem(), LogstashSpecPipelinesRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecSecureSettingsInput)(nil)).Elem(), LogstashSpecSecureSettingsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecSecureSettingsArrayInput)(nil)).Elem(), LogstashSpecSecureSettingsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecSecureSettingsEntriesInput)(nil)).Elem(), LogstashSpecSecureSettingsEntriesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecSecureSettingsEntriesArrayInput)(nil)).Elem(), LogstashSpecSecureSettingsEntriesArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecServicesInput)(nil)).Elem(), LogstashSpecServicesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecServicesArrayInput)(nil)).Elem(), LogstashSpecServicesArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecServicesServiceInput)(nil)).Elem(), LogstashSpecServicesServiceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecServicesServicePtrInput)(nil)).Elem(), LogstashSpecServicesServiceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecServicesServiceMetadataInput)(nil)).Elem(), LogstashSpecServicesServiceMetadataArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecServicesServiceMetadataPtrInput)(nil)).Elem(), LogstashSpecServicesServiceMetadataArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecServicesServiceSpecInput)(nil)).Elem(), LogstashSpecServicesServiceSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecServicesServiceSpecPtrInput)(nil)).Elem(), LogstashSpecServicesServiceSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecServicesServiceSpecPortsInput)(nil)).Elem(), LogstashSpecServicesServiceSpecPortsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecServicesServiceSpecPortsArrayInput)(nil)).Elem(), LogstashSpecServicesServiceSpecPortsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecServicesServiceSpecSessionAffinityConfigInput)(nil)).Elem(), LogstashSpecServicesServiceSpecSessionAffinityConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecServicesServiceSpecSessionAffinityConfigPtrInput)(nil)).Elem(), LogstashSpecServicesServiceSpecSessionAffinityConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecServicesServiceSpecSessionAffinityConfigClientIpInput)(nil)).Elem(), LogstashSpecServicesServiceSpecSessionAffinityConfigClientIpArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecServicesServiceSpecSessionAffinityConfigClientIpPtrInput)(nil)).Elem(), LogstashSpecServicesServiceSpecSessionAffinityConfigClientIpArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecServicesTlsInput)(nil)).Elem(), LogstashSpecServicesTlsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecServicesTlsPtrInput)(nil)).Elem(), LogstashSpecServicesTlsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecServicesTlsCertificateInput)(nil)).Elem(), LogstashSpecServicesTlsCertificateArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecServicesTlsCertificatePtrInput)(nil)).Elem(), LogstashSpecServicesTlsCertificateArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecServicesTlsSelfSignedCertificateInput)(nil)).Elem(), LogstashSpecServicesTlsSelfSignedCertificateArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecServicesTlsSelfSignedCertificatePtrInput)(nil)).Elem(), LogstashSpecServicesTlsSelfSignedCertificateArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesInput)(nil)).Elem(), LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArrayInput)(nil)).Elem(), LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecUpdateStrategyInput)(nil)).Elem(), LogstashSpecUpdateStrategyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecUpdateStrategyPtrInput)(nil)).Elem(), LogstashSpecUpdateStrategyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecUpdateStrategyRollingUpdateInput)(nil)).Elem(), LogstashSpecUpdateStrategyRollingUpdateArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecUpdateStrategyRollingUpdatePtrInput)(nil)).Elem(), LogstashSpecUpdateStrategyRollingUpdateArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesInput)(nil)).Elem(), LogstashSpecVolumeClaimTemplatesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesArrayInput)(nil)).Elem(), LogstashSpecVolumeClaimTemplatesArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesMetadataInput)(nil)).Elem(), LogstashSpecVolumeClaimTemplatesMetadataArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesMetadataPtrInput)(nil)).Elem(), LogstashSpecVolumeClaimTemplatesMetadataArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesSpecInput)(nil)).Elem(), LogstashSpecVolumeClaimTemplatesSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesSpecPtrInput)(nil)).Elem(), LogstashSpecVolumeClaimTemplatesSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesSpecDataSourceInput)(nil)).Elem(), LogstashSpecVolumeClaimTemplatesSpecDataSourceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesSpecDataSourcePtrInput)(nil)).Elem(), LogstashSpecVolumeClaimTemplatesSpecDataSourceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesSpecDataSourceRefInput)(nil)).Elem(), LogstashSpecVolumeClaimTemplatesSpecDataSourceRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrInput)(nil)).Elem(), LogstashSpecVolumeClaimTemplatesSpecDataSourceRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesSpecResourcesInput)(nil)).Elem(), LogstashSpecVolumeClaimTemplatesSpecResourcesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesSpecResourcesPtrInput)(nil)).Elem(), LogstashSpecVolumeClaimTemplatesSpecResourcesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesSpecSelectorInput)(nil)).Elem(), LogstashSpecVolumeClaimTemplatesSpecSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesSpecSelectorPtrInput)(nil)).Elem(), LogstashSpecVolumeClaimTemplatesSpecSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsInput)(nil)).Elem(), LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayInput)(nil)).Elem(), LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesStatusInput)(nil)).Elem(), LogstashSpecVolumeClaimTemplatesStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesStatusPtrInput)(nil)).Elem(), LogstashSpecVolumeClaimTemplatesStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesStatusConditionsInput)(nil)).Elem(), LogstashSpecVolumeClaimTemplatesStatusConditionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesStatusConditionsArrayInput)(nil)).Elem(), LogstashSpecVolumeClaimTemplatesStatusConditionsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusInput)(nil)).Elem(), LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrInput)(nil)).Elem(), LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashStatusInput)(nil)).Elem(), LogstashStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogstashStatusPtrInput)(nil)).Elem(), LogstashStatusArgs{})
	pulumi.RegisterOutputType(LogstashSpecOutput{})
	pulumi.RegisterOutputType(LogstashSpecPtrOutput{})
	pulumi.RegisterOutputType(LogstashSpecConfigRefOutput{})
	pulumi.RegisterOutputType(LogstashSpecConfigRefPtrOutput{})
	pulumi.RegisterOutputType(LogstashSpecElasticsearchRefsOutput{})
	pulumi.RegisterOutputType(LogstashSpecElasticsearchRefsArrayOutput{})
	pulumi.RegisterOutputType(LogstashSpecMonitoringOutput{})
	pulumi.RegisterOutputType(LogstashSpecMonitoringPtrOutput{})
	pulumi.RegisterOutputType(LogstashSpecMonitoringLogsOutput{})
	pulumi.RegisterOutputType(LogstashSpecMonitoringLogsPtrOutput{})
	pulumi.RegisterOutputType(LogstashSpecMonitoringLogsElasticsearchRefsOutput{})
	pulumi.RegisterOutputType(LogstashSpecMonitoringLogsElasticsearchRefsArrayOutput{})
	pulumi.RegisterOutputType(LogstashSpecMonitoringMetricsOutput{})
	pulumi.RegisterOutputType(LogstashSpecMonitoringMetricsPtrOutput{})
	pulumi.RegisterOutputType(LogstashSpecMonitoringMetricsElasticsearchRefsOutput{})
	pulumi.RegisterOutputType(LogstashSpecMonitoringMetricsElasticsearchRefsArrayOutput{})
	pulumi.RegisterOutputType(LogstashSpecPipelinesRefOutput{})
	pulumi.RegisterOutputType(LogstashSpecPipelinesRefPtrOutput{})
	pulumi.RegisterOutputType(LogstashSpecSecureSettingsOutput{})
	pulumi.RegisterOutputType(LogstashSpecSecureSettingsArrayOutput{})
	pulumi.RegisterOutputType(LogstashSpecSecureSettingsEntriesOutput{})
	pulumi.RegisterOutputType(LogstashSpecSecureSettingsEntriesArrayOutput{})
	pulumi.RegisterOutputType(LogstashSpecServicesOutput{})
	pulumi.RegisterOutputType(LogstashSpecServicesArrayOutput{})
	pulumi.RegisterOutputType(LogstashSpecServicesServiceOutput{})
	pulumi.RegisterOutputType(LogstashSpecServicesServicePtrOutput{})
	pulumi.RegisterOutputType(LogstashSpecServicesServiceMetadataOutput{})
	pulumi.RegisterOutputType(LogstashSpecServicesServiceMetadataPtrOutput{})
	pulumi.RegisterOutputType(LogstashSpecServicesServiceSpecOutput{})
	pulumi.RegisterOutputType(LogstashSpecServicesServiceSpecPtrOutput{})
	pulumi.RegisterOutputType(LogstashSpecServicesServiceSpecPortsOutput{})
	pulumi.RegisterOutputType(LogstashSpecServicesServiceSpecPortsArrayOutput{})
	pulumi.RegisterOutputType(LogstashSpecServicesServiceSpecSessionAffinityConfigOutput{})
	pulumi.RegisterOutputType(LogstashSpecServicesServiceSpecSessionAffinityConfigPtrOutput{})
	pulumi.RegisterOutputType(LogstashSpecServicesServiceSpecSessionAffinityConfigClientIpOutput{})
	pulumi.RegisterOutputType(LogstashSpecServicesServiceSpecSessionAffinityConfigClientIpPtrOutput{})
	pulumi.RegisterOutputType(LogstashSpecServicesTlsOutput{})
	pulumi.RegisterOutputType(LogstashSpecServicesTlsPtrOutput{})
	pulumi.RegisterOutputType(LogstashSpecServicesTlsCertificateOutput{})
	pulumi.RegisterOutputType(LogstashSpecServicesTlsCertificatePtrOutput{})
	pulumi.RegisterOutputType(LogstashSpecServicesTlsSelfSignedCertificateOutput{})
	pulumi.RegisterOutputType(LogstashSpecServicesTlsSelfSignedCertificatePtrOutput{})
	pulumi.RegisterOutputType(LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesOutput{})
	pulumi.RegisterOutputType(LogstashSpecServicesTlsSelfSignedCertificateSubjectAltNamesArrayOutput{})
	pulumi.RegisterOutputType(LogstashSpecUpdateStrategyOutput{})
	pulumi.RegisterOutputType(LogstashSpecUpdateStrategyPtrOutput{})
	pulumi.RegisterOutputType(LogstashSpecUpdateStrategyRollingUpdateOutput{})
	pulumi.RegisterOutputType(LogstashSpecUpdateStrategyRollingUpdatePtrOutput{})
	pulumi.RegisterOutputType(LogstashSpecVolumeClaimTemplatesOutput{})
	pulumi.RegisterOutputType(LogstashSpecVolumeClaimTemplatesArrayOutput{})
	pulumi.RegisterOutputType(LogstashSpecVolumeClaimTemplatesMetadataOutput{})
	pulumi.RegisterOutputType(LogstashSpecVolumeClaimTemplatesMetadataPtrOutput{})
	pulumi.RegisterOutputType(LogstashSpecVolumeClaimTemplatesSpecOutput{})
	pulumi.RegisterOutputType(LogstashSpecVolumeClaimTemplatesSpecPtrOutput{})
	pulumi.RegisterOutputType(LogstashSpecVolumeClaimTemplatesSpecDataSourceOutput{})
	pulumi.RegisterOutputType(LogstashSpecVolumeClaimTemplatesSpecDataSourcePtrOutput{})
	pulumi.RegisterOutputType(LogstashSpecVolumeClaimTemplatesSpecDataSourceRefOutput{})
	pulumi.RegisterOutputType(LogstashSpecVolumeClaimTemplatesSpecDataSourceRefPtrOutput{})
	pulumi.RegisterOutputType(LogstashSpecVolumeClaimTemplatesSpecResourcesOutput{})
	pulumi.RegisterOutputType(LogstashSpecVolumeClaimTemplatesSpecResourcesPtrOutput{})
	pulumi.RegisterOutputType(LogstashSpecVolumeClaimTemplatesSpecSelectorOutput{})
	pulumi.RegisterOutputType(LogstashSpecVolumeClaimTemplatesSpecSelectorPtrOutput{})
	pulumi.RegisterOutputType(LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsOutput{})
	pulumi.RegisterOutputType(LogstashSpecVolumeClaimTemplatesSpecSelectorMatchExpressionsArrayOutput{})
	pulumi.RegisterOutputType(LogstashSpecVolumeClaimTemplatesStatusOutput{})
	pulumi.RegisterOutputType(LogstashSpecVolumeClaimTemplatesStatusPtrOutput{})
	pulumi.RegisterOutputType(LogstashSpecVolumeClaimTemplatesStatusConditionsOutput{})
	pulumi.RegisterOutputType(LogstashSpecVolumeClaimTemplatesStatusConditionsArrayOutput{})
	pulumi.RegisterOutputType(LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusOutput{})
	pulumi.RegisterOutputType(LogstashSpecVolumeClaimTemplatesStatusModifyVolumeStatusPtrOutput{})
	pulumi.RegisterOutputType(LogstashStatusOutput{})
	pulumi.RegisterOutputType(LogstashStatusPtrOutput{})
}
