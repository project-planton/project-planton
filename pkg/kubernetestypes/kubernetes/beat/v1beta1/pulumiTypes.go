// Code generated by crd2pulumi DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package v1beta1

import (
	"context"
	"reflect"

	metav1 "github.com/pulumi/pulumi-kubernetes/sdk/v4/go/kubernetes/meta/v1"
	"github.com/pulumi/pulumi-kubernetes/sdk/v4/go/kubernetes/utilities"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

var _ = utilities.GetEnvOrDefault

// Beat is the Schema for the Beats API.
type BeatType struct {
	ApiVersion *string            `pulumi:"apiVersion"`
	Kind       *string            `pulumi:"kind"`
	Metadata   *metav1.ObjectMeta `pulumi:"metadata"`
	// BeatSpec defines the desired state of a Beat.
	Spec *BeatSpec `pulumi:"spec"`
	// BeatStatus defines the observed state of a Beat.
	Status *BeatStatus `pulumi:"status"`
}

type BeatMetadata struct {
}

// BeatSpec defines the desired state of a Beat.
type BeatSpec struct {
	// Config holds the Beat configuration. At most one of [`Config`, `ConfigRef`] can be specified.
	Config map[string]interface{} `pulumi:"config"`
	// ConfigRef contains a reference to an existing Kubernetes Secret holding the Beat configuration.
	// Beat settings must be specified as yaml, under a single "beat.yml" entry. At most one of [`Config`, `ConfigRef`]
	// can be specified.
	ConfigRef *BeatSpecConfigRef `pulumi:"configRef"`
	// DaemonSet specifies the Beat should be deployed as a DaemonSet, and allows providing its spec.
	// Cannot be used along with `deployment`. If both are absent a default for the Type is used.
	DaemonSet *BeatSpecDaemonSet `pulumi:"daemonSet"`
	// Deployment specifies the Beat should be deployed as a Deployment, and allows providing its spec.
	// Cannot be used along with `daemonSet`. If both are absent a default for the Type is used.
	Deployment *BeatSpecDeployment `pulumi:"deployment"`
	// ElasticsearchRef is a reference to an Elasticsearch cluster running in the same Kubernetes cluster.
	ElasticsearchRef *BeatSpecElasticsearchRef `pulumi:"elasticsearchRef"`
	// Image is the Beat Docker image to deploy. Version and Type have to match the Beat in the image.
	Image *string `pulumi:"image"`
	// KibanaRef is a reference to a Kibana instance running in the same Kubernetes cluster.
	// It allows automatic setup of dashboards and visualizations.
	KibanaRef *BeatSpecKibanaRef `pulumi:"kibanaRef"`
	// Monitoring enables you to collect and ship logs and metrics for this Beat.
	// Metricbeat and/or Filebeat sidecars are configured and send monitoring data to an
	// Elasticsearch monitoring cluster running in the same Kubernetes cluster.
	Monitoring *BeatSpecMonitoring `pulumi:"monitoring"`
	// RevisionHistoryLimit is the number of revisions to retain to allow rollback in the underlying DaemonSet or Deployment.
	RevisionHistoryLimit *int `pulumi:"revisionHistoryLimit"`
	// SecureSettings is a list of references to Kubernetes Secrets containing sensitive configuration options for the Beat.
	// Secrets data can be then referenced in the Beat config using the Secret's keys or as specified in `Entries` field of
	// each SecureSetting.
	SecureSettings []BeatSpecSecureSettings `pulumi:"secureSettings"`
	// ServiceAccountName is used to check access from the current resource to Elasticsearch resource in a different namespace.
	// Can only be used if ECK is enforcing RBAC on references.
	ServiceAccountName *string `pulumi:"serviceAccountName"`
	// Type is the type of the Beat to deploy (filebeat, metricbeat, heartbeat, auditbeat, journalbeat, packetbeat, and so on).
	// Any string can be used, but well-known types will have the image field defaulted and have the appropriate
	// Elasticsearch roles created automatically. It also allows for dashboard setup when combined with a `KibanaRef`.
	Type string `pulumi:"type"`
	// Version of the Beat.
	Version string `pulumi:"version"`
}

// BeatSpecInput is an input type that accepts BeatSpecArgs and BeatSpecOutput values.
// You can construct a concrete instance of `BeatSpecInput` via:
//
//	BeatSpecArgs{...}
type BeatSpecInput interface {
	pulumi.Input

	ToBeatSpecOutput() BeatSpecOutput
	ToBeatSpecOutputWithContext(context.Context) BeatSpecOutput
}

// BeatSpec defines the desired state of a Beat.
type BeatSpecArgs struct {
	// Config holds the Beat configuration. At most one of [`Config`, `ConfigRef`] can be specified.
	Config pulumi.MapInput `pulumi:"config"`
	// ConfigRef contains a reference to an existing Kubernetes Secret holding the Beat configuration.
	// Beat settings must be specified as yaml, under a single "beat.yml" entry. At most one of [`Config`, `ConfigRef`]
	// can be specified.
	ConfigRef BeatSpecConfigRefPtrInput `pulumi:"configRef"`
	// DaemonSet specifies the Beat should be deployed as a DaemonSet, and allows providing its spec.
	// Cannot be used along with `deployment`. If both are absent a default for the Type is used.
	DaemonSet BeatSpecDaemonSetPtrInput `pulumi:"daemonSet"`
	// Deployment specifies the Beat should be deployed as a Deployment, and allows providing its spec.
	// Cannot be used along with `daemonSet`. If both are absent a default for the Type is used.
	Deployment BeatSpecDeploymentPtrInput `pulumi:"deployment"`
	// ElasticsearchRef is a reference to an Elasticsearch cluster running in the same Kubernetes cluster.
	ElasticsearchRef BeatSpecElasticsearchRefPtrInput `pulumi:"elasticsearchRef"`
	// Image is the Beat Docker image to deploy. Version and Type have to match the Beat in the image.
	Image pulumi.StringPtrInput `pulumi:"image"`
	// KibanaRef is a reference to a Kibana instance running in the same Kubernetes cluster.
	// It allows automatic setup of dashboards and visualizations.
	KibanaRef BeatSpecKibanaRefPtrInput `pulumi:"kibanaRef"`
	// Monitoring enables you to collect and ship logs and metrics for this Beat.
	// Metricbeat and/or Filebeat sidecars are configured and send monitoring data to an
	// Elasticsearch monitoring cluster running in the same Kubernetes cluster.
	Monitoring BeatSpecMonitoringPtrInput `pulumi:"monitoring"`
	// RevisionHistoryLimit is the number of revisions to retain to allow rollback in the underlying DaemonSet or Deployment.
	RevisionHistoryLimit pulumi.IntPtrInput `pulumi:"revisionHistoryLimit"`
	// SecureSettings is a list of references to Kubernetes Secrets containing sensitive configuration options for the Beat.
	// Secrets data can be then referenced in the Beat config using the Secret's keys or as specified in `Entries` field of
	// each SecureSetting.
	SecureSettings BeatSpecSecureSettingsArrayInput `pulumi:"secureSettings"`
	// ServiceAccountName is used to check access from the current resource to Elasticsearch resource in a different namespace.
	// Can only be used if ECK is enforcing RBAC on references.
	ServiceAccountName pulumi.StringPtrInput `pulumi:"serviceAccountName"`
	// Type is the type of the Beat to deploy (filebeat, metricbeat, heartbeat, auditbeat, journalbeat, packetbeat, and so on).
	// Any string can be used, but well-known types will have the image field defaulted and have the appropriate
	// Elasticsearch roles created automatically. It also allows for dashboard setup when combined with a `KibanaRef`.
	Type pulumi.StringInput `pulumi:"type"`
	// Version of the Beat.
	Version pulumi.StringInput `pulumi:"version"`
}

func (BeatSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*BeatSpec)(nil)).Elem()
}

func (i BeatSpecArgs) ToBeatSpecOutput() BeatSpecOutput {
	return i.ToBeatSpecOutputWithContext(context.Background())
}

func (i BeatSpecArgs) ToBeatSpecOutputWithContext(ctx context.Context) BeatSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BeatSpecOutput)
}

func (i BeatSpecArgs) ToBeatSpecPtrOutput() BeatSpecPtrOutput {
	return i.ToBeatSpecPtrOutputWithContext(context.Background())
}

func (i BeatSpecArgs) ToBeatSpecPtrOutputWithContext(ctx context.Context) BeatSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BeatSpecOutput).ToBeatSpecPtrOutputWithContext(ctx)
}

// BeatSpecPtrInput is an input type that accepts BeatSpecArgs, BeatSpecPtr and BeatSpecPtrOutput values.
// You can construct a concrete instance of `BeatSpecPtrInput` via:
//
//	        BeatSpecArgs{...}
//
//	or:
//
//	        nil
type BeatSpecPtrInput interface {
	pulumi.Input

	ToBeatSpecPtrOutput() BeatSpecPtrOutput
	ToBeatSpecPtrOutputWithContext(context.Context) BeatSpecPtrOutput
}

type beatSpecPtrType BeatSpecArgs

func BeatSpecPtr(v *BeatSpecArgs) BeatSpecPtrInput {
	return (*beatSpecPtrType)(v)
}

func (*beatSpecPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**BeatSpec)(nil)).Elem()
}

func (i *beatSpecPtrType) ToBeatSpecPtrOutput() BeatSpecPtrOutput {
	return i.ToBeatSpecPtrOutputWithContext(context.Background())
}

func (i *beatSpecPtrType) ToBeatSpecPtrOutputWithContext(ctx context.Context) BeatSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BeatSpecPtrOutput)
}

// BeatSpec defines the desired state of a Beat.
type BeatSpecOutput struct{ *pulumi.OutputState }

func (BeatSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BeatSpec)(nil)).Elem()
}

func (o BeatSpecOutput) ToBeatSpecOutput() BeatSpecOutput {
	return o
}

func (o BeatSpecOutput) ToBeatSpecOutputWithContext(ctx context.Context) BeatSpecOutput {
	return o
}

func (o BeatSpecOutput) ToBeatSpecPtrOutput() BeatSpecPtrOutput {
	return o.ToBeatSpecPtrOutputWithContext(context.Background())
}

func (o BeatSpecOutput) ToBeatSpecPtrOutputWithContext(ctx context.Context) BeatSpecPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v BeatSpec) *BeatSpec {
		return &v
	}).(BeatSpecPtrOutput)
}

// Config holds the Beat configuration. At most one of [`Config`, `ConfigRef`] can be specified.
func (o BeatSpecOutput) Config() pulumi.MapOutput {
	return o.ApplyT(func(v BeatSpec) map[string]interface{} { return v.Config }).(pulumi.MapOutput)
}

// ConfigRef contains a reference to an existing Kubernetes Secret holding the Beat configuration.
// Beat settings must be specified as yaml, under a single "beat.yml" entry. At most one of [`Config`, `ConfigRef`]
// can be specified.
func (o BeatSpecOutput) ConfigRef() BeatSpecConfigRefPtrOutput {
	return o.ApplyT(func(v BeatSpec) *BeatSpecConfigRef { return v.ConfigRef }).(BeatSpecConfigRefPtrOutput)
}

// DaemonSet specifies the Beat should be deployed as a DaemonSet, and allows providing its spec.
// Cannot be used along with `deployment`. If both are absent a default for the Type is used.
func (o BeatSpecOutput) DaemonSet() BeatSpecDaemonSetPtrOutput {
	return o.ApplyT(func(v BeatSpec) *BeatSpecDaemonSet { return v.DaemonSet }).(BeatSpecDaemonSetPtrOutput)
}

// Deployment specifies the Beat should be deployed as a Deployment, and allows providing its spec.
// Cannot be used along with `daemonSet`. If both are absent a default for the Type is used.
func (o BeatSpecOutput) Deployment() BeatSpecDeploymentPtrOutput {
	return o.ApplyT(func(v BeatSpec) *BeatSpecDeployment { return v.Deployment }).(BeatSpecDeploymentPtrOutput)
}

// ElasticsearchRef is a reference to an Elasticsearch cluster running in the same Kubernetes cluster.
func (o BeatSpecOutput) ElasticsearchRef() BeatSpecElasticsearchRefPtrOutput {
	return o.ApplyT(func(v BeatSpec) *BeatSpecElasticsearchRef { return v.ElasticsearchRef }).(BeatSpecElasticsearchRefPtrOutput)
}

// Image is the Beat Docker image to deploy. Version and Type have to match the Beat in the image.
func (o BeatSpecOutput) Image() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BeatSpec) *string { return v.Image }).(pulumi.StringPtrOutput)
}

// KibanaRef is a reference to a Kibana instance running in the same Kubernetes cluster.
// It allows automatic setup of dashboards and visualizations.
func (o BeatSpecOutput) KibanaRef() BeatSpecKibanaRefPtrOutput {
	return o.ApplyT(func(v BeatSpec) *BeatSpecKibanaRef { return v.KibanaRef }).(BeatSpecKibanaRefPtrOutput)
}

// Monitoring enables you to collect and ship logs and metrics for this Beat.
// Metricbeat and/or Filebeat sidecars are configured and send monitoring data to an
// Elasticsearch monitoring cluster running in the same Kubernetes cluster.
func (o BeatSpecOutput) Monitoring() BeatSpecMonitoringPtrOutput {
	return o.ApplyT(func(v BeatSpec) *BeatSpecMonitoring { return v.Monitoring }).(BeatSpecMonitoringPtrOutput)
}

// RevisionHistoryLimit is the number of revisions to retain to allow rollback in the underlying DaemonSet or Deployment.
func (o BeatSpecOutput) RevisionHistoryLimit() pulumi.IntPtrOutput {
	return o.ApplyT(func(v BeatSpec) *int { return v.RevisionHistoryLimit }).(pulumi.IntPtrOutput)
}

// SecureSettings is a list of references to Kubernetes Secrets containing sensitive configuration options for the Beat.
// Secrets data can be then referenced in the Beat config using the Secret's keys or as specified in `Entries` field of
// each SecureSetting.
func (o BeatSpecOutput) SecureSettings() BeatSpecSecureSettingsArrayOutput {
	return o.ApplyT(func(v BeatSpec) []BeatSpecSecureSettings { return v.SecureSettings }).(BeatSpecSecureSettingsArrayOutput)
}

// ServiceAccountName is used to check access from the current resource to Elasticsearch resource in a different namespace.
// Can only be used if ECK is enforcing RBAC on references.
func (o BeatSpecOutput) ServiceAccountName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BeatSpec) *string { return v.ServiceAccountName }).(pulumi.StringPtrOutput)
}

// Type is the type of the Beat to deploy (filebeat, metricbeat, heartbeat, auditbeat, journalbeat, packetbeat, and so on).
// Any string can be used, but well-known types will have the image field defaulted and have the appropriate
// Elasticsearch roles created automatically. It also allows for dashboard setup when combined with a `KibanaRef`.
func (o BeatSpecOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v BeatSpec) string { return v.Type }).(pulumi.StringOutput)
}

// Version of the Beat.
func (o BeatSpecOutput) Version() pulumi.StringOutput {
	return o.ApplyT(func(v BeatSpec) string { return v.Version }).(pulumi.StringOutput)
}

type BeatSpecPtrOutput struct{ *pulumi.OutputState }

func (BeatSpecPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**BeatSpec)(nil)).Elem()
}

func (o BeatSpecPtrOutput) ToBeatSpecPtrOutput() BeatSpecPtrOutput {
	return o
}

func (o BeatSpecPtrOutput) ToBeatSpecPtrOutputWithContext(ctx context.Context) BeatSpecPtrOutput {
	return o
}

func (o BeatSpecPtrOutput) Elem() BeatSpecOutput {
	return o.ApplyT(func(v *BeatSpec) BeatSpec {
		if v != nil {
			return *v
		}
		var ret BeatSpec
		return ret
	}).(BeatSpecOutput)
}

// Config holds the Beat configuration. At most one of [`Config`, `ConfigRef`] can be specified.
func (o BeatSpecPtrOutput) Config() pulumi.MapOutput {
	return o.ApplyT(func(v *BeatSpec) map[string]interface{} {
		if v == nil {
			return nil
		}
		return v.Config
	}).(pulumi.MapOutput)
}

// ConfigRef contains a reference to an existing Kubernetes Secret holding the Beat configuration.
// Beat settings must be specified as yaml, under a single "beat.yml" entry. At most one of [`Config`, `ConfigRef`]
// can be specified.
func (o BeatSpecPtrOutput) ConfigRef() BeatSpecConfigRefPtrOutput {
	return o.ApplyT(func(v *BeatSpec) *BeatSpecConfigRef {
		if v == nil {
			return nil
		}
		return v.ConfigRef
	}).(BeatSpecConfigRefPtrOutput)
}

// DaemonSet specifies the Beat should be deployed as a DaemonSet, and allows providing its spec.
// Cannot be used along with `deployment`. If both are absent a default for the Type is used.
func (o BeatSpecPtrOutput) DaemonSet() BeatSpecDaemonSetPtrOutput {
	return o.ApplyT(func(v *BeatSpec) *BeatSpecDaemonSet {
		if v == nil {
			return nil
		}
		return v.DaemonSet
	}).(BeatSpecDaemonSetPtrOutput)
}

// Deployment specifies the Beat should be deployed as a Deployment, and allows providing its spec.
// Cannot be used along with `daemonSet`. If both are absent a default for the Type is used.
func (o BeatSpecPtrOutput) Deployment() BeatSpecDeploymentPtrOutput {
	return o.ApplyT(func(v *BeatSpec) *BeatSpecDeployment {
		if v == nil {
			return nil
		}
		return v.Deployment
	}).(BeatSpecDeploymentPtrOutput)
}

// ElasticsearchRef is a reference to an Elasticsearch cluster running in the same Kubernetes cluster.
func (o BeatSpecPtrOutput) ElasticsearchRef() BeatSpecElasticsearchRefPtrOutput {
	return o.ApplyT(func(v *BeatSpec) *BeatSpecElasticsearchRef {
		if v == nil {
			return nil
		}
		return v.ElasticsearchRef
	}).(BeatSpecElasticsearchRefPtrOutput)
}

// Image is the Beat Docker image to deploy. Version and Type have to match the Beat in the image.
func (o BeatSpecPtrOutput) Image() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BeatSpec) *string {
		if v == nil {
			return nil
		}
		return v.Image
	}).(pulumi.StringPtrOutput)
}

// KibanaRef is a reference to a Kibana instance running in the same Kubernetes cluster.
// It allows automatic setup of dashboards and visualizations.
func (o BeatSpecPtrOutput) KibanaRef() BeatSpecKibanaRefPtrOutput {
	return o.ApplyT(func(v *BeatSpec) *BeatSpecKibanaRef {
		if v == nil {
			return nil
		}
		return v.KibanaRef
	}).(BeatSpecKibanaRefPtrOutput)
}

// Monitoring enables you to collect and ship logs and metrics for this Beat.
// Metricbeat and/or Filebeat sidecars are configured and send monitoring data to an
// Elasticsearch monitoring cluster running in the same Kubernetes cluster.
func (o BeatSpecPtrOutput) Monitoring() BeatSpecMonitoringPtrOutput {
	return o.ApplyT(func(v *BeatSpec) *BeatSpecMonitoring {
		if v == nil {
			return nil
		}
		return v.Monitoring
	}).(BeatSpecMonitoringPtrOutput)
}

// RevisionHistoryLimit is the number of revisions to retain to allow rollback in the underlying DaemonSet or Deployment.
func (o BeatSpecPtrOutput) RevisionHistoryLimit() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *BeatSpec) *int {
		if v == nil {
			return nil
		}
		return v.RevisionHistoryLimit
	}).(pulumi.IntPtrOutput)
}

// SecureSettings is a list of references to Kubernetes Secrets containing sensitive configuration options for the Beat.
// Secrets data can be then referenced in the Beat config using the Secret's keys or as specified in `Entries` field of
// each SecureSetting.
func (o BeatSpecPtrOutput) SecureSettings() BeatSpecSecureSettingsArrayOutput {
	return o.ApplyT(func(v *BeatSpec) []BeatSpecSecureSettings {
		if v == nil {
			return nil
		}
		return v.SecureSettings
	}).(BeatSpecSecureSettingsArrayOutput)
}

// ServiceAccountName is used to check access from the current resource to Elasticsearch resource in a different namespace.
// Can only be used if ECK is enforcing RBAC on references.
func (o BeatSpecPtrOutput) ServiceAccountName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BeatSpec) *string {
		if v == nil {
			return nil
		}
		return v.ServiceAccountName
	}).(pulumi.StringPtrOutput)
}

// Type is the type of the Beat to deploy (filebeat, metricbeat, heartbeat, auditbeat, journalbeat, packetbeat, and so on).
// Any string can be used, but well-known types will have the image field defaulted and have the appropriate
// Elasticsearch roles created automatically. It also allows for dashboard setup when combined with a `KibanaRef`.
func (o BeatSpecPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BeatSpec) *string {
		if v == nil {
			return nil
		}
		return &v.Type
	}).(pulumi.StringPtrOutput)
}

// Version of the Beat.
func (o BeatSpecPtrOutput) Version() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BeatSpec) *string {
		if v == nil {
			return nil
		}
		return &v.Version
	}).(pulumi.StringPtrOutput)
}

// ConfigRef contains a reference to an existing Kubernetes Secret holding the Beat configuration.
// Beat settings must be specified as yaml, under a single "beat.yml" entry. At most one of [`Config`, `ConfigRef`]
// can be specified.
type BeatSpecConfigRef struct {
	// SecretName is the name of the secret.
	SecretName *string `pulumi:"secretName"`
}

// BeatSpecConfigRefInput is an input type that accepts BeatSpecConfigRefArgs and BeatSpecConfigRefOutput values.
// You can construct a concrete instance of `BeatSpecConfigRefInput` via:
//
//	BeatSpecConfigRefArgs{...}
type BeatSpecConfigRefInput interface {
	pulumi.Input

	ToBeatSpecConfigRefOutput() BeatSpecConfigRefOutput
	ToBeatSpecConfigRefOutputWithContext(context.Context) BeatSpecConfigRefOutput
}

// ConfigRef contains a reference to an existing Kubernetes Secret holding the Beat configuration.
// Beat settings must be specified as yaml, under a single "beat.yml" entry. At most one of [`Config`, `ConfigRef`]
// can be specified.
type BeatSpecConfigRefArgs struct {
	// SecretName is the name of the secret.
	SecretName pulumi.StringPtrInput `pulumi:"secretName"`
}

func (BeatSpecConfigRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*BeatSpecConfigRef)(nil)).Elem()
}

func (i BeatSpecConfigRefArgs) ToBeatSpecConfigRefOutput() BeatSpecConfigRefOutput {
	return i.ToBeatSpecConfigRefOutputWithContext(context.Background())
}

func (i BeatSpecConfigRefArgs) ToBeatSpecConfigRefOutputWithContext(ctx context.Context) BeatSpecConfigRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BeatSpecConfigRefOutput)
}

func (i BeatSpecConfigRefArgs) ToBeatSpecConfigRefPtrOutput() BeatSpecConfigRefPtrOutput {
	return i.ToBeatSpecConfigRefPtrOutputWithContext(context.Background())
}

func (i BeatSpecConfigRefArgs) ToBeatSpecConfigRefPtrOutputWithContext(ctx context.Context) BeatSpecConfigRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BeatSpecConfigRefOutput).ToBeatSpecConfigRefPtrOutputWithContext(ctx)
}

// BeatSpecConfigRefPtrInput is an input type that accepts BeatSpecConfigRefArgs, BeatSpecConfigRefPtr and BeatSpecConfigRefPtrOutput values.
// You can construct a concrete instance of `BeatSpecConfigRefPtrInput` via:
//
//	        BeatSpecConfigRefArgs{...}
//
//	or:
//
//	        nil
type BeatSpecConfigRefPtrInput interface {
	pulumi.Input

	ToBeatSpecConfigRefPtrOutput() BeatSpecConfigRefPtrOutput
	ToBeatSpecConfigRefPtrOutputWithContext(context.Context) BeatSpecConfigRefPtrOutput
}

type beatSpecConfigRefPtrType BeatSpecConfigRefArgs

func BeatSpecConfigRefPtr(v *BeatSpecConfigRefArgs) BeatSpecConfigRefPtrInput {
	return (*beatSpecConfigRefPtrType)(v)
}

func (*beatSpecConfigRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**BeatSpecConfigRef)(nil)).Elem()
}

func (i *beatSpecConfigRefPtrType) ToBeatSpecConfigRefPtrOutput() BeatSpecConfigRefPtrOutput {
	return i.ToBeatSpecConfigRefPtrOutputWithContext(context.Background())
}

func (i *beatSpecConfigRefPtrType) ToBeatSpecConfigRefPtrOutputWithContext(ctx context.Context) BeatSpecConfigRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BeatSpecConfigRefPtrOutput)
}

// ConfigRef contains a reference to an existing Kubernetes Secret holding the Beat configuration.
// Beat settings must be specified as yaml, under a single "beat.yml" entry. At most one of [`Config`, `ConfigRef`]
// can be specified.
type BeatSpecConfigRefOutput struct{ *pulumi.OutputState }

func (BeatSpecConfigRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BeatSpecConfigRef)(nil)).Elem()
}

func (o BeatSpecConfigRefOutput) ToBeatSpecConfigRefOutput() BeatSpecConfigRefOutput {
	return o
}

func (o BeatSpecConfigRefOutput) ToBeatSpecConfigRefOutputWithContext(ctx context.Context) BeatSpecConfigRefOutput {
	return o
}

func (o BeatSpecConfigRefOutput) ToBeatSpecConfigRefPtrOutput() BeatSpecConfigRefPtrOutput {
	return o.ToBeatSpecConfigRefPtrOutputWithContext(context.Background())
}

func (o BeatSpecConfigRefOutput) ToBeatSpecConfigRefPtrOutputWithContext(ctx context.Context) BeatSpecConfigRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v BeatSpecConfigRef) *BeatSpecConfigRef {
		return &v
	}).(BeatSpecConfigRefPtrOutput)
}

// SecretName is the name of the secret.
func (o BeatSpecConfigRefOutput) SecretName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BeatSpecConfigRef) *string { return v.SecretName }).(pulumi.StringPtrOutput)
}

type BeatSpecConfigRefPtrOutput struct{ *pulumi.OutputState }

func (BeatSpecConfigRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**BeatSpecConfigRef)(nil)).Elem()
}

func (o BeatSpecConfigRefPtrOutput) ToBeatSpecConfigRefPtrOutput() BeatSpecConfigRefPtrOutput {
	return o
}

func (o BeatSpecConfigRefPtrOutput) ToBeatSpecConfigRefPtrOutputWithContext(ctx context.Context) BeatSpecConfigRefPtrOutput {
	return o
}

func (o BeatSpecConfigRefPtrOutput) Elem() BeatSpecConfigRefOutput {
	return o.ApplyT(func(v *BeatSpecConfigRef) BeatSpecConfigRef {
		if v != nil {
			return *v
		}
		var ret BeatSpecConfigRef
		return ret
	}).(BeatSpecConfigRefOutput)
}

// SecretName is the name of the secret.
func (o BeatSpecConfigRefPtrOutput) SecretName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BeatSpecConfigRef) *string {
		if v == nil {
			return nil
		}
		return v.SecretName
	}).(pulumi.StringPtrOutput)
}

// DaemonSet specifies the Beat should be deployed as a DaemonSet, and allows providing its spec.
// Cannot be used along with `deployment`. If both are absent a default for the Type is used.
type BeatSpecDaemonSet struct {
	// PodTemplateSpec describes the data a pod should have when created from a template
	PodTemplate map[string]interface{} `pulumi:"podTemplate"`
	// DaemonSetUpdateStrategy is a struct used to control the update strategy for a DaemonSet.
	UpdateStrategy *BeatSpecDaemonSetUpdateStrategy `pulumi:"updateStrategy"`
}

// BeatSpecDaemonSetInput is an input type that accepts BeatSpecDaemonSetArgs and BeatSpecDaemonSetOutput values.
// You can construct a concrete instance of `BeatSpecDaemonSetInput` via:
//
//	BeatSpecDaemonSetArgs{...}
type BeatSpecDaemonSetInput interface {
	pulumi.Input

	ToBeatSpecDaemonSetOutput() BeatSpecDaemonSetOutput
	ToBeatSpecDaemonSetOutputWithContext(context.Context) BeatSpecDaemonSetOutput
}

// DaemonSet specifies the Beat should be deployed as a DaemonSet, and allows providing its spec.
// Cannot be used along with `deployment`. If both are absent a default for the Type is used.
type BeatSpecDaemonSetArgs struct {
	// PodTemplateSpec describes the data a pod should have when created from a template
	PodTemplate pulumi.MapInput `pulumi:"podTemplate"`
	// DaemonSetUpdateStrategy is a struct used to control the update strategy for a DaemonSet.
	UpdateStrategy BeatSpecDaemonSetUpdateStrategyPtrInput `pulumi:"updateStrategy"`
}

func (BeatSpecDaemonSetArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*BeatSpecDaemonSet)(nil)).Elem()
}

func (i BeatSpecDaemonSetArgs) ToBeatSpecDaemonSetOutput() BeatSpecDaemonSetOutput {
	return i.ToBeatSpecDaemonSetOutputWithContext(context.Background())
}

func (i BeatSpecDaemonSetArgs) ToBeatSpecDaemonSetOutputWithContext(ctx context.Context) BeatSpecDaemonSetOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BeatSpecDaemonSetOutput)
}

func (i BeatSpecDaemonSetArgs) ToBeatSpecDaemonSetPtrOutput() BeatSpecDaemonSetPtrOutput {
	return i.ToBeatSpecDaemonSetPtrOutputWithContext(context.Background())
}

func (i BeatSpecDaemonSetArgs) ToBeatSpecDaemonSetPtrOutputWithContext(ctx context.Context) BeatSpecDaemonSetPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BeatSpecDaemonSetOutput).ToBeatSpecDaemonSetPtrOutputWithContext(ctx)
}

// BeatSpecDaemonSetPtrInput is an input type that accepts BeatSpecDaemonSetArgs, BeatSpecDaemonSetPtr and BeatSpecDaemonSetPtrOutput values.
// You can construct a concrete instance of `BeatSpecDaemonSetPtrInput` via:
//
//	        BeatSpecDaemonSetArgs{...}
//
//	or:
//
//	        nil
type BeatSpecDaemonSetPtrInput interface {
	pulumi.Input

	ToBeatSpecDaemonSetPtrOutput() BeatSpecDaemonSetPtrOutput
	ToBeatSpecDaemonSetPtrOutputWithContext(context.Context) BeatSpecDaemonSetPtrOutput
}

type beatSpecDaemonSetPtrType BeatSpecDaemonSetArgs

func BeatSpecDaemonSetPtr(v *BeatSpecDaemonSetArgs) BeatSpecDaemonSetPtrInput {
	return (*beatSpecDaemonSetPtrType)(v)
}

func (*beatSpecDaemonSetPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**BeatSpecDaemonSet)(nil)).Elem()
}

func (i *beatSpecDaemonSetPtrType) ToBeatSpecDaemonSetPtrOutput() BeatSpecDaemonSetPtrOutput {
	return i.ToBeatSpecDaemonSetPtrOutputWithContext(context.Background())
}

func (i *beatSpecDaemonSetPtrType) ToBeatSpecDaemonSetPtrOutputWithContext(ctx context.Context) BeatSpecDaemonSetPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BeatSpecDaemonSetPtrOutput)
}

// DaemonSet specifies the Beat should be deployed as a DaemonSet, and allows providing its spec.
// Cannot be used along with `deployment`. If both are absent a default for the Type is used.
type BeatSpecDaemonSetOutput struct{ *pulumi.OutputState }

func (BeatSpecDaemonSetOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BeatSpecDaemonSet)(nil)).Elem()
}

func (o BeatSpecDaemonSetOutput) ToBeatSpecDaemonSetOutput() BeatSpecDaemonSetOutput {
	return o
}

func (o BeatSpecDaemonSetOutput) ToBeatSpecDaemonSetOutputWithContext(ctx context.Context) BeatSpecDaemonSetOutput {
	return o
}

func (o BeatSpecDaemonSetOutput) ToBeatSpecDaemonSetPtrOutput() BeatSpecDaemonSetPtrOutput {
	return o.ToBeatSpecDaemonSetPtrOutputWithContext(context.Background())
}

func (o BeatSpecDaemonSetOutput) ToBeatSpecDaemonSetPtrOutputWithContext(ctx context.Context) BeatSpecDaemonSetPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v BeatSpecDaemonSet) *BeatSpecDaemonSet {
		return &v
	}).(BeatSpecDaemonSetPtrOutput)
}

// PodTemplateSpec describes the data a pod should have when created from a template
func (o BeatSpecDaemonSetOutput) PodTemplate() pulumi.MapOutput {
	return o.ApplyT(func(v BeatSpecDaemonSet) map[string]interface{} { return v.PodTemplate }).(pulumi.MapOutput)
}

// DaemonSetUpdateStrategy is a struct used to control the update strategy for a DaemonSet.
func (o BeatSpecDaemonSetOutput) UpdateStrategy() BeatSpecDaemonSetUpdateStrategyPtrOutput {
	return o.ApplyT(func(v BeatSpecDaemonSet) *BeatSpecDaemonSetUpdateStrategy { return v.UpdateStrategy }).(BeatSpecDaemonSetUpdateStrategyPtrOutput)
}

type BeatSpecDaemonSetPtrOutput struct{ *pulumi.OutputState }

func (BeatSpecDaemonSetPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**BeatSpecDaemonSet)(nil)).Elem()
}

func (o BeatSpecDaemonSetPtrOutput) ToBeatSpecDaemonSetPtrOutput() BeatSpecDaemonSetPtrOutput {
	return o
}

func (o BeatSpecDaemonSetPtrOutput) ToBeatSpecDaemonSetPtrOutputWithContext(ctx context.Context) BeatSpecDaemonSetPtrOutput {
	return o
}

func (o BeatSpecDaemonSetPtrOutput) Elem() BeatSpecDaemonSetOutput {
	return o.ApplyT(func(v *BeatSpecDaemonSet) BeatSpecDaemonSet {
		if v != nil {
			return *v
		}
		var ret BeatSpecDaemonSet
		return ret
	}).(BeatSpecDaemonSetOutput)
}

// PodTemplateSpec describes the data a pod should have when created from a template
func (o BeatSpecDaemonSetPtrOutput) PodTemplate() pulumi.MapOutput {
	return o.ApplyT(func(v *BeatSpecDaemonSet) map[string]interface{} {
		if v == nil {
			return nil
		}
		return v.PodTemplate
	}).(pulumi.MapOutput)
}

// DaemonSetUpdateStrategy is a struct used to control the update strategy for a DaemonSet.
func (o BeatSpecDaemonSetPtrOutput) UpdateStrategy() BeatSpecDaemonSetUpdateStrategyPtrOutput {
	return o.ApplyT(func(v *BeatSpecDaemonSet) *BeatSpecDaemonSetUpdateStrategy {
		if v == nil {
			return nil
		}
		return v.UpdateStrategy
	}).(BeatSpecDaemonSetUpdateStrategyPtrOutput)
}

// DaemonSetUpdateStrategy is a struct used to control the update strategy for a DaemonSet.
type BeatSpecDaemonSetUpdateStrategy struct {
	// Rolling update config params. Present only if type = "RollingUpdate".
	// ---
	// TODO: Update this to follow our convention for oneOf, whatever we decide it
	// to be. Same as Deployment `strategy.rollingUpdate`.
	// See https://github.com/kubernetes/kubernetes/issues/35345
	RollingUpdate *BeatSpecDaemonSetUpdateStrategyRollingUpdate `pulumi:"rollingUpdate"`
	// Type of daemon set update. Can be "RollingUpdate" or "OnDelete". Default is RollingUpdate.
	Type *string `pulumi:"type"`
}

// BeatSpecDaemonSetUpdateStrategyInput is an input type that accepts BeatSpecDaemonSetUpdateStrategyArgs and BeatSpecDaemonSetUpdateStrategyOutput values.
// You can construct a concrete instance of `BeatSpecDaemonSetUpdateStrategyInput` via:
//
//	BeatSpecDaemonSetUpdateStrategyArgs{...}
type BeatSpecDaemonSetUpdateStrategyInput interface {
	pulumi.Input

	ToBeatSpecDaemonSetUpdateStrategyOutput() BeatSpecDaemonSetUpdateStrategyOutput
	ToBeatSpecDaemonSetUpdateStrategyOutputWithContext(context.Context) BeatSpecDaemonSetUpdateStrategyOutput
}

// DaemonSetUpdateStrategy is a struct used to control the update strategy for a DaemonSet.
type BeatSpecDaemonSetUpdateStrategyArgs struct {
	// Rolling update config params. Present only if type = "RollingUpdate".
	// ---
	// TODO: Update this to follow our convention for oneOf, whatever we decide it
	// to be. Same as Deployment `strategy.rollingUpdate`.
	// See https://github.com/kubernetes/kubernetes/issues/35345
	RollingUpdate BeatSpecDaemonSetUpdateStrategyRollingUpdatePtrInput `pulumi:"rollingUpdate"`
	// Type of daemon set update. Can be "RollingUpdate" or "OnDelete". Default is RollingUpdate.
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (BeatSpecDaemonSetUpdateStrategyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*BeatSpecDaemonSetUpdateStrategy)(nil)).Elem()
}

func (i BeatSpecDaemonSetUpdateStrategyArgs) ToBeatSpecDaemonSetUpdateStrategyOutput() BeatSpecDaemonSetUpdateStrategyOutput {
	return i.ToBeatSpecDaemonSetUpdateStrategyOutputWithContext(context.Background())
}

func (i BeatSpecDaemonSetUpdateStrategyArgs) ToBeatSpecDaemonSetUpdateStrategyOutputWithContext(ctx context.Context) BeatSpecDaemonSetUpdateStrategyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BeatSpecDaemonSetUpdateStrategyOutput)
}

func (i BeatSpecDaemonSetUpdateStrategyArgs) ToBeatSpecDaemonSetUpdateStrategyPtrOutput() BeatSpecDaemonSetUpdateStrategyPtrOutput {
	return i.ToBeatSpecDaemonSetUpdateStrategyPtrOutputWithContext(context.Background())
}

func (i BeatSpecDaemonSetUpdateStrategyArgs) ToBeatSpecDaemonSetUpdateStrategyPtrOutputWithContext(ctx context.Context) BeatSpecDaemonSetUpdateStrategyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BeatSpecDaemonSetUpdateStrategyOutput).ToBeatSpecDaemonSetUpdateStrategyPtrOutputWithContext(ctx)
}

// BeatSpecDaemonSetUpdateStrategyPtrInput is an input type that accepts BeatSpecDaemonSetUpdateStrategyArgs, BeatSpecDaemonSetUpdateStrategyPtr and BeatSpecDaemonSetUpdateStrategyPtrOutput values.
// You can construct a concrete instance of `BeatSpecDaemonSetUpdateStrategyPtrInput` via:
//
//	        BeatSpecDaemonSetUpdateStrategyArgs{...}
//
//	or:
//
//	        nil
type BeatSpecDaemonSetUpdateStrategyPtrInput interface {
	pulumi.Input

	ToBeatSpecDaemonSetUpdateStrategyPtrOutput() BeatSpecDaemonSetUpdateStrategyPtrOutput
	ToBeatSpecDaemonSetUpdateStrategyPtrOutputWithContext(context.Context) BeatSpecDaemonSetUpdateStrategyPtrOutput
}

type beatSpecDaemonSetUpdateStrategyPtrType BeatSpecDaemonSetUpdateStrategyArgs

func BeatSpecDaemonSetUpdateStrategyPtr(v *BeatSpecDaemonSetUpdateStrategyArgs) BeatSpecDaemonSetUpdateStrategyPtrInput {
	return (*beatSpecDaemonSetUpdateStrategyPtrType)(v)
}

func (*beatSpecDaemonSetUpdateStrategyPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**BeatSpecDaemonSetUpdateStrategy)(nil)).Elem()
}

func (i *beatSpecDaemonSetUpdateStrategyPtrType) ToBeatSpecDaemonSetUpdateStrategyPtrOutput() BeatSpecDaemonSetUpdateStrategyPtrOutput {
	return i.ToBeatSpecDaemonSetUpdateStrategyPtrOutputWithContext(context.Background())
}

func (i *beatSpecDaemonSetUpdateStrategyPtrType) ToBeatSpecDaemonSetUpdateStrategyPtrOutputWithContext(ctx context.Context) BeatSpecDaemonSetUpdateStrategyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BeatSpecDaemonSetUpdateStrategyPtrOutput)
}

// DaemonSetUpdateStrategy is a struct used to control the update strategy for a DaemonSet.
type BeatSpecDaemonSetUpdateStrategyOutput struct{ *pulumi.OutputState }

func (BeatSpecDaemonSetUpdateStrategyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BeatSpecDaemonSetUpdateStrategy)(nil)).Elem()
}

func (o BeatSpecDaemonSetUpdateStrategyOutput) ToBeatSpecDaemonSetUpdateStrategyOutput() BeatSpecDaemonSetUpdateStrategyOutput {
	return o
}

func (o BeatSpecDaemonSetUpdateStrategyOutput) ToBeatSpecDaemonSetUpdateStrategyOutputWithContext(ctx context.Context) BeatSpecDaemonSetUpdateStrategyOutput {
	return o
}

func (o BeatSpecDaemonSetUpdateStrategyOutput) ToBeatSpecDaemonSetUpdateStrategyPtrOutput() BeatSpecDaemonSetUpdateStrategyPtrOutput {
	return o.ToBeatSpecDaemonSetUpdateStrategyPtrOutputWithContext(context.Background())
}

func (o BeatSpecDaemonSetUpdateStrategyOutput) ToBeatSpecDaemonSetUpdateStrategyPtrOutputWithContext(ctx context.Context) BeatSpecDaemonSetUpdateStrategyPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v BeatSpecDaemonSetUpdateStrategy) *BeatSpecDaemonSetUpdateStrategy {
		return &v
	}).(BeatSpecDaemonSetUpdateStrategyPtrOutput)
}

// Rolling update config params. Present only if type = "RollingUpdate".
// ---
// TODO: Update this to follow our convention for oneOf, whatever we decide it
// to be. Same as Deployment `strategy.rollingUpdate`.
// See https://github.com/kubernetes/kubernetes/issues/35345
func (o BeatSpecDaemonSetUpdateStrategyOutput) RollingUpdate() BeatSpecDaemonSetUpdateStrategyRollingUpdatePtrOutput {
	return o.ApplyT(func(v BeatSpecDaemonSetUpdateStrategy) *BeatSpecDaemonSetUpdateStrategyRollingUpdate {
		return v.RollingUpdate
	}).(BeatSpecDaemonSetUpdateStrategyRollingUpdatePtrOutput)
}

// Type of daemon set update. Can be "RollingUpdate" or "OnDelete". Default is RollingUpdate.
func (o BeatSpecDaemonSetUpdateStrategyOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BeatSpecDaemonSetUpdateStrategy) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type BeatSpecDaemonSetUpdateStrategyPtrOutput struct{ *pulumi.OutputState }

func (BeatSpecDaemonSetUpdateStrategyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**BeatSpecDaemonSetUpdateStrategy)(nil)).Elem()
}

func (o BeatSpecDaemonSetUpdateStrategyPtrOutput) ToBeatSpecDaemonSetUpdateStrategyPtrOutput() BeatSpecDaemonSetUpdateStrategyPtrOutput {
	return o
}

func (o BeatSpecDaemonSetUpdateStrategyPtrOutput) ToBeatSpecDaemonSetUpdateStrategyPtrOutputWithContext(ctx context.Context) BeatSpecDaemonSetUpdateStrategyPtrOutput {
	return o
}

func (o BeatSpecDaemonSetUpdateStrategyPtrOutput) Elem() BeatSpecDaemonSetUpdateStrategyOutput {
	return o.ApplyT(func(v *BeatSpecDaemonSetUpdateStrategy) BeatSpecDaemonSetUpdateStrategy {
		if v != nil {
			return *v
		}
		var ret BeatSpecDaemonSetUpdateStrategy
		return ret
	}).(BeatSpecDaemonSetUpdateStrategyOutput)
}

// Rolling update config params. Present only if type = "RollingUpdate".
// ---
// TODO: Update this to follow our convention for oneOf, whatever we decide it
// to be. Same as Deployment `strategy.rollingUpdate`.
// See https://github.com/kubernetes/kubernetes/issues/35345
func (o BeatSpecDaemonSetUpdateStrategyPtrOutput) RollingUpdate() BeatSpecDaemonSetUpdateStrategyRollingUpdatePtrOutput {
	return o.ApplyT(func(v *BeatSpecDaemonSetUpdateStrategy) *BeatSpecDaemonSetUpdateStrategyRollingUpdate {
		if v == nil {
			return nil
		}
		return v.RollingUpdate
	}).(BeatSpecDaemonSetUpdateStrategyRollingUpdatePtrOutput)
}

// Type of daemon set update. Can be "RollingUpdate" or "OnDelete". Default is RollingUpdate.
func (o BeatSpecDaemonSetUpdateStrategyPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BeatSpecDaemonSetUpdateStrategy) *string {
		if v == nil {
			return nil
		}
		return v.Type
	}).(pulumi.StringPtrOutput)
}

// Rolling update config params. Present only if type = "RollingUpdate".
// ---
// TODO: Update this to follow our convention for oneOf, whatever we decide it
// to be. Same as Deployment `strategy.rollingUpdate`.
// See https://github.com/kubernetes/kubernetes/issues/35345
type BeatSpecDaemonSetUpdateStrategyRollingUpdate struct {
	// The maximum number of nodes with an existing available DaemonSet pod that
	// can have an updated DaemonSet pod during during an update.
	// Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
	// This can not be 0 if MaxUnavailable is 0.
	// Absolute number is calculated from percentage by rounding up to a minimum of 1.
	// Default value is 0.
	// Example: when this is set to 30%, at most 30% of the total number of nodes
	// that should be running the daemon pod (i.e. status.desiredNumberScheduled)
	// can have their a new pod created before the old pod is marked as deleted.
	// The update starts by launching new pods on 30% of nodes. Once an updated
	// pod is available (Ready for at least minReadySeconds) the old DaemonSet pod
	// on that node is marked deleted. If the old pod becomes unavailable for any
	// reason (Ready transitions to false, is evicted, or is drained) an updated
	// pod is immediatedly created on that node without considering surge limits.
	// Allowing surge implies the possibility that the resources consumed by the
	// daemonset on any given node can double if the readiness check fails, and
	// so resource intensive daemonsets should take into account that they may
	// cause evictions during disruption.
	MaxSurge interface{} `pulumi:"maxSurge"`
	// The maximum number of DaemonSet pods that can be unavailable during the
	// update. Value can be an absolute number (ex: 5) or a percentage of total
	// number of DaemonSet pods at the start of the update (ex: 10%). Absolute
	// number is calculated from percentage by rounding up.
	// This cannot be 0 if MaxSurge is 0
	// Default value is 1.
	// Example: when this is set to 30%, at most 30% of the total number of nodes
	// that should be running the daemon pod (i.e. status.desiredNumberScheduled)
	// can have their pods stopped for an update at any given time. The update
	// starts by stopping at most 30% of those DaemonSet pods and then brings
	// up new DaemonSet pods in their place. Once the new pods are available,
	// it then proceeds onto other DaemonSet pods, thus ensuring that at least
	// 70% of original number of DaemonSet pods are available at all times during
	// the update.
	MaxUnavailable interface{} `pulumi:"maxUnavailable"`
}

// BeatSpecDaemonSetUpdateStrategyRollingUpdateInput is an input type that accepts BeatSpecDaemonSetUpdateStrategyRollingUpdateArgs and BeatSpecDaemonSetUpdateStrategyRollingUpdateOutput values.
// You can construct a concrete instance of `BeatSpecDaemonSetUpdateStrategyRollingUpdateInput` via:
//
//	BeatSpecDaemonSetUpdateStrategyRollingUpdateArgs{...}
type BeatSpecDaemonSetUpdateStrategyRollingUpdateInput interface {
	pulumi.Input

	ToBeatSpecDaemonSetUpdateStrategyRollingUpdateOutput() BeatSpecDaemonSetUpdateStrategyRollingUpdateOutput
	ToBeatSpecDaemonSetUpdateStrategyRollingUpdateOutputWithContext(context.Context) BeatSpecDaemonSetUpdateStrategyRollingUpdateOutput
}

// Rolling update config params. Present only if type = "RollingUpdate".
// ---
// TODO: Update this to follow our convention for oneOf, whatever we decide it
// to be. Same as Deployment `strategy.rollingUpdate`.
// See https://github.com/kubernetes/kubernetes/issues/35345
type BeatSpecDaemonSetUpdateStrategyRollingUpdateArgs struct {
	// The maximum number of nodes with an existing available DaemonSet pod that
	// can have an updated DaemonSet pod during during an update.
	// Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
	// This can not be 0 if MaxUnavailable is 0.
	// Absolute number is calculated from percentage by rounding up to a minimum of 1.
	// Default value is 0.
	// Example: when this is set to 30%, at most 30% of the total number of nodes
	// that should be running the daemon pod (i.e. status.desiredNumberScheduled)
	// can have their a new pod created before the old pod is marked as deleted.
	// The update starts by launching new pods on 30% of nodes. Once an updated
	// pod is available (Ready for at least minReadySeconds) the old DaemonSet pod
	// on that node is marked deleted. If the old pod becomes unavailable for any
	// reason (Ready transitions to false, is evicted, or is drained) an updated
	// pod is immediatedly created on that node without considering surge limits.
	// Allowing surge implies the possibility that the resources consumed by the
	// daemonset on any given node can double if the readiness check fails, and
	// so resource intensive daemonsets should take into account that they may
	// cause evictions during disruption.
	MaxSurge pulumi.Input `pulumi:"maxSurge"`
	// The maximum number of DaemonSet pods that can be unavailable during the
	// update. Value can be an absolute number (ex: 5) or a percentage of total
	// number of DaemonSet pods at the start of the update (ex: 10%). Absolute
	// number is calculated from percentage by rounding up.
	// This cannot be 0 if MaxSurge is 0
	// Default value is 1.
	// Example: when this is set to 30%, at most 30% of the total number of nodes
	// that should be running the daemon pod (i.e. status.desiredNumberScheduled)
	// can have their pods stopped for an update at any given time. The update
	// starts by stopping at most 30% of those DaemonSet pods and then brings
	// up new DaemonSet pods in their place. Once the new pods are available,
	// it then proceeds onto other DaemonSet pods, thus ensuring that at least
	// 70% of original number of DaemonSet pods are available at all times during
	// the update.
	MaxUnavailable pulumi.Input `pulumi:"maxUnavailable"`
}

func (BeatSpecDaemonSetUpdateStrategyRollingUpdateArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*BeatSpecDaemonSetUpdateStrategyRollingUpdate)(nil)).Elem()
}

func (i BeatSpecDaemonSetUpdateStrategyRollingUpdateArgs) ToBeatSpecDaemonSetUpdateStrategyRollingUpdateOutput() BeatSpecDaemonSetUpdateStrategyRollingUpdateOutput {
	return i.ToBeatSpecDaemonSetUpdateStrategyRollingUpdateOutputWithContext(context.Background())
}

func (i BeatSpecDaemonSetUpdateStrategyRollingUpdateArgs) ToBeatSpecDaemonSetUpdateStrategyRollingUpdateOutputWithContext(ctx context.Context) BeatSpecDaemonSetUpdateStrategyRollingUpdateOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BeatSpecDaemonSetUpdateStrategyRollingUpdateOutput)
}

func (i BeatSpecDaemonSetUpdateStrategyRollingUpdateArgs) ToBeatSpecDaemonSetUpdateStrategyRollingUpdatePtrOutput() BeatSpecDaemonSetUpdateStrategyRollingUpdatePtrOutput {
	return i.ToBeatSpecDaemonSetUpdateStrategyRollingUpdatePtrOutputWithContext(context.Background())
}

func (i BeatSpecDaemonSetUpdateStrategyRollingUpdateArgs) ToBeatSpecDaemonSetUpdateStrategyRollingUpdatePtrOutputWithContext(ctx context.Context) BeatSpecDaemonSetUpdateStrategyRollingUpdatePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BeatSpecDaemonSetUpdateStrategyRollingUpdateOutput).ToBeatSpecDaemonSetUpdateStrategyRollingUpdatePtrOutputWithContext(ctx)
}

// BeatSpecDaemonSetUpdateStrategyRollingUpdatePtrInput is an input type that accepts BeatSpecDaemonSetUpdateStrategyRollingUpdateArgs, BeatSpecDaemonSetUpdateStrategyRollingUpdatePtr and BeatSpecDaemonSetUpdateStrategyRollingUpdatePtrOutput values.
// You can construct a concrete instance of `BeatSpecDaemonSetUpdateStrategyRollingUpdatePtrInput` via:
//
//	        BeatSpecDaemonSetUpdateStrategyRollingUpdateArgs{...}
//
//	or:
//
//	        nil
type BeatSpecDaemonSetUpdateStrategyRollingUpdatePtrInput interface {
	pulumi.Input

	ToBeatSpecDaemonSetUpdateStrategyRollingUpdatePtrOutput() BeatSpecDaemonSetUpdateStrategyRollingUpdatePtrOutput
	ToBeatSpecDaemonSetUpdateStrategyRollingUpdatePtrOutputWithContext(context.Context) BeatSpecDaemonSetUpdateStrategyRollingUpdatePtrOutput
}

type beatSpecDaemonSetUpdateStrategyRollingUpdatePtrType BeatSpecDaemonSetUpdateStrategyRollingUpdateArgs

func BeatSpecDaemonSetUpdateStrategyRollingUpdatePtr(v *BeatSpecDaemonSetUpdateStrategyRollingUpdateArgs) BeatSpecDaemonSetUpdateStrategyRollingUpdatePtrInput {
	return (*beatSpecDaemonSetUpdateStrategyRollingUpdatePtrType)(v)
}

func (*beatSpecDaemonSetUpdateStrategyRollingUpdatePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**BeatSpecDaemonSetUpdateStrategyRollingUpdate)(nil)).Elem()
}

func (i *beatSpecDaemonSetUpdateStrategyRollingUpdatePtrType) ToBeatSpecDaemonSetUpdateStrategyRollingUpdatePtrOutput() BeatSpecDaemonSetUpdateStrategyRollingUpdatePtrOutput {
	return i.ToBeatSpecDaemonSetUpdateStrategyRollingUpdatePtrOutputWithContext(context.Background())
}

func (i *beatSpecDaemonSetUpdateStrategyRollingUpdatePtrType) ToBeatSpecDaemonSetUpdateStrategyRollingUpdatePtrOutputWithContext(ctx context.Context) BeatSpecDaemonSetUpdateStrategyRollingUpdatePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BeatSpecDaemonSetUpdateStrategyRollingUpdatePtrOutput)
}

// Rolling update config params. Present only if type = "RollingUpdate".
// ---
// TODO: Update this to follow our convention for oneOf, whatever we decide it
// to be. Same as Deployment `strategy.rollingUpdate`.
// See https://github.com/kubernetes/kubernetes/issues/35345
type BeatSpecDaemonSetUpdateStrategyRollingUpdateOutput struct{ *pulumi.OutputState }

func (BeatSpecDaemonSetUpdateStrategyRollingUpdateOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BeatSpecDaemonSetUpdateStrategyRollingUpdate)(nil)).Elem()
}

func (o BeatSpecDaemonSetUpdateStrategyRollingUpdateOutput) ToBeatSpecDaemonSetUpdateStrategyRollingUpdateOutput() BeatSpecDaemonSetUpdateStrategyRollingUpdateOutput {
	return o
}

func (o BeatSpecDaemonSetUpdateStrategyRollingUpdateOutput) ToBeatSpecDaemonSetUpdateStrategyRollingUpdateOutputWithContext(ctx context.Context) BeatSpecDaemonSetUpdateStrategyRollingUpdateOutput {
	return o
}

func (o BeatSpecDaemonSetUpdateStrategyRollingUpdateOutput) ToBeatSpecDaemonSetUpdateStrategyRollingUpdatePtrOutput() BeatSpecDaemonSetUpdateStrategyRollingUpdatePtrOutput {
	return o.ToBeatSpecDaemonSetUpdateStrategyRollingUpdatePtrOutputWithContext(context.Background())
}

func (o BeatSpecDaemonSetUpdateStrategyRollingUpdateOutput) ToBeatSpecDaemonSetUpdateStrategyRollingUpdatePtrOutputWithContext(ctx context.Context) BeatSpecDaemonSetUpdateStrategyRollingUpdatePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v BeatSpecDaemonSetUpdateStrategyRollingUpdate) *BeatSpecDaemonSetUpdateStrategyRollingUpdate {
		return &v
	}).(BeatSpecDaemonSetUpdateStrategyRollingUpdatePtrOutput)
}

// The maximum number of nodes with an existing available DaemonSet pod that
// can have an updated DaemonSet pod during during an update.
// Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
// This can not be 0 if MaxUnavailable is 0.
// Absolute number is calculated from percentage by rounding up to a minimum of 1.
// Default value is 0.
// Example: when this is set to 30%, at most 30% of the total number of nodes
// that should be running the daemon pod (i.e. status.desiredNumberScheduled)
// can have their a new pod created before the old pod is marked as deleted.
// The update starts by launching new pods on 30% of nodes. Once an updated
// pod is available (Ready for at least minReadySeconds) the old DaemonSet pod
// on that node is marked deleted. If the old pod becomes unavailable for any
// reason (Ready transitions to false, is evicted, or is drained) an updated
// pod is immediatedly created on that node without considering surge limits.
// Allowing surge implies the possibility that the resources consumed by the
// daemonset on any given node can double if the readiness check fails, and
// so resource intensive daemonsets should take into account that they may
// cause evictions during disruption.
func (o BeatSpecDaemonSetUpdateStrategyRollingUpdateOutput) MaxSurge() pulumi.AnyOutput {
	return o.ApplyT(func(v BeatSpecDaemonSetUpdateStrategyRollingUpdate) interface{} { return v.MaxSurge }).(pulumi.AnyOutput)
}

// The maximum number of DaemonSet pods that can be unavailable during the
// update. Value can be an absolute number (ex: 5) or a percentage of total
// number of DaemonSet pods at the start of the update (ex: 10%). Absolute
// number is calculated from percentage by rounding up.
// This cannot be 0 if MaxSurge is 0
// Default value is 1.
// Example: when this is set to 30%, at most 30% of the total number of nodes
// that should be running the daemon pod (i.e. status.desiredNumberScheduled)
// can have their pods stopped for an update at any given time. The update
// starts by stopping at most 30% of those DaemonSet pods and then brings
// up new DaemonSet pods in their place. Once the new pods are available,
// it then proceeds onto other DaemonSet pods, thus ensuring that at least
// 70% of original number of DaemonSet pods are available at all times during
// the update.
func (o BeatSpecDaemonSetUpdateStrategyRollingUpdateOutput) MaxUnavailable() pulumi.AnyOutput {
	return o.ApplyT(func(v BeatSpecDaemonSetUpdateStrategyRollingUpdate) interface{} { return v.MaxUnavailable }).(pulumi.AnyOutput)
}

type BeatSpecDaemonSetUpdateStrategyRollingUpdatePtrOutput struct{ *pulumi.OutputState }

func (BeatSpecDaemonSetUpdateStrategyRollingUpdatePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**BeatSpecDaemonSetUpdateStrategyRollingUpdate)(nil)).Elem()
}

func (o BeatSpecDaemonSetUpdateStrategyRollingUpdatePtrOutput) ToBeatSpecDaemonSetUpdateStrategyRollingUpdatePtrOutput() BeatSpecDaemonSetUpdateStrategyRollingUpdatePtrOutput {
	return o
}

func (o BeatSpecDaemonSetUpdateStrategyRollingUpdatePtrOutput) ToBeatSpecDaemonSetUpdateStrategyRollingUpdatePtrOutputWithContext(ctx context.Context) BeatSpecDaemonSetUpdateStrategyRollingUpdatePtrOutput {
	return o
}

func (o BeatSpecDaemonSetUpdateStrategyRollingUpdatePtrOutput) Elem() BeatSpecDaemonSetUpdateStrategyRollingUpdateOutput {
	return o.ApplyT(func(v *BeatSpecDaemonSetUpdateStrategyRollingUpdate) BeatSpecDaemonSetUpdateStrategyRollingUpdate {
		if v != nil {
			return *v
		}
		var ret BeatSpecDaemonSetUpdateStrategyRollingUpdate
		return ret
	}).(BeatSpecDaemonSetUpdateStrategyRollingUpdateOutput)
}

// The maximum number of nodes with an existing available DaemonSet pod that
// can have an updated DaemonSet pod during during an update.
// Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
// This can not be 0 if MaxUnavailable is 0.
// Absolute number is calculated from percentage by rounding up to a minimum of 1.
// Default value is 0.
// Example: when this is set to 30%, at most 30% of the total number of nodes
// that should be running the daemon pod (i.e. status.desiredNumberScheduled)
// can have their a new pod created before the old pod is marked as deleted.
// The update starts by launching new pods on 30% of nodes. Once an updated
// pod is available (Ready for at least minReadySeconds) the old DaemonSet pod
// on that node is marked deleted. If the old pod becomes unavailable for any
// reason (Ready transitions to false, is evicted, or is drained) an updated
// pod is immediatedly created on that node without considering surge limits.
// Allowing surge implies the possibility that the resources consumed by the
// daemonset on any given node can double if the readiness check fails, and
// so resource intensive daemonsets should take into account that they may
// cause evictions during disruption.
func (o BeatSpecDaemonSetUpdateStrategyRollingUpdatePtrOutput) MaxSurge() pulumi.AnyOutput {
	return o.ApplyT(func(v *BeatSpecDaemonSetUpdateStrategyRollingUpdate) interface{} {
		if v == nil {
			return nil
		}
		return v.MaxSurge
	}).(pulumi.AnyOutput)
}

// The maximum number of DaemonSet pods that can be unavailable during the
// update. Value can be an absolute number (ex: 5) or a percentage of total
// number of DaemonSet pods at the start of the update (ex: 10%). Absolute
// number is calculated from percentage by rounding up.
// This cannot be 0 if MaxSurge is 0
// Default value is 1.
// Example: when this is set to 30%, at most 30% of the total number of nodes
// that should be running the daemon pod (i.e. status.desiredNumberScheduled)
// can have their pods stopped for an update at any given time. The update
// starts by stopping at most 30% of those DaemonSet pods and then brings
// up new DaemonSet pods in their place. Once the new pods are available,
// it then proceeds onto other DaemonSet pods, thus ensuring that at least
// 70% of original number of DaemonSet pods are available at all times during
// the update.
func (o BeatSpecDaemonSetUpdateStrategyRollingUpdatePtrOutput) MaxUnavailable() pulumi.AnyOutput {
	return o.ApplyT(func(v *BeatSpecDaemonSetUpdateStrategyRollingUpdate) interface{} {
		if v == nil {
			return nil
		}
		return v.MaxUnavailable
	}).(pulumi.AnyOutput)
}

// Deployment specifies the Beat should be deployed as a Deployment, and allows providing its spec.
// Cannot be used along with `daemonSet`. If both are absent a default for the Type is used.
type BeatSpecDeployment struct {
	// PodTemplateSpec describes the data a pod should have when created from a template
	PodTemplate map[string]interface{} `pulumi:"podTemplate"`
	Replicas    *int                   `pulumi:"replicas"`
	// DeploymentStrategy describes how to replace existing pods with new ones.
	Strategy *BeatSpecDeploymentStrategy `pulumi:"strategy"`
}

// BeatSpecDeploymentInput is an input type that accepts BeatSpecDeploymentArgs and BeatSpecDeploymentOutput values.
// You can construct a concrete instance of `BeatSpecDeploymentInput` via:
//
//	BeatSpecDeploymentArgs{...}
type BeatSpecDeploymentInput interface {
	pulumi.Input

	ToBeatSpecDeploymentOutput() BeatSpecDeploymentOutput
	ToBeatSpecDeploymentOutputWithContext(context.Context) BeatSpecDeploymentOutput
}

// Deployment specifies the Beat should be deployed as a Deployment, and allows providing its spec.
// Cannot be used along with `daemonSet`. If both are absent a default for the Type is used.
type BeatSpecDeploymentArgs struct {
	// PodTemplateSpec describes the data a pod should have when created from a template
	PodTemplate pulumi.MapInput    `pulumi:"podTemplate"`
	Replicas    pulumi.IntPtrInput `pulumi:"replicas"`
	// DeploymentStrategy describes how to replace existing pods with new ones.
	Strategy BeatSpecDeploymentStrategyPtrInput `pulumi:"strategy"`
}

func (BeatSpecDeploymentArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*BeatSpecDeployment)(nil)).Elem()
}

func (i BeatSpecDeploymentArgs) ToBeatSpecDeploymentOutput() BeatSpecDeploymentOutput {
	return i.ToBeatSpecDeploymentOutputWithContext(context.Background())
}

func (i BeatSpecDeploymentArgs) ToBeatSpecDeploymentOutputWithContext(ctx context.Context) BeatSpecDeploymentOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BeatSpecDeploymentOutput)
}

func (i BeatSpecDeploymentArgs) ToBeatSpecDeploymentPtrOutput() BeatSpecDeploymentPtrOutput {
	return i.ToBeatSpecDeploymentPtrOutputWithContext(context.Background())
}

func (i BeatSpecDeploymentArgs) ToBeatSpecDeploymentPtrOutputWithContext(ctx context.Context) BeatSpecDeploymentPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BeatSpecDeploymentOutput).ToBeatSpecDeploymentPtrOutputWithContext(ctx)
}

// BeatSpecDeploymentPtrInput is an input type that accepts BeatSpecDeploymentArgs, BeatSpecDeploymentPtr and BeatSpecDeploymentPtrOutput values.
// You can construct a concrete instance of `BeatSpecDeploymentPtrInput` via:
//
//	        BeatSpecDeploymentArgs{...}
//
//	or:
//
//	        nil
type BeatSpecDeploymentPtrInput interface {
	pulumi.Input

	ToBeatSpecDeploymentPtrOutput() BeatSpecDeploymentPtrOutput
	ToBeatSpecDeploymentPtrOutputWithContext(context.Context) BeatSpecDeploymentPtrOutput
}

type beatSpecDeploymentPtrType BeatSpecDeploymentArgs

func BeatSpecDeploymentPtr(v *BeatSpecDeploymentArgs) BeatSpecDeploymentPtrInput {
	return (*beatSpecDeploymentPtrType)(v)
}

func (*beatSpecDeploymentPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**BeatSpecDeployment)(nil)).Elem()
}

func (i *beatSpecDeploymentPtrType) ToBeatSpecDeploymentPtrOutput() BeatSpecDeploymentPtrOutput {
	return i.ToBeatSpecDeploymentPtrOutputWithContext(context.Background())
}

func (i *beatSpecDeploymentPtrType) ToBeatSpecDeploymentPtrOutputWithContext(ctx context.Context) BeatSpecDeploymentPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BeatSpecDeploymentPtrOutput)
}

// Deployment specifies the Beat should be deployed as a Deployment, and allows providing its spec.
// Cannot be used along with `daemonSet`. If both are absent a default for the Type is used.
type BeatSpecDeploymentOutput struct{ *pulumi.OutputState }

func (BeatSpecDeploymentOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BeatSpecDeployment)(nil)).Elem()
}

func (o BeatSpecDeploymentOutput) ToBeatSpecDeploymentOutput() BeatSpecDeploymentOutput {
	return o
}

func (o BeatSpecDeploymentOutput) ToBeatSpecDeploymentOutputWithContext(ctx context.Context) BeatSpecDeploymentOutput {
	return o
}

func (o BeatSpecDeploymentOutput) ToBeatSpecDeploymentPtrOutput() BeatSpecDeploymentPtrOutput {
	return o.ToBeatSpecDeploymentPtrOutputWithContext(context.Background())
}

func (o BeatSpecDeploymentOutput) ToBeatSpecDeploymentPtrOutputWithContext(ctx context.Context) BeatSpecDeploymentPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v BeatSpecDeployment) *BeatSpecDeployment {
		return &v
	}).(BeatSpecDeploymentPtrOutput)
}

// PodTemplateSpec describes the data a pod should have when created from a template
func (o BeatSpecDeploymentOutput) PodTemplate() pulumi.MapOutput {
	return o.ApplyT(func(v BeatSpecDeployment) map[string]interface{} { return v.PodTemplate }).(pulumi.MapOutput)
}

func (o BeatSpecDeploymentOutput) Replicas() pulumi.IntPtrOutput {
	return o.ApplyT(func(v BeatSpecDeployment) *int { return v.Replicas }).(pulumi.IntPtrOutput)
}

// DeploymentStrategy describes how to replace existing pods with new ones.
func (o BeatSpecDeploymentOutput) Strategy() BeatSpecDeploymentStrategyPtrOutput {
	return o.ApplyT(func(v BeatSpecDeployment) *BeatSpecDeploymentStrategy { return v.Strategy }).(BeatSpecDeploymentStrategyPtrOutput)
}

type BeatSpecDeploymentPtrOutput struct{ *pulumi.OutputState }

func (BeatSpecDeploymentPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**BeatSpecDeployment)(nil)).Elem()
}

func (o BeatSpecDeploymentPtrOutput) ToBeatSpecDeploymentPtrOutput() BeatSpecDeploymentPtrOutput {
	return o
}

func (o BeatSpecDeploymentPtrOutput) ToBeatSpecDeploymentPtrOutputWithContext(ctx context.Context) BeatSpecDeploymentPtrOutput {
	return o
}

func (o BeatSpecDeploymentPtrOutput) Elem() BeatSpecDeploymentOutput {
	return o.ApplyT(func(v *BeatSpecDeployment) BeatSpecDeployment {
		if v != nil {
			return *v
		}
		var ret BeatSpecDeployment
		return ret
	}).(BeatSpecDeploymentOutput)
}

// PodTemplateSpec describes the data a pod should have when created from a template
func (o BeatSpecDeploymentPtrOutput) PodTemplate() pulumi.MapOutput {
	return o.ApplyT(func(v *BeatSpecDeployment) map[string]interface{} {
		if v == nil {
			return nil
		}
		return v.PodTemplate
	}).(pulumi.MapOutput)
}

func (o BeatSpecDeploymentPtrOutput) Replicas() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *BeatSpecDeployment) *int {
		if v == nil {
			return nil
		}
		return v.Replicas
	}).(pulumi.IntPtrOutput)
}

// DeploymentStrategy describes how to replace existing pods with new ones.
func (o BeatSpecDeploymentPtrOutput) Strategy() BeatSpecDeploymentStrategyPtrOutput {
	return o.ApplyT(func(v *BeatSpecDeployment) *BeatSpecDeploymentStrategy {
		if v == nil {
			return nil
		}
		return v.Strategy
	}).(BeatSpecDeploymentStrategyPtrOutput)
}

// DeploymentStrategy describes how to replace existing pods with new ones.
type BeatSpecDeploymentStrategy struct {
	// Rolling update config params. Present only if DeploymentStrategyType =
	// RollingUpdate.
	// ---
	// TODO: Update this to follow our convention for oneOf, whatever we decide it
	// to be.
	RollingUpdate *BeatSpecDeploymentStrategyRollingUpdate `pulumi:"rollingUpdate"`
	// Type of deployment. Can be "Recreate" or "RollingUpdate". Default is RollingUpdate.
	Type *string `pulumi:"type"`
}

// BeatSpecDeploymentStrategyInput is an input type that accepts BeatSpecDeploymentStrategyArgs and BeatSpecDeploymentStrategyOutput values.
// You can construct a concrete instance of `BeatSpecDeploymentStrategyInput` via:
//
//	BeatSpecDeploymentStrategyArgs{...}
type BeatSpecDeploymentStrategyInput interface {
	pulumi.Input

	ToBeatSpecDeploymentStrategyOutput() BeatSpecDeploymentStrategyOutput
	ToBeatSpecDeploymentStrategyOutputWithContext(context.Context) BeatSpecDeploymentStrategyOutput
}

// DeploymentStrategy describes how to replace existing pods with new ones.
type BeatSpecDeploymentStrategyArgs struct {
	// Rolling update config params. Present only if DeploymentStrategyType =
	// RollingUpdate.
	// ---
	// TODO: Update this to follow our convention for oneOf, whatever we decide it
	// to be.
	RollingUpdate BeatSpecDeploymentStrategyRollingUpdatePtrInput `pulumi:"rollingUpdate"`
	// Type of deployment. Can be "Recreate" or "RollingUpdate". Default is RollingUpdate.
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (BeatSpecDeploymentStrategyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*BeatSpecDeploymentStrategy)(nil)).Elem()
}

func (i BeatSpecDeploymentStrategyArgs) ToBeatSpecDeploymentStrategyOutput() BeatSpecDeploymentStrategyOutput {
	return i.ToBeatSpecDeploymentStrategyOutputWithContext(context.Background())
}

func (i BeatSpecDeploymentStrategyArgs) ToBeatSpecDeploymentStrategyOutputWithContext(ctx context.Context) BeatSpecDeploymentStrategyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BeatSpecDeploymentStrategyOutput)
}

func (i BeatSpecDeploymentStrategyArgs) ToBeatSpecDeploymentStrategyPtrOutput() BeatSpecDeploymentStrategyPtrOutput {
	return i.ToBeatSpecDeploymentStrategyPtrOutputWithContext(context.Background())
}

func (i BeatSpecDeploymentStrategyArgs) ToBeatSpecDeploymentStrategyPtrOutputWithContext(ctx context.Context) BeatSpecDeploymentStrategyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BeatSpecDeploymentStrategyOutput).ToBeatSpecDeploymentStrategyPtrOutputWithContext(ctx)
}

// BeatSpecDeploymentStrategyPtrInput is an input type that accepts BeatSpecDeploymentStrategyArgs, BeatSpecDeploymentStrategyPtr and BeatSpecDeploymentStrategyPtrOutput values.
// You can construct a concrete instance of `BeatSpecDeploymentStrategyPtrInput` via:
//
//	        BeatSpecDeploymentStrategyArgs{...}
//
//	or:
//
//	        nil
type BeatSpecDeploymentStrategyPtrInput interface {
	pulumi.Input

	ToBeatSpecDeploymentStrategyPtrOutput() BeatSpecDeploymentStrategyPtrOutput
	ToBeatSpecDeploymentStrategyPtrOutputWithContext(context.Context) BeatSpecDeploymentStrategyPtrOutput
}

type beatSpecDeploymentStrategyPtrType BeatSpecDeploymentStrategyArgs

func BeatSpecDeploymentStrategyPtr(v *BeatSpecDeploymentStrategyArgs) BeatSpecDeploymentStrategyPtrInput {
	return (*beatSpecDeploymentStrategyPtrType)(v)
}

func (*beatSpecDeploymentStrategyPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**BeatSpecDeploymentStrategy)(nil)).Elem()
}

func (i *beatSpecDeploymentStrategyPtrType) ToBeatSpecDeploymentStrategyPtrOutput() BeatSpecDeploymentStrategyPtrOutput {
	return i.ToBeatSpecDeploymentStrategyPtrOutputWithContext(context.Background())
}

func (i *beatSpecDeploymentStrategyPtrType) ToBeatSpecDeploymentStrategyPtrOutputWithContext(ctx context.Context) BeatSpecDeploymentStrategyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BeatSpecDeploymentStrategyPtrOutput)
}

// DeploymentStrategy describes how to replace existing pods with new ones.
type BeatSpecDeploymentStrategyOutput struct{ *pulumi.OutputState }

func (BeatSpecDeploymentStrategyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BeatSpecDeploymentStrategy)(nil)).Elem()
}

func (o BeatSpecDeploymentStrategyOutput) ToBeatSpecDeploymentStrategyOutput() BeatSpecDeploymentStrategyOutput {
	return o
}

func (o BeatSpecDeploymentStrategyOutput) ToBeatSpecDeploymentStrategyOutputWithContext(ctx context.Context) BeatSpecDeploymentStrategyOutput {
	return o
}

func (o BeatSpecDeploymentStrategyOutput) ToBeatSpecDeploymentStrategyPtrOutput() BeatSpecDeploymentStrategyPtrOutput {
	return o.ToBeatSpecDeploymentStrategyPtrOutputWithContext(context.Background())
}

func (o BeatSpecDeploymentStrategyOutput) ToBeatSpecDeploymentStrategyPtrOutputWithContext(ctx context.Context) BeatSpecDeploymentStrategyPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v BeatSpecDeploymentStrategy) *BeatSpecDeploymentStrategy {
		return &v
	}).(BeatSpecDeploymentStrategyPtrOutput)
}

// Rolling update config params. Present only if DeploymentStrategyType =
// RollingUpdate.
// ---
// TODO: Update this to follow our convention for oneOf, whatever we decide it
// to be.
func (o BeatSpecDeploymentStrategyOutput) RollingUpdate() BeatSpecDeploymentStrategyRollingUpdatePtrOutput {
	return o.ApplyT(func(v BeatSpecDeploymentStrategy) *BeatSpecDeploymentStrategyRollingUpdate { return v.RollingUpdate }).(BeatSpecDeploymentStrategyRollingUpdatePtrOutput)
}

// Type of deployment. Can be "Recreate" or "RollingUpdate". Default is RollingUpdate.
func (o BeatSpecDeploymentStrategyOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BeatSpecDeploymentStrategy) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type BeatSpecDeploymentStrategyPtrOutput struct{ *pulumi.OutputState }

func (BeatSpecDeploymentStrategyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**BeatSpecDeploymentStrategy)(nil)).Elem()
}

func (o BeatSpecDeploymentStrategyPtrOutput) ToBeatSpecDeploymentStrategyPtrOutput() BeatSpecDeploymentStrategyPtrOutput {
	return o
}

func (o BeatSpecDeploymentStrategyPtrOutput) ToBeatSpecDeploymentStrategyPtrOutputWithContext(ctx context.Context) BeatSpecDeploymentStrategyPtrOutput {
	return o
}

func (o BeatSpecDeploymentStrategyPtrOutput) Elem() BeatSpecDeploymentStrategyOutput {
	return o.ApplyT(func(v *BeatSpecDeploymentStrategy) BeatSpecDeploymentStrategy {
		if v != nil {
			return *v
		}
		var ret BeatSpecDeploymentStrategy
		return ret
	}).(BeatSpecDeploymentStrategyOutput)
}

// Rolling update config params. Present only if DeploymentStrategyType =
// RollingUpdate.
// ---
// TODO: Update this to follow our convention for oneOf, whatever we decide it
// to be.
func (o BeatSpecDeploymentStrategyPtrOutput) RollingUpdate() BeatSpecDeploymentStrategyRollingUpdatePtrOutput {
	return o.ApplyT(func(v *BeatSpecDeploymentStrategy) *BeatSpecDeploymentStrategyRollingUpdate {
		if v == nil {
			return nil
		}
		return v.RollingUpdate
	}).(BeatSpecDeploymentStrategyRollingUpdatePtrOutput)
}

// Type of deployment. Can be "Recreate" or "RollingUpdate". Default is RollingUpdate.
func (o BeatSpecDeploymentStrategyPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BeatSpecDeploymentStrategy) *string {
		if v == nil {
			return nil
		}
		return v.Type
	}).(pulumi.StringPtrOutput)
}

// Rolling update config params. Present only if DeploymentStrategyType =
// RollingUpdate.
// ---
// TODO: Update this to follow our convention for oneOf, whatever we decide it
// to be.
type BeatSpecDeploymentStrategyRollingUpdate struct {
	// The maximum number of pods that can be scheduled above the desired number of
	// pods.
	// Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
	// This can not be 0 if MaxUnavailable is 0.
	// Absolute number is calculated from percentage by rounding up.
	// Defaults to 25%.
	// Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when
	// the rolling update starts, such that the total number of old and new pods do not exceed
	// 130% of desired pods. Once old pods have been killed,
	// new ReplicaSet can be scaled up further, ensuring that total number of pods running
	// at any time during the update is at most 130% of desired pods.
	MaxSurge interface{} `pulumi:"maxSurge"`
	// The maximum number of pods that can be unavailable during the update.
	// Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
	// Absolute number is calculated from percentage by rounding down.
	// This can not be 0 if MaxSurge is 0.
	// Defaults to 25%.
	// Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods
	// immediately when the rolling update starts. Once new pods are ready, old ReplicaSet
	// can be scaled down further, followed by scaling up the new ReplicaSet, ensuring
	// that the total number of pods available at all times during the update is at
	// least 70% of desired pods.
	MaxUnavailable interface{} `pulumi:"maxUnavailable"`
}

// BeatSpecDeploymentStrategyRollingUpdateInput is an input type that accepts BeatSpecDeploymentStrategyRollingUpdateArgs and BeatSpecDeploymentStrategyRollingUpdateOutput values.
// You can construct a concrete instance of `BeatSpecDeploymentStrategyRollingUpdateInput` via:
//
//	BeatSpecDeploymentStrategyRollingUpdateArgs{...}
type BeatSpecDeploymentStrategyRollingUpdateInput interface {
	pulumi.Input

	ToBeatSpecDeploymentStrategyRollingUpdateOutput() BeatSpecDeploymentStrategyRollingUpdateOutput
	ToBeatSpecDeploymentStrategyRollingUpdateOutputWithContext(context.Context) BeatSpecDeploymentStrategyRollingUpdateOutput
}

// Rolling update config params. Present only if DeploymentStrategyType =
// RollingUpdate.
// ---
// TODO: Update this to follow our convention for oneOf, whatever we decide it
// to be.
type BeatSpecDeploymentStrategyRollingUpdateArgs struct {
	// The maximum number of pods that can be scheduled above the desired number of
	// pods.
	// Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
	// This can not be 0 if MaxUnavailable is 0.
	// Absolute number is calculated from percentage by rounding up.
	// Defaults to 25%.
	// Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when
	// the rolling update starts, such that the total number of old and new pods do not exceed
	// 130% of desired pods. Once old pods have been killed,
	// new ReplicaSet can be scaled up further, ensuring that total number of pods running
	// at any time during the update is at most 130% of desired pods.
	MaxSurge pulumi.Input `pulumi:"maxSurge"`
	// The maximum number of pods that can be unavailable during the update.
	// Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
	// Absolute number is calculated from percentage by rounding down.
	// This can not be 0 if MaxSurge is 0.
	// Defaults to 25%.
	// Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods
	// immediately when the rolling update starts. Once new pods are ready, old ReplicaSet
	// can be scaled down further, followed by scaling up the new ReplicaSet, ensuring
	// that the total number of pods available at all times during the update is at
	// least 70% of desired pods.
	MaxUnavailable pulumi.Input `pulumi:"maxUnavailable"`
}

func (BeatSpecDeploymentStrategyRollingUpdateArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*BeatSpecDeploymentStrategyRollingUpdate)(nil)).Elem()
}

func (i BeatSpecDeploymentStrategyRollingUpdateArgs) ToBeatSpecDeploymentStrategyRollingUpdateOutput() BeatSpecDeploymentStrategyRollingUpdateOutput {
	return i.ToBeatSpecDeploymentStrategyRollingUpdateOutputWithContext(context.Background())
}

func (i BeatSpecDeploymentStrategyRollingUpdateArgs) ToBeatSpecDeploymentStrategyRollingUpdateOutputWithContext(ctx context.Context) BeatSpecDeploymentStrategyRollingUpdateOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BeatSpecDeploymentStrategyRollingUpdateOutput)
}

func (i BeatSpecDeploymentStrategyRollingUpdateArgs) ToBeatSpecDeploymentStrategyRollingUpdatePtrOutput() BeatSpecDeploymentStrategyRollingUpdatePtrOutput {
	return i.ToBeatSpecDeploymentStrategyRollingUpdatePtrOutputWithContext(context.Background())
}

func (i BeatSpecDeploymentStrategyRollingUpdateArgs) ToBeatSpecDeploymentStrategyRollingUpdatePtrOutputWithContext(ctx context.Context) BeatSpecDeploymentStrategyRollingUpdatePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BeatSpecDeploymentStrategyRollingUpdateOutput).ToBeatSpecDeploymentStrategyRollingUpdatePtrOutputWithContext(ctx)
}

// BeatSpecDeploymentStrategyRollingUpdatePtrInput is an input type that accepts BeatSpecDeploymentStrategyRollingUpdateArgs, BeatSpecDeploymentStrategyRollingUpdatePtr and BeatSpecDeploymentStrategyRollingUpdatePtrOutput values.
// You can construct a concrete instance of `BeatSpecDeploymentStrategyRollingUpdatePtrInput` via:
//
//	        BeatSpecDeploymentStrategyRollingUpdateArgs{...}
//
//	or:
//
//	        nil
type BeatSpecDeploymentStrategyRollingUpdatePtrInput interface {
	pulumi.Input

	ToBeatSpecDeploymentStrategyRollingUpdatePtrOutput() BeatSpecDeploymentStrategyRollingUpdatePtrOutput
	ToBeatSpecDeploymentStrategyRollingUpdatePtrOutputWithContext(context.Context) BeatSpecDeploymentStrategyRollingUpdatePtrOutput
}

type beatSpecDeploymentStrategyRollingUpdatePtrType BeatSpecDeploymentStrategyRollingUpdateArgs

func BeatSpecDeploymentStrategyRollingUpdatePtr(v *BeatSpecDeploymentStrategyRollingUpdateArgs) BeatSpecDeploymentStrategyRollingUpdatePtrInput {
	return (*beatSpecDeploymentStrategyRollingUpdatePtrType)(v)
}

func (*beatSpecDeploymentStrategyRollingUpdatePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**BeatSpecDeploymentStrategyRollingUpdate)(nil)).Elem()
}

func (i *beatSpecDeploymentStrategyRollingUpdatePtrType) ToBeatSpecDeploymentStrategyRollingUpdatePtrOutput() BeatSpecDeploymentStrategyRollingUpdatePtrOutput {
	return i.ToBeatSpecDeploymentStrategyRollingUpdatePtrOutputWithContext(context.Background())
}

func (i *beatSpecDeploymentStrategyRollingUpdatePtrType) ToBeatSpecDeploymentStrategyRollingUpdatePtrOutputWithContext(ctx context.Context) BeatSpecDeploymentStrategyRollingUpdatePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BeatSpecDeploymentStrategyRollingUpdatePtrOutput)
}

// Rolling update config params. Present only if DeploymentStrategyType =
// RollingUpdate.
// ---
// TODO: Update this to follow our convention for oneOf, whatever we decide it
// to be.
type BeatSpecDeploymentStrategyRollingUpdateOutput struct{ *pulumi.OutputState }

func (BeatSpecDeploymentStrategyRollingUpdateOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BeatSpecDeploymentStrategyRollingUpdate)(nil)).Elem()
}

func (o BeatSpecDeploymentStrategyRollingUpdateOutput) ToBeatSpecDeploymentStrategyRollingUpdateOutput() BeatSpecDeploymentStrategyRollingUpdateOutput {
	return o
}

func (o BeatSpecDeploymentStrategyRollingUpdateOutput) ToBeatSpecDeploymentStrategyRollingUpdateOutputWithContext(ctx context.Context) BeatSpecDeploymentStrategyRollingUpdateOutput {
	return o
}

func (o BeatSpecDeploymentStrategyRollingUpdateOutput) ToBeatSpecDeploymentStrategyRollingUpdatePtrOutput() BeatSpecDeploymentStrategyRollingUpdatePtrOutput {
	return o.ToBeatSpecDeploymentStrategyRollingUpdatePtrOutputWithContext(context.Background())
}

func (o BeatSpecDeploymentStrategyRollingUpdateOutput) ToBeatSpecDeploymentStrategyRollingUpdatePtrOutputWithContext(ctx context.Context) BeatSpecDeploymentStrategyRollingUpdatePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v BeatSpecDeploymentStrategyRollingUpdate) *BeatSpecDeploymentStrategyRollingUpdate {
		return &v
	}).(BeatSpecDeploymentStrategyRollingUpdatePtrOutput)
}

// The maximum number of pods that can be scheduled above the desired number of
// pods.
// Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
// This can not be 0 if MaxUnavailable is 0.
// Absolute number is calculated from percentage by rounding up.
// Defaults to 25%.
// Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when
// the rolling update starts, such that the total number of old and new pods do not exceed
// 130% of desired pods. Once old pods have been killed,
// new ReplicaSet can be scaled up further, ensuring that total number of pods running
// at any time during the update is at most 130% of desired pods.
func (o BeatSpecDeploymentStrategyRollingUpdateOutput) MaxSurge() pulumi.AnyOutput {
	return o.ApplyT(func(v BeatSpecDeploymentStrategyRollingUpdate) interface{} { return v.MaxSurge }).(pulumi.AnyOutput)
}

// The maximum number of pods that can be unavailable during the update.
// Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
// Absolute number is calculated from percentage by rounding down.
// This can not be 0 if MaxSurge is 0.
// Defaults to 25%.
// Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods
// immediately when the rolling update starts. Once new pods are ready, old ReplicaSet
// can be scaled down further, followed by scaling up the new ReplicaSet, ensuring
// that the total number of pods available at all times during the update is at
// least 70% of desired pods.
func (o BeatSpecDeploymentStrategyRollingUpdateOutput) MaxUnavailable() pulumi.AnyOutput {
	return o.ApplyT(func(v BeatSpecDeploymentStrategyRollingUpdate) interface{} { return v.MaxUnavailable }).(pulumi.AnyOutput)
}

type BeatSpecDeploymentStrategyRollingUpdatePtrOutput struct{ *pulumi.OutputState }

func (BeatSpecDeploymentStrategyRollingUpdatePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**BeatSpecDeploymentStrategyRollingUpdate)(nil)).Elem()
}

func (o BeatSpecDeploymentStrategyRollingUpdatePtrOutput) ToBeatSpecDeploymentStrategyRollingUpdatePtrOutput() BeatSpecDeploymentStrategyRollingUpdatePtrOutput {
	return o
}

func (o BeatSpecDeploymentStrategyRollingUpdatePtrOutput) ToBeatSpecDeploymentStrategyRollingUpdatePtrOutputWithContext(ctx context.Context) BeatSpecDeploymentStrategyRollingUpdatePtrOutput {
	return o
}

func (o BeatSpecDeploymentStrategyRollingUpdatePtrOutput) Elem() BeatSpecDeploymentStrategyRollingUpdateOutput {
	return o.ApplyT(func(v *BeatSpecDeploymentStrategyRollingUpdate) BeatSpecDeploymentStrategyRollingUpdate {
		if v != nil {
			return *v
		}
		var ret BeatSpecDeploymentStrategyRollingUpdate
		return ret
	}).(BeatSpecDeploymentStrategyRollingUpdateOutput)
}

// The maximum number of pods that can be scheduled above the desired number of
// pods.
// Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
// This can not be 0 if MaxUnavailable is 0.
// Absolute number is calculated from percentage by rounding up.
// Defaults to 25%.
// Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when
// the rolling update starts, such that the total number of old and new pods do not exceed
// 130% of desired pods. Once old pods have been killed,
// new ReplicaSet can be scaled up further, ensuring that total number of pods running
// at any time during the update is at most 130% of desired pods.
func (o BeatSpecDeploymentStrategyRollingUpdatePtrOutput) MaxSurge() pulumi.AnyOutput {
	return o.ApplyT(func(v *BeatSpecDeploymentStrategyRollingUpdate) interface{} {
		if v == nil {
			return nil
		}
		return v.MaxSurge
	}).(pulumi.AnyOutput)
}

// The maximum number of pods that can be unavailable during the update.
// Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
// Absolute number is calculated from percentage by rounding down.
// This can not be 0 if MaxSurge is 0.
// Defaults to 25%.
// Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods
// immediately when the rolling update starts. Once new pods are ready, old ReplicaSet
// can be scaled down further, followed by scaling up the new ReplicaSet, ensuring
// that the total number of pods available at all times during the update is at
// least 70% of desired pods.
func (o BeatSpecDeploymentStrategyRollingUpdatePtrOutput) MaxUnavailable() pulumi.AnyOutput {
	return o.ApplyT(func(v *BeatSpecDeploymentStrategyRollingUpdate) interface{} {
		if v == nil {
			return nil
		}
		return v.MaxUnavailable
	}).(pulumi.AnyOutput)
}

// ElasticsearchRef is a reference to an Elasticsearch cluster running in the same Kubernetes cluster.
type BeatSpecElasticsearchRef struct {
	// Name of an existing Kubernetes object corresponding to an Elastic resource managed by ECK.
	Name *string `pulumi:"name"`
	// Namespace of the Kubernetes object. If empty, defaults to the current namespace.
	Namespace *string `pulumi:"namespace"`
	// SecretName is the name of an existing Kubernetes secret that contains connection information for associating an
	// Elastic resource not managed by the operator. The referenced secret must contain the following:
	// - `url`: the URL to reach the Elastic resource
	// - `username`: the username of the user to be authenticated to the Elastic resource
	// - `password`: the password of the user to be authenticated to the Elastic resource
	// - `ca.crt`: the CA certificate in PEM format (optional)
	// - `api-key`: the key to authenticate against the Elastic resource instead of a username and password (supported only for `elasticsearchRefs` in AgentSpec and in BeatSpec)
	//   This field cannot be used in combination with the other fields name, namespace or serviceName.
	SecretName *string `pulumi:"secretName"`
	// ServiceName is the name of an existing Kubernetes service which is used to make requests to the referenced
	// object. It has to be in the same namespace as the referenced resource. If left empty, the default HTTP service of
	// the referenced resource is used.
	ServiceName *string `pulumi:"serviceName"`
}

// BeatSpecElasticsearchRefInput is an input type that accepts BeatSpecElasticsearchRefArgs and BeatSpecElasticsearchRefOutput values.
// You can construct a concrete instance of `BeatSpecElasticsearchRefInput` via:
//
//	BeatSpecElasticsearchRefArgs{...}
type BeatSpecElasticsearchRefInput interface {
	pulumi.Input

	ToBeatSpecElasticsearchRefOutput() BeatSpecElasticsearchRefOutput
	ToBeatSpecElasticsearchRefOutputWithContext(context.Context) BeatSpecElasticsearchRefOutput
}

// ElasticsearchRef is a reference to an Elasticsearch cluster running in the same Kubernetes cluster.
type BeatSpecElasticsearchRefArgs struct {
	// Name of an existing Kubernetes object corresponding to an Elastic resource managed by ECK.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace of the Kubernetes object. If empty, defaults to the current namespace.
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// SecretName is the name of an existing Kubernetes secret that contains connection information for associating an
	// Elastic resource not managed by the operator. The referenced secret must contain the following:
	// - `url`: the URL to reach the Elastic resource
	// - `username`: the username of the user to be authenticated to the Elastic resource
	// - `password`: the password of the user to be authenticated to the Elastic resource
	// - `ca.crt`: the CA certificate in PEM format (optional)
	// - `api-key`: the key to authenticate against the Elastic resource instead of a username and password (supported only for `elasticsearchRefs` in AgentSpec and in BeatSpec)
	//   This field cannot be used in combination with the other fields name, namespace or serviceName.
	SecretName pulumi.StringPtrInput `pulumi:"secretName"`
	// ServiceName is the name of an existing Kubernetes service which is used to make requests to the referenced
	// object. It has to be in the same namespace as the referenced resource. If left empty, the default HTTP service of
	// the referenced resource is used.
	ServiceName pulumi.StringPtrInput `pulumi:"serviceName"`
}

func (BeatSpecElasticsearchRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*BeatSpecElasticsearchRef)(nil)).Elem()
}

func (i BeatSpecElasticsearchRefArgs) ToBeatSpecElasticsearchRefOutput() BeatSpecElasticsearchRefOutput {
	return i.ToBeatSpecElasticsearchRefOutputWithContext(context.Background())
}

func (i BeatSpecElasticsearchRefArgs) ToBeatSpecElasticsearchRefOutputWithContext(ctx context.Context) BeatSpecElasticsearchRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BeatSpecElasticsearchRefOutput)
}

func (i BeatSpecElasticsearchRefArgs) ToBeatSpecElasticsearchRefPtrOutput() BeatSpecElasticsearchRefPtrOutput {
	return i.ToBeatSpecElasticsearchRefPtrOutputWithContext(context.Background())
}

func (i BeatSpecElasticsearchRefArgs) ToBeatSpecElasticsearchRefPtrOutputWithContext(ctx context.Context) BeatSpecElasticsearchRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BeatSpecElasticsearchRefOutput).ToBeatSpecElasticsearchRefPtrOutputWithContext(ctx)
}

// BeatSpecElasticsearchRefPtrInput is an input type that accepts BeatSpecElasticsearchRefArgs, BeatSpecElasticsearchRefPtr and BeatSpecElasticsearchRefPtrOutput values.
// You can construct a concrete instance of `BeatSpecElasticsearchRefPtrInput` via:
//
//	        BeatSpecElasticsearchRefArgs{...}
//
//	or:
//
//	        nil
type BeatSpecElasticsearchRefPtrInput interface {
	pulumi.Input

	ToBeatSpecElasticsearchRefPtrOutput() BeatSpecElasticsearchRefPtrOutput
	ToBeatSpecElasticsearchRefPtrOutputWithContext(context.Context) BeatSpecElasticsearchRefPtrOutput
}

type beatSpecElasticsearchRefPtrType BeatSpecElasticsearchRefArgs

func BeatSpecElasticsearchRefPtr(v *BeatSpecElasticsearchRefArgs) BeatSpecElasticsearchRefPtrInput {
	return (*beatSpecElasticsearchRefPtrType)(v)
}

func (*beatSpecElasticsearchRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**BeatSpecElasticsearchRef)(nil)).Elem()
}

func (i *beatSpecElasticsearchRefPtrType) ToBeatSpecElasticsearchRefPtrOutput() BeatSpecElasticsearchRefPtrOutput {
	return i.ToBeatSpecElasticsearchRefPtrOutputWithContext(context.Background())
}

func (i *beatSpecElasticsearchRefPtrType) ToBeatSpecElasticsearchRefPtrOutputWithContext(ctx context.Context) BeatSpecElasticsearchRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BeatSpecElasticsearchRefPtrOutput)
}

// ElasticsearchRef is a reference to an Elasticsearch cluster running in the same Kubernetes cluster.
type BeatSpecElasticsearchRefOutput struct{ *pulumi.OutputState }

func (BeatSpecElasticsearchRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BeatSpecElasticsearchRef)(nil)).Elem()
}

func (o BeatSpecElasticsearchRefOutput) ToBeatSpecElasticsearchRefOutput() BeatSpecElasticsearchRefOutput {
	return o
}

func (o BeatSpecElasticsearchRefOutput) ToBeatSpecElasticsearchRefOutputWithContext(ctx context.Context) BeatSpecElasticsearchRefOutput {
	return o
}

func (o BeatSpecElasticsearchRefOutput) ToBeatSpecElasticsearchRefPtrOutput() BeatSpecElasticsearchRefPtrOutput {
	return o.ToBeatSpecElasticsearchRefPtrOutputWithContext(context.Background())
}

func (o BeatSpecElasticsearchRefOutput) ToBeatSpecElasticsearchRefPtrOutputWithContext(ctx context.Context) BeatSpecElasticsearchRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v BeatSpecElasticsearchRef) *BeatSpecElasticsearchRef {
		return &v
	}).(BeatSpecElasticsearchRefPtrOutput)
}

// Name of an existing Kubernetes object corresponding to an Elastic resource managed by ECK.
func (o BeatSpecElasticsearchRefOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BeatSpecElasticsearchRef) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace of the Kubernetes object. If empty, defaults to the current namespace.
func (o BeatSpecElasticsearchRefOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BeatSpecElasticsearchRef) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// SecretName is the name of an existing Kubernetes secret that contains connection information for associating an
// Elastic resource not managed by the operator. The referenced secret must contain the following:
//   - `url`: the URL to reach the Elastic resource
//   - `username`: the username of the user to be authenticated to the Elastic resource
//   - `password`: the password of the user to be authenticated to the Elastic resource
//   - `ca.crt`: the CA certificate in PEM format (optional)
//   - `api-key`: the key to authenticate against the Elastic resource instead of a username and password (supported only for `elasticsearchRefs` in AgentSpec and in BeatSpec)
//     This field cannot be used in combination with the other fields name, namespace or serviceName.
func (o BeatSpecElasticsearchRefOutput) SecretName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BeatSpecElasticsearchRef) *string { return v.SecretName }).(pulumi.StringPtrOutput)
}

// ServiceName is the name of an existing Kubernetes service which is used to make requests to the referenced
// object. It has to be in the same namespace as the referenced resource. If left empty, the default HTTP service of
// the referenced resource is used.
func (o BeatSpecElasticsearchRefOutput) ServiceName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BeatSpecElasticsearchRef) *string { return v.ServiceName }).(pulumi.StringPtrOutput)
}

type BeatSpecElasticsearchRefPtrOutput struct{ *pulumi.OutputState }

func (BeatSpecElasticsearchRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**BeatSpecElasticsearchRef)(nil)).Elem()
}

func (o BeatSpecElasticsearchRefPtrOutput) ToBeatSpecElasticsearchRefPtrOutput() BeatSpecElasticsearchRefPtrOutput {
	return o
}

func (o BeatSpecElasticsearchRefPtrOutput) ToBeatSpecElasticsearchRefPtrOutputWithContext(ctx context.Context) BeatSpecElasticsearchRefPtrOutput {
	return o
}

func (o BeatSpecElasticsearchRefPtrOutput) Elem() BeatSpecElasticsearchRefOutput {
	return o.ApplyT(func(v *BeatSpecElasticsearchRef) BeatSpecElasticsearchRef {
		if v != nil {
			return *v
		}
		var ret BeatSpecElasticsearchRef
		return ret
	}).(BeatSpecElasticsearchRefOutput)
}

// Name of an existing Kubernetes object corresponding to an Elastic resource managed by ECK.
func (o BeatSpecElasticsearchRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BeatSpecElasticsearchRef) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Namespace of the Kubernetes object. If empty, defaults to the current namespace.
func (o BeatSpecElasticsearchRefPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BeatSpecElasticsearchRef) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

// SecretName is the name of an existing Kubernetes secret that contains connection information for associating an
// Elastic resource not managed by the operator. The referenced secret must contain the following:
//   - `url`: the URL to reach the Elastic resource
//   - `username`: the username of the user to be authenticated to the Elastic resource
//   - `password`: the password of the user to be authenticated to the Elastic resource
//   - `ca.crt`: the CA certificate in PEM format (optional)
//   - `api-key`: the key to authenticate against the Elastic resource instead of a username and password (supported only for `elasticsearchRefs` in AgentSpec and in BeatSpec)
//     This field cannot be used in combination with the other fields name, namespace or serviceName.
func (o BeatSpecElasticsearchRefPtrOutput) SecretName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BeatSpecElasticsearchRef) *string {
		if v == nil {
			return nil
		}
		return v.SecretName
	}).(pulumi.StringPtrOutput)
}

// ServiceName is the name of an existing Kubernetes service which is used to make requests to the referenced
// object. It has to be in the same namespace as the referenced resource. If left empty, the default HTTP service of
// the referenced resource is used.
func (o BeatSpecElasticsearchRefPtrOutput) ServiceName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BeatSpecElasticsearchRef) *string {
		if v == nil {
			return nil
		}
		return v.ServiceName
	}).(pulumi.StringPtrOutput)
}

// KibanaRef is a reference to a Kibana instance running in the same Kubernetes cluster.
// It allows automatic setup of dashboards and visualizations.
type BeatSpecKibanaRef struct {
	// Name of an existing Kubernetes object corresponding to an Elastic resource managed by ECK.
	Name *string `pulumi:"name"`
	// Namespace of the Kubernetes object. If empty, defaults to the current namespace.
	Namespace *string `pulumi:"namespace"`
	// SecretName is the name of an existing Kubernetes secret that contains connection information for associating an
	// Elastic resource not managed by the operator. The referenced secret must contain the following:
	// - `url`: the URL to reach the Elastic resource
	// - `username`: the username of the user to be authenticated to the Elastic resource
	// - `password`: the password of the user to be authenticated to the Elastic resource
	// - `ca.crt`: the CA certificate in PEM format (optional)
	// - `api-key`: the key to authenticate against the Elastic resource instead of a username and password (supported only for `elasticsearchRefs` in AgentSpec and in BeatSpec)
	//   This field cannot be used in combination with the other fields name, namespace or serviceName.
	SecretName *string `pulumi:"secretName"`
	// ServiceName is the name of an existing Kubernetes service which is used to make requests to the referenced
	// object. It has to be in the same namespace as the referenced resource. If left empty, the default HTTP service of
	// the referenced resource is used.
	ServiceName *string `pulumi:"serviceName"`
}

// BeatSpecKibanaRefInput is an input type that accepts BeatSpecKibanaRefArgs and BeatSpecKibanaRefOutput values.
// You can construct a concrete instance of `BeatSpecKibanaRefInput` via:
//
//	BeatSpecKibanaRefArgs{...}
type BeatSpecKibanaRefInput interface {
	pulumi.Input

	ToBeatSpecKibanaRefOutput() BeatSpecKibanaRefOutput
	ToBeatSpecKibanaRefOutputWithContext(context.Context) BeatSpecKibanaRefOutput
}

// KibanaRef is a reference to a Kibana instance running in the same Kubernetes cluster.
// It allows automatic setup of dashboards and visualizations.
type BeatSpecKibanaRefArgs struct {
	// Name of an existing Kubernetes object corresponding to an Elastic resource managed by ECK.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace of the Kubernetes object. If empty, defaults to the current namespace.
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// SecretName is the name of an existing Kubernetes secret that contains connection information for associating an
	// Elastic resource not managed by the operator. The referenced secret must contain the following:
	// - `url`: the URL to reach the Elastic resource
	// - `username`: the username of the user to be authenticated to the Elastic resource
	// - `password`: the password of the user to be authenticated to the Elastic resource
	// - `ca.crt`: the CA certificate in PEM format (optional)
	// - `api-key`: the key to authenticate against the Elastic resource instead of a username and password (supported only for `elasticsearchRefs` in AgentSpec and in BeatSpec)
	//   This field cannot be used in combination with the other fields name, namespace or serviceName.
	SecretName pulumi.StringPtrInput `pulumi:"secretName"`
	// ServiceName is the name of an existing Kubernetes service which is used to make requests to the referenced
	// object. It has to be in the same namespace as the referenced resource. If left empty, the default HTTP service of
	// the referenced resource is used.
	ServiceName pulumi.StringPtrInput `pulumi:"serviceName"`
}

func (BeatSpecKibanaRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*BeatSpecKibanaRef)(nil)).Elem()
}

func (i BeatSpecKibanaRefArgs) ToBeatSpecKibanaRefOutput() BeatSpecKibanaRefOutput {
	return i.ToBeatSpecKibanaRefOutputWithContext(context.Background())
}

func (i BeatSpecKibanaRefArgs) ToBeatSpecKibanaRefOutputWithContext(ctx context.Context) BeatSpecKibanaRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BeatSpecKibanaRefOutput)
}

func (i BeatSpecKibanaRefArgs) ToBeatSpecKibanaRefPtrOutput() BeatSpecKibanaRefPtrOutput {
	return i.ToBeatSpecKibanaRefPtrOutputWithContext(context.Background())
}

func (i BeatSpecKibanaRefArgs) ToBeatSpecKibanaRefPtrOutputWithContext(ctx context.Context) BeatSpecKibanaRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BeatSpecKibanaRefOutput).ToBeatSpecKibanaRefPtrOutputWithContext(ctx)
}

// BeatSpecKibanaRefPtrInput is an input type that accepts BeatSpecKibanaRefArgs, BeatSpecKibanaRefPtr and BeatSpecKibanaRefPtrOutput values.
// You can construct a concrete instance of `BeatSpecKibanaRefPtrInput` via:
//
//	        BeatSpecKibanaRefArgs{...}
//
//	or:
//
//	        nil
type BeatSpecKibanaRefPtrInput interface {
	pulumi.Input

	ToBeatSpecKibanaRefPtrOutput() BeatSpecKibanaRefPtrOutput
	ToBeatSpecKibanaRefPtrOutputWithContext(context.Context) BeatSpecKibanaRefPtrOutput
}

type beatSpecKibanaRefPtrType BeatSpecKibanaRefArgs

func BeatSpecKibanaRefPtr(v *BeatSpecKibanaRefArgs) BeatSpecKibanaRefPtrInput {
	return (*beatSpecKibanaRefPtrType)(v)
}

func (*beatSpecKibanaRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**BeatSpecKibanaRef)(nil)).Elem()
}

func (i *beatSpecKibanaRefPtrType) ToBeatSpecKibanaRefPtrOutput() BeatSpecKibanaRefPtrOutput {
	return i.ToBeatSpecKibanaRefPtrOutputWithContext(context.Background())
}

func (i *beatSpecKibanaRefPtrType) ToBeatSpecKibanaRefPtrOutputWithContext(ctx context.Context) BeatSpecKibanaRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BeatSpecKibanaRefPtrOutput)
}

// KibanaRef is a reference to a Kibana instance running in the same Kubernetes cluster.
// It allows automatic setup of dashboards and visualizations.
type BeatSpecKibanaRefOutput struct{ *pulumi.OutputState }

func (BeatSpecKibanaRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BeatSpecKibanaRef)(nil)).Elem()
}

func (o BeatSpecKibanaRefOutput) ToBeatSpecKibanaRefOutput() BeatSpecKibanaRefOutput {
	return o
}

func (o BeatSpecKibanaRefOutput) ToBeatSpecKibanaRefOutputWithContext(ctx context.Context) BeatSpecKibanaRefOutput {
	return o
}

func (o BeatSpecKibanaRefOutput) ToBeatSpecKibanaRefPtrOutput() BeatSpecKibanaRefPtrOutput {
	return o.ToBeatSpecKibanaRefPtrOutputWithContext(context.Background())
}

func (o BeatSpecKibanaRefOutput) ToBeatSpecKibanaRefPtrOutputWithContext(ctx context.Context) BeatSpecKibanaRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v BeatSpecKibanaRef) *BeatSpecKibanaRef {
		return &v
	}).(BeatSpecKibanaRefPtrOutput)
}

// Name of an existing Kubernetes object corresponding to an Elastic resource managed by ECK.
func (o BeatSpecKibanaRefOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BeatSpecKibanaRef) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace of the Kubernetes object. If empty, defaults to the current namespace.
func (o BeatSpecKibanaRefOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BeatSpecKibanaRef) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// SecretName is the name of an existing Kubernetes secret that contains connection information for associating an
// Elastic resource not managed by the operator. The referenced secret must contain the following:
//   - `url`: the URL to reach the Elastic resource
//   - `username`: the username of the user to be authenticated to the Elastic resource
//   - `password`: the password of the user to be authenticated to the Elastic resource
//   - `ca.crt`: the CA certificate in PEM format (optional)
//   - `api-key`: the key to authenticate against the Elastic resource instead of a username and password (supported only for `elasticsearchRefs` in AgentSpec and in BeatSpec)
//     This field cannot be used in combination with the other fields name, namespace or serviceName.
func (o BeatSpecKibanaRefOutput) SecretName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BeatSpecKibanaRef) *string { return v.SecretName }).(pulumi.StringPtrOutput)
}

// ServiceName is the name of an existing Kubernetes service which is used to make requests to the referenced
// object. It has to be in the same namespace as the referenced resource. If left empty, the default HTTP service of
// the referenced resource is used.
func (o BeatSpecKibanaRefOutput) ServiceName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BeatSpecKibanaRef) *string { return v.ServiceName }).(pulumi.StringPtrOutput)
}

type BeatSpecKibanaRefPtrOutput struct{ *pulumi.OutputState }

func (BeatSpecKibanaRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**BeatSpecKibanaRef)(nil)).Elem()
}

func (o BeatSpecKibanaRefPtrOutput) ToBeatSpecKibanaRefPtrOutput() BeatSpecKibanaRefPtrOutput {
	return o
}

func (o BeatSpecKibanaRefPtrOutput) ToBeatSpecKibanaRefPtrOutputWithContext(ctx context.Context) BeatSpecKibanaRefPtrOutput {
	return o
}

func (o BeatSpecKibanaRefPtrOutput) Elem() BeatSpecKibanaRefOutput {
	return o.ApplyT(func(v *BeatSpecKibanaRef) BeatSpecKibanaRef {
		if v != nil {
			return *v
		}
		var ret BeatSpecKibanaRef
		return ret
	}).(BeatSpecKibanaRefOutput)
}

// Name of an existing Kubernetes object corresponding to an Elastic resource managed by ECK.
func (o BeatSpecKibanaRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BeatSpecKibanaRef) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Namespace of the Kubernetes object. If empty, defaults to the current namespace.
func (o BeatSpecKibanaRefPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BeatSpecKibanaRef) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

// SecretName is the name of an existing Kubernetes secret that contains connection information for associating an
// Elastic resource not managed by the operator. The referenced secret must contain the following:
//   - `url`: the URL to reach the Elastic resource
//   - `username`: the username of the user to be authenticated to the Elastic resource
//   - `password`: the password of the user to be authenticated to the Elastic resource
//   - `ca.crt`: the CA certificate in PEM format (optional)
//   - `api-key`: the key to authenticate against the Elastic resource instead of a username and password (supported only for `elasticsearchRefs` in AgentSpec and in BeatSpec)
//     This field cannot be used in combination with the other fields name, namespace or serviceName.
func (o BeatSpecKibanaRefPtrOutput) SecretName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BeatSpecKibanaRef) *string {
		if v == nil {
			return nil
		}
		return v.SecretName
	}).(pulumi.StringPtrOutput)
}

// ServiceName is the name of an existing Kubernetes service which is used to make requests to the referenced
// object. It has to be in the same namespace as the referenced resource. If left empty, the default HTTP service of
// the referenced resource is used.
func (o BeatSpecKibanaRefPtrOutput) ServiceName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BeatSpecKibanaRef) *string {
		if v == nil {
			return nil
		}
		return v.ServiceName
	}).(pulumi.StringPtrOutput)
}

// Monitoring enables you to collect and ship logs and metrics for this Beat.
// Metricbeat and/or Filebeat sidecars are configured and send monitoring data to an
// Elasticsearch monitoring cluster running in the same Kubernetes cluster.
type BeatSpecMonitoring struct {
	// Logs holds references to Elasticsearch clusters which receive log data from an associated resource.
	Logs *BeatSpecMonitoringLogs `pulumi:"logs"`
	// Metrics holds references to Elasticsearch clusters which receive monitoring data from this resource.
	Metrics *BeatSpecMonitoringMetrics `pulumi:"metrics"`
}

// BeatSpecMonitoringInput is an input type that accepts BeatSpecMonitoringArgs and BeatSpecMonitoringOutput values.
// You can construct a concrete instance of `BeatSpecMonitoringInput` via:
//
//	BeatSpecMonitoringArgs{...}
type BeatSpecMonitoringInput interface {
	pulumi.Input

	ToBeatSpecMonitoringOutput() BeatSpecMonitoringOutput
	ToBeatSpecMonitoringOutputWithContext(context.Context) BeatSpecMonitoringOutput
}

// Monitoring enables you to collect and ship logs and metrics for this Beat.
// Metricbeat and/or Filebeat sidecars are configured and send monitoring data to an
// Elasticsearch monitoring cluster running in the same Kubernetes cluster.
type BeatSpecMonitoringArgs struct {
	// Logs holds references to Elasticsearch clusters which receive log data from an associated resource.
	Logs BeatSpecMonitoringLogsPtrInput `pulumi:"logs"`
	// Metrics holds references to Elasticsearch clusters which receive monitoring data from this resource.
	Metrics BeatSpecMonitoringMetricsPtrInput `pulumi:"metrics"`
}

func (BeatSpecMonitoringArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*BeatSpecMonitoring)(nil)).Elem()
}

func (i BeatSpecMonitoringArgs) ToBeatSpecMonitoringOutput() BeatSpecMonitoringOutput {
	return i.ToBeatSpecMonitoringOutputWithContext(context.Background())
}

func (i BeatSpecMonitoringArgs) ToBeatSpecMonitoringOutputWithContext(ctx context.Context) BeatSpecMonitoringOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BeatSpecMonitoringOutput)
}

func (i BeatSpecMonitoringArgs) ToBeatSpecMonitoringPtrOutput() BeatSpecMonitoringPtrOutput {
	return i.ToBeatSpecMonitoringPtrOutputWithContext(context.Background())
}

func (i BeatSpecMonitoringArgs) ToBeatSpecMonitoringPtrOutputWithContext(ctx context.Context) BeatSpecMonitoringPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BeatSpecMonitoringOutput).ToBeatSpecMonitoringPtrOutputWithContext(ctx)
}

// BeatSpecMonitoringPtrInput is an input type that accepts BeatSpecMonitoringArgs, BeatSpecMonitoringPtr and BeatSpecMonitoringPtrOutput values.
// You can construct a concrete instance of `BeatSpecMonitoringPtrInput` via:
//
//	        BeatSpecMonitoringArgs{...}
//
//	or:
//
//	        nil
type BeatSpecMonitoringPtrInput interface {
	pulumi.Input

	ToBeatSpecMonitoringPtrOutput() BeatSpecMonitoringPtrOutput
	ToBeatSpecMonitoringPtrOutputWithContext(context.Context) BeatSpecMonitoringPtrOutput
}

type beatSpecMonitoringPtrType BeatSpecMonitoringArgs

func BeatSpecMonitoringPtr(v *BeatSpecMonitoringArgs) BeatSpecMonitoringPtrInput {
	return (*beatSpecMonitoringPtrType)(v)
}

func (*beatSpecMonitoringPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**BeatSpecMonitoring)(nil)).Elem()
}

func (i *beatSpecMonitoringPtrType) ToBeatSpecMonitoringPtrOutput() BeatSpecMonitoringPtrOutput {
	return i.ToBeatSpecMonitoringPtrOutputWithContext(context.Background())
}

func (i *beatSpecMonitoringPtrType) ToBeatSpecMonitoringPtrOutputWithContext(ctx context.Context) BeatSpecMonitoringPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BeatSpecMonitoringPtrOutput)
}

// Monitoring enables you to collect and ship logs and metrics for this Beat.
// Metricbeat and/or Filebeat sidecars are configured and send monitoring data to an
// Elasticsearch monitoring cluster running in the same Kubernetes cluster.
type BeatSpecMonitoringOutput struct{ *pulumi.OutputState }

func (BeatSpecMonitoringOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BeatSpecMonitoring)(nil)).Elem()
}

func (o BeatSpecMonitoringOutput) ToBeatSpecMonitoringOutput() BeatSpecMonitoringOutput {
	return o
}

func (o BeatSpecMonitoringOutput) ToBeatSpecMonitoringOutputWithContext(ctx context.Context) BeatSpecMonitoringOutput {
	return o
}

func (o BeatSpecMonitoringOutput) ToBeatSpecMonitoringPtrOutput() BeatSpecMonitoringPtrOutput {
	return o.ToBeatSpecMonitoringPtrOutputWithContext(context.Background())
}

func (o BeatSpecMonitoringOutput) ToBeatSpecMonitoringPtrOutputWithContext(ctx context.Context) BeatSpecMonitoringPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v BeatSpecMonitoring) *BeatSpecMonitoring {
		return &v
	}).(BeatSpecMonitoringPtrOutput)
}

// Logs holds references to Elasticsearch clusters which receive log data from an associated resource.
func (o BeatSpecMonitoringOutput) Logs() BeatSpecMonitoringLogsPtrOutput {
	return o.ApplyT(func(v BeatSpecMonitoring) *BeatSpecMonitoringLogs { return v.Logs }).(BeatSpecMonitoringLogsPtrOutput)
}

// Metrics holds references to Elasticsearch clusters which receive monitoring data from this resource.
func (o BeatSpecMonitoringOutput) Metrics() BeatSpecMonitoringMetricsPtrOutput {
	return o.ApplyT(func(v BeatSpecMonitoring) *BeatSpecMonitoringMetrics { return v.Metrics }).(BeatSpecMonitoringMetricsPtrOutput)
}

type BeatSpecMonitoringPtrOutput struct{ *pulumi.OutputState }

func (BeatSpecMonitoringPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**BeatSpecMonitoring)(nil)).Elem()
}

func (o BeatSpecMonitoringPtrOutput) ToBeatSpecMonitoringPtrOutput() BeatSpecMonitoringPtrOutput {
	return o
}

func (o BeatSpecMonitoringPtrOutput) ToBeatSpecMonitoringPtrOutputWithContext(ctx context.Context) BeatSpecMonitoringPtrOutput {
	return o
}

func (o BeatSpecMonitoringPtrOutput) Elem() BeatSpecMonitoringOutput {
	return o.ApplyT(func(v *BeatSpecMonitoring) BeatSpecMonitoring {
		if v != nil {
			return *v
		}
		var ret BeatSpecMonitoring
		return ret
	}).(BeatSpecMonitoringOutput)
}

// Logs holds references to Elasticsearch clusters which receive log data from an associated resource.
func (o BeatSpecMonitoringPtrOutput) Logs() BeatSpecMonitoringLogsPtrOutput {
	return o.ApplyT(func(v *BeatSpecMonitoring) *BeatSpecMonitoringLogs {
		if v == nil {
			return nil
		}
		return v.Logs
	}).(BeatSpecMonitoringLogsPtrOutput)
}

// Metrics holds references to Elasticsearch clusters which receive monitoring data from this resource.
func (o BeatSpecMonitoringPtrOutput) Metrics() BeatSpecMonitoringMetricsPtrOutput {
	return o.ApplyT(func(v *BeatSpecMonitoring) *BeatSpecMonitoringMetrics {
		if v == nil {
			return nil
		}
		return v.Metrics
	}).(BeatSpecMonitoringMetricsPtrOutput)
}

// Logs holds references to Elasticsearch clusters which receive log data from an associated resource.
type BeatSpecMonitoringLogs struct {
	// ElasticsearchRefs is a reference to a list of monitoring Elasticsearch clusters running in the same Kubernetes cluster.
	// Due to existing limitations, only a single Elasticsearch cluster is currently supported.
	ElasticsearchRefs []BeatSpecMonitoringLogsElasticsearchRefs `pulumi:"elasticsearchRefs"`
}

// BeatSpecMonitoringLogsInput is an input type that accepts BeatSpecMonitoringLogsArgs and BeatSpecMonitoringLogsOutput values.
// You can construct a concrete instance of `BeatSpecMonitoringLogsInput` via:
//
//	BeatSpecMonitoringLogsArgs{...}
type BeatSpecMonitoringLogsInput interface {
	pulumi.Input

	ToBeatSpecMonitoringLogsOutput() BeatSpecMonitoringLogsOutput
	ToBeatSpecMonitoringLogsOutputWithContext(context.Context) BeatSpecMonitoringLogsOutput
}

// Logs holds references to Elasticsearch clusters which receive log data from an associated resource.
type BeatSpecMonitoringLogsArgs struct {
	// ElasticsearchRefs is a reference to a list of monitoring Elasticsearch clusters running in the same Kubernetes cluster.
	// Due to existing limitations, only a single Elasticsearch cluster is currently supported.
	ElasticsearchRefs BeatSpecMonitoringLogsElasticsearchRefsArrayInput `pulumi:"elasticsearchRefs"`
}

func (BeatSpecMonitoringLogsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*BeatSpecMonitoringLogs)(nil)).Elem()
}

func (i BeatSpecMonitoringLogsArgs) ToBeatSpecMonitoringLogsOutput() BeatSpecMonitoringLogsOutput {
	return i.ToBeatSpecMonitoringLogsOutputWithContext(context.Background())
}

func (i BeatSpecMonitoringLogsArgs) ToBeatSpecMonitoringLogsOutputWithContext(ctx context.Context) BeatSpecMonitoringLogsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BeatSpecMonitoringLogsOutput)
}

func (i BeatSpecMonitoringLogsArgs) ToBeatSpecMonitoringLogsPtrOutput() BeatSpecMonitoringLogsPtrOutput {
	return i.ToBeatSpecMonitoringLogsPtrOutputWithContext(context.Background())
}

func (i BeatSpecMonitoringLogsArgs) ToBeatSpecMonitoringLogsPtrOutputWithContext(ctx context.Context) BeatSpecMonitoringLogsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BeatSpecMonitoringLogsOutput).ToBeatSpecMonitoringLogsPtrOutputWithContext(ctx)
}

// BeatSpecMonitoringLogsPtrInput is an input type that accepts BeatSpecMonitoringLogsArgs, BeatSpecMonitoringLogsPtr and BeatSpecMonitoringLogsPtrOutput values.
// You can construct a concrete instance of `BeatSpecMonitoringLogsPtrInput` via:
//
//	        BeatSpecMonitoringLogsArgs{...}
//
//	or:
//
//	        nil
type BeatSpecMonitoringLogsPtrInput interface {
	pulumi.Input

	ToBeatSpecMonitoringLogsPtrOutput() BeatSpecMonitoringLogsPtrOutput
	ToBeatSpecMonitoringLogsPtrOutputWithContext(context.Context) BeatSpecMonitoringLogsPtrOutput
}

type beatSpecMonitoringLogsPtrType BeatSpecMonitoringLogsArgs

func BeatSpecMonitoringLogsPtr(v *BeatSpecMonitoringLogsArgs) BeatSpecMonitoringLogsPtrInput {
	return (*beatSpecMonitoringLogsPtrType)(v)
}

func (*beatSpecMonitoringLogsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**BeatSpecMonitoringLogs)(nil)).Elem()
}

func (i *beatSpecMonitoringLogsPtrType) ToBeatSpecMonitoringLogsPtrOutput() BeatSpecMonitoringLogsPtrOutput {
	return i.ToBeatSpecMonitoringLogsPtrOutputWithContext(context.Background())
}

func (i *beatSpecMonitoringLogsPtrType) ToBeatSpecMonitoringLogsPtrOutputWithContext(ctx context.Context) BeatSpecMonitoringLogsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BeatSpecMonitoringLogsPtrOutput)
}

// Logs holds references to Elasticsearch clusters which receive log data from an associated resource.
type BeatSpecMonitoringLogsOutput struct{ *pulumi.OutputState }

func (BeatSpecMonitoringLogsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BeatSpecMonitoringLogs)(nil)).Elem()
}

func (o BeatSpecMonitoringLogsOutput) ToBeatSpecMonitoringLogsOutput() BeatSpecMonitoringLogsOutput {
	return o
}

func (o BeatSpecMonitoringLogsOutput) ToBeatSpecMonitoringLogsOutputWithContext(ctx context.Context) BeatSpecMonitoringLogsOutput {
	return o
}

func (o BeatSpecMonitoringLogsOutput) ToBeatSpecMonitoringLogsPtrOutput() BeatSpecMonitoringLogsPtrOutput {
	return o.ToBeatSpecMonitoringLogsPtrOutputWithContext(context.Background())
}

func (o BeatSpecMonitoringLogsOutput) ToBeatSpecMonitoringLogsPtrOutputWithContext(ctx context.Context) BeatSpecMonitoringLogsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v BeatSpecMonitoringLogs) *BeatSpecMonitoringLogs {
		return &v
	}).(BeatSpecMonitoringLogsPtrOutput)
}

// ElasticsearchRefs is a reference to a list of monitoring Elasticsearch clusters running in the same Kubernetes cluster.
// Due to existing limitations, only a single Elasticsearch cluster is currently supported.
func (o BeatSpecMonitoringLogsOutput) ElasticsearchRefs() BeatSpecMonitoringLogsElasticsearchRefsArrayOutput {
	return o.ApplyT(func(v BeatSpecMonitoringLogs) []BeatSpecMonitoringLogsElasticsearchRefs { return v.ElasticsearchRefs }).(BeatSpecMonitoringLogsElasticsearchRefsArrayOutput)
}

type BeatSpecMonitoringLogsPtrOutput struct{ *pulumi.OutputState }

func (BeatSpecMonitoringLogsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**BeatSpecMonitoringLogs)(nil)).Elem()
}

func (o BeatSpecMonitoringLogsPtrOutput) ToBeatSpecMonitoringLogsPtrOutput() BeatSpecMonitoringLogsPtrOutput {
	return o
}

func (o BeatSpecMonitoringLogsPtrOutput) ToBeatSpecMonitoringLogsPtrOutputWithContext(ctx context.Context) BeatSpecMonitoringLogsPtrOutput {
	return o
}

func (o BeatSpecMonitoringLogsPtrOutput) Elem() BeatSpecMonitoringLogsOutput {
	return o.ApplyT(func(v *BeatSpecMonitoringLogs) BeatSpecMonitoringLogs {
		if v != nil {
			return *v
		}
		var ret BeatSpecMonitoringLogs
		return ret
	}).(BeatSpecMonitoringLogsOutput)
}

// ElasticsearchRefs is a reference to a list of monitoring Elasticsearch clusters running in the same Kubernetes cluster.
// Due to existing limitations, only a single Elasticsearch cluster is currently supported.
func (o BeatSpecMonitoringLogsPtrOutput) ElasticsearchRefs() BeatSpecMonitoringLogsElasticsearchRefsArrayOutput {
	return o.ApplyT(func(v *BeatSpecMonitoringLogs) []BeatSpecMonitoringLogsElasticsearchRefs {
		if v == nil {
			return nil
		}
		return v.ElasticsearchRefs
	}).(BeatSpecMonitoringLogsElasticsearchRefsArrayOutput)
}

// ObjectSelector defines a reference to a Kubernetes object which can be an Elastic resource managed by the operator
// or a Secret describing an external Elastic resource not managed by the operator.
type BeatSpecMonitoringLogsElasticsearchRefs struct {
	// Name of an existing Kubernetes object corresponding to an Elastic resource managed by ECK.
	Name *string `pulumi:"name"`
	// Namespace of the Kubernetes object. If empty, defaults to the current namespace.
	Namespace *string `pulumi:"namespace"`
	// SecretName is the name of an existing Kubernetes secret that contains connection information for associating an
	// Elastic resource not managed by the operator. The referenced secret must contain the following:
	// - `url`: the URL to reach the Elastic resource
	// - `username`: the username of the user to be authenticated to the Elastic resource
	// - `password`: the password of the user to be authenticated to the Elastic resource
	// - `ca.crt`: the CA certificate in PEM format (optional)
	// - `api-key`: the key to authenticate against the Elastic resource instead of a username and password (supported only for `elasticsearchRefs` in AgentSpec and in BeatSpec)
	//   This field cannot be used in combination with the other fields name, namespace or serviceName.
	SecretName *string `pulumi:"secretName"`
	// ServiceName is the name of an existing Kubernetes service which is used to make requests to the referenced
	// object. It has to be in the same namespace as the referenced resource. If left empty, the default HTTP service of
	// the referenced resource is used.
	ServiceName *string `pulumi:"serviceName"`
}

// BeatSpecMonitoringLogsElasticsearchRefsInput is an input type that accepts BeatSpecMonitoringLogsElasticsearchRefsArgs and BeatSpecMonitoringLogsElasticsearchRefsOutput values.
// You can construct a concrete instance of `BeatSpecMonitoringLogsElasticsearchRefsInput` via:
//
//	BeatSpecMonitoringLogsElasticsearchRefsArgs{...}
type BeatSpecMonitoringLogsElasticsearchRefsInput interface {
	pulumi.Input

	ToBeatSpecMonitoringLogsElasticsearchRefsOutput() BeatSpecMonitoringLogsElasticsearchRefsOutput
	ToBeatSpecMonitoringLogsElasticsearchRefsOutputWithContext(context.Context) BeatSpecMonitoringLogsElasticsearchRefsOutput
}

// ObjectSelector defines a reference to a Kubernetes object which can be an Elastic resource managed by the operator
// or a Secret describing an external Elastic resource not managed by the operator.
type BeatSpecMonitoringLogsElasticsearchRefsArgs struct {
	// Name of an existing Kubernetes object corresponding to an Elastic resource managed by ECK.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace of the Kubernetes object. If empty, defaults to the current namespace.
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// SecretName is the name of an existing Kubernetes secret that contains connection information for associating an
	// Elastic resource not managed by the operator. The referenced secret must contain the following:
	// - `url`: the URL to reach the Elastic resource
	// - `username`: the username of the user to be authenticated to the Elastic resource
	// - `password`: the password of the user to be authenticated to the Elastic resource
	// - `ca.crt`: the CA certificate in PEM format (optional)
	// - `api-key`: the key to authenticate against the Elastic resource instead of a username and password (supported only for `elasticsearchRefs` in AgentSpec and in BeatSpec)
	//   This field cannot be used in combination with the other fields name, namespace or serviceName.
	SecretName pulumi.StringPtrInput `pulumi:"secretName"`
	// ServiceName is the name of an existing Kubernetes service which is used to make requests to the referenced
	// object. It has to be in the same namespace as the referenced resource. If left empty, the default HTTP service of
	// the referenced resource is used.
	ServiceName pulumi.StringPtrInput `pulumi:"serviceName"`
}

func (BeatSpecMonitoringLogsElasticsearchRefsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*BeatSpecMonitoringLogsElasticsearchRefs)(nil)).Elem()
}

func (i BeatSpecMonitoringLogsElasticsearchRefsArgs) ToBeatSpecMonitoringLogsElasticsearchRefsOutput() BeatSpecMonitoringLogsElasticsearchRefsOutput {
	return i.ToBeatSpecMonitoringLogsElasticsearchRefsOutputWithContext(context.Background())
}

func (i BeatSpecMonitoringLogsElasticsearchRefsArgs) ToBeatSpecMonitoringLogsElasticsearchRefsOutputWithContext(ctx context.Context) BeatSpecMonitoringLogsElasticsearchRefsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BeatSpecMonitoringLogsElasticsearchRefsOutput)
}

// BeatSpecMonitoringLogsElasticsearchRefsArrayInput is an input type that accepts BeatSpecMonitoringLogsElasticsearchRefsArray and BeatSpecMonitoringLogsElasticsearchRefsArrayOutput values.
// You can construct a concrete instance of `BeatSpecMonitoringLogsElasticsearchRefsArrayInput` via:
//
//	BeatSpecMonitoringLogsElasticsearchRefsArray{ BeatSpecMonitoringLogsElasticsearchRefsArgs{...} }
type BeatSpecMonitoringLogsElasticsearchRefsArrayInput interface {
	pulumi.Input

	ToBeatSpecMonitoringLogsElasticsearchRefsArrayOutput() BeatSpecMonitoringLogsElasticsearchRefsArrayOutput
	ToBeatSpecMonitoringLogsElasticsearchRefsArrayOutputWithContext(context.Context) BeatSpecMonitoringLogsElasticsearchRefsArrayOutput
}

type BeatSpecMonitoringLogsElasticsearchRefsArray []BeatSpecMonitoringLogsElasticsearchRefsInput

func (BeatSpecMonitoringLogsElasticsearchRefsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]BeatSpecMonitoringLogsElasticsearchRefs)(nil)).Elem()
}

func (i BeatSpecMonitoringLogsElasticsearchRefsArray) ToBeatSpecMonitoringLogsElasticsearchRefsArrayOutput() BeatSpecMonitoringLogsElasticsearchRefsArrayOutput {
	return i.ToBeatSpecMonitoringLogsElasticsearchRefsArrayOutputWithContext(context.Background())
}

func (i BeatSpecMonitoringLogsElasticsearchRefsArray) ToBeatSpecMonitoringLogsElasticsearchRefsArrayOutputWithContext(ctx context.Context) BeatSpecMonitoringLogsElasticsearchRefsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BeatSpecMonitoringLogsElasticsearchRefsArrayOutput)
}

// ObjectSelector defines a reference to a Kubernetes object which can be an Elastic resource managed by the operator
// or a Secret describing an external Elastic resource not managed by the operator.
type BeatSpecMonitoringLogsElasticsearchRefsOutput struct{ *pulumi.OutputState }

func (BeatSpecMonitoringLogsElasticsearchRefsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BeatSpecMonitoringLogsElasticsearchRefs)(nil)).Elem()
}

func (o BeatSpecMonitoringLogsElasticsearchRefsOutput) ToBeatSpecMonitoringLogsElasticsearchRefsOutput() BeatSpecMonitoringLogsElasticsearchRefsOutput {
	return o
}

func (o BeatSpecMonitoringLogsElasticsearchRefsOutput) ToBeatSpecMonitoringLogsElasticsearchRefsOutputWithContext(ctx context.Context) BeatSpecMonitoringLogsElasticsearchRefsOutput {
	return o
}

// Name of an existing Kubernetes object corresponding to an Elastic resource managed by ECK.
func (o BeatSpecMonitoringLogsElasticsearchRefsOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BeatSpecMonitoringLogsElasticsearchRefs) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace of the Kubernetes object. If empty, defaults to the current namespace.
func (o BeatSpecMonitoringLogsElasticsearchRefsOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BeatSpecMonitoringLogsElasticsearchRefs) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// SecretName is the name of an existing Kubernetes secret that contains connection information for associating an
// Elastic resource not managed by the operator. The referenced secret must contain the following:
//   - `url`: the URL to reach the Elastic resource
//   - `username`: the username of the user to be authenticated to the Elastic resource
//   - `password`: the password of the user to be authenticated to the Elastic resource
//   - `ca.crt`: the CA certificate in PEM format (optional)
//   - `api-key`: the key to authenticate against the Elastic resource instead of a username and password (supported only for `elasticsearchRefs` in AgentSpec and in BeatSpec)
//     This field cannot be used in combination with the other fields name, namespace or serviceName.
func (o BeatSpecMonitoringLogsElasticsearchRefsOutput) SecretName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BeatSpecMonitoringLogsElasticsearchRefs) *string { return v.SecretName }).(pulumi.StringPtrOutput)
}

// ServiceName is the name of an existing Kubernetes service which is used to make requests to the referenced
// object. It has to be in the same namespace as the referenced resource. If left empty, the default HTTP service of
// the referenced resource is used.
func (o BeatSpecMonitoringLogsElasticsearchRefsOutput) ServiceName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BeatSpecMonitoringLogsElasticsearchRefs) *string { return v.ServiceName }).(pulumi.StringPtrOutput)
}

type BeatSpecMonitoringLogsElasticsearchRefsArrayOutput struct{ *pulumi.OutputState }

func (BeatSpecMonitoringLogsElasticsearchRefsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]BeatSpecMonitoringLogsElasticsearchRefs)(nil)).Elem()
}

func (o BeatSpecMonitoringLogsElasticsearchRefsArrayOutput) ToBeatSpecMonitoringLogsElasticsearchRefsArrayOutput() BeatSpecMonitoringLogsElasticsearchRefsArrayOutput {
	return o
}

func (o BeatSpecMonitoringLogsElasticsearchRefsArrayOutput) ToBeatSpecMonitoringLogsElasticsearchRefsArrayOutputWithContext(ctx context.Context) BeatSpecMonitoringLogsElasticsearchRefsArrayOutput {
	return o
}

func (o BeatSpecMonitoringLogsElasticsearchRefsArrayOutput) Index(i pulumi.IntInput) BeatSpecMonitoringLogsElasticsearchRefsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) BeatSpecMonitoringLogsElasticsearchRefs {
		return vs[0].([]BeatSpecMonitoringLogsElasticsearchRefs)[vs[1].(int)]
	}).(BeatSpecMonitoringLogsElasticsearchRefsOutput)
}

// Metrics holds references to Elasticsearch clusters which receive monitoring data from this resource.
type BeatSpecMonitoringMetrics struct {
	// ElasticsearchRefs is a reference to a list of monitoring Elasticsearch clusters running in the same Kubernetes cluster.
	// Due to existing limitations, only a single Elasticsearch cluster is currently supported.
	ElasticsearchRefs []BeatSpecMonitoringMetricsElasticsearchRefs `pulumi:"elasticsearchRefs"`
}

// BeatSpecMonitoringMetricsInput is an input type that accepts BeatSpecMonitoringMetricsArgs and BeatSpecMonitoringMetricsOutput values.
// You can construct a concrete instance of `BeatSpecMonitoringMetricsInput` via:
//
//	BeatSpecMonitoringMetricsArgs{...}
type BeatSpecMonitoringMetricsInput interface {
	pulumi.Input

	ToBeatSpecMonitoringMetricsOutput() BeatSpecMonitoringMetricsOutput
	ToBeatSpecMonitoringMetricsOutputWithContext(context.Context) BeatSpecMonitoringMetricsOutput
}

// Metrics holds references to Elasticsearch clusters which receive monitoring data from this resource.
type BeatSpecMonitoringMetricsArgs struct {
	// ElasticsearchRefs is a reference to a list of monitoring Elasticsearch clusters running in the same Kubernetes cluster.
	// Due to existing limitations, only a single Elasticsearch cluster is currently supported.
	ElasticsearchRefs BeatSpecMonitoringMetricsElasticsearchRefsArrayInput `pulumi:"elasticsearchRefs"`
}

func (BeatSpecMonitoringMetricsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*BeatSpecMonitoringMetrics)(nil)).Elem()
}

func (i BeatSpecMonitoringMetricsArgs) ToBeatSpecMonitoringMetricsOutput() BeatSpecMonitoringMetricsOutput {
	return i.ToBeatSpecMonitoringMetricsOutputWithContext(context.Background())
}

func (i BeatSpecMonitoringMetricsArgs) ToBeatSpecMonitoringMetricsOutputWithContext(ctx context.Context) BeatSpecMonitoringMetricsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BeatSpecMonitoringMetricsOutput)
}

func (i BeatSpecMonitoringMetricsArgs) ToBeatSpecMonitoringMetricsPtrOutput() BeatSpecMonitoringMetricsPtrOutput {
	return i.ToBeatSpecMonitoringMetricsPtrOutputWithContext(context.Background())
}

func (i BeatSpecMonitoringMetricsArgs) ToBeatSpecMonitoringMetricsPtrOutputWithContext(ctx context.Context) BeatSpecMonitoringMetricsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BeatSpecMonitoringMetricsOutput).ToBeatSpecMonitoringMetricsPtrOutputWithContext(ctx)
}

// BeatSpecMonitoringMetricsPtrInput is an input type that accepts BeatSpecMonitoringMetricsArgs, BeatSpecMonitoringMetricsPtr and BeatSpecMonitoringMetricsPtrOutput values.
// You can construct a concrete instance of `BeatSpecMonitoringMetricsPtrInput` via:
//
//	        BeatSpecMonitoringMetricsArgs{...}
//
//	or:
//
//	        nil
type BeatSpecMonitoringMetricsPtrInput interface {
	pulumi.Input

	ToBeatSpecMonitoringMetricsPtrOutput() BeatSpecMonitoringMetricsPtrOutput
	ToBeatSpecMonitoringMetricsPtrOutputWithContext(context.Context) BeatSpecMonitoringMetricsPtrOutput
}

type beatSpecMonitoringMetricsPtrType BeatSpecMonitoringMetricsArgs

func BeatSpecMonitoringMetricsPtr(v *BeatSpecMonitoringMetricsArgs) BeatSpecMonitoringMetricsPtrInput {
	return (*beatSpecMonitoringMetricsPtrType)(v)
}

func (*beatSpecMonitoringMetricsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**BeatSpecMonitoringMetrics)(nil)).Elem()
}

func (i *beatSpecMonitoringMetricsPtrType) ToBeatSpecMonitoringMetricsPtrOutput() BeatSpecMonitoringMetricsPtrOutput {
	return i.ToBeatSpecMonitoringMetricsPtrOutputWithContext(context.Background())
}

func (i *beatSpecMonitoringMetricsPtrType) ToBeatSpecMonitoringMetricsPtrOutputWithContext(ctx context.Context) BeatSpecMonitoringMetricsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BeatSpecMonitoringMetricsPtrOutput)
}

// Metrics holds references to Elasticsearch clusters which receive monitoring data from this resource.
type BeatSpecMonitoringMetricsOutput struct{ *pulumi.OutputState }

func (BeatSpecMonitoringMetricsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BeatSpecMonitoringMetrics)(nil)).Elem()
}

func (o BeatSpecMonitoringMetricsOutput) ToBeatSpecMonitoringMetricsOutput() BeatSpecMonitoringMetricsOutput {
	return o
}

func (o BeatSpecMonitoringMetricsOutput) ToBeatSpecMonitoringMetricsOutputWithContext(ctx context.Context) BeatSpecMonitoringMetricsOutput {
	return o
}

func (o BeatSpecMonitoringMetricsOutput) ToBeatSpecMonitoringMetricsPtrOutput() BeatSpecMonitoringMetricsPtrOutput {
	return o.ToBeatSpecMonitoringMetricsPtrOutputWithContext(context.Background())
}

func (o BeatSpecMonitoringMetricsOutput) ToBeatSpecMonitoringMetricsPtrOutputWithContext(ctx context.Context) BeatSpecMonitoringMetricsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v BeatSpecMonitoringMetrics) *BeatSpecMonitoringMetrics {
		return &v
	}).(BeatSpecMonitoringMetricsPtrOutput)
}

// ElasticsearchRefs is a reference to a list of monitoring Elasticsearch clusters running in the same Kubernetes cluster.
// Due to existing limitations, only a single Elasticsearch cluster is currently supported.
func (o BeatSpecMonitoringMetricsOutput) ElasticsearchRefs() BeatSpecMonitoringMetricsElasticsearchRefsArrayOutput {
	return o.ApplyT(func(v BeatSpecMonitoringMetrics) []BeatSpecMonitoringMetricsElasticsearchRefs {
		return v.ElasticsearchRefs
	}).(BeatSpecMonitoringMetricsElasticsearchRefsArrayOutput)
}

type BeatSpecMonitoringMetricsPtrOutput struct{ *pulumi.OutputState }

func (BeatSpecMonitoringMetricsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**BeatSpecMonitoringMetrics)(nil)).Elem()
}

func (o BeatSpecMonitoringMetricsPtrOutput) ToBeatSpecMonitoringMetricsPtrOutput() BeatSpecMonitoringMetricsPtrOutput {
	return o
}

func (o BeatSpecMonitoringMetricsPtrOutput) ToBeatSpecMonitoringMetricsPtrOutputWithContext(ctx context.Context) BeatSpecMonitoringMetricsPtrOutput {
	return o
}

func (o BeatSpecMonitoringMetricsPtrOutput) Elem() BeatSpecMonitoringMetricsOutput {
	return o.ApplyT(func(v *BeatSpecMonitoringMetrics) BeatSpecMonitoringMetrics {
		if v != nil {
			return *v
		}
		var ret BeatSpecMonitoringMetrics
		return ret
	}).(BeatSpecMonitoringMetricsOutput)
}

// ElasticsearchRefs is a reference to a list of monitoring Elasticsearch clusters running in the same Kubernetes cluster.
// Due to existing limitations, only a single Elasticsearch cluster is currently supported.
func (o BeatSpecMonitoringMetricsPtrOutput) ElasticsearchRefs() BeatSpecMonitoringMetricsElasticsearchRefsArrayOutput {
	return o.ApplyT(func(v *BeatSpecMonitoringMetrics) []BeatSpecMonitoringMetricsElasticsearchRefs {
		if v == nil {
			return nil
		}
		return v.ElasticsearchRefs
	}).(BeatSpecMonitoringMetricsElasticsearchRefsArrayOutput)
}

// ObjectSelector defines a reference to a Kubernetes object which can be an Elastic resource managed by the operator
// or a Secret describing an external Elastic resource not managed by the operator.
type BeatSpecMonitoringMetricsElasticsearchRefs struct {
	// Name of an existing Kubernetes object corresponding to an Elastic resource managed by ECK.
	Name *string `pulumi:"name"`
	// Namespace of the Kubernetes object. If empty, defaults to the current namespace.
	Namespace *string `pulumi:"namespace"`
	// SecretName is the name of an existing Kubernetes secret that contains connection information for associating an
	// Elastic resource not managed by the operator. The referenced secret must contain the following:
	// - `url`: the URL to reach the Elastic resource
	// - `username`: the username of the user to be authenticated to the Elastic resource
	// - `password`: the password of the user to be authenticated to the Elastic resource
	// - `ca.crt`: the CA certificate in PEM format (optional)
	// - `api-key`: the key to authenticate against the Elastic resource instead of a username and password (supported only for `elasticsearchRefs` in AgentSpec and in BeatSpec)
	//   This field cannot be used in combination with the other fields name, namespace or serviceName.
	SecretName *string `pulumi:"secretName"`
	// ServiceName is the name of an existing Kubernetes service which is used to make requests to the referenced
	// object. It has to be in the same namespace as the referenced resource. If left empty, the default HTTP service of
	// the referenced resource is used.
	ServiceName *string `pulumi:"serviceName"`
}

// BeatSpecMonitoringMetricsElasticsearchRefsInput is an input type that accepts BeatSpecMonitoringMetricsElasticsearchRefsArgs and BeatSpecMonitoringMetricsElasticsearchRefsOutput values.
// You can construct a concrete instance of `BeatSpecMonitoringMetricsElasticsearchRefsInput` via:
//
//	BeatSpecMonitoringMetricsElasticsearchRefsArgs{...}
type BeatSpecMonitoringMetricsElasticsearchRefsInput interface {
	pulumi.Input

	ToBeatSpecMonitoringMetricsElasticsearchRefsOutput() BeatSpecMonitoringMetricsElasticsearchRefsOutput
	ToBeatSpecMonitoringMetricsElasticsearchRefsOutputWithContext(context.Context) BeatSpecMonitoringMetricsElasticsearchRefsOutput
}

// ObjectSelector defines a reference to a Kubernetes object which can be an Elastic resource managed by the operator
// or a Secret describing an external Elastic resource not managed by the operator.
type BeatSpecMonitoringMetricsElasticsearchRefsArgs struct {
	// Name of an existing Kubernetes object corresponding to an Elastic resource managed by ECK.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace of the Kubernetes object. If empty, defaults to the current namespace.
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// SecretName is the name of an existing Kubernetes secret that contains connection information for associating an
	// Elastic resource not managed by the operator. The referenced secret must contain the following:
	// - `url`: the URL to reach the Elastic resource
	// - `username`: the username of the user to be authenticated to the Elastic resource
	// - `password`: the password of the user to be authenticated to the Elastic resource
	// - `ca.crt`: the CA certificate in PEM format (optional)
	// - `api-key`: the key to authenticate against the Elastic resource instead of a username and password (supported only for `elasticsearchRefs` in AgentSpec and in BeatSpec)
	//   This field cannot be used in combination with the other fields name, namespace or serviceName.
	SecretName pulumi.StringPtrInput `pulumi:"secretName"`
	// ServiceName is the name of an existing Kubernetes service which is used to make requests to the referenced
	// object. It has to be in the same namespace as the referenced resource. If left empty, the default HTTP service of
	// the referenced resource is used.
	ServiceName pulumi.StringPtrInput `pulumi:"serviceName"`
}

func (BeatSpecMonitoringMetricsElasticsearchRefsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*BeatSpecMonitoringMetricsElasticsearchRefs)(nil)).Elem()
}

func (i BeatSpecMonitoringMetricsElasticsearchRefsArgs) ToBeatSpecMonitoringMetricsElasticsearchRefsOutput() BeatSpecMonitoringMetricsElasticsearchRefsOutput {
	return i.ToBeatSpecMonitoringMetricsElasticsearchRefsOutputWithContext(context.Background())
}

func (i BeatSpecMonitoringMetricsElasticsearchRefsArgs) ToBeatSpecMonitoringMetricsElasticsearchRefsOutputWithContext(ctx context.Context) BeatSpecMonitoringMetricsElasticsearchRefsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BeatSpecMonitoringMetricsElasticsearchRefsOutput)
}

// BeatSpecMonitoringMetricsElasticsearchRefsArrayInput is an input type that accepts BeatSpecMonitoringMetricsElasticsearchRefsArray and BeatSpecMonitoringMetricsElasticsearchRefsArrayOutput values.
// You can construct a concrete instance of `BeatSpecMonitoringMetricsElasticsearchRefsArrayInput` via:
//
//	BeatSpecMonitoringMetricsElasticsearchRefsArray{ BeatSpecMonitoringMetricsElasticsearchRefsArgs{...} }
type BeatSpecMonitoringMetricsElasticsearchRefsArrayInput interface {
	pulumi.Input

	ToBeatSpecMonitoringMetricsElasticsearchRefsArrayOutput() BeatSpecMonitoringMetricsElasticsearchRefsArrayOutput
	ToBeatSpecMonitoringMetricsElasticsearchRefsArrayOutputWithContext(context.Context) BeatSpecMonitoringMetricsElasticsearchRefsArrayOutput
}

type BeatSpecMonitoringMetricsElasticsearchRefsArray []BeatSpecMonitoringMetricsElasticsearchRefsInput

func (BeatSpecMonitoringMetricsElasticsearchRefsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]BeatSpecMonitoringMetricsElasticsearchRefs)(nil)).Elem()
}

func (i BeatSpecMonitoringMetricsElasticsearchRefsArray) ToBeatSpecMonitoringMetricsElasticsearchRefsArrayOutput() BeatSpecMonitoringMetricsElasticsearchRefsArrayOutput {
	return i.ToBeatSpecMonitoringMetricsElasticsearchRefsArrayOutputWithContext(context.Background())
}

func (i BeatSpecMonitoringMetricsElasticsearchRefsArray) ToBeatSpecMonitoringMetricsElasticsearchRefsArrayOutputWithContext(ctx context.Context) BeatSpecMonitoringMetricsElasticsearchRefsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BeatSpecMonitoringMetricsElasticsearchRefsArrayOutput)
}

// ObjectSelector defines a reference to a Kubernetes object which can be an Elastic resource managed by the operator
// or a Secret describing an external Elastic resource not managed by the operator.
type BeatSpecMonitoringMetricsElasticsearchRefsOutput struct{ *pulumi.OutputState }

func (BeatSpecMonitoringMetricsElasticsearchRefsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BeatSpecMonitoringMetricsElasticsearchRefs)(nil)).Elem()
}

func (o BeatSpecMonitoringMetricsElasticsearchRefsOutput) ToBeatSpecMonitoringMetricsElasticsearchRefsOutput() BeatSpecMonitoringMetricsElasticsearchRefsOutput {
	return o
}

func (o BeatSpecMonitoringMetricsElasticsearchRefsOutput) ToBeatSpecMonitoringMetricsElasticsearchRefsOutputWithContext(ctx context.Context) BeatSpecMonitoringMetricsElasticsearchRefsOutput {
	return o
}

// Name of an existing Kubernetes object corresponding to an Elastic resource managed by ECK.
func (o BeatSpecMonitoringMetricsElasticsearchRefsOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BeatSpecMonitoringMetricsElasticsearchRefs) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace of the Kubernetes object. If empty, defaults to the current namespace.
func (o BeatSpecMonitoringMetricsElasticsearchRefsOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BeatSpecMonitoringMetricsElasticsearchRefs) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// SecretName is the name of an existing Kubernetes secret that contains connection information for associating an
// Elastic resource not managed by the operator. The referenced secret must contain the following:
//   - `url`: the URL to reach the Elastic resource
//   - `username`: the username of the user to be authenticated to the Elastic resource
//   - `password`: the password of the user to be authenticated to the Elastic resource
//   - `ca.crt`: the CA certificate in PEM format (optional)
//   - `api-key`: the key to authenticate against the Elastic resource instead of a username and password (supported only for `elasticsearchRefs` in AgentSpec and in BeatSpec)
//     This field cannot be used in combination with the other fields name, namespace or serviceName.
func (o BeatSpecMonitoringMetricsElasticsearchRefsOutput) SecretName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BeatSpecMonitoringMetricsElasticsearchRefs) *string { return v.SecretName }).(pulumi.StringPtrOutput)
}

// ServiceName is the name of an existing Kubernetes service which is used to make requests to the referenced
// object. It has to be in the same namespace as the referenced resource. If left empty, the default HTTP service of
// the referenced resource is used.
func (o BeatSpecMonitoringMetricsElasticsearchRefsOutput) ServiceName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BeatSpecMonitoringMetricsElasticsearchRefs) *string { return v.ServiceName }).(pulumi.StringPtrOutput)
}

type BeatSpecMonitoringMetricsElasticsearchRefsArrayOutput struct{ *pulumi.OutputState }

func (BeatSpecMonitoringMetricsElasticsearchRefsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]BeatSpecMonitoringMetricsElasticsearchRefs)(nil)).Elem()
}

func (o BeatSpecMonitoringMetricsElasticsearchRefsArrayOutput) ToBeatSpecMonitoringMetricsElasticsearchRefsArrayOutput() BeatSpecMonitoringMetricsElasticsearchRefsArrayOutput {
	return o
}

func (o BeatSpecMonitoringMetricsElasticsearchRefsArrayOutput) ToBeatSpecMonitoringMetricsElasticsearchRefsArrayOutputWithContext(ctx context.Context) BeatSpecMonitoringMetricsElasticsearchRefsArrayOutput {
	return o
}

func (o BeatSpecMonitoringMetricsElasticsearchRefsArrayOutput) Index(i pulumi.IntInput) BeatSpecMonitoringMetricsElasticsearchRefsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) BeatSpecMonitoringMetricsElasticsearchRefs {
		return vs[0].([]BeatSpecMonitoringMetricsElasticsearchRefs)[vs[1].(int)]
	}).(BeatSpecMonitoringMetricsElasticsearchRefsOutput)
}

// SecretSource defines a data source based on a Kubernetes Secret.
type BeatSpecSecureSettings struct {
	// Entries define how to project each key-value pair in the secret to filesystem paths.
	// If not defined, all keys will be projected to similarly named paths in the filesystem.
	// If defined, only the specified keys will be projected to the corresponding paths.
	Entries []BeatSpecSecureSettingsEntries `pulumi:"entries"`
	// SecretName is the name of the secret.
	SecretName string `pulumi:"secretName"`
}

// BeatSpecSecureSettingsInput is an input type that accepts BeatSpecSecureSettingsArgs and BeatSpecSecureSettingsOutput values.
// You can construct a concrete instance of `BeatSpecSecureSettingsInput` via:
//
//	BeatSpecSecureSettingsArgs{...}
type BeatSpecSecureSettingsInput interface {
	pulumi.Input

	ToBeatSpecSecureSettingsOutput() BeatSpecSecureSettingsOutput
	ToBeatSpecSecureSettingsOutputWithContext(context.Context) BeatSpecSecureSettingsOutput
}

// SecretSource defines a data source based on a Kubernetes Secret.
type BeatSpecSecureSettingsArgs struct {
	// Entries define how to project each key-value pair in the secret to filesystem paths.
	// If not defined, all keys will be projected to similarly named paths in the filesystem.
	// If defined, only the specified keys will be projected to the corresponding paths.
	Entries BeatSpecSecureSettingsEntriesArrayInput `pulumi:"entries"`
	// SecretName is the name of the secret.
	SecretName pulumi.StringInput `pulumi:"secretName"`
}

func (BeatSpecSecureSettingsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*BeatSpecSecureSettings)(nil)).Elem()
}

func (i BeatSpecSecureSettingsArgs) ToBeatSpecSecureSettingsOutput() BeatSpecSecureSettingsOutput {
	return i.ToBeatSpecSecureSettingsOutputWithContext(context.Background())
}

func (i BeatSpecSecureSettingsArgs) ToBeatSpecSecureSettingsOutputWithContext(ctx context.Context) BeatSpecSecureSettingsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BeatSpecSecureSettingsOutput)
}

// BeatSpecSecureSettingsArrayInput is an input type that accepts BeatSpecSecureSettingsArray and BeatSpecSecureSettingsArrayOutput values.
// You can construct a concrete instance of `BeatSpecSecureSettingsArrayInput` via:
//
//	BeatSpecSecureSettingsArray{ BeatSpecSecureSettingsArgs{...} }
type BeatSpecSecureSettingsArrayInput interface {
	pulumi.Input

	ToBeatSpecSecureSettingsArrayOutput() BeatSpecSecureSettingsArrayOutput
	ToBeatSpecSecureSettingsArrayOutputWithContext(context.Context) BeatSpecSecureSettingsArrayOutput
}

type BeatSpecSecureSettingsArray []BeatSpecSecureSettingsInput

func (BeatSpecSecureSettingsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]BeatSpecSecureSettings)(nil)).Elem()
}

func (i BeatSpecSecureSettingsArray) ToBeatSpecSecureSettingsArrayOutput() BeatSpecSecureSettingsArrayOutput {
	return i.ToBeatSpecSecureSettingsArrayOutputWithContext(context.Background())
}

func (i BeatSpecSecureSettingsArray) ToBeatSpecSecureSettingsArrayOutputWithContext(ctx context.Context) BeatSpecSecureSettingsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BeatSpecSecureSettingsArrayOutput)
}

// SecretSource defines a data source based on a Kubernetes Secret.
type BeatSpecSecureSettingsOutput struct{ *pulumi.OutputState }

func (BeatSpecSecureSettingsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BeatSpecSecureSettings)(nil)).Elem()
}

func (o BeatSpecSecureSettingsOutput) ToBeatSpecSecureSettingsOutput() BeatSpecSecureSettingsOutput {
	return o
}

func (o BeatSpecSecureSettingsOutput) ToBeatSpecSecureSettingsOutputWithContext(ctx context.Context) BeatSpecSecureSettingsOutput {
	return o
}

// Entries define how to project each key-value pair in the secret to filesystem paths.
// If not defined, all keys will be projected to similarly named paths in the filesystem.
// If defined, only the specified keys will be projected to the corresponding paths.
func (o BeatSpecSecureSettingsOutput) Entries() BeatSpecSecureSettingsEntriesArrayOutput {
	return o.ApplyT(func(v BeatSpecSecureSettings) []BeatSpecSecureSettingsEntries { return v.Entries }).(BeatSpecSecureSettingsEntriesArrayOutput)
}

// SecretName is the name of the secret.
func (o BeatSpecSecureSettingsOutput) SecretName() pulumi.StringOutput {
	return o.ApplyT(func(v BeatSpecSecureSettings) string { return v.SecretName }).(pulumi.StringOutput)
}

type BeatSpecSecureSettingsArrayOutput struct{ *pulumi.OutputState }

func (BeatSpecSecureSettingsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]BeatSpecSecureSettings)(nil)).Elem()
}

func (o BeatSpecSecureSettingsArrayOutput) ToBeatSpecSecureSettingsArrayOutput() BeatSpecSecureSettingsArrayOutput {
	return o
}

func (o BeatSpecSecureSettingsArrayOutput) ToBeatSpecSecureSettingsArrayOutputWithContext(ctx context.Context) BeatSpecSecureSettingsArrayOutput {
	return o
}

func (o BeatSpecSecureSettingsArrayOutput) Index(i pulumi.IntInput) BeatSpecSecureSettingsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) BeatSpecSecureSettings {
		return vs[0].([]BeatSpecSecureSettings)[vs[1].(int)]
	}).(BeatSpecSecureSettingsOutput)
}

// KeyToPath defines how to map a key in a Secret object to a filesystem path.
type BeatSpecSecureSettingsEntries struct {
	// Key is the key contained in the secret.
	Key string `pulumi:"key"`
	// Path is the relative file path to map the key to.
	// Path must not be an absolute file path and must not contain any ".." components.
	Path *string `pulumi:"path"`
}

// BeatSpecSecureSettingsEntriesInput is an input type that accepts BeatSpecSecureSettingsEntriesArgs and BeatSpecSecureSettingsEntriesOutput values.
// You can construct a concrete instance of `BeatSpecSecureSettingsEntriesInput` via:
//
//	BeatSpecSecureSettingsEntriesArgs{...}
type BeatSpecSecureSettingsEntriesInput interface {
	pulumi.Input

	ToBeatSpecSecureSettingsEntriesOutput() BeatSpecSecureSettingsEntriesOutput
	ToBeatSpecSecureSettingsEntriesOutputWithContext(context.Context) BeatSpecSecureSettingsEntriesOutput
}

// KeyToPath defines how to map a key in a Secret object to a filesystem path.
type BeatSpecSecureSettingsEntriesArgs struct {
	// Key is the key contained in the secret.
	Key pulumi.StringInput `pulumi:"key"`
	// Path is the relative file path to map the key to.
	// Path must not be an absolute file path and must not contain any ".." components.
	Path pulumi.StringPtrInput `pulumi:"path"`
}

func (BeatSpecSecureSettingsEntriesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*BeatSpecSecureSettingsEntries)(nil)).Elem()
}

func (i BeatSpecSecureSettingsEntriesArgs) ToBeatSpecSecureSettingsEntriesOutput() BeatSpecSecureSettingsEntriesOutput {
	return i.ToBeatSpecSecureSettingsEntriesOutputWithContext(context.Background())
}

func (i BeatSpecSecureSettingsEntriesArgs) ToBeatSpecSecureSettingsEntriesOutputWithContext(ctx context.Context) BeatSpecSecureSettingsEntriesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BeatSpecSecureSettingsEntriesOutput)
}

// BeatSpecSecureSettingsEntriesArrayInput is an input type that accepts BeatSpecSecureSettingsEntriesArray and BeatSpecSecureSettingsEntriesArrayOutput values.
// You can construct a concrete instance of `BeatSpecSecureSettingsEntriesArrayInput` via:
//
//	BeatSpecSecureSettingsEntriesArray{ BeatSpecSecureSettingsEntriesArgs{...} }
type BeatSpecSecureSettingsEntriesArrayInput interface {
	pulumi.Input

	ToBeatSpecSecureSettingsEntriesArrayOutput() BeatSpecSecureSettingsEntriesArrayOutput
	ToBeatSpecSecureSettingsEntriesArrayOutputWithContext(context.Context) BeatSpecSecureSettingsEntriesArrayOutput
}

type BeatSpecSecureSettingsEntriesArray []BeatSpecSecureSettingsEntriesInput

func (BeatSpecSecureSettingsEntriesArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]BeatSpecSecureSettingsEntries)(nil)).Elem()
}

func (i BeatSpecSecureSettingsEntriesArray) ToBeatSpecSecureSettingsEntriesArrayOutput() BeatSpecSecureSettingsEntriesArrayOutput {
	return i.ToBeatSpecSecureSettingsEntriesArrayOutputWithContext(context.Background())
}

func (i BeatSpecSecureSettingsEntriesArray) ToBeatSpecSecureSettingsEntriesArrayOutputWithContext(ctx context.Context) BeatSpecSecureSettingsEntriesArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BeatSpecSecureSettingsEntriesArrayOutput)
}

// KeyToPath defines how to map a key in a Secret object to a filesystem path.
type BeatSpecSecureSettingsEntriesOutput struct{ *pulumi.OutputState }

func (BeatSpecSecureSettingsEntriesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BeatSpecSecureSettingsEntries)(nil)).Elem()
}

func (o BeatSpecSecureSettingsEntriesOutput) ToBeatSpecSecureSettingsEntriesOutput() BeatSpecSecureSettingsEntriesOutput {
	return o
}

func (o BeatSpecSecureSettingsEntriesOutput) ToBeatSpecSecureSettingsEntriesOutputWithContext(ctx context.Context) BeatSpecSecureSettingsEntriesOutput {
	return o
}

// Key is the key contained in the secret.
func (o BeatSpecSecureSettingsEntriesOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v BeatSpecSecureSettingsEntries) string { return v.Key }).(pulumi.StringOutput)
}

// Path is the relative file path to map the key to.
// Path must not be an absolute file path and must not contain any ".." components.
func (o BeatSpecSecureSettingsEntriesOutput) Path() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BeatSpecSecureSettingsEntries) *string { return v.Path }).(pulumi.StringPtrOutput)
}

type BeatSpecSecureSettingsEntriesArrayOutput struct{ *pulumi.OutputState }

func (BeatSpecSecureSettingsEntriesArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]BeatSpecSecureSettingsEntries)(nil)).Elem()
}

func (o BeatSpecSecureSettingsEntriesArrayOutput) ToBeatSpecSecureSettingsEntriesArrayOutput() BeatSpecSecureSettingsEntriesArrayOutput {
	return o
}

func (o BeatSpecSecureSettingsEntriesArrayOutput) ToBeatSpecSecureSettingsEntriesArrayOutputWithContext(ctx context.Context) BeatSpecSecureSettingsEntriesArrayOutput {
	return o
}

func (o BeatSpecSecureSettingsEntriesArrayOutput) Index(i pulumi.IntInput) BeatSpecSecureSettingsEntriesOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) BeatSpecSecureSettingsEntries {
		return vs[0].([]BeatSpecSecureSettingsEntries)[vs[1].(int)]
	}).(BeatSpecSecureSettingsEntriesOutput)
}

// BeatStatus defines the observed state of a Beat.
type BeatStatus struct {
	AvailableNodes *int `pulumi:"availableNodes"`
	// AssociationStatus is the status of an association resource.
	ElasticsearchAssociationStatus *string `pulumi:"elasticsearchAssociationStatus"`
	ExpectedNodes                  *int    `pulumi:"expectedNodes"`
	Health                         *string `pulumi:"health"`
	// AssociationStatus is the status of an association resource.
	KibanaAssociationStatus *string `pulumi:"kibanaAssociationStatus"`
	// AssociationStatusMap is the map of association's namespaced name string to its AssociationStatus. For resources that
	// have a single Association of a given type (for ex. single ES reference), this map contains a single entry.
	MonitoringAssociationStatus map[string]string `pulumi:"monitoringAssociationStatus"`
	// ObservedGeneration represents the .metadata.generation that the status is based upon.
	// It corresponds to the metadata generation, which is updated on mutation by the API Server.
	// If the generation observed in status diverges from the generation in metadata, the Beats
	// controller has not yet processed the changes contained in the Beats specification.
	ObservedGeneration *int `pulumi:"observedGeneration"`
	// Version of the stack resource currently running. During version upgrades, multiple versions may run
	// in parallel: this value specifies the lowest version currently running.
	Version *string `pulumi:"version"`
}

// BeatStatusInput is an input type that accepts BeatStatusArgs and BeatStatusOutput values.
// You can construct a concrete instance of `BeatStatusInput` via:
//
//	BeatStatusArgs{...}
type BeatStatusInput interface {
	pulumi.Input

	ToBeatStatusOutput() BeatStatusOutput
	ToBeatStatusOutputWithContext(context.Context) BeatStatusOutput
}

// BeatStatus defines the observed state of a Beat.
type BeatStatusArgs struct {
	AvailableNodes pulumi.IntPtrInput `pulumi:"availableNodes"`
	// AssociationStatus is the status of an association resource.
	ElasticsearchAssociationStatus pulumi.StringPtrInput `pulumi:"elasticsearchAssociationStatus"`
	ExpectedNodes                  pulumi.IntPtrInput    `pulumi:"expectedNodes"`
	Health                         pulumi.StringPtrInput `pulumi:"health"`
	// AssociationStatus is the status of an association resource.
	KibanaAssociationStatus pulumi.StringPtrInput `pulumi:"kibanaAssociationStatus"`
	// AssociationStatusMap is the map of association's namespaced name string to its AssociationStatus. For resources that
	// have a single Association of a given type (for ex. single ES reference), this map contains a single entry.
	MonitoringAssociationStatus pulumi.StringMapInput `pulumi:"monitoringAssociationStatus"`
	// ObservedGeneration represents the .metadata.generation that the status is based upon.
	// It corresponds to the metadata generation, which is updated on mutation by the API Server.
	// If the generation observed in status diverges from the generation in metadata, the Beats
	// controller has not yet processed the changes contained in the Beats specification.
	ObservedGeneration pulumi.IntPtrInput `pulumi:"observedGeneration"`
	// Version of the stack resource currently running. During version upgrades, multiple versions may run
	// in parallel: this value specifies the lowest version currently running.
	Version pulumi.StringPtrInput `pulumi:"version"`
}

func (BeatStatusArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*BeatStatus)(nil)).Elem()
}

func (i BeatStatusArgs) ToBeatStatusOutput() BeatStatusOutput {
	return i.ToBeatStatusOutputWithContext(context.Background())
}

func (i BeatStatusArgs) ToBeatStatusOutputWithContext(ctx context.Context) BeatStatusOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BeatStatusOutput)
}

func (i BeatStatusArgs) ToBeatStatusPtrOutput() BeatStatusPtrOutput {
	return i.ToBeatStatusPtrOutputWithContext(context.Background())
}

func (i BeatStatusArgs) ToBeatStatusPtrOutputWithContext(ctx context.Context) BeatStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BeatStatusOutput).ToBeatStatusPtrOutputWithContext(ctx)
}

// BeatStatusPtrInput is an input type that accepts BeatStatusArgs, BeatStatusPtr and BeatStatusPtrOutput values.
// You can construct a concrete instance of `BeatStatusPtrInput` via:
//
//	        BeatStatusArgs{...}
//
//	or:
//
//	        nil
type BeatStatusPtrInput interface {
	pulumi.Input

	ToBeatStatusPtrOutput() BeatStatusPtrOutput
	ToBeatStatusPtrOutputWithContext(context.Context) BeatStatusPtrOutput
}

type beatStatusPtrType BeatStatusArgs

func BeatStatusPtr(v *BeatStatusArgs) BeatStatusPtrInput {
	return (*beatStatusPtrType)(v)
}

func (*beatStatusPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**BeatStatus)(nil)).Elem()
}

func (i *beatStatusPtrType) ToBeatStatusPtrOutput() BeatStatusPtrOutput {
	return i.ToBeatStatusPtrOutputWithContext(context.Background())
}

func (i *beatStatusPtrType) ToBeatStatusPtrOutputWithContext(ctx context.Context) BeatStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BeatStatusPtrOutput)
}

// BeatStatus defines the observed state of a Beat.
type BeatStatusOutput struct{ *pulumi.OutputState }

func (BeatStatusOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BeatStatus)(nil)).Elem()
}

func (o BeatStatusOutput) ToBeatStatusOutput() BeatStatusOutput {
	return o
}

func (o BeatStatusOutput) ToBeatStatusOutputWithContext(ctx context.Context) BeatStatusOutput {
	return o
}

func (o BeatStatusOutput) ToBeatStatusPtrOutput() BeatStatusPtrOutput {
	return o.ToBeatStatusPtrOutputWithContext(context.Background())
}

func (o BeatStatusOutput) ToBeatStatusPtrOutputWithContext(ctx context.Context) BeatStatusPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v BeatStatus) *BeatStatus {
		return &v
	}).(BeatStatusPtrOutput)
}

func (o BeatStatusOutput) AvailableNodes() pulumi.IntPtrOutput {
	return o.ApplyT(func(v BeatStatus) *int { return v.AvailableNodes }).(pulumi.IntPtrOutput)
}

// AssociationStatus is the status of an association resource.
func (o BeatStatusOutput) ElasticsearchAssociationStatus() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BeatStatus) *string { return v.ElasticsearchAssociationStatus }).(pulumi.StringPtrOutput)
}

func (o BeatStatusOutput) ExpectedNodes() pulumi.IntPtrOutput {
	return o.ApplyT(func(v BeatStatus) *int { return v.ExpectedNodes }).(pulumi.IntPtrOutput)
}

func (o BeatStatusOutput) Health() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BeatStatus) *string { return v.Health }).(pulumi.StringPtrOutput)
}

// AssociationStatus is the status of an association resource.
func (o BeatStatusOutput) KibanaAssociationStatus() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BeatStatus) *string { return v.KibanaAssociationStatus }).(pulumi.StringPtrOutput)
}

// AssociationStatusMap is the map of association's namespaced name string to its AssociationStatus. For resources that
// have a single Association of a given type (for ex. single ES reference), this map contains a single entry.
func (o BeatStatusOutput) MonitoringAssociationStatus() pulumi.StringMapOutput {
	return o.ApplyT(func(v BeatStatus) map[string]string { return v.MonitoringAssociationStatus }).(pulumi.StringMapOutput)
}

// ObservedGeneration represents the .metadata.generation that the status is based upon.
// It corresponds to the metadata generation, which is updated on mutation by the API Server.
// If the generation observed in status diverges from the generation in metadata, the Beats
// controller has not yet processed the changes contained in the Beats specification.
func (o BeatStatusOutput) ObservedGeneration() pulumi.IntPtrOutput {
	return o.ApplyT(func(v BeatStatus) *int { return v.ObservedGeneration }).(pulumi.IntPtrOutput)
}

// Version of the stack resource currently running. During version upgrades, multiple versions may run
// in parallel: this value specifies the lowest version currently running.
func (o BeatStatusOutput) Version() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BeatStatus) *string { return v.Version }).(pulumi.StringPtrOutput)
}

type BeatStatusPtrOutput struct{ *pulumi.OutputState }

func (BeatStatusPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**BeatStatus)(nil)).Elem()
}

func (o BeatStatusPtrOutput) ToBeatStatusPtrOutput() BeatStatusPtrOutput {
	return o
}

func (o BeatStatusPtrOutput) ToBeatStatusPtrOutputWithContext(ctx context.Context) BeatStatusPtrOutput {
	return o
}

func (o BeatStatusPtrOutput) Elem() BeatStatusOutput {
	return o.ApplyT(func(v *BeatStatus) BeatStatus {
		if v != nil {
			return *v
		}
		var ret BeatStatus
		return ret
	}).(BeatStatusOutput)
}

func (o BeatStatusPtrOutput) AvailableNodes() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *BeatStatus) *int {
		if v == nil {
			return nil
		}
		return v.AvailableNodes
	}).(pulumi.IntPtrOutput)
}

// AssociationStatus is the status of an association resource.
func (o BeatStatusPtrOutput) ElasticsearchAssociationStatus() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BeatStatus) *string {
		if v == nil {
			return nil
		}
		return v.ElasticsearchAssociationStatus
	}).(pulumi.StringPtrOutput)
}

func (o BeatStatusPtrOutput) ExpectedNodes() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *BeatStatus) *int {
		if v == nil {
			return nil
		}
		return v.ExpectedNodes
	}).(pulumi.IntPtrOutput)
}

func (o BeatStatusPtrOutput) Health() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BeatStatus) *string {
		if v == nil {
			return nil
		}
		return v.Health
	}).(pulumi.StringPtrOutput)
}

// AssociationStatus is the status of an association resource.
func (o BeatStatusPtrOutput) KibanaAssociationStatus() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BeatStatus) *string {
		if v == nil {
			return nil
		}
		return v.KibanaAssociationStatus
	}).(pulumi.StringPtrOutput)
}

// AssociationStatusMap is the map of association's namespaced name string to its AssociationStatus. For resources that
// have a single Association of a given type (for ex. single ES reference), this map contains a single entry.
func (o BeatStatusPtrOutput) MonitoringAssociationStatus() pulumi.StringMapOutput {
	return o.ApplyT(func(v *BeatStatus) map[string]string {
		if v == nil {
			return nil
		}
		return v.MonitoringAssociationStatus
	}).(pulumi.StringMapOutput)
}

// ObservedGeneration represents the .metadata.generation that the status is based upon.
// It corresponds to the metadata generation, which is updated on mutation by the API Server.
// If the generation observed in status diverges from the generation in metadata, the Beats
// controller has not yet processed the changes contained in the Beats specification.
func (o BeatStatusPtrOutput) ObservedGeneration() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *BeatStatus) *int {
		if v == nil {
			return nil
		}
		return v.ObservedGeneration
	}).(pulumi.IntPtrOutput)
}

// Version of the stack resource currently running. During version upgrades, multiple versions may run
// in parallel: this value specifies the lowest version currently running.
func (o BeatStatusPtrOutput) Version() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BeatStatus) *string {
		if v == nil {
			return nil
		}
		return v.Version
	}).(pulumi.StringPtrOutput)
}

// AssociationStatusMap is the map of association's namespaced name string to its AssociationStatus. For resources that
// have a single Association of a given type (for ex. single ES reference), this map contains a single entry.
type BeatStatusMonitoringAssociationStatus struct {
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*BeatSpecInput)(nil)).Elem(), BeatSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*BeatSpecPtrInput)(nil)).Elem(), BeatSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*BeatSpecConfigRefInput)(nil)).Elem(), BeatSpecConfigRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*BeatSpecConfigRefPtrInput)(nil)).Elem(), BeatSpecConfigRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*BeatSpecDaemonSetInput)(nil)).Elem(), BeatSpecDaemonSetArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*BeatSpecDaemonSetPtrInput)(nil)).Elem(), BeatSpecDaemonSetArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*BeatSpecDaemonSetUpdateStrategyInput)(nil)).Elem(), BeatSpecDaemonSetUpdateStrategyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*BeatSpecDaemonSetUpdateStrategyPtrInput)(nil)).Elem(), BeatSpecDaemonSetUpdateStrategyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*BeatSpecDaemonSetUpdateStrategyRollingUpdateInput)(nil)).Elem(), BeatSpecDaemonSetUpdateStrategyRollingUpdateArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*BeatSpecDaemonSetUpdateStrategyRollingUpdatePtrInput)(nil)).Elem(), BeatSpecDaemonSetUpdateStrategyRollingUpdateArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*BeatSpecDeploymentInput)(nil)).Elem(), BeatSpecDeploymentArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*BeatSpecDeploymentPtrInput)(nil)).Elem(), BeatSpecDeploymentArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*BeatSpecDeploymentStrategyInput)(nil)).Elem(), BeatSpecDeploymentStrategyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*BeatSpecDeploymentStrategyPtrInput)(nil)).Elem(), BeatSpecDeploymentStrategyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*BeatSpecDeploymentStrategyRollingUpdateInput)(nil)).Elem(), BeatSpecDeploymentStrategyRollingUpdateArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*BeatSpecDeploymentStrategyRollingUpdatePtrInput)(nil)).Elem(), BeatSpecDeploymentStrategyRollingUpdateArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*BeatSpecElasticsearchRefInput)(nil)).Elem(), BeatSpecElasticsearchRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*BeatSpecElasticsearchRefPtrInput)(nil)).Elem(), BeatSpecElasticsearchRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*BeatSpecKibanaRefInput)(nil)).Elem(), BeatSpecKibanaRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*BeatSpecKibanaRefPtrInput)(nil)).Elem(), BeatSpecKibanaRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*BeatSpecMonitoringInput)(nil)).Elem(), BeatSpecMonitoringArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*BeatSpecMonitoringPtrInput)(nil)).Elem(), BeatSpecMonitoringArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*BeatSpecMonitoringLogsInput)(nil)).Elem(), BeatSpecMonitoringLogsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*BeatSpecMonitoringLogsPtrInput)(nil)).Elem(), BeatSpecMonitoringLogsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*BeatSpecMonitoringLogsElasticsearchRefsInput)(nil)).Elem(), BeatSpecMonitoringLogsElasticsearchRefsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*BeatSpecMonitoringLogsElasticsearchRefsArrayInput)(nil)).Elem(), BeatSpecMonitoringLogsElasticsearchRefsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*BeatSpecMonitoringMetricsInput)(nil)).Elem(), BeatSpecMonitoringMetricsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*BeatSpecMonitoringMetricsPtrInput)(nil)).Elem(), BeatSpecMonitoringMetricsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*BeatSpecMonitoringMetricsElasticsearchRefsInput)(nil)).Elem(), BeatSpecMonitoringMetricsElasticsearchRefsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*BeatSpecMonitoringMetricsElasticsearchRefsArrayInput)(nil)).Elem(), BeatSpecMonitoringMetricsElasticsearchRefsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*BeatSpecSecureSettingsInput)(nil)).Elem(), BeatSpecSecureSettingsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*BeatSpecSecureSettingsArrayInput)(nil)).Elem(), BeatSpecSecureSettingsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*BeatSpecSecureSettingsEntriesInput)(nil)).Elem(), BeatSpecSecureSettingsEntriesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*BeatSpecSecureSettingsEntriesArrayInput)(nil)).Elem(), BeatSpecSecureSettingsEntriesArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*BeatStatusInput)(nil)).Elem(), BeatStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*BeatStatusPtrInput)(nil)).Elem(), BeatStatusArgs{})
	pulumi.RegisterOutputType(BeatSpecOutput{})
	pulumi.RegisterOutputType(BeatSpecPtrOutput{})
	pulumi.RegisterOutputType(BeatSpecConfigRefOutput{})
	pulumi.RegisterOutputType(BeatSpecConfigRefPtrOutput{})
	pulumi.RegisterOutputType(BeatSpecDaemonSetOutput{})
	pulumi.RegisterOutputType(BeatSpecDaemonSetPtrOutput{})
	pulumi.RegisterOutputType(BeatSpecDaemonSetUpdateStrategyOutput{})
	pulumi.RegisterOutputType(BeatSpecDaemonSetUpdateStrategyPtrOutput{})
	pulumi.RegisterOutputType(BeatSpecDaemonSetUpdateStrategyRollingUpdateOutput{})
	pulumi.RegisterOutputType(BeatSpecDaemonSetUpdateStrategyRollingUpdatePtrOutput{})
	pulumi.RegisterOutputType(BeatSpecDeploymentOutput{})
	pulumi.RegisterOutputType(BeatSpecDeploymentPtrOutput{})
	pulumi.RegisterOutputType(BeatSpecDeploymentStrategyOutput{})
	pulumi.RegisterOutputType(BeatSpecDeploymentStrategyPtrOutput{})
	pulumi.RegisterOutputType(BeatSpecDeploymentStrategyRollingUpdateOutput{})
	pulumi.RegisterOutputType(BeatSpecDeploymentStrategyRollingUpdatePtrOutput{})
	pulumi.RegisterOutputType(BeatSpecElasticsearchRefOutput{})
	pulumi.RegisterOutputType(BeatSpecElasticsearchRefPtrOutput{})
	pulumi.RegisterOutputType(BeatSpecKibanaRefOutput{})
	pulumi.RegisterOutputType(BeatSpecKibanaRefPtrOutput{})
	pulumi.RegisterOutputType(BeatSpecMonitoringOutput{})
	pulumi.RegisterOutputType(BeatSpecMonitoringPtrOutput{})
	pulumi.RegisterOutputType(BeatSpecMonitoringLogsOutput{})
	pulumi.RegisterOutputType(BeatSpecMonitoringLogsPtrOutput{})
	pulumi.RegisterOutputType(BeatSpecMonitoringLogsElasticsearchRefsOutput{})
	pulumi.RegisterOutputType(BeatSpecMonitoringLogsElasticsearchRefsArrayOutput{})
	pulumi.RegisterOutputType(BeatSpecMonitoringMetricsOutput{})
	pulumi.RegisterOutputType(BeatSpecMonitoringMetricsPtrOutput{})
	pulumi.RegisterOutputType(BeatSpecMonitoringMetricsElasticsearchRefsOutput{})
	pulumi.RegisterOutputType(BeatSpecMonitoringMetricsElasticsearchRefsArrayOutput{})
	pulumi.RegisterOutputType(BeatSpecSecureSettingsOutput{})
	pulumi.RegisterOutputType(BeatSpecSecureSettingsArrayOutput{})
	pulumi.RegisterOutputType(BeatSpecSecureSettingsEntriesOutput{})
	pulumi.RegisterOutputType(BeatSpecSecureSettingsEntriesArrayOutput{})
	pulumi.RegisterOutputType(BeatStatusOutput{})
	pulumi.RegisterOutputType(BeatStatusPtrOutput{})
}
