// Code generated by crd2pulumi DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package v1

import (
	"context"
	"reflect"

	metav1 "github.com/pulumi/pulumi-kubernetes/sdk/v4/go/kubernetes/meta/v1"
	"github.com/pulumi/pulumi-kubernetes/sdk/v4/go/kubernetes/utilities"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

var _ = utilities.GetEnvOrDefault

// GRPCRoute provides a way to route gRPC requests. This includes the capability
// to match requests by hostname, gRPC service, gRPC method, or HTTP/2 header.
// Filters can be used to specify additional processing steps. Backends specify
// where matching requests will be routed.
//
// GRPCRoute falls under extended support within the Gateway API. Within the
// following specification, the word "MUST" indicates that an implementation
// supporting GRPCRoute must conform to the indicated requirement, but an
// implementation not supporting this route type need not follow the requirement
// unless explicitly indicated.
//
// Implementations supporting `GRPCRoute` with the `HTTPS` `ProtocolType` MUST
// accept HTTP/2 connections without an initial upgrade from HTTP/1.1, i.e. via
// ALPN. If the implementation does not support this, then it MUST set the
// "Accepted" condition to "False" for the affected listener with a reason of
// "UnsupportedProtocol".  Implementations MAY also accept HTTP/2 connections
// with an upgrade from HTTP/1.
//
// Implementations supporting `GRPCRoute` with the `HTTP` `ProtocolType` MUST
// support HTTP/2 over cleartext TCP (h2c,
// https://www.rfc-editor.org/rfc/rfc7540#section-3.1) without an initial
// upgrade from HTTP/1.1, i.e. with prior knowledge
// (https://www.rfc-editor.org/rfc/rfc7540#section-3.4). If the implementation
// does not support this, then it MUST set the "Accepted" condition to "False"
// for the affected listener with a reason of "UnsupportedProtocol".
// Implementations MAY also accept HTTP/2 connections with an upgrade from
// HTTP/1, i.e. without prior knowledge.
type GRPCRouteType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata *metav1.ObjectMeta `pulumi:"metadata"`
	Spec     *GRPCRouteSpec     `pulumi:"spec"`
	Status   *GRPCRouteStatus   `pulumi:"status"`
}

// GRPCRouteTypeInput is an input type that accepts GRPCRouteTypeArgs and GRPCRouteTypeOutput values.
// You can construct a concrete instance of `GRPCRouteTypeInput` via:
//
//	GRPCRouteTypeArgs{...}
type GRPCRouteTypeInput interface {
	pulumi.Input

	ToGRPCRouteTypeOutput() GRPCRouteTypeOutput
	ToGRPCRouteTypeOutputWithContext(context.Context) GRPCRouteTypeOutput
}

// GRPCRoute provides a way to route gRPC requests. This includes the capability
// to match requests by hostname, gRPC service, gRPC method, or HTTP/2 header.
// Filters can be used to specify additional processing steps. Backends specify
// where matching requests will be routed.
//
// GRPCRoute falls under extended support within the Gateway API. Within the
// following specification, the word "MUST" indicates that an implementation
// supporting GRPCRoute must conform to the indicated requirement, but an
// implementation not supporting this route type need not follow the requirement
// unless explicitly indicated.
//
// Implementations supporting `GRPCRoute` with the `HTTPS` `ProtocolType` MUST
// accept HTTP/2 connections without an initial upgrade from HTTP/1.1, i.e. via
// ALPN. If the implementation does not support this, then it MUST set the
// "Accepted" condition to "False" for the affected listener with a reason of
// "UnsupportedProtocol".  Implementations MAY also accept HTTP/2 connections
// with an upgrade from HTTP/1.
//
// Implementations supporting `GRPCRoute` with the `HTTP` `ProtocolType` MUST
// support HTTP/2 over cleartext TCP (h2c,
// https://www.rfc-editor.org/rfc/rfc7540#section-3.1) without an initial
// upgrade from HTTP/1.1, i.e. with prior knowledge
// (https://www.rfc-editor.org/rfc/rfc7540#section-3.4). If the implementation
// does not support this, then it MUST set the "Accepted" condition to "False"
// for the affected listener with a reason of "UnsupportedProtocol".
// Implementations MAY also accept HTTP/2 connections with an upgrade from
// HTTP/1, i.e. without prior knowledge.
type GRPCRouteTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata metav1.ObjectMetaPtrInput `pulumi:"metadata"`
	Spec     GRPCRouteSpecPtrInput     `pulumi:"spec"`
	Status   GRPCRouteStatusPtrInput   `pulumi:"status"`
}

func (GRPCRouteTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteType)(nil)).Elem()
}

func (i GRPCRouteTypeArgs) ToGRPCRouteTypeOutput() GRPCRouteTypeOutput {
	return i.ToGRPCRouteTypeOutputWithContext(context.Background())
}

func (i GRPCRouteTypeArgs) ToGRPCRouteTypeOutputWithContext(ctx context.Context) GRPCRouteTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteTypeOutput)
}

// GRPCRouteTypeArrayInput is an input type that accepts GRPCRouteTypeArray and GRPCRouteTypeArrayOutput values.
// You can construct a concrete instance of `GRPCRouteTypeArrayInput` via:
//
//	GRPCRouteTypeArray{ GRPCRouteTypeArgs{...} }
type GRPCRouteTypeArrayInput interface {
	pulumi.Input

	ToGRPCRouteTypeArrayOutput() GRPCRouteTypeArrayOutput
	ToGRPCRouteTypeArrayOutputWithContext(context.Context) GRPCRouteTypeArrayOutput
}

type GRPCRouteTypeArray []GRPCRouteTypeInput

func (GRPCRouteTypeArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteType)(nil)).Elem()
}

func (i GRPCRouteTypeArray) ToGRPCRouteTypeArrayOutput() GRPCRouteTypeArrayOutput {
	return i.ToGRPCRouteTypeArrayOutputWithContext(context.Background())
}

func (i GRPCRouteTypeArray) ToGRPCRouteTypeArrayOutputWithContext(ctx context.Context) GRPCRouteTypeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteTypeArrayOutput)
}

// GRPCRoute provides a way to route gRPC requests. This includes the capability
// to match requests by hostname, gRPC service, gRPC method, or HTTP/2 header.
// Filters can be used to specify additional processing steps. Backends specify
// where matching requests will be routed.
//
// GRPCRoute falls under extended support within the Gateway API. Within the
// following specification, the word "MUST" indicates that an implementation
// supporting GRPCRoute must conform to the indicated requirement, but an
// implementation not supporting this route type need not follow the requirement
// unless explicitly indicated.
//
// Implementations supporting `GRPCRoute` with the `HTTPS` `ProtocolType` MUST
// accept HTTP/2 connections without an initial upgrade from HTTP/1.1, i.e. via
// ALPN. If the implementation does not support this, then it MUST set the
// "Accepted" condition to "False" for the affected listener with a reason of
// "UnsupportedProtocol".  Implementations MAY also accept HTTP/2 connections
// with an upgrade from HTTP/1.
//
// Implementations supporting `GRPCRoute` with the `HTTP` `ProtocolType` MUST
// support HTTP/2 over cleartext TCP (h2c,
// https://www.rfc-editor.org/rfc/rfc7540#section-3.1) without an initial
// upgrade from HTTP/1.1, i.e. with prior knowledge
// (https://www.rfc-editor.org/rfc/rfc7540#section-3.4). If the implementation
// does not support this, then it MUST set the "Accepted" condition to "False"
// for the affected listener with a reason of "UnsupportedProtocol".
// Implementations MAY also accept HTTP/2 connections with an upgrade from
// HTTP/1, i.e. without prior knowledge.
type GRPCRouteTypeOutput struct{ *pulumi.OutputState }

func (GRPCRouteTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteType)(nil)).Elem()
}

func (o GRPCRouteTypeOutput) ToGRPCRouteTypeOutput() GRPCRouteTypeOutput {
	return o
}

func (o GRPCRouteTypeOutput) ToGRPCRouteTypeOutputWithContext(ctx context.Context) GRPCRouteTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o GRPCRouteTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o GRPCRouteTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
func (o GRPCRouteTypeOutput) Metadata() metav1.ObjectMetaPtrOutput {
	return o.ApplyT(func(v GRPCRouteType) *metav1.ObjectMeta { return v.Metadata }).(metav1.ObjectMetaPtrOutput)
}

func (o GRPCRouteTypeOutput) Spec() GRPCRouteSpecPtrOutput {
	return o.ApplyT(func(v GRPCRouteType) *GRPCRouteSpec { return v.Spec }).(GRPCRouteSpecPtrOutput)
}

func (o GRPCRouteTypeOutput) Status() GRPCRouteStatusPtrOutput {
	return o.ApplyT(func(v GRPCRouteType) *GRPCRouteStatus { return v.Status }).(GRPCRouteStatusPtrOutput)
}

type GRPCRouteTypeArrayOutput struct{ *pulumi.OutputState }

func (GRPCRouteTypeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteType)(nil)).Elem()
}

func (o GRPCRouteTypeArrayOutput) ToGRPCRouteTypeArrayOutput() GRPCRouteTypeArrayOutput {
	return o
}

func (o GRPCRouteTypeArrayOutput) ToGRPCRouteTypeArrayOutputWithContext(ctx context.Context) GRPCRouteTypeArrayOutput {
	return o
}

func (o GRPCRouteTypeArrayOutput) Index(i pulumi.IntInput) GRPCRouteTypeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GRPCRouteType {
		return vs[0].([]GRPCRouteType)[vs[1].(int)]
	}).(GRPCRouteTypeOutput)
}

// GRPCRouteList is a list of GRPCRoute
type GRPCRouteListType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// List of grpcroutes. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md
	Items []GRPCRouteType `pulumi:"items"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Metadata *metav1.ListMeta `pulumi:"metadata"`
}

// GRPCRouteListTypeInput is an input type that accepts GRPCRouteListTypeArgs and GRPCRouteListTypeOutput values.
// You can construct a concrete instance of `GRPCRouteListTypeInput` via:
//
//	GRPCRouteListTypeArgs{...}
type GRPCRouteListTypeInput interface {
	pulumi.Input

	ToGRPCRouteListTypeOutput() GRPCRouteListTypeOutput
	ToGRPCRouteListTypeOutputWithContext(context.Context) GRPCRouteListTypeOutput
}

// GRPCRouteList is a list of GRPCRoute
type GRPCRouteListTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// List of grpcroutes. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md
	Items GRPCRouteTypeArrayInput `pulumi:"items"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Metadata metav1.ListMetaPtrInput `pulumi:"metadata"`
}

func (GRPCRouteListTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteListType)(nil)).Elem()
}

func (i GRPCRouteListTypeArgs) ToGRPCRouteListTypeOutput() GRPCRouteListTypeOutput {
	return i.ToGRPCRouteListTypeOutputWithContext(context.Background())
}

func (i GRPCRouteListTypeArgs) ToGRPCRouteListTypeOutputWithContext(ctx context.Context) GRPCRouteListTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteListTypeOutput)
}

// GRPCRouteList is a list of GRPCRoute
type GRPCRouteListTypeOutput struct{ *pulumi.OutputState }

func (GRPCRouteListTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteListType)(nil)).Elem()
}

func (o GRPCRouteListTypeOutput) ToGRPCRouteListTypeOutput() GRPCRouteListTypeOutput {
	return o
}

func (o GRPCRouteListTypeOutput) ToGRPCRouteListTypeOutputWithContext(ctx context.Context) GRPCRouteListTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o GRPCRouteListTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteListType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// List of grpcroutes. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md
func (o GRPCRouteListTypeOutput) Items() GRPCRouteTypeArrayOutput {
	return o.ApplyT(func(v GRPCRouteListType) []GRPCRouteType { return v.Items }).(GRPCRouteTypeArrayOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o GRPCRouteListTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteListType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o GRPCRouteListTypeOutput) Metadata() metav1.ListMetaPtrOutput {
	return o.ApplyT(func(v GRPCRouteListType) *metav1.ListMeta { return v.Metadata }).(metav1.ListMetaPtrOutput)
}

// GRPCRoute provides a way to route gRPC requests. This includes the capability
// to match requests by hostname, gRPC service, gRPC method, or HTTP/2 header.
// Filters can be used to specify additional processing steps. Backends specify
// where matching requests will be routed.
//
// GRPCRoute falls under extended support within the Gateway API. Within the
// following specification, the word "MUST" indicates that an implementation
// supporting GRPCRoute must conform to the indicated requirement, but an
// implementation not supporting this route type need not follow the requirement
// unless explicitly indicated.
//
// Implementations supporting `GRPCRoute` with the `HTTPS` `ProtocolType` MUST
// accept HTTP/2 connections without an initial upgrade from HTTP/1.1, i.e. via
// ALPN. If the implementation does not support this, then it MUST set the
// "Accepted" condition to "False" for the affected listener with a reason of
// "UnsupportedProtocol".  Implementations MAY also accept HTTP/2 connections
// with an upgrade from HTTP/1.
//
// Implementations supporting `GRPCRoute` with the `HTTP` `ProtocolType` MUST
// support HTTP/2 over cleartext TCP (h2c,
// https://www.rfc-editor.org/rfc/rfc7540#section-3.1) without an initial
// upgrade from HTTP/1.1, i.e. with prior knowledge
// (https://www.rfc-editor.org/rfc/rfc7540#section-3.4). If the implementation
// does not support this, then it MUST set the "Accepted" condition to "False"
// for the affected listener with a reason of "UnsupportedProtocol".
// Implementations MAY also accept HTTP/2 connections with an upgrade from
// HTTP/1, i.e. without prior knowledge.
type GRPCRoutePatchType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata *metav1.ObjectMetaPatch `pulumi:"metadata"`
	Spec     *GRPCRouteSpecPatch     `pulumi:"spec"`
	Status   *GRPCRouteStatusPatch   `pulumi:"status"`
}

// GRPCRoutePatchTypeInput is an input type that accepts GRPCRoutePatchTypeArgs and GRPCRoutePatchTypeOutput values.
// You can construct a concrete instance of `GRPCRoutePatchTypeInput` via:
//
//	GRPCRoutePatchTypeArgs{...}
type GRPCRoutePatchTypeInput interface {
	pulumi.Input

	ToGRPCRoutePatchTypeOutput() GRPCRoutePatchTypeOutput
	ToGRPCRoutePatchTypeOutputWithContext(context.Context) GRPCRoutePatchTypeOutput
}

// GRPCRoute provides a way to route gRPC requests. This includes the capability
// to match requests by hostname, gRPC service, gRPC method, or HTTP/2 header.
// Filters can be used to specify additional processing steps. Backends specify
// where matching requests will be routed.
//
// GRPCRoute falls under extended support within the Gateway API. Within the
// following specification, the word "MUST" indicates that an implementation
// supporting GRPCRoute must conform to the indicated requirement, but an
// implementation not supporting this route type need not follow the requirement
// unless explicitly indicated.
//
// Implementations supporting `GRPCRoute` with the `HTTPS` `ProtocolType` MUST
// accept HTTP/2 connections without an initial upgrade from HTTP/1.1, i.e. via
// ALPN. If the implementation does not support this, then it MUST set the
// "Accepted" condition to "False" for the affected listener with a reason of
// "UnsupportedProtocol".  Implementations MAY also accept HTTP/2 connections
// with an upgrade from HTTP/1.
//
// Implementations supporting `GRPCRoute` with the `HTTP` `ProtocolType` MUST
// support HTTP/2 over cleartext TCP (h2c,
// https://www.rfc-editor.org/rfc/rfc7540#section-3.1) without an initial
// upgrade from HTTP/1.1, i.e. with prior knowledge
// (https://www.rfc-editor.org/rfc/rfc7540#section-3.4). If the implementation
// does not support this, then it MUST set the "Accepted" condition to "False"
// for the affected listener with a reason of "UnsupportedProtocol".
// Implementations MAY also accept HTTP/2 connections with an upgrade from
// HTTP/1, i.e. without prior knowledge.
type GRPCRoutePatchTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata metav1.ObjectMetaPatchPtrInput `pulumi:"metadata"`
	Spec     GRPCRouteSpecPatchPtrInput     `pulumi:"spec"`
	Status   GRPCRouteStatusPatchPtrInput   `pulumi:"status"`
}

func (GRPCRoutePatchTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRoutePatchType)(nil)).Elem()
}

func (i GRPCRoutePatchTypeArgs) ToGRPCRoutePatchTypeOutput() GRPCRoutePatchTypeOutput {
	return i.ToGRPCRoutePatchTypeOutputWithContext(context.Background())
}

func (i GRPCRoutePatchTypeArgs) ToGRPCRoutePatchTypeOutputWithContext(ctx context.Context) GRPCRoutePatchTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRoutePatchTypeOutput)
}

// GRPCRoute provides a way to route gRPC requests. This includes the capability
// to match requests by hostname, gRPC service, gRPC method, or HTTP/2 header.
// Filters can be used to specify additional processing steps. Backends specify
// where matching requests will be routed.
//
// GRPCRoute falls under extended support within the Gateway API. Within the
// following specification, the word "MUST" indicates that an implementation
// supporting GRPCRoute must conform to the indicated requirement, but an
// implementation not supporting this route type need not follow the requirement
// unless explicitly indicated.
//
// Implementations supporting `GRPCRoute` with the `HTTPS` `ProtocolType` MUST
// accept HTTP/2 connections without an initial upgrade from HTTP/1.1, i.e. via
// ALPN. If the implementation does not support this, then it MUST set the
// "Accepted" condition to "False" for the affected listener with a reason of
// "UnsupportedProtocol".  Implementations MAY also accept HTTP/2 connections
// with an upgrade from HTTP/1.
//
// Implementations supporting `GRPCRoute` with the `HTTP` `ProtocolType` MUST
// support HTTP/2 over cleartext TCP (h2c,
// https://www.rfc-editor.org/rfc/rfc7540#section-3.1) without an initial
// upgrade from HTTP/1.1, i.e. with prior knowledge
// (https://www.rfc-editor.org/rfc/rfc7540#section-3.4). If the implementation
// does not support this, then it MUST set the "Accepted" condition to "False"
// for the affected listener with a reason of "UnsupportedProtocol".
// Implementations MAY also accept HTTP/2 connections with an upgrade from
// HTTP/1, i.e. without prior knowledge.
type GRPCRoutePatchTypeOutput struct{ *pulumi.OutputState }

func (GRPCRoutePatchTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRoutePatchType)(nil)).Elem()
}

func (o GRPCRoutePatchTypeOutput) ToGRPCRoutePatchTypeOutput() GRPCRoutePatchTypeOutput {
	return o
}

func (o GRPCRoutePatchTypeOutput) ToGRPCRoutePatchTypeOutputWithContext(ctx context.Context) GRPCRoutePatchTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o GRPCRoutePatchTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRoutePatchType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o GRPCRoutePatchTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRoutePatchType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
func (o GRPCRoutePatchTypeOutput) Metadata() metav1.ObjectMetaPatchPtrOutput {
	return o.ApplyT(func(v GRPCRoutePatchType) *metav1.ObjectMetaPatch { return v.Metadata }).(metav1.ObjectMetaPatchPtrOutput)
}

func (o GRPCRoutePatchTypeOutput) Spec() GRPCRouteSpecPatchPtrOutput {
	return o.ApplyT(func(v GRPCRoutePatchType) *GRPCRouteSpecPatch { return v.Spec }).(GRPCRouteSpecPatchPtrOutput)
}

func (o GRPCRoutePatchTypeOutput) Status() GRPCRouteStatusPatchPtrOutput {
	return o.ApplyT(func(v GRPCRoutePatchType) *GRPCRouteStatusPatch { return v.Status }).(GRPCRouteStatusPatchPtrOutput)
}

// Spec defines the desired state of GRPCRoute.
type GRPCRouteSpec struct {
	// Hostnames defines a set of hostnames to match against the GRPC
	// Host header to select a GRPCRoute to process the request. This matches
	// the RFC 1123 definition of a hostname with 2 notable exceptions:
	//
	// 1. IPs are not allowed.
	// 2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard
	//    label MUST appear by itself as the first label.
	//
	// If a hostname is specified by both the Listener and GRPCRoute, there
	// MUST be at least one intersecting hostname for the GRPCRoute to be
	// attached to the Listener. For example:
	//
	// * A Listener with `test.example.com` as the hostname matches GRPCRoutes
	//   that have either not specified any hostnames, or have specified at
	//   least one of `test.example.com` or `*.example.com`.
	// * A Listener with `*.example.com` as the hostname matches GRPCRoutes
	//   that have either not specified any hostnames or have specified at least
	//   one hostname that matches the Listener hostname. For example,
	//   `test.example.com` and `*.example.com` would both match. On the other
	//   hand, `example.com` and `test.example.net` would not match.
	//
	// Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
	// as a suffix match. That means that a match for `*.example.com` would match
	// both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
	//
	// If both the Listener and GRPCRoute have specified hostnames, any
	// GRPCRoute hostnames that do not match the Listener hostname MUST be
	// ignored. For example, if a Listener specified `*.example.com`, and the
	// GRPCRoute specified `test.example.com` and `test.example.net`,
	// `test.example.net` MUST NOT be considered for a match.
	//
	// If both the Listener and GRPCRoute have specified hostnames, and none
	// match with the criteria above, then the GRPCRoute MUST NOT be accepted by
	// the implementation. The implementation MUST raise an 'Accepted' Condition
	// with a status of `False` in the corresponding RouteParentStatus.
	//
	// If a Route (A) of type HTTPRoute or GRPCRoute is attached to a
	// Listener and that listener already has another Route (B) of the other
	// type attached and the intersection of the hostnames of A and B is
	// non-empty, then the implementation MUST accept exactly one of these two
	// routes, determined by the following criteria, in order:
	//
	// * The oldest Route based on creation timestamp.
	// * The Route appearing first in alphabetical order by
	//   "{namespace}/{name}".
	//
	// The rejected Route MUST raise an 'Accepted' condition with a status of
	// 'False' in the corresponding RouteParentStatus.
	//
	// Support: Core
	Hostnames []string `pulumi:"hostnames"`
	// ParentRefs references the resources (usually Gateways) that a Route wants
	// to be attached to. Note that the referenced parent resource needs to
	// allow this for the attachment to be complete. For Gateways, that means
	// the Gateway needs to allow attachment from Routes of this kind and
	// namespace. For Services, that means the Service must either be in the same
	// namespace for a "producer" route, or the mesh implementation must support
	// and allow "consumer" routes for the referenced Service. ReferenceGrant is
	// not applicable for governing ParentRefs to Services - it is not possible to
	// create a "producer" route for a Service in a different namespace from the
	// Route.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// This API may be extended in the future to support additional kinds of parent
	// resources.
	//
	// ParentRefs must be _distinct_. This means either that:
	//
	// * They select different objects.  If this is the case, then parentRef
	//   entries are distinct. In terms of fields, this means that the
	//   multi-part key defined by `group`, `kind`, `namespace`, and `name` must
	//   be unique across all parentRef entries in the Route.
	// * They do not select different objects, but for each optional field used,
	//   each ParentRef that selects the same object must set the same set of
	//   optional fields to different values. If one ParentRef sets a
	//   combination of optional fields, all must set the same combination.
	//
	// Some examples:
	//
	// * If one ParentRef sets `sectionName`, all ParentRefs referencing the
	//   same object must also set `sectionName`.
	// * If one ParentRef sets `port`, all ParentRefs referencing the same
	//   object must also set `port`.
	// * If one ParentRef sets `sectionName` and `port`, all ParentRefs
	//   referencing the same object must also set `sectionName` and `port`.
	//
	// It is possible to separately reference multiple distinct objects that may
	// be collapsed by an implementation. For example, some implementations may
	// choose to merge compatible Gateway Listeners together. If that is the
	// case, the list of routes attached to those resources should also be
	// merged.
	//
	// Note that for ParentRefs that cross namespace boundaries, there are specific
	// rules. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example,
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable other kinds of cross-namespace reference.
	ParentRefs []GRPCRouteSpecParentRefs `pulumi:"parentRefs"`
	// Rules are a list of GRPC matchers, filters and actions.
	Rules []GRPCRouteSpecRules `pulumi:"rules"`
}

// GRPCRouteSpecInput is an input type that accepts GRPCRouteSpecArgs and GRPCRouteSpecOutput values.
// You can construct a concrete instance of `GRPCRouteSpecInput` via:
//
//	GRPCRouteSpecArgs{...}
type GRPCRouteSpecInput interface {
	pulumi.Input

	ToGRPCRouteSpecOutput() GRPCRouteSpecOutput
	ToGRPCRouteSpecOutputWithContext(context.Context) GRPCRouteSpecOutput
}

// Spec defines the desired state of GRPCRoute.
type GRPCRouteSpecArgs struct {
	// Hostnames defines a set of hostnames to match against the GRPC
	// Host header to select a GRPCRoute to process the request. This matches
	// the RFC 1123 definition of a hostname with 2 notable exceptions:
	//
	// 1. IPs are not allowed.
	// 2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard
	//    label MUST appear by itself as the first label.
	//
	// If a hostname is specified by both the Listener and GRPCRoute, there
	// MUST be at least one intersecting hostname for the GRPCRoute to be
	// attached to the Listener. For example:
	//
	// * A Listener with `test.example.com` as the hostname matches GRPCRoutes
	//   that have either not specified any hostnames, or have specified at
	//   least one of `test.example.com` or `*.example.com`.
	// * A Listener with `*.example.com` as the hostname matches GRPCRoutes
	//   that have either not specified any hostnames or have specified at least
	//   one hostname that matches the Listener hostname. For example,
	//   `test.example.com` and `*.example.com` would both match. On the other
	//   hand, `example.com` and `test.example.net` would not match.
	//
	// Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
	// as a suffix match. That means that a match for `*.example.com` would match
	// both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
	//
	// If both the Listener and GRPCRoute have specified hostnames, any
	// GRPCRoute hostnames that do not match the Listener hostname MUST be
	// ignored. For example, if a Listener specified `*.example.com`, and the
	// GRPCRoute specified `test.example.com` and `test.example.net`,
	// `test.example.net` MUST NOT be considered for a match.
	//
	// If both the Listener and GRPCRoute have specified hostnames, and none
	// match with the criteria above, then the GRPCRoute MUST NOT be accepted by
	// the implementation. The implementation MUST raise an 'Accepted' Condition
	// with a status of `False` in the corresponding RouteParentStatus.
	//
	// If a Route (A) of type HTTPRoute or GRPCRoute is attached to a
	// Listener and that listener already has another Route (B) of the other
	// type attached and the intersection of the hostnames of A and B is
	// non-empty, then the implementation MUST accept exactly one of these two
	// routes, determined by the following criteria, in order:
	//
	// * The oldest Route based on creation timestamp.
	// * The Route appearing first in alphabetical order by
	//   "{namespace}/{name}".
	//
	// The rejected Route MUST raise an 'Accepted' condition with a status of
	// 'False' in the corresponding RouteParentStatus.
	//
	// Support: Core
	Hostnames pulumi.StringArrayInput `pulumi:"hostnames"`
	// ParentRefs references the resources (usually Gateways) that a Route wants
	// to be attached to. Note that the referenced parent resource needs to
	// allow this for the attachment to be complete. For Gateways, that means
	// the Gateway needs to allow attachment from Routes of this kind and
	// namespace. For Services, that means the Service must either be in the same
	// namespace for a "producer" route, or the mesh implementation must support
	// and allow "consumer" routes for the referenced Service. ReferenceGrant is
	// not applicable for governing ParentRefs to Services - it is not possible to
	// create a "producer" route for a Service in a different namespace from the
	// Route.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// This API may be extended in the future to support additional kinds of parent
	// resources.
	//
	// ParentRefs must be _distinct_. This means either that:
	//
	// * They select different objects.  If this is the case, then parentRef
	//   entries are distinct. In terms of fields, this means that the
	//   multi-part key defined by `group`, `kind`, `namespace`, and `name` must
	//   be unique across all parentRef entries in the Route.
	// * They do not select different objects, but for each optional field used,
	//   each ParentRef that selects the same object must set the same set of
	//   optional fields to different values. If one ParentRef sets a
	//   combination of optional fields, all must set the same combination.
	//
	// Some examples:
	//
	// * If one ParentRef sets `sectionName`, all ParentRefs referencing the
	//   same object must also set `sectionName`.
	// * If one ParentRef sets `port`, all ParentRefs referencing the same
	//   object must also set `port`.
	// * If one ParentRef sets `sectionName` and `port`, all ParentRefs
	//   referencing the same object must also set `sectionName` and `port`.
	//
	// It is possible to separately reference multiple distinct objects that may
	// be collapsed by an implementation. For example, some implementations may
	// choose to merge compatible Gateway Listeners together. If that is the
	// case, the list of routes attached to those resources should also be
	// merged.
	//
	// Note that for ParentRefs that cross namespace boundaries, there are specific
	// rules. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example,
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable other kinds of cross-namespace reference.
	ParentRefs GRPCRouteSpecParentRefsArrayInput `pulumi:"parentRefs"`
	// Rules are a list of GRPC matchers, filters and actions.
	Rules GRPCRouteSpecRulesArrayInput `pulumi:"rules"`
}

func (GRPCRouteSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpec)(nil)).Elem()
}

func (i GRPCRouteSpecArgs) ToGRPCRouteSpecOutput() GRPCRouteSpecOutput {
	return i.ToGRPCRouteSpecOutputWithContext(context.Background())
}

func (i GRPCRouteSpecArgs) ToGRPCRouteSpecOutputWithContext(ctx context.Context) GRPCRouteSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecOutput)
}

func (i GRPCRouteSpecArgs) ToGRPCRouteSpecPtrOutput() GRPCRouteSpecPtrOutput {
	return i.ToGRPCRouteSpecPtrOutputWithContext(context.Background())
}

func (i GRPCRouteSpecArgs) ToGRPCRouteSpecPtrOutputWithContext(ctx context.Context) GRPCRouteSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecOutput).ToGRPCRouteSpecPtrOutputWithContext(ctx)
}

// GRPCRouteSpecPtrInput is an input type that accepts GRPCRouteSpecArgs, GRPCRouteSpecPtr and GRPCRouteSpecPtrOutput values.
// You can construct a concrete instance of `GRPCRouteSpecPtrInput` via:
//
//	        GRPCRouteSpecArgs{...}
//
//	or:
//
//	        nil
type GRPCRouteSpecPtrInput interface {
	pulumi.Input

	ToGRPCRouteSpecPtrOutput() GRPCRouteSpecPtrOutput
	ToGRPCRouteSpecPtrOutputWithContext(context.Context) GRPCRouteSpecPtrOutput
}

type grpcrouteSpecPtrType GRPCRouteSpecArgs

func GRPCRouteSpecPtr(v *GRPCRouteSpecArgs) GRPCRouteSpecPtrInput {
	return (*grpcrouteSpecPtrType)(v)
}

func (*grpcrouteSpecPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpec)(nil)).Elem()
}

func (i *grpcrouteSpecPtrType) ToGRPCRouteSpecPtrOutput() GRPCRouteSpecPtrOutput {
	return i.ToGRPCRouteSpecPtrOutputWithContext(context.Background())
}

func (i *grpcrouteSpecPtrType) ToGRPCRouteSpecPtrOutputWithContext(ctx context.Context) GRPCRouteSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecPtrOutput)
}

// Spec defines the desired state of GRPCRoute.
type GRPCRouteSpecOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpec)(nil)).Elem()
}

func (o GRPCRouteSpecOutput) ToGRPCRouteSpecOutput() GRPCRouteSpecOutput {
	return o
}

func (o GRPCRouteSpecOutput) ToGRPCRouteSpecOutputWithContext(ctx context.Context) GRPCRouteSpecOutput {
	return o
}

func (o GRPCRouteSpecOutput) ToGRPCRouteSpecPtrOutput() GRPCRouteSpecPtrOutput {
	return o.ToGRPCRouteSpecPtrOutputWithContext(context.Background())
}

func (o GRPCRouteSpecOutput) ToGRPCRouteSpecPtrOutputWithContext(ctx context.Context) GRPCRouteSpecPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GRPCRouteSpec) *GRPCRouteSpec {
		return &v
	}).(GRPCRouteSpecPtrOutput)
}

// Hostnames defines a set of hostnames to match against the GRPC
// Host header to select a GRPCRoute to process the request. This matches
// the RFC 1123 definition of a hostname with 2 notable exceptions:
//
//  1. IPs are not allowed.
//  2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard
//     label MUST appear by itself as the first label.
//
// If a hostname is specified by both the Listener and GRPCRoute, there
// MUST be at least one intersecting hostname for the GRPCRoute to be
// attached to the Listener. For example:
//
//   - A Listener with `test.example.com` as the hostname matches GRPCRoutes
//     that have either not specified any hostnames, or have specified at
//     least one of `test.example.com` or `*.example.com`.
//   - A Listener with `*.example.com` as the hostname matches GRPCRoutes
//     that have either not specified any hostnames or have specified at least
//     one hostname that matches the Listener hostname. For example,
//     `test.example.com` and `*.example.com` would both match. On the other
//     hand, `example.com` and `test.example.net` would not match.
//
// Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
// as a suffix match. That means that a match for `*.example.com` would match
// both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
//
// If both the Listener and GRPCRoute have specified hostnames, any
// GRPCRoute hostnames that do not match the Listener hostname MUST be
// ignored. For example, if a Listener specified `*.example.com`, and the
// GRPCRoute specified `test.example.com` and `test.example.net`,
// `test.example.net` MUST NOT be considered for a match.
//
// If both the Listener and GRPCRoute have specified hostnames, and none
// match with the criteria above, then the GRPCRoute MUST NOT be accepted by
// the implementation. The implementation MUST raise an 'Accepted' Condition
// with a status of `False` in the corresponding RouteParentStatus.
//
// If a Route (A) of type HTTPRoute or GRPCRoute is attached to a
// Listener and that listener already has another Route (B) of the other
// type attached and the intersection of the hostnames of A and B is
// non-empty, then the implementation MUST accept exactly one of these two
// routes, determined by the following criteria, in order:
//
//   - The oldest Route based on creation timestamp.
//   - The Route appearing first in alphabetical order by
//     "{namespace}/{name}".
//
// The rejected Route MUST raise an 'Accepted' condition with a status of
// 'False' in the corresponding RouteParentStatus.
//
// Support: Core
func (o GRPCRouteSpecOutput) Hostnames() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GRPCRouteSpec) []string { return v.Hostnames }).(pulumi.StringArrayOutput)
}

// ParentRefs references the resources (usually Gateways) that a Route wants
// to be attached to. Note that the referenced parent resource needs to
// allow this for the attachment to be complete. For Gateways, that means
// the Gateway needs to allow attachment from Routes of this kind and
// namespace. For Services, that means the Service must either be in the same
// namespace for a "producer" route, or the mesh implementation must support
// and allow "consumer" routes for the referenced Service. ReferenceGrant is
// not applicable for governing ParentRefs to Services - it is not possible to
// create a "producer" route for a Service in a different namespace from the
// Route.
//
// There are two kinds of parent resources with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// ParentRefs must be _distinct_. This means either that:
//
//   - They select different objects.  If this is the case, then parentRef
//     entries are distinct. In terms of fields, this means that the
//     multi-part key defined by `group`, `kind`, `namespace`, and `name` must
//     be unique across all parentRef entries in the Route.
//   - They do not select different objects, but for each optional field used,
//     each ParentRef that selects the same object must set the same set of
//     optional fields to different values. If one ParentRef sets a
//     combination of optional fields, all must set the same combination.
//
// Some examples:
//
//   - If one ParentRef sets `sectionName`, all ParentRefs referencing the
//     same object must also set `sectionName`.
//   - If one ParentRef sets `port`, all ParentRefs referencing the same
//     object must also set `port`.
//   - If one ParentRef sets `sectionName` and `port`, all ParentRefs
//     referencing the same object must also set `sectionName` and `port`.
//
// It is possible to separately reference multiple distinct objects that may
// be collapsed by an implementation. For example, some implementations may
// choose to merge compatible Gateway Listeners together. If that is the
// case, the list of routes attached to those resources should also be
// merged.
//
// Note that for ParentRefs that cross namespace boundaries, there are specific
// rules. Cross-namespace references are only valid if they are explicitly
// allowed by something in the namespace they are referring to. For example,
// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
// generic way to enable other kinds of cross-namespace reference.
func (o GRPCRouteSpecOutput) ParentRefs() GRPCRouteSpecParentRefsArrayOutput {
	return o.ApplyT(func(v GRPCRouteSpec) []GRPCRouteSpecParentRefs { return v.ParentRefs }).(GRPCRouteSpecParentRefsArrayOutput)
}

// Rules are a list of GRPC matchers, filters and actions.
func (o GRPCRouteSpecOutput) Rules() GRPCRouteSpecRulesArrayOutput {
	return o.ApplyT(func(v GRPCRouteSpec) []GRPCRouteSpecRules { return v.Rules }).(GRPCRouteSpecRulesArrayOutput)
}

type GRPCRouteSpecPtrOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpec)(nil)).Elem()
}

func (o GRPCRouteSpecPtrOutput) ToGRPCRouteSpecPtrOutput() GRPCRouteSpecPtrOutput {
	return o
}

func (o GRPCRouteSpecPtrOutput) ToGRPCRouteSpecPtrOutputWithContext(ctx context.Context) GRPCRouteSpecPtrOutput {
	return o
}

func (o GRPCRouteSpecPtrOutput) Elem() GRPCRouteSpecOutput {
	return o.ApplyT(func(v *GRPCRouteSpec) GRPCRouteSpec {
		if v != nil {
			return *v
		}
		var ret GRPCRouteSpec
		return ret
	}).(GRPCRouteSpecOutput)
}

// Hostnames defines a set of hostnames to match against the GRPC
// Host header to select a GRPCRoute to process the request. This matches
// the RFC 1123 definition of a hostname with 2 notable exceptions:
//
//  1. IPs are not allowed.
//  2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard
//     label MUST appear by itself as the first label.
//
// If a hostname is specified by both the Listener and GRPCRoute, there
// MUST be at least one intersecting hostname for the GRPCRoute to be
// attached to the Listener. For example:
//
//   - A Listener with `test.example.com` as the hostname matches GRPCRoutes
//     that have either not specified any hostnames, or have specified at
//     least one of `test.example.com` or `*.example.com`.
//   - A Listener with `*.example.com` as the hostname matches GRPCRoutes
//     that have either not specified any hostnames or have specified at least
//     one hostname that matches the Listener hostname. For example,
//     `test.example.com` and `*.example.com` would both match. On the other
//     hand, `example.com` and `test.example.net` would not match.
//
// Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
// as a suffix match. That means that a match for `*.example.com` would match
// both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
//
// If both the Listener and GRPCRoute have specified hostnames, any
// GRPCRoute hostnames that do not match the Listener hostname MUST be
// ignored. For example, if a Listener specified `*.example.com`, and the
// GRPCRoute specified `test.example.com` and `test.example.net`,
// `test.example.net` MUST NOT be considered for a match.
//
// If both the Listener and GRPCRoute have specified hostnames, and none
// match with the criteria above, then the GRPCRoute MUST NOT be accepted by
// the implementation. The implementation MUST raise an 'Accepted' Condition
// with a status of `False` in the corresponding RouteParentStatus.
//
// If a Route (A) of type HTTPRoute or GRPCRoute is attached to a
// Listener and that listener already has another Route (B) of the other
// type attached and the intersection of the hostnames of A and B is
// non-empty, then the implementation MUST accept exactly one of these two
// routes, determined by the following criteria, in order:
//
//   - The oldest Route based on creation timestamp.
//   - The Route appearing first in alphabetical order by
//     "{namespace}/{name}".
//
// The rejected Route MUST raise an 'Accepted' condition with a status of
// 'False' in the corresponding RouteParentStatus.
//
// Support: Core
func (o GRPCRouteSpecPtrOutput) Hostnames() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *GRPCRouteSpec) []string {
		if v == nil {
			return nil
		}
		return v.Hostnames
	}).(pulumi.StringArrayOutput)
}

// ParentRefs references the resources (usually Gateways) that a Route wants
// to be attached to. Note that the referenced parent resource needs to
// allow this for the attachment to be complete. For Gateways, that means
// the Gateway needs to allow attachment from Routes of this kind and
// namespace. For Services, that means the Service must either be in the same
// namespace for a "producer" route, or the mesh implementation must support
// and allow "consumer" routes for the referenced Service. ReferenceGrant is
// not applicable for governing ParentRefs to Services - it is not possible to
// create a "producer" route for a Service in a different namespace from the
// Route.
//
// There are two kinds of parent resources with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// ParentRefs must be _distinct_. This means either that:
//
//   - They select different objects.  If this is the case, then parentRef
//     entries are distinct. In terms of fields, this means that the
//     multi-part key defined by `group`, `kind`, `namespace`, and `name` must
//     be unique across all parentRef entries in the Route.
//   - They do not select different objects, but for each optional field used,
//     each ParentRef that selects the same object must set the same set of
//     optional fields to different values. If one ParentRef sets a
//     combination of optional fields, all must set the same combination.
//
// Some examples:
//
//   - If one ParentRef sets `sectionName`, all ParentRefs referencing the
//     same object must also set `sectionName`.
//   - If one ParentRef sets `port`, all ParentRefs referencing the same
//     object must also set `port`.
//   - If one ParentRef sets `sectionName` and `port`, all ParentRefs
//     referencing the same object must also set `sectionName` and `port`.
//
// It is possible to separately reference multiple distinct objects that may
// be collapsed by an implementation. For example, some implementations may
// choose to merge compatible Gateway Listeners together. If that is the
// case, the list of routes attached to those resources should also be
// merged.
//
// Note that for ParentRefs that cross namespace boundaries, there are specific
// rules. Cross-namespace references are only valid if they are explicitly
// allowed by something in the namespace they are referring to. For example,
// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
// generic way to enable other kinds of cross-namespace reference.
func (o GRPCRouteSpecPtrOutput) ParentRefs() GRPCRouteSpecParentRefsArrayOutput {
	return o.ApplyT(func(v *GRPCRouteSpec) []GRPCRouteSpecParentRefs {
		if v == nil {
			return nil
		}
		return v.ParentRefs
	}).(GRPCRouteSpecParentRefsArrayOutput)
}

// Rules are a list of GRPC matchers, filters and actions.
func (o GRPCRouteSpecPtrOutput) Rules() GRPCRouteSpecRulesArrayOutput {
	return o.ApplyT(func(v *GRPCRouteSpec) []GRPCRouteSpecRules {
		if v == nil {
			return nil
		}
		return v.Rules
	}).(GRPCRouteSpecRulesArrayOutput)
}

// ParentReference identifies an API object (usually a Gateway) that can be considered
// a parent of this resource (usually a route). There are two kinds of parent resources
// with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
type GRPCRouteSpecParentRefs struct {
	// Group is the group of the referent.
	// When unspecified, "gateway.networking.k8s.io" is inferred.
	// To set the core API group (such as for a "Service" kind referent),
	// Group must be explicitly set to "" (empty string).
	//
	// Support: Core
	Group *string `pulumi:"group"`
	// Kind is kind of the referent.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// Support for other resources is Implementation-Specific.
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	//
	// Support: Core
	Name *string `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers
	// to the local namespace of the Route.
	//
	// Note that there are specific rules for ParentRefs which cross namespace
	// boundaries. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example:
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable any other kind of cross-namespace reference.
	//
	// Support: Core
	Namespace *string `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted
	// differently based on the type of parent resource.
	//
	// When the parent resource is a Gateway, this targets all listeners
	// listening on the specified port that also support this kind of Route(and
	// select this Route). It's not recommended to set `Port` unless the
	// networking behaviors specified in a Route must apply to a specific port
	// as opposed to a listener(s) whose port(s) may be changed. When both Port
	// and SectionName are specified, the name and port of the selected listener
	// must match both specified values.
	//
	// Implementations MAY choose to support other parent resources.
	// Implementations supporting other types of parent resources MUST clearly
	// document how/if Port is interpreted.
	//
	// For the purpose of status, an attachment is considered successful as
	// long as the parent resource accepts it partially. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
	// from the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route,
	// the Route MUST be considered detached from the Gateway.
	//
	// Support: Extended
	Port *int `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the
	// following resources, SectionName is interpreted as the following:
	//
	// * Gateway: Listener name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	// * Service: Port name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	//
	// Implementations MAY choose to support attaching Routes to other resources.
	// If that is the case, they MUST clearly document how SectionName is
	// interpreted.
	//
	// When unspecified (empty string), this will reference the entire resource.
	// For the purpose of status, an attachment is considered successful if at
	// least one section in the parent resource accepts it. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
	// the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route, the
	// Route MUST be considered detached from the Gateway.
	//
	// Support: Core
	SectionName *string `pulumi:"sectionName"`
}

// GRPCRouteSpecParentRefsInput is an input type that accepts GRPCRouteSpecParentRefsArgs and GRPCRouteSpecParentRefsOutput values.
// You can construct a concrete instance of `GRPCRouteSpecParentRefsInput` via:
//
//	GRPCRouteSpecParentRefsArgs{...}
type GRPCRouteSpecParentRefsInput interface {
	pulumi.Input

	ToGRPCRouteSpecParentRefsOutput() GRPCRouteSpecParentRefsOutput
	ToGRPCRouteSpecParentRefsOutputWithContext(context.Context) GRPCRouteSpecParentRefsOutput
}

// ParentReference identifies an API object (usually a Gateway) that can be considered
// a parent of this resource (usually a route). There are two kinds of parent resources
// with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
type GRPCRouteSpecParentRefsArgs struct {
	// Group is the group of the referent.
	// When unspecified, "gateway.networking.k8s.io" is inferred.
	// To set the core API group (such as for a "Service" kind referent),
	// Group must be explicitly set to "" (empty string).
	//
	// Support: Core
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is kind of the referent.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// Support for other resources is Implementation-Specific.
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	//
	// Support: Core
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers
	// to the local namespace of the Route.
	//
	// Note that there are specific rules for ParentRefs which cross namespace
	// boundaries. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example:
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable any other kind of cross-namespace reference.
	//
	// Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted
	// differently based on the type of parent resource.
	//
	// When the parent resource is a Gateway, this targets all listeners
	// listening on the specified port that also support this kind of Route(and
	// select this Route). It's not recommended to set `Port` unless the
	// networking behaviors specified in a Route must apply to a specific port
	// as opposed to a listener(s) whose port(s) may be changed. When both Port
	// and SectionName are specified, the name and port of the selected listener
	// must match both specified values.
	//
	// Implementations MAY choose to support other parent resources.
	// Implementations supporting other types of parent resources MUST clearly
	// document how/if Port is interpreted.
	//
	// For the purpose of status, an attachment is considered successful as
	// long as the parent resource accepts it partially. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
	// from the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route,
	// the Route MUST be considered detached from the Gateway.
	//
	// Support: Extended
	Port pulumi.IntPtrInput `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the
	// following resources, SectionName is interpreted as the following:
	//
	// * Gateway: Listener name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	// * Service: Port name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	//
	// Implementations MAY choose to support attaching Routes to other resources.
	// If that is the case, they MUST clearly document how SectionName is
	// interpreted.
	//
	// When unspecified (empty string), this will reference the entire resource.
	// For the purpose of status, an attachment is considered successful if at
	// least one section in the parent resource accepts it. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
	// the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route, the
	// Route MUST be considered detached from the Gateway.
	//
	// Support: Core
	SectionName pulumi.StringPtrInput `pulumi:"sectionName"`
}

func (GRPCRouteSpecParentRefsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecParentRefs)(nil)).Elem()
}

func (i GRPCRouteSpecParentRefsArgs) ToGRPCRouteSpecParentRefsOutput() GRPCRouteSpecParentRefsOutput {
	return i.ToGRPCRouteSpecParentRefsOutputWithContext(context.Background())
}

func (i GRPCRouteSpecParentRefsArgs) ToGRPCRouteSpecParentRefsOutputWithContext(ctx context.Context) GRPCRouteSpecParentRefsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecParentRefsOutput)
}

// GRPCRouteSpecParentRefsArrayInput is an input type that accepts GRPCRouteSpecParentRefsArray and GRPCRouteSpecParentRefsArrayOutput values.
// You can construct a concrete instance of `GRPCRouteSpecParentRefsArrayInput` via:
//
//	GRPCRouteSpecParentRefsArray{ GRPCRouteSpecParentRefsArgs{...} }
type GRPCRouteSpecParentRefsArrayInput interface {
	pulumi.Input

	ToGRPCRouteSpecParentRefsArrayOutput() GRPCRouteSpecParentRefsArrayOutput
	ToGRPCRouteSpecParentRefsArrayOutputWithContext(context.Context) GRPCRouteSpecParentRefsArrayOutput
}

type GRPCRouteSpecParentRefsArray []GRPCRouteSpecParentRefsInput

func (GRPCRouteSpecParentRefsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecParentRefs)(nil)).Elem()
}

func (i GRPCRouteSpecParentRefsArray) ToGRPCRouteSpecParentRefsArrayOutput() GRPCRouteSpecParentRefsArrayOutput {
	return i.ToGRPCRouteSpecParentRefsArrayOutputWithContext(context.Background())
}

func (i GRPCRouteSpecParentRefsArray) ToGRPCRouteSpecParentRefsArrayOutputWithContext(ctx context.Context) GRPCRouteSpecParentRefsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecParentRefsArrayOutput)
}

// ParentReference identifies an API object (usually a Gateway) that can be considered
// a parent of this resource (usually a route). There are two kinds of parent resources
// with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
type GRPCRouteSpecParentRefsOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecParentRefsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecParentRefs)(nil)).Elem()
}

func (o GRPCRouteSpecParentRefsOutput) ToGRPCRouteSpecParentRefsOutput() GRPCRouteSpecParentRefsOutput {
	return o
}

func (o GRPCRouteSpecParentRefsOutput) ToGRPCRouteSpecParentRefsOutputWithContext(ctx context.Context) GRPCRouteSpecParentRefsOutput {
	return o
}

// Group is the group of the referent.
// When unspecified, "gateway.networking.k8s.io" is inferred.
// To set the core API group (such as for a "Service" kind referent),
// Group must be explicitly set to "" (empty string).
//
// Support: Core
func (o GRPCRouteSpecParentRefsOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecParentRefs) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent.
//
// There are two kinds of parent resources with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// Support for other resources is Implementation-Specific.
func (o GRPCRouteSpecParentRefsOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecParentRefs) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
//
// Support: Core
func (o GRPCRouteSpecParentRefsOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecParentRefs) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the referent. When unspecified, this refers
// to the local namespace of the Route.
//
// Note that there are specific rules for ParentRefs which cross namespace
// boundaries. Cross-namespace references are only valid if they are explicitly
// allowed by something in the namespace they are referring to. For example:
// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
// generic way to enable any other kind of cross-namespace reference.
//
// Support: Core
func (o GRPCRouteSpecParentRefsOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecParentRefs) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Port is the network port this Route targets. It can be interpreted
// differently based on the type of parent resource.
//
// When the parent resource is a Gateway, this targets all listeners
// listening on the specified port that also support this kind of Route(and
// select this Route). It's not recommended to set `Port` unless the
// networking behaviors specified in a Route must apply to a specific port
// as opposed to a listener(s) whose port(s) may be changed. When both Port
// and SectionName are specified, the name and port of the selected listener
// must match both specified values.
//
// Implementations MAY choose to support other parent resources.
// Implementations supporting other types of parent resources MUST clearly
// document how/if Port is interpreted.
//
// For the purpose of status, an attachment is considered successful as
// long as the parent resource accepts it partially. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
// from the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route,
// the Route MUST be considered detached from the Gateway.
//
// Support: Extended
func (o GRPCRouteSpecParentRefsOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecParentRefs) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// SectionName is the name of a section within the target resource. In the
// following resources, SectionName is interpreted as the following:
//
//   - Gateway: Listener name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//   - Service: Port name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//
// Implementations MAY choose to support attaching Routes to other resources.
// If that is the case, they MUST clearly document how SectionName is
// interpreted.
//
// When unspecified (empty string), this will reference the entire resource.
// For the purpose of status, an attachment is considered successful if at
// least one section in the parent resource accepts it. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
// the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route, the
// Route MUST be considered detached from the Gateway.
//
// Support: Core
func (o GRPCRouteSpecParentRefsOutput) SectionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecParentRefs) *string { return v.SectionName }).(pulumi.StringPtrOutput)
}

type GRPCRouteSpecParentRefsArrayOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecParentRefsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecParentRefs)(nil)).Elem()
}

func (o GRPCRouteSpecParentRefsArrayOutput) ToGRPCRouteSpecParentRefsArrayOutput() GRPCRouteSpecParentRefsArrayOutput {
	return o
}

func (o GRPCRouteSpecParentRefsArrayOutput) ToGRPCRouteSpecParentRefsArrayOutputWithContext(ctx context.Context) GRPCRouteSpecParentRefsArrayOutput {
	return o
}

func (o GRPCRouteSpecParentRefsArrayOutput) Index(i pulumi.IntInput) GRPCRouteSpecParentRefsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GRPCRouteSpecParentRefs {
		return vs[0].([]GRPCRouteSpecParentRefs)[vs[1].(int)]
	}).(GRPCRouteSpecParentRefsOutput)
}

// ParentReference identifies an API object (usually a Gateway) that can be considered
// a parent of this resource (usually a route). There are two kinds of parent resources
// with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
type GRPCRouteSpecParentRefsPatch struct {
	// Group is the group of the referent.
	// When unspecified, "gateway.networking.k8s.io" is inferred.
	// To set the core API group (such as for a "Service" kind referent),
	// Group must be explicitly set to "" (empty string).
	//
	// Support: Core
	Group *string `pulumi:"group"`
	// Kind is kind of the referent.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// Support for other resources is Implementation-Specific.
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	//
	// Support: Core
	Name *string `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers
	// to the local namespace of the Route.
	//
	// Note that there are specific rules for ParentRefs which cross namespace
	// boundaries. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example:
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable any other kind of cross-namespace reference.
	//
	// Support: Core
	Namespace *string `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted
	// differently based on the type of parent resource.
	//
	// When the parent resource is a Gateway, this targets all listeners
	// listening on the specified port that also support this kind of Route(and
	// select this Route). It's not recommended to set `Port` unless the
	// networking behaviors specified in a Route must apply to a specific port
	// as opposed to a listener(s) whose port(s) may be changed. When both Port
	// and SectionName are specified, the name and port of the selected listener
	// must match both specified values.
	//
	// Implementations MAY choose to support other parent resources.
	// Implementations supporting other types of parent resources MUST clearly
	// document how/if Port is interpreted.
	//
	// For the purpose of status, an attachment is considered successful as
	// long as the parent resource accepts it partially. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
	// from the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route,
	// the Route MUST be considered detached from the Gateway.
	//
	// Support: Extended
	Port *int `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the
	// following resources, SectionName is interpreted as the following:
	//
	// * Gateway: Listener name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	// * Service: Port name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	//
	// Implementations MAY choose to support attaching Routes to other resources.
	// If that is the case, they MUST clearly document how SectionName is
	// interpreted.
	//
	// When unspecified (empty string), this will reference the entire resource.
	// For the purpose of status, an attachment is considered successful if at
	// least one section in the parent resource accepts it. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
	// the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route, the
	// Route MUST be considered detached from the Gateway.
	//
	// Support: Core
	SectionName *string `pulumi:"sectionName"`
}

// GRPCRouteSpecParentRefsPatchInput is an input type that accepts GRPCRouteSpecParentRefsPatchArgs and GRPCRouteSpecParentRefsPatchOutput values.
// You can construct a concrete instance of `GRPCRouteSpecParentRefsPatchInput` via:
//
//	GRPCRouteSpecParentRefsPatchArgs{...}
type GRPCRouteSpecParentRefsPatchInput interface {
	pulumi.Input

	ToGRPCRouteSpecParentRefsPatchOutput() GRPCRouteSpecParentRefsPatchOutput
	ToGRPCRouteSpecParentRefsPatchOutputWithContext(context.Context) GRPCRouteSpecParentRefsPatchOutput
}

// ParentReference identifies an API object (usually a Gateway) that can be considered
// a parent of this resource (usually a route). There are two kinds of parent resources
// with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
type GRPCRouteSpecParentRefsPatchArgs struct {
	// Group is the group of the referent.
	// When unspecified, "gateway.networking.k8s.io" is inferred.
	// To set the core API group (such as for a "Service" kind referent),
	// Group must be explicitly set to "" (empty string).
	//
	// Support: Core
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is kind of the referent.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// Support for other resources is Implementation-Specific.
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	//
	// Support: Core
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers
	// to the local namespace of the Route.
	//
	// Note that there are specific rules for ParentRefs which cross namespace
	// boundaries. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example:
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable any other kind of cross-namespace reference.
	//
	// Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted
	// differently based on the type of parent resource.
	//
	// When the parent resource is a Gateway, this targets all listeners
	// listening on the specified port that also support this kind of Route(and
	// select this Route). It's not recommended to set `Port` unless the
	// networking behaviors specified in a Route must apply to a specific port
	// as opposed to a listener(s) whose port(s) may be changed. When both Port
	// and SectionName are specified, the name and port of the selected listener
	// must match both specified values.
	//
	// Implementations MAY choose to support other parent resources.
	// Implementations supporting other types of parent resources MUST clearly
	// document how/if Port is interpreted.
	//
	// For the purpose of status, an attachment is considered successful as
	// long as the parent resource accepts it partially. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
	// from the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route,
	// the Route MUST be considered detached from the Gateway.
	//
	// Support: Extended
	Port pulumi.IntPtrInput `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the
	// following resources, SectionName is interpreted as the following:
	//
	// * Gateway: Listener name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	// * Service: Port name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	//
	// Implementations MAY choose to support attaching Routes to other resources.
	// If that is the case, they MUST clearly document how SectionName is
	// interpreted.
	//
	// When unspecified (empty string), this will reference the entire resource.
	// For the purpose of status, an attachment is considered successful if at
	// least one section in the parent resource accepts it. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
	// the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route, the
	// Route MUST be considered detached from the Gateway.
	//
	// Support: Core
	SectionName pulumi.StringPtrInput `pulumi:"sectionName"`
}

func (GRPCRouteSpecParentRefsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecParentRefsPatch)(nil)).Elem()
}

func (i GRPCRouteSpecParentRefsPatchArgs) ToGRPCRouteSpecParentRefsPatchOutput() GRPCRouteSpecParentRefsPatchOutput {
	return i.ToGRPCRouteSpecParentRefsPatchOutputWithContext(context.Background())
}

func (i GRPCRouteSpecParentRefsPatchArgs) ToGRPCRouteSpecParentRefsPatchOutputWithContext(ctx context.Context) GRPCRouteSpecParentRefsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecParentRefsPatchOutput)
}

// GRPCRouteSpecParentRefsPatchArrayInput is an input type that accepts GRPCRouteSpecParentRefsPatchArray and GRPCRouteSpecParentRefsPatchArrayOutput values.
// You can construct a concrete instance of `GRPCRouteSpecParentRefsPatchArrayInput` via:
//
//	GRPCRouteSpecParentRefsPatchArray{ GRPCRouteSpecParentRefsPatchArgs{...} }
type GRPCRouteSpecParentRefsPatchArrayInput interface {
	pulumi.Input

	ToGRPCRouteSpecParentRefsPatchArrayOutput() GRPCRouteSpecParentRefsPatchArrayOutput
	ToGRPCRouteSpecParentRefsPatchArrayOutputWithContext(context.Context) GRPCRouteSpecParentRefsPatchArrayOutput
}

type GRPCRouteSpecParentRefsPatchArray []GRPCRouteSpecParentRefsPatchInput

func (GRPCRouteSpecParentRefsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecParentRefsPatch)(nil)).Elem()
}

func (i GRPCRouteSpecParentRefsPatchArray) ToGRPCRouteSpecParentRefsPatchArrayOutput() GRPCRouteSpecParentRefsPatchArrayOutput {
	return i.ToGRPCRouteSpecParentRefsPatchArrayOutputWithContext(context.Background())
}

func (i GRPCRouteSpecParentRefsPatchArray) ToGRPCRouteSpecParentRefsPatchArrayOutputWithContext(ctx context.Context) GRPCRouteSpecParentRefsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecParentRefsPatchArrayOutput)
}

// ParentReference identifies an API object (usually a Gateway) that can be considered
// a parent of this resource (usually a route). There are two kinds of parent resources
// with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
type GRPCRouteSpecParentRefsPatchOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecParentRefsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecParentRefsPatch)(nil)).Elem()
}

func (o GRPCRouteSpecParentRefsPatchOutput) ToGRPCRouteSpecParentRefsPatchOutput() GRPCRouteSpecParentRefsPatchOutput {
	return o
}

func (o GRPCRouteSpecParentRefsPatchOutput) ToGRPCRouteSpecParentRefsPatchOutputWithContext(ctx context.Context) GRPCRouteSpecParentRefsPatchOutput {
	return o
}

// Group is the group of the referent.
// When unspecified, "gateway.networking.k8s.io" is inferred.
// To set the core API group (such as for a "Service" kind referent),
// Group must be explicitly set to "" (empty string).
//
// Support: Core
func (o GRPCRouteSpecParentRefsPatchOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecParentRefsPatch) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent.
//
// There are two kinds of parent resources with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// Support for other resources is Implementation-Specific.
func (o GRPCRouteSpecParentRefsPatchOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecParentRefsPatch) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
//
// Support: Core
func (o GRPCRouteSpecParentRefsPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecParentRefsPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the referent. When unspecified, this refers
// to the local namespace of the Route.
//
// Note that there are specific rules for ParentRefs which cross namespace
// boundaries. Cross-namespace references are only valid if they are explicitly
// allowed by something in the namespace they are referring to. For example:
// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
// generic way to enable any other kind of cross-namespace reference.
//
// Support: Core
func (o GRPCRouteSpecParentRefsPatchOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecParentRefsPatch) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Port is the network port this Route targets. It can be interpreted
// differently based on the type of parent resource.
//
// When the parent resource is a Gateway, this targets all listeners
// listening on the specified port that also support this kind of Route(and
// select this Route). It's not recommended to set `Port` unless the
// networking behaviors specified in a Route must apply to a specific port
// as opposed to a listener(s) whose port(s) may be changed. When both Port
// and SectionName are specified, the name and port of the selected listener
// must match both specified values.
//
// Implementations MAY choose to support other parent resources.
// Implementations supporting other types of parent resources MUST clearly
// document how/if Port is interpreted.
//
// For the purpose of status, an attachment is considered successful as
// long as the parent resource accepts it partially. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
// from the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route,
// the Route MUST be considered detached from the Gateway.
//
// Support: Extended
func (o GRPCRouteSpecParentRefsPatchOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecParentRefsPatch) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// SectionName is the name of a section within the target resource. In the
// following resources, SectionName is interpreted as the following:
//
//   - Gateway: Listener name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//   - Service: Port name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//
// Implementations MAY choose to support attaching Routes to other resources.
// If that is the case, they MUST clearly document how SectionName is
// interpreted.
//
// When unspecified (empty string), this will reference the entire resource.
// For the purpose of status, an attachment is considered successful if at
// least one section in the parent resource accepts it. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
// the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route, the
// Route MUST be considered detached from the Gateway.
//
// Support: Core
func (o GRPCRouteSpecParentRefsPatchOutput) SectionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecParentRefsPatch) *string { return v.SectionName }).(pulumi.StringPtrOutput)
}

type GRPCRouteSpecParentRefsPatchArrayOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecParentRefsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecParentRefsPatch)(nil)).Elem()
}

func (o GRPCRouteSpecParentRefsPatchArrayOutput) ToGRPCRouteSpecParentRefsPatchArrayOutput() GRPCRouteSpecParentRefsPatchArrayOutput {
	return o
}

func (o GRPCRouteSpecParentRefsPatchArrayOutput) ToGRPCRouteSpecParentRefsPatchArrayOutputWithContext(ctx context.Context) GRPCRouteSpecParentRefsPatchArrayOutput {
	return o
}

func (o GRPCRouteSpecParentRefsPatchArrayOutput) Index(i pulumi.IntInput) GRPCRouteSpecParentRefsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GRPCRouteSpecParentRefsPatch {
		return vs[0].([]GRPCRouteSpecParentRefsPatch)[vs[1].(int)]
	}).(GRPCRouteSpecParentRefsPatchOutput)
}

// Spec defines the desired state of GRPCRoute.
type GRPCRouteSpecPatch struct {
	// Hostnames defines a set of hostnames to match against the GRPC
	// Host header to select a GRPCRoute to process the request. This matches
	// the RFC 1123 definition of a hostname with 2 notable exceptions:
	//
	// 1. IPs are not allowed.
	// 2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard
	//    label MUST appear by itself as the first label.
	//
	// If a hostname is specified by both the Listener and GRPCRoute, there
	// MUST be at least one intersecting hostname for the GRPCRoute to be
	// attached to the Listener. For example:
	//
	// * A Listener with `test.example.com` as the hostname matches GRPCRoutes
	//   that have either not specified any hostnames, or have specified at
	//   least one of `test.example.com` or `*.example.com`.
	// * A Listener with `*.example.com` as the hostname matches GRPCRoutes
	//   that have either not specified any hostnames or have specified at least
	//   one hostname that matches the Listener hostname. For example,
	//   `test.example.com` and `*.example.com` would both match. On the other
	//   hand, `example.com` and `test.example.net` would not match.
	//
	// Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
	// as a suffix match. That means that a match for `*.example.com` would match
	// both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
	//
	// If both the Listener and GRPCRoute have specified hostnames, any
	// GRPCRoute hostnames that do not match the Listener hostname MUST be
	// ignored. For example, if a Listener specified `*.example.com`, and the
	// GRPCRoute specified `test.example.com` and `test.example.net`,
	// `test.example.net` MUST NOT be considered for a match.
	//
	// If both the Listener and GRPCRoute have specified hostnames, and none
	// match with the criteria above, then the GRPCRoute MUST NOT be accepted by
	// the implementation. The implementation MUST raise an 'Accepted' Condition
	// with a status of `False` in the corresponding RouteParentStatus.
	//
	// If a Route (A) of type HTTPRoute or GRPCRoute is attached to a
	// Listener and that listener already has another Route (B) of the other
	// type attached and the intersection of the hostnames of A and B is
	// non-empty, then the implementation MUST accept exactly one of these two
	// routes, determined by the following criteria, in order:
	//
	// * The oldest Route based on creation timestamp.
	// * The Route appearing first in alphabetical order by
	//   "{namespace}/{name}".
	//
	// The rejected Route MUST raise an 'Accepted' condition with a status of
	// 'False' in the corresponding RouteParentStatus.
	//
	// Support: Core
	Hostnames []string `pulumi:"hostnames"`
	// ParentRefs references the resources (usually Gateways) that a Route wants
	// to be attached to. Note that the referenced parent resource needs to
	// allow this for the attachment to be complete. For Gateways, that means
	// the Gateway needs to allow attachment from Routes of this kind and
	// namespace. For Services, that means the Service must either be in the same
	// namespace for a "producer" route, or the mesh implementation must support
	// and allow "consumer" routes for the referenced Service. ReferenceGrant is
	// not applicable for governing ParentRefs to Services - it is not possible to
	// create a "producer" route for a Service in a different namespace from the
	// Route.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// This API may be extended in the future to support additional kinds of parent
	// resources.
	//
	// ParentRefs must be _distinct_. This means either that:
	//
	// * They select different objects.  If this is the case, then parentRef
	//   entries are distinct. In terms of fields, this means that the
	//   multi-part key defined by `group`, `kind`, `namespace`, and `name` must
	//   be unique across all parentRef entries in the Route.
	// * They do not select different objects, but for each optional field used,
	//   each ParentRef that selects the same object must set the same set of
	//   optional fields to different values. If one ParentRef sets a
	//   combination of optional fields, all must set the same combination.
	//
	// Some examples:
	//
	// * If one ParentRef sets `sectionName`, all ParentRefs referencing the
	//   same object must also set `sectionName`.
	// * If one ParentRef sets `port`, all ParentRefs referencing the same
	//   object must also set `port`.
	// * If one ParentRef sets `sectionName` and `port`, all ParentRefs
	//   referencing the same object must also set `sectionName` and `port`.
	//
	// It is possible to separately reference multiple distinct objects that may
	// be collapsed by an implementation. For example, some implementations may
	// choose to merge compatible Gateway Listeners together. If that is the
	// case, the list of routes attached to those resources should also be
	// merged.
	//
	// Note that for ParentRefs that cross namespace boundaries, there are specific
	// rules. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example,
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable other kinds of cross-namespace reference.
	ParentRefs []GRPCRouteSpecParentRefsPatch `pulumi:"parentRefs"`
	// Rules are a list of GRPC matchers, filters and actions.
	Rules []GRPCRouteSpecRulesPatch `pulumi:"rules"`
}

// GRPCRouteSpecPatchInput is an input type that accepts GRPCRouteSpecPatchArgs and GRPCRouteSpecPatchOutput values.
// You can construct a concrete instance of `GRPCRouteSpecPatchInput` via:
//
//	GRPCRouteSpecPatchArgs{...}
type GRPCRouteSpecPatchInput interface {
	pulumi.Input

	ToGRPCRouteSpecPatchOutput() GRPCRouteSpecPatchOutput
	ToGRPCRouteSpecPatchOutputWithContext(context.Context) GRPCRouteSpecPatchOutput
}

// Spec defines the desired state of GRPCRoute.
type GRPCRouteSpecPatchArgs struct {
	// Hostnames defines a set of hostnames to match against the GRPC
	// Host header to select a GRPCRoute to process the request. This matches
	// the RFC 1123 definition of a hostname with 2 notable exceptions:
	//
	// 1. IPs are not allowed.
	// 2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard
	//    label MUST appear by itself as the first label.
	//
	// If a hostname is specified by both the Listener and GRPCRoute, there
	// MUST be at least one intersecting hostname for the GRPCRoute to be
	// attached to the Listener. For example:
	//
	// * A Listener with `test.example.com` as the hostname matches GRPCRoutes
	//   that have either not specified any hostnames, or have specified at
	//   least one of `test.example.com` or `*.example.com`.
	// * A Listener with `*.example.com` as the hostname matches GRPCRoutes
	//   that have either not specified any hostnames or have specified at least
	//   one hostname that matches the Listener hostname. For example,
	//   `test.example.com` and `*.example.com` would both match. On the other
	//   hand, `example.com` and `test.example.net` would not match.
	//
	// Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
	// as a suffix match. That means that a match for `*.example.com` would match
	// both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
	//
	// If both the Listener and GRPCRoute have specified hostnames, any
	// GRPCRoute hostnames that do not match the Listener hostname MUST be
	// ignored. For example, if a Listener specified `*.example.com`, and the
	// GRPCRoute specified `test.example.com` and `test.example.net`,
	// `test.example.net` MUST NOT be considered for a match.
	//
	// If both the Listener and GRPCRoute have specified hostnames, and none
	// match with the criteria above, then the GRPCRoute MUST NOT be accepted by
	// the implementation. The implementation MUST raise an 'Accepted' Condition
	// with a status of `False` in the corresponding RouteParentStatus.
	//
	// If a Route (A) of type HTTPRoute or GRPCRoute is attached to a
	// Listener and that listener already has another Route (B) of the other
	// type attached and the intersection of the hostnames of A and B is
	// non-empty, then the implementation MUST accept exactly one of these two
	// routes, determined by the following criteria, in order:
	//
	// * The oldest Route based on creation timestamp.
	// * The Route appearing first in alphabetical order by
	//   "{namespace}/{name}".
	//
	// The rejected Route MUST raise an 'Accepted' condition with a status of
	// 'False' in the corresponding RouteParentStatus.
	//
	// Support: Core
	Hostnames pulumi.StringArrayInput `pulumi:"hostnames"`
	// ParentRefs references the resources (usually Gateways) that a Route wants
	// to be attached to. Note that the referenced parent resource needs to
	// allow this for the attachment to be complete. For Gateways, that means
	// the Gateway needs to allow attachment from Routes of this kind and
	// namespace. For Services, that means the Service must either be in the same
	// namespace for a "producer" route, or the mesh implementation must support
	// and allow "consumer" routes for the referenced Service. ReferenceGrant is
	// not applicable for governing ParentRefs to Services - it is not possible to
	// create a "producer" route for a Service in a different namespace from the
	// Route.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// This API may be extended in the future to support additional kinds of parent
	// resources.
	//
	// ParentRefs must be _distinct_. This means either that:
	//
	// * They select different objects.  If this is the case, then parentRef
	//   entries are distinct. In terms of fields, this means that the
	//   multi-part key defined by `group`, `kind`, `namespace`, and `name` must
	//   be unique across all parentRef entries in the Route.
	// * They do not select different objects, but for each optional field used,
	//   each ParentRef that selects the same object must set the same set of
	//   optional fields to different values. If one ParentRef sets a
	//   combination of optional fields, all must set the same combination.
	//
	// Some examples:
	//
	// * If one ParentRef sets `sectionName`, all ParentRefs referencing the
	//   same object must also set `sectionName`.
	// * If one ParentRef sets `port`, all ParentRefs referencing the same
	//   object must also set `port`.
	// * If one ParentRef sets `sectionName` and `port`, all ParentRefs
	//   referencing the same object must also set `sectionName` and `port`.
	//
	// It is possible to separately reference multiple distinct objects that may
	// be collapsed by an implementation. For example, some implementations may
	// choose to merge compatible Gateway Listeners together. If that is the
	// case, the list of routes attached to those resources should also be
	// merged.
	//
	// Note that for ParentRefs that cross namespace boundaries, there are specific
	// rules. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example,
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable other kinds of cross-namespace reference.
	ParentRefs GRPCRouteSpecParentRefsPatchArrayInput `pulumi:"parentRefs"`
	// Rules are a list of GRPC matchers, filters and actions.
	Rules GRPCRouteSpecRulesPatchArrayInput `pulumi:"rules"`
}

func (GRPCRouteSpecPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecPatch)(nil)).Elem()
}

func (i GRPCRouteSpecPatchArgs) ToGRPCRouteSpecPatchOutput() GRPCRouteSpecPatchOutput {
	return i.ToGRPCRouteSpecPatchOutputWithContext(context.Background())
}

func (i GRPCRouteSpecPatchArgs) ToGRPCRouteSpecPatchOutputWithContext(ctx context.Context) GRPCRouteSpecPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecPatchOutput)
}

func (i GRPCRouteSpecPatchArgs) ToGRPCRouteSpecPatchPtrOutput() GRPCRouteSpecPatchPtrOutput {
	return i.ToGRPCRouteSpecPatchPtrOutputWithContext(context.Background())
}

func (i GRPCRouteSpecPatchArgs) ToGRPCRouteSpecPatchPtrOutputWithContext(ctx context.Context) GRPCRouteSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecPatchOutput).ToGRPCRouteSpecPatchPtrOutputWithContext(ctx)
}

// GRPCRouteSpecPatchPtrInput is an input type that accepts GRPCRouteSpecPatchArgs, GRPCRouteSpecPatchPtr and GRPCRouteSpecPatchPtrOutput values.
// You can construct a concrete instance of `GRPCRouteSpecPatchPtrInput` via:
//
//	        GRPCRouteSpecPatchArgs{...}
//
//	or:
//
//	        nil
type GRPCRouteSpecPatchPtrInput interface {
	pulumi.Input

	ToGRPCRouteSpecPatchPtrOutput() GRPCRouteSpecPatchPtrOutput
	ToGRPCRouteSpecPatchPtrOutputWithContext(context.Context) GRPCRouteSpecPatchPtrOutput
}

type grpcrouteSpecPatchPtrType GRPCRouteSpecPatchArgs

func GRPCRouteSpecPatchPtr(v *GRPCRouteSpecPatchArgs) GRPCRouteSpecPatchPtrInput {
	return (*grpcrouteSpecPatchPtrType)(v)
}

func (*grpcrouteSpecPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecPatch)(nil)).Elem()
}

func (i *grpcrouteSpecPatchPtrType) ToGRPCRouteSpecPatchPtrOutput() GRPCRouteSpecPatchPtrOutput {
	return i.ToGRPCRouteSpecPatchPtrOutputWithContext(context.Background())
}

func (i *grpcrouteSpecPatchPtrType) ToGRPCRouteSpecPatchPtrOutputWithContext(ctx context.Context) GRPCRouteSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecPatchPtrOutput)
}

// Spec defines the desired state of GRPCRoute.
type GRPCRouteSpecPatchOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecPatch)(nil)).Elem()
}

func (o GRPCRouteSpecPatchOutput) ToGRPCRouteSpecPatchOutput() GRPCRouteSpecPatchOutput {
	return o
}

func (o GRPCRouteSpecPatchOutput) ToGRPCRouteSpecPatchOutputWithContext(ctx context.Context) GRPCRouteSpecPatchOutput {
	return o
}

func (o GRPCRouteSpecPatchOutput) ToGRPCRouteSpecPatchPtrOutput() GRPCRouteSpecPatchPtrOutput {
	return o.ToGRPCRouteSpecPatchPtrOutputWithContext(context.Background())
}

func (o GRPCRouteSpecPatchOutput) ToGRPCRouteSpecPatchPtrOutputWithContext(ctx context.Context) GRPCRouteSpecPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GRPCRouteSpecPatch) *GRPCRouteSpecPatch {
		return &v
	}).(GRPCRouteSpecPatchPtrOutput)
}

// Hostnames defines a set of hostnames to match against the GRPC
// Host header to select a GRPCRoute to process the request. This matches
// the RFC 1123 definition of a hostname with 2 notable exceptions:
//
//  1. IPs are not allowed.
//  2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard
//     label MUST appear by itself as the first label.
//
// If a hostname is specified by both the Listener and GRPCRoute, there
// MUST be at least one intersecting hostname for the GRPCRoute to be
// attached to the Listener. For example:
//
//   - A Listener with `test.example.com` as the hostname matches GRPCRoutes
//     that have either not specified any hostnames, or have specified at
//     least one of `test.example.com` or `*.example.com`.
//   - A Listener with `*.example.com` as the hostname matches GRPCRoutes
//     that have either not specified any hostnames or have specified at least
//     one hostname that matches the Listener hostname. For example,
//     `test.example.com` and `*.example.com` would both match. On the other
//     hand, `example.com` and `test.example.net` would not match.
//
// Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
// as a suffix match. That means that a match for `*.example.com` would match
// both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
//
// If both the Listener and GRPCRoute have specified hostnames, any
// GRPCRoute hostnames that do not match the Listener hostname MUST be
// ignored. For example, if a Listener specified `*.example.com`, and the
// GRPCRoute specified `test.example.com` and `test.example.net`,
// `test.example.net` MUST NOT be considered for a match.
//
// If both the Listener and GRPCRoute have specified hostnames, and none
// match with the criteria above, then the GRPCRoute MUST NOT be accepted by
// the implementation. The implementation MUST raise an 'Accepted' Condition
// with a status of `False` in the corresponding RouteParentStatus.
//
// If a Route (A) of type HTTPRoute or GRPCRoute is attached to a
// Listener and that listener already has another Route (B) of the other
// type attached and the intersection of the hostnames of A and B is
// non-empty, then the implementation MUST accept exactly one of these two
// routes, determined by the following criteria, in order:
//
//   - The oldest Route based on creation timestamp.
//   - The Route appearing first in alphabetical order by
//     "{namespace}/{name}".
//
// The rejected Route MUST raise an 'Accepted' condition with a status of
// 'False' in the corresponding RouteParentStatus.
//
// Support: Core
func (o GRPCRouteSpecPatchOutput) Hostnames() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GRPCRouteSpecPatch) []string { return v.Hostnames }).(pulumi.StringArrayOutput)
}

// ParentRefs references the resources (usually Gateways) that a Route wants
// to be attached to. Note that the referenced parent resource needs to
// allow this for the attachment to be complete. For Gateways, that means
// the Gateway needs to allow attachment from Routes of this kind and
// namespace. For Services, that means the Service must either be in the same
// namespace for a "producer" route, or the mesh implementation must support
// and allow "consumer" routes for the referenced Service. ReferenceGrant is
// not applicable for governing ParentRefs to Services - it is not possible to
// create a "producer" route for a Service in a different namespace from the
// Route.
//
// There are two kinds of parent resources with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// ParentRefs must be _distinct_. This means either that:
//
//   - They select different objects.  If this is the case, then parentRef
//     entries are distinct. In terms of fields, this means that the
//     multi-part key defined by `group`, `kind`, `namespace`, and `name` must
//     be unique across all parentRef entries in the Route.
//   - They do not select different objects, but for each optional field used,
//     each ParentRef that selects the same object must set the same set of
//     optional fields to different values. If one ParentRef sets a
//     combination of optional fields, all must set the same combination.
//
// Some examples:
//
//   - If one ParentRef sets `sectionName`, all ParentRefs referencing the
//     same object must also set `sectionName`.
//   - If one ParentRef sets `port`, all ParentRefs referencing the same
//     object must also set `port`.
//   - If one ParentRef sets `sectionName` and `port`, all ParentRefs
//     referencing the same object must also set `sectionName` and `port`.
//
// It is possible to separately reference multiple distinct objects that may
// be collapsed by an implementation. For example, some implementations may
// choose to merge compatible Gateway Listeners together. If that is the
// case, the list of routes attached to those resources should also be
// merged.
//
// Note that for ParentRefs that cross namespace boundaries, there are specific
// rules. Cross-namespace references are only valid if they are explicitly
// allowed by something in the namespace they are referring to. For example,
// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
// generic way to enable other kinds of cross-namespace reference.
func (o GRPCRouteSpecPatchOutput) ParentRefs() GRPCRouteSpecParentRefsPatchArrayOutput {
	return o.ApplyT(func(v GRPCRouteSpecPatch) []GRPCRouteSpecParentRefsPatch { return v.ParentRefs }).(GRPCRouteSpecParentRefsPatchArrayOutput)
}

// Rules are a list of GRPC matchers, filters and actions.
func (o GRPCRouteSpecPatchOutput) Rules() GRPCRouteSpecRulesPatchArrayOutput {
	return o.ApplyT(func(v GRPCRouteSpecPatch) []GRPCRouteSpecRulesPatch { return v.Rules }).(GRPCRouteSpecRulesPatchArrayOutput)
}

type GRPCRouteSpecPatchPtrOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecPatch)(nil)).Elem()
}

func (o GRPCRouteSpecPatchPtrOutput) ToGRPCRouteSpecPatchPtrOutput() GRPCRouteSpecPatchPtrOutput {
	return o
}

func (o GRPCRouteSpecPatchPtrOutput) ToGRPCRouteSpecPatchPtrOutputWithContext(ctx context.Context) GRPCRouteSpecPatchPtrOutput {
	return o
}

func (o GRPCRouteSpecPatchPtrOutput) Elem() GRPCRouteSpecPatchOutput {
	return o.ApplyT(func(v *GRPCRouteSpecPatch) GRPCRouteSpecPatch {
		if v != nil {
			return *v
		}
		var ret GRPCRouteSpecPatch
		return ret
	}).(GRPCRouteSpecPatchOutput)
}

// Hostnames defines a set of hostnames to match against the GRPC
// Host header to select a GRPCRoute to process the request. This matches
// the RFC 1123 definition of a hostname with 2 notable exceptions:
//
//  1. IPs are not allowed.
//  2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard
//     label MUST appear by itself as the first label.
//
// If a hostname is specified by both the Listener and GRPCRoute, there
// MUST be at least one intersecting hostname for the GRPCRoute to be
// attached to the Listener. For example:
//
//   - A Listener with `test.example.com` as the hostname matches GRPCRoutes
//     that have either not specified any hostnames, or have specified at
//     least one of `test.example.com` or `*.example.com`.
//   - A Listener with `*.example.com` as the hostname matches GRPCRoutes
//     that have either not specified any hostnames or have specified at least
//     one hostname that matches the Listener hostname. For example,
//     `test.example.com` and `*.example.com` would both match. On the other
//     hand, `example.com` and `test.example.net` would not match.
//
// Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
// as a suffix match. That means that a match for `*.example.com` would match
// both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
//
// If both the Listener and GRPCRoute have specified hostnames, any
// GRPCRoute hostnames that do not match the Listener hostname MUST be
// ignored. For example, if a Listener specified `*.example.com`, and the
// GRPCRoute specified `test.example.com` and `test.example.net`,
// `test.example.net` MUST NOT be considered for a match.
//
// If both the Listener and GRPCRoute have specified hostnames, and none
// match with the criteria above, then the GRPCRoute MUST NOT be accepted by
// the implementation. The implementation MUST raise an 'Accepted' Condition
// with a status of `False` in the corresponding RouteParentStatus.
//
// If a Route (A) of type HTTPRoute or GRPCRoute is attached to a
// Listener and that listener already has another Route (B) of the other
// type attached and the intersection of the hostnames of A and B is
// non-empty, then the implementation MUST accept exactly one of these two
// routes, determined by the following criteria, in order:
//
//   - The oldest Route based on creation timestamp.
//   - The Route appearing first in alphabetical order by
//     "{namespace}/{name}".
//
// The rejected Route MUST raise an 'Accepted' condition with a status of
// 'False' in the corresponding RouteParentStatus.
//
// Support: Core
func (o GRPCRouteSpecPatchPtrOutput) Hostnames() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *GRPCRouteSpecPatch) []string {
		if v == nil {
			return nil
		}
		return v.Hostnames
	}).(pulumi.StringArrayOutput)
}

// ParentRefs references the resources (usually Gateways) that a Route wants
// to be attached to. Note that the referenced parent resource needs to
// allow this for the attachment to be complete. For Gateways, that means
// the Gateway needs to allow attachment from Routes of this kind and
// namespace. For Services, that means the Service must either be in the same
// namespace for a "producer" route, or the mesh implementation must support
// and allow "consumer" routes for the referenced Service. ReferenceGrant is
// not applicable for governing ParentRefs to Services - it is not possible to
// create a "producer" route for a Service in a different namespace from the
// Route.
//
// There are two kinds of parent resources with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// ParentRefs must be _distinct_. This means either that:
//
//   - They select different objects.  If this is the case, then parentRef
//     entries are distinct. In terms of fields, this means that the
//     multi-part key defined by `group`, `kind`, `namespace`, and `name` must
//     be unique across all parentRef entries in the Route.
//   - They do not select different objects, but for each optional field used,
//     each ParentRef that selects the same object must set the same set of
//     optional fields to different values. If one ParentRef sets a
//     combination of optional fields, all must set the same combination.
//
// Some examples:
//
//   - If one ParentRef sets `sectionName`, all ParentRefs referencing the
//     same object must also set `sectionName`.
//   - If one ParentRef sets `port`, all ParentRefs referencing the same
//     object must also set `port`.
//   - If one ParentRef sets `sectionName` and `port`, all ParentRefs
//     referencing the same object must also set `sectionName` and `port`.
//
// It is possible to separately reference multiple distinct objects that may
// be collapsed by an implementation. For example, some implementations may
// choose to merge compatible Gateway Listeners together. If that is the
// case, the list of routes attached to those resources should also be
// merged.
//
// Note that for ParentRefs that cross namespace boundaries, there are specific
// rules. Cross-namespace references are only valid if they are explicitly
// allowed by something in the namespace they are referring to. For example,
// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
// generic way to enable other kinds of cross-namespace reference.
func (o GRPCRouteSpecPatchPtrOutput) ParentRefs() GRPCRouteSpecParentRefsPatchArrayOutput {
	return o.ApplyT(func(v *GRPCRouteSpecPatch) []GRPCRouteSpecParentRefsPatch {
		if v == nil {
			return nil
		}
		return v.ParentRefs
	}).(GRPCRouteSpecParentRefsPatchArrayOutput)
}

// Rules are a list of GRPC matchers, filters and actions.
func (o GRPCRouteSpecPatchPtrOutput) Rules() GRPCRouteSpecRulesPatchArrayOutput {
	return o.ApplyT(func(v *GRPCRouteSpecPatch) []GRPCRouteSpecRulesPatch {
		if v == nil {
			return nil
		}
		return v.Rules
	}).(GRPCRouteSpecRulesPatchArrayOutput)
}

// GRPCRouteRule defines the semantics for matching a gRPC request based on
// conditions (matches), processing it (filters), and forwarding the request to
// an API object (backendRefs).
type GRPCRouteSpecRules struct {
	// BackendRefs defines the backend(s) where matching requests should be
	// sent.
	//
	// Failure behavior here depends on how many BackendRefs are specified and
	// how many are invalid.
	//
	// If *all* entries in BackendRefs are invalid, and there are also no filters
	// specified in this route rule, *all* traffic which matches this rule MUST
	// receive an `UNAVAILABLE` status.
	//
	// See the GRPCBackendRef definition for the rules about what makes a single
	// GRPCBackendRef invalid.
	//
	// When a GRPCBackendRef is invalid, `UNAVAILABLE` statuses MUST be returned for
	// requests that would have otherwise been routed to an invalid backend. If
	// multiple backends are specified, and some are invalid, the proportion of
	// requests that would otherwise have been routed to an invalid backend
	// MUST receive an `UNAVAILABLE` status.
	//
	// For example, if two backends are specified with equal weights, and one is
	// invalid, 50 percent of traffic MUST receive an `UNAVAILABLE` status.
	// Implementations may choose how that 50 percent is determined.
	//
	// Support: Core for Kubernetes Service
	//
	// Support: Implementation-specific for any other resource
	//
	// Support for weight: Core
	BackendRefs []GRPCRouteSpecRulesBackendRefs `pulumi:"backendRefs"`
	// Filters define the filters that are applied to requests that match
	// this rule.
	//
	// The effects of ordering of multiple behaviors are currently unspecified.
	// This can change in the future based on feedback during the alpha stage.
	//
	// Conformance-levels at this level are defined based on the type of filter:
	//
	// - ALL core filters MUST be supported by all implementations that support
	//   GRPCRoute.
	// - Implementers are encouraged to support extended filters.
	// - Implementation-specific custom filters have no API guarantees across
	//   implementations.
	//
	// Specifying the same filter multiple times is not supported unless explicitly
	// indicated in the filter.
	//
	// If an implementation can not support a combination of filters, it must clearly
	// document that limitation. In cases where incompatible or unsupported
	// filters are specified and cause the `Accepted` condition to be set to status
	// `False`, implementations may use the `IncompatibleFilters` reason to specify
	// this configuration error.
	//
	// Support: Core
	Filters []GRPCRouteSpecRulesFilters `pulumi:"filters"`
	// Matches define conditions used for matching the rule against incoming
	// gRPC requests. Each match is independent, i.e. this rule will be matched
	// if **any** one of the matches is satisfied.
	//
	// For example, take the following matches configuration:
	//
	// For a request to match against this rule, it MUST satisfy
	// EITHER of the two conditions:
	//
	// - service of foo.bar AND contains the header `version: 2`
	// - service of foo.bar.v2
	//
	// See the documentation for GRPCRouteMatch on how to specify multiple
	// match conditions to be ANDed together.
	//
	// If no matches are specified, the implementation MUST match every gRPC request.
	//
	// Proxy or Load Balancer routing configuration generated from GRPCRoutes
	// MUST prioritize rules based on the following criteria, continuing on
	// ties. Merging MUST not be done between GRPCRoutes and HTTPRoutes.
	// Precedence MUST be given to the rule with the largest number of:
	//
	// * Characters in a matching non-wildcard hostname.
	// * Characters in a matching hostname.
	// * Characters in a matching service.
	// * Characters in a matching method.
	// * Header matches.
	//
	// If ties still exist across multiple Routes, matching precedence MUST be
	// determined in order of the following criteria, continuing on ties:
	//
	// * The oldest Route based on creation timestamp.
	// * The Route appearing first in alphabetical order by
	//   "{namespace}/{name}".
	//
	// If ties still exist within the Route that has been given precedence,
	// matching precedence MUST be granted to the first matching rule meeting
	// the above criteria.
	Matches []GRPCRouteSpecRulesMatches `pulumi:"matches"`
}

// GRPCRouteSpecRulesInput is an input type that accepts GRPCRouteSpecRulesArgs and GRPCRouteSpecRulesOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesInput` via:
//
//	GRPCRouteSpecRulesArgs{...}
type GRPCRouteSpecRulesInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesOutput() GRPCRouteSpecRulesOutput
	ToGRPCRouteSpecRulesOutputWithContext(context.Context) GRPCRouteSpecRulesOutput
}

// GRPCRouteRule defines the semantics for matching a gRPC request based on
// conditions (matches), processing it (filters), and forwarding the request to
// an API object (backendRefs).
type GRPCRouteSpecRulesArgs struct {
	// BackendRefs defines the backend(s) where matching requests should be
	// sent.
	//
	// Failure behavior here depends on how many BackendRefs are specified and
	// how many are invalid.
	//
	// If *all* entries in BackendRefs are invalid, and there are also no filters
	// specified in this route rule, *all* traffic which matches this rule MUST
	// receive an `UNAVAILABLE` status.
	//
	// See the GRPCBackendRef definition for the rules about what makes a single
	// GRPCBackendRef invalid.
	//
	// When a GRPCBackendRef is invalid, `UNAVAILABLE` statuses MUST be returned for
	// requests that would have otherwise been routed to an invalid backend. If
	// multiple backends are specified, and some are invalid, the proportion of
	// requests that would otherwise have been routed to an invalid backend
	// MUST receive an `UNAVAILABLE` status.
	//
	// For example, if two backends are specified with equal weights, and one is
	// invalid, 50 percent of traffic MUST receive an `UNAVAILABLE` status.
	// Implementations may choose how that 50 percent is determined.
	//
	// Support: Core for Kubernetes Service
	//
	// Support: Implementation-specific for any other resource
	//
	// Support for weight: Core
	BackendRefs GRPCRouteSpecRulesBackendRefsArrayInput `pulumi:"backendRefs"`
	// Filters define the filters that are applied to requests that match
	// this rule.
	//
	// The effects of ordering of multiple behaviors are currently unspecified.
	// This can change in the future based on feedback during the alpha stage.
	//
	// Conformance-levels at this level are defined based on the type of filter:
	//
	// - ALL core filters MUST be supported by all implementations that support
	//   GRPCRoute.
	// - Implementers are encouraged to support extended filters.
	// - Implementation-specific custom filters have no API guarantees across
	//   implementations.
	//
	// Specifying the same filter multiple times is not supported unless explicitly
	// indicated in the filter.
	//
	// If an implementation can not support a combination of filters, it must clearly
	// document that limitation. In cases where incompatible or unsupported
	// filters are specified and cause the `Accepted` condition to be set to status
	// `False`, implementations may use the `IncompatibleFilters` reason to specify
	// this configuration error.
	//
	// Support: Core
	Filters GRPCRouteSpecRulesFiltersArrayInput `pulumi:"filters"`
	// Matches define conditions used for matching the rule against incoming
	// gRPC requests. Each match is independent, i.e. this rule will be matched
	// if **any** one of the matches is satisfied.
	//
	// For example, take the following matches configuration:
	//
	// For a request to match against this rule, it MUST satisfy
	// EITHER of the two conditions:
	//
	// - service of foo.bar AND contains the header `version: 2`
	// - service of foo.bar.v2
	//
	// See the documentation for GRPCRouteMatch on how to specify multiple
	// match conditions to be ANDed together.
	//
	// If no matches are specified, the implementation MUST match every gRPC request.
	//
	// Proxy or Load Balancer routing configuration generated from GRPCRoutes
	// MUST prioritize rules based on the following criteria, continuing on
	// ties. Merging MUST not be done between GRPCRoutes and HTTPRoutes.
	// Precedence MUST be given to the rule with the largest number of:
	//
	// * Characters in a matching non-wildcard hostname.
	// * Characters in a matching hostname.
	// * Characters in a matching service.
	// * Characters in a matching method.
	// * Header matches.
	//
	// If ties still exist across multiple Routes, matching precedence MUST be
	// determined in order of the following criteria, continuing on ties:
	//
	// * The oldest Route based on creation timestamp.
	// * The Route appearing first in alphabetical order by
	//   "{namespace}/{name}".
	//
	// If ties still exist within the Route that has been given precedence,
	// matching precedence MUST be granted to the first matching rule meeting
	// the above criteria.
	Matches GRPCRouteSpecRulesMatchesArrayInput `pulumi:"matches"`
}

func (GRPCRouteSpecRulesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRules)(nil)).Elem()
}

func (i GRPCRouteSpecRulesArgs) ToGRPCRouteSpecRulesOutput() GRPCRouteSpecRulesOutput {
	return i.ToGRPCRouteSpecRulesOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesArgs) ToGRPCRouteSpecRulesOutputWithContext(ctx context.Context) GRPCRouteSpecRulesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesOutput)
}

// GRPCRouteSpecRulesArrayInput is an input type that accepts GRPCRouteSpecRulesArray and GRPCRouteSpecRulesArrayOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesArrayInput` via:
//
//	GRPCRouteSpecRulesArray{ GRPCRouteSpecRulesArgs{...} }
type GRPCRouteSpecRulesArrayInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesArrayOutput() GRPCRouteSpecRulesArrayOutput
	ToGRPCRouteSpecRulesArrayOutputWithContext(context.Context) GRPCRouteSpecRulesArrayOutput
}

type GRPCRouteSpecRulesArray []GRPCRouteSpecRulesInput

func (GRPCRouteSpecRulesArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRules)(nil)).Elem()
}

func (i GRPCRouteSpecRulesArray) ToGRPCRouteSpecRulesArrayOutput() GRPCRouteSpecRulesArrayOutput {
	return i.ToGRPCRouteSpecRulesArrayOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesArray) ToGRPCRouteSpecRulesArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesArrayOutput)
}

// GRPCRouteRule defines the semantics for matching a gRPC request based on
// conditions (matches), processing it (filters), and forwarding the request to
// an API object (backendRefs).
type GRPCRouteSpecRulesOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRules)(nil)).Elem()
}

func (o GRPCRouteSpecRulesOutput) ToGRPCRouteSpecRulesOutput() GRPCRouteSpecRulesOutput {
	return o
}

func (o GRPCRouteSpecRulesOutput) ToGRPCRouteSpecRulesOutputWithContext(ctx context.Context) GRPCRouteSpecRulesOutput {
	return o
}

// BackendRefs defines the backend(s) where matching requests should be
// sent.
//
// Failure behavior here depends on how many BackendRefs are specified and
// how many are invalid.
//
// If *all* entries in BackendRefs are invalid, and there are also no filters
// specified in this route rule, *all* traffic which matches this rule MUST
// receive an `UNAVAILABLE` status.
//
// See the GRPCBackendRef definition for the rules about what makes a single
// GRPCBackendRef invalid.
//
// When a GRPCBackendRef is invalid, `UNAVAILABLE` statuses MUST be returned for
// requests that would have otherwise been routed to an invalid backend. If
// multiple backends are specified, and some are invalid, the proportion of
// requests that would otherwise have been routed to an invalid backend
// MUST receive an `UNAVAILABLE` status.
//
// For example, if two backends are specified with equal weights, and one is
// invalid, 50 percent of traffic MUST receive an `UNAVAILABLE` status.
// Implementations may choose how that 50 percent is determined.
//
// Support: Core for Kubernetes Service
//
// Support: Implementation-specific for any other resource
//
// Support for weight: Core
func (o GRPCRouteSpecRulesOutput) BackendRefs() GRPCRouteSpecRulesBackendRefsArrayOutput {
	return o.ApplyT(func(v GRPCRouteSpecRules) []GRPCRouteSpecRulesBackendRefs { return v.BackendRefs }).(GRPCRouteSpecRulesBackendRefsArrayOutput)
}

// Filters define the filters that are applied to requests that match
// this rule.
//
// The effects of ordering of multiple behaviors are currently unspecified.
// This can change in the future based on feedback during the alpha stage.
//
// Conformance-levels at this level are defined based on the type of filter:
//
//   - ALL core filters MUST be supported by all implementations that support
//     GRPCRoute.
//   - Implementers are encouraged to support extended filters.
//   - Implementation-specific custom filters have no API guarantees across
//     implementations.
//
// Specifying the same filter multiple times is not supported unless explicitly
// indicated in the filter.
//
// If an implementation can not support a combination of filters, it must clearly
// document that limitation. In cases where incompatible or unsupported
// filters are specified and cause the `Accepted` condition to be set to status
// `False`, implementations may use the `IncompatibleFilters` reason to specify
// this configuration error.
//
// Support: Core
func (o GRPCRouteSpecRulesOutput) Filters() GRPCRouteSpecRulesFiltersArrayOutput {
	return o.ApplyT(func(v GRPCRouteSpecRules) []GRPCRouteSpecRulesFilters { return v.Filters }).(GRPCRouteSpecRulesFiltersArrayOutput)
}

// Matches define conditions used for matching the rule against incoming
// gRPC requests. Each match is independent, i.e. this rule will be matched
// if **any** one of the matches is satisfied.
//
// For example, take the following matches configuration:
//
// For a request to match against this rule, it MUST satisfy
// EITHER of the two conditions:
//
// - service of foo.bar AND contains the header `version: 2`
// - service of foo.bar.v2
//
// See the documentation for GRPCRouteMatch on how to specify multiple
// match conditions to be ANDed together.
//
// If no matches are specified, the implementation MUST match every gRPC request.
//
// Proxy or Load Balancer routing configuration generated from GRPCRoutes
// MUST prioritize rules based on the following criteria, continuing on
// ties. Merging MUST not be done between GRPCRoutes and HTTPRoutes.
// Precedence MUST be given to the rule with the largest number of:
//
// * Characters in a matching non-wildcard hostname.
// * Characters in a matching hostname.
// * Characters in a matching service.
// * Characters in a matching method.
// * Header matches.
//
// If ties still exist across multiple Routes, matching precedence MUST be
// determined in order of the following criteria, continuing on ties:
//
//   - The oldest Route based on creation timestamp.
//   - The Route appearing first in alphabetical order by
//     "{namespace}/{name}".
//
// If ties still exist within the Route that has been given precedence,
// matching precedence MUST be granted to the first matching rule meeting
// the above criteria.
func (o GRPCRouteSpecRulesOutput) Matches() GRPCRouteSpecRulesMatchesArrayOutput {
	return o.ApplyT(func(v GRPCRouteSpecRules) []GRPCRouteSpecRulesMatches { return v.Matches }).(GRPCRouteSpecRulesMatchesArrayOutput)
}

type GRPCRouteSpecRulesArrayOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRules)(nil)).Elem()
}

func (o GRPCRouteSpecRulesArrayOutput) ToGRPCRouteSpecRulesArrayOutput() GRPCRouteSpecRulesArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesArrayOutput) ToGRPCRouteSpecRulesArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesArrayOutput) Index(i pulumi.IntInput) GRPCRouteSpecRulesOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GRPCRouteSpecRules {
		return vs[0].([]GRPCRouteSpecRules)[vs[1].(int)]
	}).(GRPCRouteSpecRulesOutput)
}

// GRPCBackendRef defines how a GRPCRoute forwards a gRPC request.
//
// Note that when a namespace different than the local namespace is specified, a
// ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// <gateway:experimental:description>
//
// When the BackendRef points to a Kubernetes Service, implementations SHOULD
// honor the appProtocol field if it is set for the target Service Port.
//
// Implementations supporting appProtocol SHOULD recognize the Kubernetes
// Standard Application Protocols defined in KEP-3726.
//
// If a Service appProtocol isn't specified, an implementation MAY infer the
// backend protocol through its own means. Implementations MAY infer the
// protocol from the Route type referring to the backend Service.
//
// If a Route is not able to send traffic to the backend using the specified
// protocol then the backend is considered invalid. Implementations MUST set the
// "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.
//
// </gateway:experimental:description>
type GRPCRouteSpecRulesBackendRefs struct {
	// Filters defined at this level MUST be executed if and only if the
	// request is being forwarded to the backend defined here.
	//
	// Support: Implementation-specific (For broader support of filters, use the
	// Filters field in GRPCRouteRule.)
	Filters []GRPCRouteSpecRulesBackendRefsFilters `pulumi:"filters"`
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group *string `pulumi:"group"`
	// Kind is the Kubernetes resource kind of the referent. For example
	// "Service".
	//
	// Defaults to "Service" when not specified.
	//
	// ExternalName services can refer to CNAME DNS records that may live
	// outside of the cluster and as such are difficult to reason about in
	// terms of conformance. They also may not be safe to forward to (see
	// CVE-2021-25740 for more information). Implementations SHOULD NOT
	// support ExternalName Services.
	//
	// Support: Core (Services with a type other than ExternalName)
	//
	// Support: Implementation-specific (Services with type ExternalName)
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	Name *string `pulumi:"name"`
	// Namespace is the namespace of the backend. When unspecified, the local
	// namespace is inferred.
	//
	// Note that when a namespace different than the local namespace is specified,
	// a ReferenceGrant object is required in the referent namespace to allow that
	// namespace's owner to accept the reference. See the ReferenceGrant
	// documentation for details.
	//
	// Support: Core
	Namespace *string `pulumi:"namespace"`
	// Port specifies the destination port number to use for this resource.
	// Port is required when the referent is a Kubernetes Service. In this
	// case, the port number is the service port number, not the target port.
	// For other resources, destination port might be derived from the referent
	// resource or this field.
	Port *int `pulumi:"port"`
	// Weight specifies the proportion of requests forwarded to the referenced
	// backend. This is computed as weight/(sum of all weights in this
	// BackendRefs list). For non-zero values, there may be some epsilon from
	// the exact proportion defined here depending on the precision an
	// implementation supports. Weight is not a percentage and the sum of
	// weights does not need to equal 100.
	//
	// If only one backend is specified and it has a weight greater than 0, 100%
	// of the traffic is forwarded to that backend. If weight is set to 0, no
	// traffic should be forwarded for this entry. If unspecified, weight
	// defaults to 1.
	//
	// Support for this field varies based on the context where used.
	Weight *int `pulumi:"weight"`
}

// GRPCRouteSpecRulesBackendRefsInput is an input type that accepts GRPCRouteSpecRulesBackendRefsArgs and GRPCRouteSpecRulesBackendRefsOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsInput` via:
//
//	GRPCRouteSpecRulesBackendRefsArgs{...}
type GRPCRouteSpecRulesBackendRefsInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsOutput() GRPCRouteSpecRulesBackendRefsOutput
	ToGRPCRouteSpecRulesBackendRefsOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsOutput
}

// GRPCBackendRef defines how a GRPCRoute forwards a gRPC request.
//
// Note that when a namespace different than the local namespace is specified, a
// ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// <gateway:experimental:description>
//
// When the BackendRef points to a Kubernetes Service, implementations SHOULD
// honor the appProtocol field if it is set for the target Service Port.
//
// Implementations supporting appProtocol SHOULD recognize the Kubernetes
// Standard Application Protocols defined in KEP-3726.
//
// If a Service appProtocol isn't specified, an implementation MAY infer the
// backend protocol through its own means. Implementations MAY infer the
// protocol from the Route type referring to the backend Service.
//
// If a Route is not able to send traffic to the backend using the specified
// protocol then the backend is considered invalid. Implementations MUST set the
// "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.
//
// </gateway:experimental:description>
type GRPCRouteSpecRulesBackendRefsArgs struct {
	// Filters defined at this level MUST be executed if and only if the
	// request is being forwarded to the backend defined here.
	//
	// Support: Implementation-specific (For broader support of filters, use the
	// Filters field in GRPCRouteRule.)
	Filters GRPCRouteSpecRulesBackendRefsFiltersArrayInput `pulumi:"filters"`
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is the Kubernetes resource kind of the referent. For example
	// "Service".
	//
	// Defaults to "Service" when not specified.
	//
	// ExternalName services can refer to CNAME DNS records that may live
	// outside of the cluster and as such are difficult to reason about in
	// terms of conformance. They also may not be safe to forward to (see
	// CVE-2021-25740 for more information). Implementations SHOULD NOT
	// support ExternalName Services.
	//
	// Support: Core (Services with a type other than ExternalName)
	//
	// Support: Implementation-specific (Services with type ExternalName)
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace is the namespace of the backend. When unspecified, the local
	// namespace is inferred.
	//
	// Note that when a namespace different than the local namespace is specified,
	// a ReferenceGrant object is required in the referent namespace to allow that
	// namespace's owner to accept the reference. See the ReferenceGrant
	// documentation for details.
	//
	// Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Port specifies the destination port number to use for this resource.
	// Port is required when the referent is a Kubernetes Service. In this
	// case, the port number is the service port number, not the target port.
	// For other resources, destination port might be derived from the referent
	// resource or this field.
	Port pulumi.IntPtrInput `pulumi:"port"`
	// Weight specifies the proportion of requests forwarded to the referenced
	// backend. This is computed as weight/(sum of all weights in this
	// BackendRefs list). For non-zero values, there may be some epsilon from
	// the exact proportion defined here depending on the precision an
	// implementation supports. Weight is not a percentage and the sum of
	// weights does not need to equal 100.
	//
	// If only one backend is specified and it has a weight greater than 0, 100%
	// of the traffic is forwarded to that backend. If weight is set to 0, no
	// traffic should be forwarded for this entry. If unspecified, weight
	// defaults to 1.
	//
	// Support for this field varies based on the context where used.
	Weight pulumi.IntPtrInput `pulumi:"weight"`
}

func (GRPCRouteSpecRulesBackendRefsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefs)(nil)).Elem()
}

func (i GRPCRouteSpecRulesBackendRefsArgs) ToGRPCRouteSpecRulesBackendRefsOutput() GRPCRouteSpecRulesBackendRefsOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsArgs) ToGRPCRouteSpecRulesBackendRefsOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsOutput)
}

// GRPCRouteSpecRulesBackendRefsArrayInput is an input type that accepts GRPCRouteSpecRulesBackendRefsArray and GRPCRouteSpecRulesBackendRefsArrayOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsArrayInput` via:
//
//	GRPCRouteSpecRulesBackendRefsArray{ GRPCRouteSpecRulesBackendRefsArgs{...} }
type GRPCRouteSpecRulesBackendRefsArrayInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsArrayOutput() GRPCRouteSpecRulesBackendRefsArrayOutput
	ToGRPCRouteSpecRulesBackendRefsArrayOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsArrayOutput
}

type GRPCRouteSpecRulesBackendRefsArray []GRPCRouteSpecRulesBackendRefsInput

func (GRPCRouteSpecRulesBackendRefsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesBackendRefs)(nil)).Elem()
}

func (i GRPCRouteSpecRulesBackendRefsArray) ToGRPCRouteSpecRulesBackendRefsArrayOutput() GRPCRouteSpecRulesBackendRefsArrayOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsArrayOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsArray) ToGRPCRouteSpecRulesBackendRefsArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsArrayOutput)
}

// GRPCBackendRef defines how a GRPCRoute forwards a gRPC request.
//
// Note that when a namespace different than the local namespace is specified, a
// ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// <gateway:experimental:description>
//
// When the BackendRef points to a Kubernetes Service, implementations SHOULD
// honor the appProtocol field if it is set for the target Service Port.
//
// Implementations supporting appProtocol SHOULD recognize the Kubernetes
// Standard Application Protocols defined in KEP-3726.
//
// If a Service appProtocol isn't specified, an implementation MAY infer the
// backend protocol through its own means. Implementations MAY infer the
// protocol from the Route type referring to the backend Service.
//
// If a Route is not able to send traffic to the backend using the specified
// protocol then the backend is considered invalid. Implementations MUST set the
// "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.
//
// </gateway:experimental:description>
type GRPCRouteSpecRulesBackendRefsOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefs)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsOutput) ToGRPCRouteSpecRulesBackendRefsOutput() GRPCRouteSpecRulesBackendRefsOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsOutput) ToGRPCRouteSpecRulesBackendRefsOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsOutput {
	return o
}

// Filters defined at this level MUST be executed if and only if the
// request is being forwarded to the backend defined here.
//
// Support: Implementation-specific (For broader support of filters, use the
// Filters field in GRPCRouteRule.)
func (o GRPCRouteSpecRulesBackendRefsOutput) Filters() GRPCRouteSpecRulesBackendRefsFiltersArrayOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefs) []GRPCRouteSpecRulesBackendRefsFilters { return v.Filters }).(GRPCRouteSpecRulesBackendRefsFiltersArrayOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o GRPCRouteSpecRulesBackendRefsOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefs) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is the Kubernetes resource kind of the referent. For example
// "Service".
//
// Defaults to "Service" when not specified.
//
// ExternalName services can refer to CNAME DNS records that may live
// outside of the cluster and as such are difficult to reason about in
// terms of conformance. They also may not be safe to forward to (see
// CVE-2021-25740 for more information). Implementations SHOULD NOT
// support ExternalName Services.
//
// Support: Core (Services with a type other than ExternalName)
//
// Support: Implementation-specific (Services with type ExternalName)
func (o GRPCRouteSpecRulesBackendRefsOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefs) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o GRPCRouteSpecRulesBackendRefsOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefs) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the backend. When unspecified, the local
// namespace is inferred.
//
// Note that when a namespace different than the local namespace is specified,
// a ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// Support: Core
func (o GRPCRouteSpecRulesBackendRefsOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefs) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Port specifies the destination port number to use for this resource.
// Port is required when the referent is a Kubernetes Service. In this
// case, the port number is the service port number, not the target port.
// For other resources, destination port might be derived from the referent
// resource or this field.
func (o GRPCRouteSpecRulesBackendRefsOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefs) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// Weight specifies the proportion of requests forwarded to the referenced
// backend. This is computed as weight/(sum of all weights in this
// BackendRefs list). For non-zero values, there may be some epsilon from
// the exact proportion defined here depending on the precision an
// implementation supports. Weight is not a percentage and the sum of
// weights does not need to equal 100.
//
// If only one backend is specified and it has a weight greater than 0, 100%
// of the traffic is forwarded to that backend. If weight is set to 0, no
// traffic should be forwarded for this entry. If unspecified, weight
// defaults to 1.
//
// Support for this field varies based on the context where used.
func (o GRPCRouteSpecRulesBackendRefsOutput) Weight() pulumi.IntPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefs) *int { return v.Weight }).(pulumi.IntPtrOutput)
}

type GRPCRouteSpecRulesBackendRefsArrayOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesBackendRefs)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsArrayOutput) ToGRPCRouteSpecRulesBackendRefsArrayOutput() GRPCRouteSpecRulesBackendRefsArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsArrayOutput) ToGRPCRouteSpecRulesBackendRefsArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsArrayOutput) Index(i pulumi.IntInput) GRPCRouteSpecRulesBackendRefsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GRPCRouteSpecRulesBackendRefs {
		return vs[0].([]GRPCRouteSpecRulesBackendRefs)[vs[1].(int)]
	}).(GRPCRouteSpecRulesBackendRefsOutput)
}

// GRPCRouteFilter defines processing steps that must be completed during the
// request or response lifecycle. GRPCRouteFilters are meant as an extension
// point to express processing that may be done in Gateway implementations. Some
// examples include request or response modification, implementing
// authentication strategies, rate-limiting, and traffic shaping. API
// guarantee/conformance is defined based on the type of the filter.
type GRPCRouteSpecRulesBackendRefsFilters struct {
	ExtensionRef           *GRPCRouteSpecRulesBackendRefsFiltersExtensionRef           `pulumi:"extensionRef"`
	RequestHeaderModifier  *GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifier  `pulumi:"requestHeaderModifier"`
	RequestMirror          *GRPCRouteSpecRulesBackendRefsFiltersRequestMirror          `pulumi:"requestMirror"`
	ResponseHeaderModifier *GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifier `pulumi:"responseHeaderModifier"`
	// Type identifies the type of filter to apply. As with other API fields,
	// types are classified into three conformance levels:
	//
	// - Core: Filter types and their corresponding configuration defined by
	// "Support: Core" in this package, e.g. "RequestHeaderModifier". All
	// implementations supporting GRPCRoute MUST support core filters.
	//
	// - Extended: Filter types and their corresponding configuration defined by
	// "Support: Extended" in this package, e.g. "RequestMirror". Implementers
	// are encouraged to support extended filters.
	//
	// - Implementation-specific: Filters that are defined and supported by specific vendors.
	// In the future, filters showing convergence in behavior across multiple
	// implementations will be considered for inclusion in extended or core
	// conformance levels. Filter-specific configuration for such filters
	// is specified using the ExtensionRef field. `Type` MUST be set to
	// "ExtensionRef" for custom filters.
	//
	// Implementers are encouraged to define custom implementation types to
	// extend the core API with implementation-specific behavior.
	//
	// If a reference to a custom filter type cannot be resolved, the filter
	// MUST NOT be skipped. Instead, requests that would have been processed by
	// that filter MUST receive a HTTP error response.
	Type *string `pulumi:"type"`
}

// GRPCRouteSpecRulesBackendRefsFiltersInput is an input type that accepts GRPCRouteSpecRulesBackendRefsFiltersArgs and GRPCRouteSpecRulesBackendRefsFiltersOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsFiltersInput` via:
//
//	GRPCRouteSpecRulesBackendRefsFiltersArgs{...}
type GRPCRouteSpecRulesBackendRefsFiltersInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsFiltersOutput() GRPCRouteSpecRulesBackendRefsFiltersOutput
	ToGRPCRouteSpecRulesBackendRefsFiltersOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsFiltersOutput
}

// GRPCRouteFilter defines processing steps that must be completed during the
// request or response lifecycle. GRPCRouteFilters are meant as an extension
// point to express processing that may be done in Gateway implementations. Some
// examples include request or response modification, implementing
// authentication strategies, rate-limiting, and traffic shaping. API
// guarantee/conformance is defined based on the type of the filter.
type GRPCRouteSpecRulesBackendRefsFiltersArgs struct {
	ExtensionRef           GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrInput           `pulumi:"extensionRef"`
	RequestHeaderModifier  GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrInput  `pulumi:"requestHeaderModifier"`
	RequestMirror          GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrInput          `pulumi:"requestMirror"`
	ResponseHeaderModifier GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrInput `pulumi:"responseHeaderModifier"`
	// Type identifies the type of filter to apply. As with other API fields,
	// types are classified into three conformance levels:
	//
	// - Core: Filter types and their corresponding configuration defined by
	// "Support: Core" in this package, e.g. "RequestHeaderModifier". All
	// implementations supporting GRPCRoute MUST support core filters.
	//
	// - Extended: Filter types and their corresponding configuration defined by
	// "Support: Extended" in this package, e.g. "RequestMirror". Implementers
	// are encouraged to support extended filters.
	//
	// - Implementation-specific: Filters that are defined and supported by specific vendors.
	// In the future, filters showing convergence in behavior across multiple
	// implementations will be considered for inclusion in extended or core
	// conformance levels. Filter-specific configuration for such filters
	// is specified using the ExtensionRef field. `Type` MUST be set to
	// "ExtensionRef" for custom filters.
	//
	// Implementers are encouraged to define custom implementation types to
	// extend the core API with implementation-specific behavior.
	//
	// If a reference to a custom filter type cannot be resolved, the filter
	// MUST NOT be skipped. Instead, requests that would have been processed by
	// that filter MUST receive a HTTP error response.
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (GRPCRouteSpecRulesBackendRefsFiltersArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFilters)(nil)).Elem()
}

func (i GRPCRouteSpecRulesBackendRefsFiltersArgs) ToGRPCRouteSpecRulesBackendRefsFiltersOutput() GRPCRouteSpecRulesBackendRefsFiltersOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsFiltersArgs) ToGRPCRouteSpecRulesBackendRefsFiltersOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersOutput)
}

// GRPCRouteSpecRulesBackendRefsFiltersArrayInput is an input type that accepts GRPCRouteSpecRulesBackendRefsFiltersArray and GRPCRouteSpecRulesBackendRefsFiltersArrayOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsFiltersArrayInput` via:
//
//	GRPCRouteSpecRulesBackendRefsFiltersArray{ GRPCRouteSpecRulesBackendRefsFiltersArgs{...} }
type GRPCRouteSpecRulesBackendRefsFiltersArrayInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsFiltersArrayOutput() GRPCRouteSpecRulesBackendRefsFiltersArrayOutput
	ToGRPCRouteSpecRulesBackendRefsFiltersArrayOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsFiltersArrayOutput
}

type GRPCRouteSpecRulesBackendRefsFiltersArray []GRPCRouteSpecRulesBackendRefsFiltersInput

func (GRPCRouteSpecRulesBackendRefsFiltersArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesBackendRefsFilters)(nil)).Elem()
}

func (i GRPCRouteSpecRulesBackendRefsFiltersArray) ToGRPCRouteSpecRulesBackendRefsFiltersArrayOutput() GRPCRouteSpecRulesBackendRefsFiltersArrayOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersArrayOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsFiltersArray) ToGRPCRouteSpecRulesBackendRefsFiltersArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersArrayOutput)
}

// GRPCRouteFilter defines processing steps that must be completed during the
// request or response lifecycle. GRPCRouteFilters are meant as an extension
// point to express processing that may be done in Gateway implementations. Some
// examples include request or response modification, implementing
// authentication strategies, rate-limiting, and traffic shaping. API
// guarantee/conformance is defined based on the type of the filter.
type GRPCRouteSpecRulesBackendRefsFiltersOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsFiltersOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFilters)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsFiltersOutput) ToGRPCRouteSpecRulesBackendRefsFiltersOutput() GRPCRouteSpecRulesBackendRefsFiltersOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersOutput) ToGRPCRouteSpecRulesBackendRefsFiltersOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersOutput) ExtensionRef() GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFilters) *GRPCRouteSpecRulesBackendRefsFiltersExtensionRef {
		return v.ExtensionRef
	}).(GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput)
}

func (o GRPCRouteSpecRulesBackendRefsFiltersOutput) RequestHeaderModifier() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFilters) *GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifier {
		return v.RequestHeaderModifier
	}).(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput)
}

func (o GRPCRouteSpecRulesBackendRefsFiltersOutput) RequestMirror() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFilters) *GRPCRouteSpecRulesBackendRefsFiltersRequestMirror {
		return v.RequestMirror
	}).(GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput)
}

func (o GRPCRouteSpecRulesBackendRefsFiltersOutput) ResponseHeaderModifier() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFilters) *GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifier {
		return v.ResponseHeaderModifier
	}).(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput)
}

// Type identifies the type of filter to apply. As with other API fields,
// types are classified into three conformance levels:
//
// - Core: Filter types and their corresponding configuration defined by
// "Support: Core" in this package, e.g. "RequestHeaderModifier". All
// implementations supporting GRPCRoute MUST support core filters.
//
// - Extended: Filter types and their corresponding configuration defined by
// "Support: Extended" in this package, e.g. "RequestMirror". Implementers
// are encouraged to support extended filters.
//
// - Implementation-specific: Filters that are defined and supported by specific vendors.
// In the future, filters showing convergence in behavior across multiple
// implementations will be considered for inclusion in extended or core
// conformance levels. Filter-specific configuration for such filters
// is specified using the ExtensionRef field. `Type` MUST be set to
// "ExtensionRef" for custom filters.
//
// Implementers are encouraged to define custom implementation types to
// extend the core API with implementation-specific behavior.
//
// If a reference to a custom filter type cannot be resolved, the filter
// MUST NOT be skipped. Instead, requests that would have been processed by
// that filter MUST receive a HTTP error response.
func (o GRPCRouteSpecRulesBackendRefsFiltersOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFilters) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type GRPCRouteSpecRulesBackendRefsFiltersArrayOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsFiltersArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesBackendRefsFilters)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsFiltersArrayOutput) ToGRPCRouteSpecRulesBackendRefsFiltersArrayOutput() GRPCRouteSpecRulesBackendRefsFiltersArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersArrayOutput) ToGRPCRouteSpecRulesBackendRefsFiltersArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersArrayOutput) Index(i pulumi.IntInput) GRPCRouteSpecRulesBackendRefsFiltersOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GRPCRouteSpecRulesBackendRefsFilters {
		return vs[0].([]GRPCRouteSpecRulesBackendRefsFilters)[vs[1].(int)]
	}).(GRPCRouteSpecRulesBackendRefsFiltersOutput)
}

// ExtensionRef is an optional, implementation-specific extension to the
// "filter" behavior.  For example, resource "myroutefilter" in group
// "networking.example.net"). ExtensionRef MUST NOT be used for core and
// extended filters.
//
// Support: Implementation-specific
//
// This filter can be used multiple times within the same rule.
type GRPCRouteSpecRulesBackendRefsFiltersExtensionRef struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group *string `pulumi:"group"`
	// Kind is kind of the referent. For example "HTTPRoute" or "Service".
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	Name *string `pulumi:"name"`
}

// GRPCRouteSpecRulesBackendRefsFiltersExtensionRefInput is an input type that accepts GRPCRouteSpecRulesBackendRefsFiltersExtensionRefArgs and GRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsFiltersExtensionRefInput` via:
//
//	GRPCRouteSpecRulesBackendRefsFiltersExtensionRefArgs{...}
type GRPCRouteSpecRulesBackendRefsFiltersExtensionRefInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutput() GRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutput
	ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutput
}

// ExtensionRef is an optional, implementation-specific extension to the
// "filter" behavior.  For example, resource "myroutefilter" in group
// "networking.example.net"). ExtensionRef MUST NOT be used for core and
// extended filters.
//
// Support: Implementation-specific
//
// This filter can be used multiple times within the same rule.
type GRPCRouteSpecRulesBackendRefsFiltersExtensionRefArgs struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is kind of the referent. For example "HTTPRoute" or "Service".
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (GRPCRouteSpecRulesBackendRefsFiltersExtensionRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersExtensionRef)(nil)).Elem()
}

func (i GRPCRouteSpecRulesBackendRefsFiltersExtensionRefArgs) ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutput() GRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsFiltersExtensionRefArgs) ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutput)
}

func (i GRPCRouteSpecRulesBackendRefsFiltersExtensionRefArgs) ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsFiltersExtensionRefArgs) ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutput).ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutputWithContext(ctx)
}

// GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrInput is an input type that accepts GRPCRouteSpecRulesBackendRefsFiltersExtensionRefArgs, GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtr and GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrInput` via:
//
//	        GRPCRouteSpecRulesBackendRefsFiltersExtensionRefArgs{...}
//
//	or:
//
//	        nil
type GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput
	ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput
}

type grpcrouteSpecRulesBackendRefsFiltersExtensionRefPtrType GRPCRouteSpecRulesBackendRefsFiltersExtensionRefArgs

func GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtr(v *GRPCRouteSpecRulesBackendRefsFiltersExtensionRefArgs) GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrInput {
	return (*grpcrouteSpecRulesBackendRefsFiltersExtensionRefPtrType)(v)
}

func (*grpcrouteSpecRulesBackendRefsFiltersExtensionRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesBackendRefsFiltersExtensionRef)(nil)).Elem()
}

func (i *grpcrouteSpecRulesBackendRefsFiltersExtensionRefPtrType) ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutputWithContext(context.Background())
}

func (i *grpcrouteSpecRulesBackendRefsFiltersExtensionRefPtrType) ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput)
}

// ExtensionRef is an optional, implementation-specific extension to the
// "filter" behavior.  For example, resource "myroutefilter" in group
// "networking.example.net"). ExtensionRef MUST NOT be used for core and
// extended filters.
//
// Support: Implementation-specific
//
// This filter can be used multiple times within the same rule.
type GRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersExtensionRef)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutput) ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutput() GRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutput) ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutput) ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput {
	return o.ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutputWithContext(context.Background())
}

func (o GRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutput) ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GRPCRouteSpecRulesBackendRefsFiltersExtensionRef) *GRPCRouteSpecRulesBackendRefsFiltersExtensionRef {
		return &v
	}).(GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o GRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersExtensionRef) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent. For example "HTTPRoute" or "Service".
func (o GRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersExtensionRef) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o GRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersExtensionRef) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesBackendRefsFiltersExtensionRef)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput) ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput) ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput) Elem() GRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesBackendRefsFiltersExtensionRef) GRPCRouteSpecRulesBackendRefsFiltersExtensionRef {
		if v != nil {
			return *v
		}
		var ret GRPCRouteSpecRulesBackendRefsFiltersExtensionRef
		return ret
	}).(GRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesBackendRefsFiltersExtensionRef) *string {
		if v == nil {
			return nil
		}
		return v.Group
	}).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent. For example "HTTPRoute" or "Service".
func (o GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesBackendRefsFiltersExtensionRef) *string {
		if v == nil {
			return nil
		}
		return v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesBackendRefsFiltersExtensionRef) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// ExtensionRef is an optional, implementation-specific extension to the
// "filter" behavior.  For example, resource "myroutefilter" in group
// "networking.example.net"). ExtensionRef MUST NOT be used for core and
// extended filters.
//
// Support: Implementation-specific
//
// This filter can be used multiple times within the same rule.
type GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatch struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group *string `pulumi:"group"`
	// Kind is kind of the referent. For example "HTTPRoute" or "Service".
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	Name *string `pulumi:"name"`
}

// GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchInput is an input type that accepts GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchArgs and GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchInput` via:
//
//	GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchArgs{...}
type GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutput() GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutput
	ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutput
}

// ExtensionRef is an optional, implementation-specific extension to the
// "filter" behavior.  For example, resource "myroutefilter" in group
// "networking.example.net"). ExtensionRef MUST NOT be used for core and
// extended filters.
//
// Support: Implementation-specific
//
// This filter can be used multiple times within the same rule.
type GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchArgs struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is kind of the referent. For example "HTTPRoute" or "Service".
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatch)(nil)).Elem()
}

func (i GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchArgs) ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutput() GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchArgs) ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutput)
}

func (i GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchArgs) ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchArgs) ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutput).ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutputWithContext(ctx)
}

// GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrInput is an input type that accepts GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchArgs, GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtr and GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrInput` via:
//
//	        GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchArgs{...}
//
//	or:
//
//	        nil
type GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput
	ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput
}

type grpcrouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrType GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchArgs

func GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtr(v *GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchArgs) GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrInput {
	return (*grpcrouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrType)(v)
}

func (*grpcrouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatch)(nil)).Elem()
}

func (i *grpcrouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrType) ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutputWithContext(context.Background())
}

func (i *grpcrouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrType) ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput)
}

// ExtensionRef is an optional, implementation-specific extension to the
// "filter" behavior.  For example, resource "myroutefilter" in group
// "networking.example.net"). ExtensionRef MUST NOT be used for core and
// extended filters.
//
// Support: Implementation-specific
//
// This filter can be used multiple times within the same rule.
type GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatch)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutput) ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutput() GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutput) ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutput) ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput {
	return o.ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutputWithContext(context.Background())
}

func (o GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutput) ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatch) *GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatch {
		return &v
	}).(GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatch) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent. For example "HTTPRoute" or "Service".
func (o GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatch) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatch)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput) ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput) ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput) Elem() GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatch) GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatch {
		if v != nil {
			return *v
		}
		var ret GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatch
		return ret
	}).(GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Group
	}).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent. For example "HTTPRoute" or "Service".
func (o GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// GRPCRouteFilter defines processing steps that must be completed during the
// request or response lifecycle. GRPCRouteFilters are meant as an extension
// point to express processing that may be done in Gateway implementations. Some
// examples include request or response modification, implementing
// authentication strategies, rate-limiting, and traffic shaping. API
// guarantee/conformance is defined based on the type of the filter.
type GRPCRouteSpecRulesBackendRefsFiltersPatch struct {
	ExtensionRef           *GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatch           `pulumi:"extensionRef"`
	RequestHeaderModifier  *GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatch  `pulumi:"requestHeaderModifier"`
	RequestMirror          *GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatch          `pulumi:"requestMirror"`
	ResponseHeaderModifier *GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatch `pulumi:"responseHeaderModifier"`
	// Type identifies the type of filter to apply. As with other API fields,
	// types are classified into three conformance levels:
	//
	// - Core: Filter types and their corresponding configuration defined by
	// "Support: Core" in this package, e.g. "RequestHeaderModifier". All
	// implementations supporting GRPCRoute MUST support core filters.
	//
	// - Extended: Filter types and their corresponding configuration defined by
	// "Support: Extended" in this package, e.g. "RequestMirror". Implementers
	// are encouraged to support extended filters.
	//
	// - Implementation-specific: Filters that are defined and supported by specific vendors.
	// In the future, filters showing convergence in behavior across multiple
	// implementations will be considered for inclusion in extended or core
	// conformance levels. Filter-specific configuration for such filters
	// is specified using the ExtensionRef field. `Type` MUST be set to
	// "ExtensionRef" for custom filters.
	//
	// Implementers are encouraged to define custom implementation types to
	// extend the core API with implementation-specific behavior.
	//
	// If a reference to a custom filter type cannot be resolved, the filter
	// MUST NOT be skipped. Instead, requests that would have been processed by
	// that filter MUST receive a HTTP error response.
	Type *string `pulumi:"type"`
}

// GRPCRouteSpecRulesBackendRefsFiltersPatchInput is an input type that accepts GRPCRouteSpecRulesBackendRefsFiltersPatchArgs and GRPCRouteSpecRulesBackendRefsFiltersPatchOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsFiltersPatchInput` via:
//
//	GRPCRouteSpecRulesBackendRefsFiltersPatchArgs{...}
type GRPCRouteSpecRulesBackendRefsFiltersPatchInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsFiltersPatchOutput() GRPCRouteSpecRulesBackendRefsFiltersPatchOutput
	ToGRPCRouteSpecRulesBackendRefsFiltersPatchOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsFiltersPatchOutput
}

// GRPCRouteFilter defines processing steps that must be completed during the
// request or response lifecycle. GRPCRouteFilters are meant as an extension
// point to express processing that may be done in Gateway implementations. Some
// examples include request or response modification, implementing
// authentication strategies, rate-limiting, and traffic shaping. API
// guarantee/conformance is defined based on the type of the filter.
type GRPCRouteSpecRulesBackendRefsFiltersPatchArgs struct {
	ExtensionRef           GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrInput           `pulumi:"extensionRef"`
	RequestHeaderModifier  GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrInput  `pulumi:"requestHeaderModifier"`
	RequestMirror          GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrInput          `pulumi:"requestMirror"`
	ResponseHeaderModifier GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrInput `pulumi:"responseHeaderModifier"`
	// Type identifies the type of filter to apply. As with other API fields,
	// types are classified into three conformance levels:
	//
	// - Core: Filter types and their corresponding configuration defined by
	// "Support: Core" in this package, e.g. "RequestHeaderModifier". All
	// implementations supporting GRPCRoute MUST support core filters.
	//
	// - Extended: Filter types and their corresponding configuration defined by
	// "Support: Extended" in this package, e.g. "RequestMirror". Implementers
	// are encouraged to support extended filters.
	//
	// - Implementation-specific: Filters that are defined and supported by specific vendors.
	// In the future, filters showing convergence in behavior across multiple
	// implementations will be considered for inclusion in extended or core
	// conformance levels. Filter-specific configuration for such filters
	// is specified using the ExtensionRef field. `Type` MUST be set to
	// "ExtensionRef" for custom filters.
	//
	// Implementers are encouraged to define custom implementation types to
	// extend the core API with implementation-specific behavior.
	//
	// If a reference to a custom filter type cannot be resolved, the filter
	// MUST NOT be skipped. Instead, requests that would have been processed by
	// that filter MUST receive a HTTP error response.
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (GRPCRouteSpecRulesBackendRefsFiltersPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersPatch)(nil)).Elem()
}

func (i GRPCRouteSpecRulesBackendRefsFiltersPatchArgs) ToGRPCRouteSpecRulesBackendRefsFiltersPatchOutput() GRPCRouteSpecRulesBackendRefsFiltersPatchOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersPatchOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsFiltersPatchArgs) ToGRPCRouteSpecRulesBackendRefsFiltersPatchOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersPatchOutput)
}

// GRPCRouteSpecRulesBackendRefsFiltersPatchArrayInput is an input type that accepts GRPCRouteSpecRulesBackendRefsFiltersPatchArray and GRPCRouteSpecRulesBackendRefsFiltersPatchArrayOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsFiltersPatchArrayInput` via:
//
//	GRPCRouteSpecRulesBackendRefsFiltersPatchArray{ GRPCRouteSpecRulesBackendRefsFiltersPatchArgs{...} }
type GRPCRouteSpecRulesBackendRefsFiltersPatchArrayInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsFiltersPatchArrayOutput() GRPCRouteSpecRulesBackendRefsFiltersPatchArrayOutput
	ToGRPCRouteSpecRulesBackendRefsFiltersPatchArrayOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsFiltersPatchArrayOutput
}

type GRPCRouteSpecRulesBackendRefsFiltersPatchArray []GRPCRouteSpecRulesBackendRefsFiltersPatchInput

func (GRPCRouteSpecRulesBackendRefsFiltersPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesBackendRefsFiltersPatch)(nil)).Elem()
}

func (i GRPCRouteSpecRulesBackendRefsFiltersPatchArray) ToGRPCRouteSpecRulesBackendRefsFiltersPatchArrayOutput() GRPCRouteSpecRulesBackendRefsFiltersPatchArrayOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersPatchArrayOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsFiltersPatchArray) ToGRPCRouteSpecRulesBackendRefsFiltersPatchArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersPatchArrayOutput)
}

// GRPCRouteFilter defines processing steps that must be completed during the
// request or response lifecycle. GRPCRouteFilters are meant as an extension
// point to express processing that may be done in Gateway implementations. Some
// examples include request or response modification, implementing
// authentication strategies, rate-limiting, and traffic shaping. API
// guarantee/conformance is defined based on the type of the filter.
type GRPCRouteSpecRulesBackendRefsFiltersPatchOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsFiltersPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersPatch)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsFiltersPatchOutput) ToGRPCRouteSpecRulesBackendRefsFiltersPatchOutput() GRPCRouteSpecRulesBackendRefsFiltersPatchOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersPatchOutput) ToGRPCRouteSpecRulesBackendRefsFiltersPatchOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersPatchOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersPatchOutput) ExtensionRef() GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersPatch) *GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatch {
		return v.ExtensionRef
	}).(GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput)
}

func (o GRPCRouteSpecRulesBackendRefsFiltersPatchOutput) RequestHeaderModifier() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersPatch) *GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatch {
		return v.RequestHeaderModifier
	}).(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput)
}

func (o GRPCRouteSpecRulesBackendRefsFiltersPatchOutput) RequestMirror() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersPatch) *GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatch {
		return v.RequestMirror
	}).(GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput)
}

func (o GRPCRouteSpecRulesBackendRefsFiltersPatchOutput) ResponseHeaderModifier() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersPatch) *GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatch {
		return v.ResponseHeaderModifier
	}).(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput)
}

// Type identifies the type of filter to apply. As with other API fields,
// types are classified into three conformance levels:
//
// - Core: Filter types and their corresponding configuration defined by
// "Support: Core" in this package, e.g. "RequestHeaderModifier". All
// implementations supporting GRPCRoute MUST support core filters.
//
// - Extended: Filter types and their corresponding configuration defined by
// "Support: Extended" in this package, e.g. "RequestMirror". Implementers
// are encouraged to support extended filters.
//
// - Implementation-specific: Filters that are defined and supported by specific vendors.
// In the future, filters showing convergence in behavior across multiple
// implementations will be considered for inclusion in extended or core
// conformance levels. Filter-specific configuration for such filters
// is specified using the ExtensionRef field. `Type` MUST be set to
// "ExtensionRef" for custom filters.
//
// Implementers are encouraged to define custom implementation types to
// extend the core API with implementation-specific behavior.
//
// If a reference to a custom filter type cannot be resolved, the filter
// MUST NOT be skipped. Instead, requests that would have been processed by
// that filter MUST receive a HTTP error response.
func (o GRPCRouteSpecRulesBackendRefsFiltersPatchOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersPatch) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type GRPCRouteSpecRulesBackendRefsFiltersPatchArrayOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsFiltersPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesBackendRefsFiltersPatch)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsFiltersPatchArrayOutput) ToGRPCRouteSpecRulesBackendRefsFiltersPatchArrayOutput() GRPCRouteSpecRulesBackendRefsFiltersPatchArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersPatchArrayOutput) ToGRPCRouteSpecRulesBackendRefsFiltersPatchArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersPatchArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersPatchArrayOutput) Index(i pulumi.IntInput) GRPCRouteSpecRulesBackendRefsFiltersPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GRPCRouteSpecRulesBackendRefsFiltersPatch {
		return vs[0].([]GRPCRouteSpecRulesBackendRefsFiltersPatch)[vs[1].(int)]
	}).(GRPCRouteSpecRulesBackendRefsFiltersPatchOutput)
}

// RequestHeaderModifier defines a schema for a filter that modifies request
// headers.
//
// Support: Core
type GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifier struct {
	// Add adds the given header(s) (name, value) to the request
	// before the action. It appends to any existing values associated
	// with the header name.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   add:
	//   - name: "my-header"
	//     value: "bar,baz"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: foo,bar,baz
	Add []GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd `pulumi:"add"`
	// Remove the given header(s) from the HTTP request before the action. The
	// value of Remove is a list of HTTP header names. Note that the header
	// names are case-insensitive (see
	// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header1: foo
	//   my-header2: bar
	//   my-header3: baz
	//
	// Config:
	//   remove: ["my-header1", "my-header3"]
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header2: bar
	Remove []string `pulumi:"remove"`
	// Set overwrites the request with the given header (name, value)
	// before the action.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   set:
	//   - name: "my-header"
	//     value: "bar"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: bar
	Set []GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet `pulumi:"set"`
}

// GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierInput is an input type that accepts GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs and GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierInput` via:
//
//	GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs{...}
type GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput
	ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput
}

// RequestHeaderModifier defines a schema for a filter that modifies request
// headers.
//
// Support: Core
type GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs struct {
	// Add adds the given header(s) (name, value) to the request
	// before the action. It appends to any existing values associated
	// with the header name.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   add:
	//   - name: "my-header"
	//     value: "bar,baz"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: foo,bar,baz
	Add GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayInput `pulumi:"add"`
	// Remove the given header(s) from the HTTP request before the action. The
	// value of Remove is a list of HTTP header names. Note that the header
	// names are case-insensitive (see
	// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header1: foo
	//   my-header2: bar
	//   my-header3: baz
	//
	// Config:
	//   remove: ["my-header1", "my-header3"]
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header2: bar
	Remove pulumi.StringArrayInput `pulumi:"remove"`
	// Set overwrites the request with the given header (name, value)
	// before the action.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   set:
	//   - name: "my-header"
	//     value: "bar"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: bar
	Set GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayInput `pulumi:"set"`
}

func (GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifier)(nil)).Elem()
}

func (i GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput)
}

func (i GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput).ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutputWithContext(ctx)
}

// GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrInput is an input type that accepts GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs, GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtr and GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrInput` via:
//
//	        GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs{...}
//
//	or:
//
//	        nil
type GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput
	ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput
}

type grpcrouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrType GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs

func GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtr(v *GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrInput {
	return (*grpcrouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrType)(v)
}

func (*grpcrouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifier)(nil)).Elem()
}

func (i *grpcrouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrType) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutputWithContext(context.Background())
}

func (i *grpcrouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrType) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput)
}

// RequestHeaderModifier defines a schema for a filter that modifies request
// headers.
//
// Support: Core
type GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifier)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput {
	return o.ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutputWithContext(context.Background())
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifier) *GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifier {
		return &v
	}).(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput)
}

// Add adds the given header(s) (name, value) to the request
// before the action. It appends to any existing values associated
// with the header name.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	add:
//	- name: "my-header"
//	  value: "bar,baz"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: foo,bar,baz
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput) Add() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifier) []GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd {
		return v.Add
	}).(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput)
}

// Remove the given header(s) from the HTTP request before the action. The
// value of Remove is a list of HTTP header names. Note that the header
// names are case-insensitive (see
// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header1: foo
//	my-header2: bar
//	my-header3: baz
//
// Config:
//
//	remove: ["my-header1", "my-header3"]
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header2: bar
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput) Remove() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifier) []string { return v.Remove }).(pulumi.StringArrayOutput)
}

// Set overwrites the request with the given header (name, value)
// before the action.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	set:
//	- name: "my-header"
//	  value: "bar"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: bar
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput) Set() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifier) []GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet {
		return v.Set
	}).(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput)
}

type GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifier)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput) Elem() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifier) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifier {
		if v != nil {
			return *v
		}
		var ret GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifier
		return ret
	}).(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput)
}

// Add adds the given header(s) (name, value) to the request
// before the action. It appends to any existing values associated
// with the header name.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	add:
//	- name: "my-header"
//	  value: "bar,baz"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: foo,bar,baz
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput) Add() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifier) []GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd {
		if v == nil {
			return nil
		}
		return v.Add
	}).(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput)
}

// Remove the given header(s) from the HTTP request before the action. The
// value of Remove is a list of HTTP header names. Note that the header
// names are case-insensitive (see
// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header1: foo
//	my-header2: bar
//	my-header3: baz
//
// Config:
//
//	remove: ["my-header1", "my-header3"]
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header2: bar
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput) Remove() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifier) []string {
		if v == nil {
			return nil
		}
		return v.Remove
	}).(pulumi.StringArrayOutput)
}

// Set overwrites the request with the given header (name, value)
// before the action.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	set:
//	- name: "my-header"
//	  value: "bar"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: bar
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput) Set() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifier) []GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet {
		if v == nil {
			return nil
		}
		return v.Set
	}).(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name *string `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value *string `pulumi:"value"`
}

// GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddInput is an input type that accepts GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArgs and GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddInput` via:
//
//	GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArgs{...}
type GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput
	ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArgs struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd)(nil)).Elem()
}

func (i GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArgs) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArgs) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput)
}

// GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayInput is an input type that accepts GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArray and GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayInput` via:
//
//	GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArray{ GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArgs{...} }
type GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput
	ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput
}

type GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArray []GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddInput

func (GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd)(nil)).Elem()
}

func (i GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArray) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArray) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput {
	return o
}

// Name is the name of the HTTP Header to be matched. Name matching MUST be
// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
//
// If multiple entries specify equivalent header names, the first entry with
// an equivalent name MUST be considered for a match. Subsequent entries
// with an equivalent header name MUST be ignored. Due to the
// case-insensitivity of header names, "foo" and "Foo" are considered
// equivalent.
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Value is the value of HTTP Header to be matched.
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput) Index(i pulumi.IntInput) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd {
		return vs[0].([]GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd)[vs[1].(int)]
	}).(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatch struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name *string `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value *string `pulumi:"value"`
}

// GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchInput is an input type that accepts GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArgs and GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchInput` via:
//
//	GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArgs{...}
type GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchOutput
	ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchOutput
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArgs struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatch)(nil)).Elem()
}

func (i GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArgs) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArgs) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchOutput)
}

// GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayInput is an input type that accepts GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArray and GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayInput` via:
//
//	GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArray{ GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArgs{...} }
type GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayOutput
	ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayOutput
}

type GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArray []GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchInput

func (GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatch)(nil)).Elem()
}

func (i GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArray) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArray) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatch)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchOutput {
	return o
}

// Name is the name of the HTTP Header to be matched. Name matching MUST be
// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
//
// If multiple entries specify equivalent header names, the first entry with
// an equivalent name MUST be considered for a match. Subsequent entries
// with an equivalent header name MUST be ignored. Due to the
// case-insensitivity of header names, "foo" and "Foo" are considered
// equivalent.
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Value is the value of HTTP Header to be matched.
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatch) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatch)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayOutput) Index(i pulumi.IntInput) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatch {
		return vs[0].([]GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatch)[vs[1].(int)]
	}).(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchOutput)
}

// RequestHeaderModifier defines a schema for a filter that modifies request
// headers.
//
// Support: Core
type GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatch struct {
	// Add adds the given header(s) (name, value) to the request
	// before the action. It appends to any existing values associated
	// with the header name.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   add:
	//   - name: "my-header"
	//     value: "bar,baz"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: foo,bar,baz
	Add []GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatch `pulumi:"add"`
	// Remove the given header(s) from the HTTP request before the action. The
	// value of Remove is a list of HTTP header names. Note that the header
	// names are case-insensitive (see
	// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header1: foo
	//   my-header2: bar
	//   my-header3: baz
	//
	// Config:
	//   remove: ["my-header1", "my-header3"]
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header2: bar
	Remove []string `pulumi:"remove"`
	// Set overwrites the request with the given header (name, value)
	// before the action.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   set:
	//   - name: "my-header"
	//     value: "bar"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: bar
	Set []GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatch `pulumi:"set"`
}

// GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchInput is an input type that accepts GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchArgs and GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchInput` via:
//
//	GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchArgs{...}
type GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutput
	ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutput
}

// RequestHeaderModifier defines a schema for a filter that modifies request
// headers.
//
// Support: Core
type GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchArgs struct {
	// Add adds the given header(s) (name, value) to the request
	// before the action. It appends to any existing values associated
	// with the header name.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   add:
	//   - name: "my-header"
	//     value: "bar,baz"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: foo,bar,baz
	Add GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayInput `pulumi:"add"`
	// Remove the given header(s) from the HTTP request before the action. The
	// value of Remove is a list of HTTP header names. Note that the header
	// names are case-insensitive (see
	// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header1: foo
	//   my-header2: bar
	//   my-header3: baz
	//
	// Config:
	//   remove: ["my-header1", "my-header3"]
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header2: bar
	Remove pulumi.StringArrayInput `pulumi:"remove"`
	// Set overwrites the request with the given header (name, value)
	// before the action.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   set:
	//   - name: "my-header"
	//     value: "bar"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: bar
	Set GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayInput `pulumi:"set"`
}

func (GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatch)(nil)).Elem()
}

func (i GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchArgs) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchArgs) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutput)
}

func (i GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchArgs) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchArgs) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutput).ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutputWithContext(ctx)
}

// GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrInput is an input type that accepts GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchArgs, GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtr and GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrInput` via:
//
//	        GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchArgs{...}
//
//	or:
//
//	        nil
type GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput
	ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput
}

type grpcrouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrType GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchArgs

func GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtr(v *GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchArgs) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrInput {
	return (*grpcrouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrType)(v)
}

func (*grpcrouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatch)(nil)).Elem()
}

func (i *grpcrouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrType) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutputWithContext(context.Background())
}

func (i *grpcrouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrType) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput)
}

// RequestHeaderModifier defines a schema for a filter that modifies request
// headers.
//
// Support: Core
type GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatch)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput {
	return o.ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutputWithContext(context.Background())
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatch) *GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatch {
		return &v
	}).(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput)
}

// Add adds the given header(s) (name, value) to the request
// before the action. It appends to any existing values associated
// with the header name.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	add:
//	- name: "my-header"
//	  value: "bar,baz"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: foo,bar,baz
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutput) Add() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatch) []GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatch {
		return v.Add
	}).(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayOutput)
}

// Remove the given header(s) from the HTTP request before the action. The
// value of Remove is a list of HTTP header names. Note that the header
// names are case-insensitive (see
// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header1: foo
//	my-header2: bar
//	my-header3: baz
//
// Config:
//
//	remove: ["my-header1", "my-header3"]
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header2: bar
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutput) Remove() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatch) []string { return v.Remove }).(pulumi.StringArrayOutput)
}

// Set overwrites the request with the given header (name, value)
// before the action.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	set:
//	- name: "my-header"
//	  value: "bar"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: bar
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutput) Set() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatch) []GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatch {
		return v.Set
	}).(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayOutput)
}

type GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatch)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput) Elem() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatch) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatch {
		if v != nil {
			return *v
		}
		var ret GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatch
		return ret
	}).(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutput)
}

// Add adds the given header(s) (name, value) to the request
// before the action. It appends to any existing values associated
// with the header name.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	add:
//	- name: "my-header"
//	  value: "bar,baz"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: foo,bar,baz
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput) Add() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatch) []GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatch {
		if v == nil {
			return nil
		}
		return v.Add
	}).(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayOutput)
}

// Remove the given header(s) from the HTTP request before the action. The
// value of Remove is a list of HTTP header names. Note that the header
// names are case-insensitive (see
// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header1: foo
//	my-header2: bar
//	my-header3: baz
//
// Config:
//
//	remove: ["my-header1", "my-header3"]
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header2: bar
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput) Remove() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatch) []string {
		if v == nil {
			return nil
		}
		return v.Remove
	}).(pulumi.StringArrayOutput)
}

// Set overwrites the request with the given header (name, value)
// before the action.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	set:
//	- name: "my-header"
//	  value: "bar"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: bar
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput) Set() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatch) []GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatch {
		if v == nil {
			return nil
		}
		return v.Set
	}).(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name *string `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value *string `pulumi:"value"`
}

// GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetInput is an input type that accepts GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArgs and GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetInput` via:
//
//	GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArgs{...}
type GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput
	ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArgs struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet)(nil)).Elem()
}

func (i GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArgs) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArgs) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput)
}

// GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayInput is an input type that accepts GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArray and GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayInput` via:
//
//	GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArray{ GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArgs{...} }
type GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput
	ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput
}

type GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArray []GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetInput

func (GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet)(nil)).Elem()
}

func (i GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArray) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArray) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput {
	return o
}

// Name is the name of the HTTP Header to be matched. Name matching MUST be
// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
//
// If multiple entries specify equivalent header names, the first entry with
// an equivalent name MUST be considered for a match. Subsequent entries
// with an equivalent header name MUST be ignored. Due to the
// case-insensitivity of header names, "foo" and "Foo" are considered
// equivalent.
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Value is the value of HTTP Header to be matched.
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput) Index(i pulumi.IntInput) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet {
		return vs[0].([]GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet)[vs[1].(int)]
	}).(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatch struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name *string `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value *string `pulumi:"value"`
}

// GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchInput is an input type that accepts GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArgs and GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchInput` via:
//
//	GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArgs{...}
type GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchOutput
	ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchOutput
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArgs struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatch)(nil)).Elem()
}

func (i GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArgs) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArgs) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchOutput)
}

// GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayInput is an input type that accepts GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArray and GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayInput` via:
//
//	GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArray{ GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArgs{...} }
type GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayOutput
	ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayOutput
}

type GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArray []GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchInput

func (GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatch)(nil)).Elem()
}

func (i GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArray) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArray) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatch)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchOutput {
	return o
}

// Name is the name of the HTTP Header to be matched. Name matching MUST be
// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
//
// If multiple entries specify equivalent header names, the first entry with
// an equivalent name MUST be considered for a match. Subsequent entries
// with an equivalent header name MUST be ignored. Due to the
// case-insensitivity of header names, "foo" and "Foo" are considered
// equivalent.
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Value is the value of HTTP Header to be matched.
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatch) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatch)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayOutput) Index(i pulumi.IntInput) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatch {
		return vs[0].([]GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatch)[vs[1].(int)]
	}).(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchOutput)
}

// RequestMirror defines a schema for a filter that mirrors requests.
// Requests are sent to the specified destination, but responses from
// that destination are ignored.
//
// This filter can be used multiple times within the same rule. Note that
// not all implementations will be able to support mirroring to multiple
// backends.
//
// Support: Extended
type GRPCRouteSpecRulesBackendRefsFiltersRequestMirror struct {
	BackendRef *GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef `pulumi:"backendRef"`
}

// GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorInput is an input type that accepts GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorArgs and GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorInput` via:
//
//	GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorArgs{...}
type GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorOutput
	ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorOutput
}

// RequestMirror defines a schema for a filter that mirrors requests.
// Requests are sent to the specified destination, but responses from
// that destination are ignored.
//
// This filter can be used multiple times within the same rule. Note that
// not all implementations will be able to support mirroring to multiple
// backends.
//
// Support: Extended
type GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorArgs struct {
	BackendRef GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrInput `pulumi:"backendRef"`
}

func (GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersRequestMirror)(nil)).Elem()
}

func (i GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorArgs) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorArgs) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorOutput)
}

func (i GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorArgs) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorArgs) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorOutput).ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutputWithContext(ctx)
}

// GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrInput is an input type that accepts GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorArgs, GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtr and GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrInput` via:
//
//	        GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorArgs{...}
//
//	or:
//
//	        nil
type GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput
	ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput
}

type grpcrouteSpecRulesBackendRefsFiltersRequestMirrorPtrType GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorArgs

func GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtr(v *GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorArgs) GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrInput {
	return (*grpcrouteSpecRulesBackendRefsFiltersRequestMirrorPtrType)(v)
}

func (*grpcrouteSpecRulesBackendRefsFiltersRequestMirrorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesBackendRefsFiltersRequestMirror)(nil)).Elem()
}

func (i *grpcrouteSpecRulesBackendRefsFiltersRequestMirrorPtrType) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutputWithContext(context.Background())
}

func (i *grpcrouteSpecRulesBackendRefsFiltersRequestMirrorPtrType) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput)
}

// RequestMirror defines a schema for a filter that mirrors requests.
// Requests are sent to the specified destination, but responses from
// that destination are ignored.
//
// This filter can be used multiple times within the same rule. Note that
// not all implementations will be able to support mirroring to multiple
// backends.
//
// Support: Extended
type GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersRequestMirror)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput {
	return o.ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutputWithContext(context.Background())
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GRPCRouteSpecRulesBackendRefsFiltersRequestMirror) *GRPCRouteSpecRulesBackendRefsFiltersRequestMirror {
		return &v
	}).(GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput)
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorOutput) BackendRef() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersRequestMirror) *GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef {
		return v.BackendRef
	}).(GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput)
}

type GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesBackendRefsFiltersRequestMirror)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput) Elem() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesBackendRefsFiltersRequestMirror) GRPCRouteSpecRulesBackendRefsFiltersRequestMirror {
		if v != nil {
			return *v
		}
		var ret GRPCRouteSpecRulesBackendRefsFiltersRequestMirror
		return ret
	}).(GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorOutput)
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput) BackendRef() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesBackendRefsFiltersRequestMirror) *GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef {
		if v == nil {
			return nil
		}
		return v.BackendRef
	}).(GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput)
}

// BackendRef references a resource where mirrored requests are sent.
//
// Mirrored requests must be sent only to a single destination endpoint
// within this BackendRef, irrespective of how many endpoints are present
// within this BackendRef.
//
// If the referent cannot be found, this BackendRef is invalid and must be
// dropped from the Gateway. The controller must ensure the "ResolvedRefs"
// condition on the Route status is set to `status: False` and not configure
// this backend in the underlying implementation.
//
// If there is a cross-namespace reference to an *existing* object
// that is not allowed by a ReferenceGrant, the controller must ensure the
// "ResolvedRefs"  condition on the Route is set to `status: False`,
// with the "RefNotPermitted" reason and not configure this backend in the
// underlying implementation.
//
// In either error case, the Message of the `ResolvedRefs` Condition
// should be used to provide more detail about the problem.
//
// Support: Extended for Kubernetes Service
//
// Support: Implementation-specific for any other resource
type GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group *string `pulumi:"group"`
	// Kind is the Kubernetes resource kind of the referent. For example
	// "Service".
	//
	// Defaults to "Service" when not specified.
	//
	// ExternalName services can refer to CNAME DNS records that may live
	// outside of the cluster and as such are difficult to reason about in
	// terms of conformance. They also may not be safe to forward to (see
	// CVE-2021-25740 for more information). Implementations SHOULD NOT
	// support ExternalName Services.
	//
	// Support: Core (Services with a type other than ExternalName)
	//
	// Support: Implementation-specific (Services with type ExternalName)
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	Name *string `pulumi:"name"`
	// Namespace is the namespace of the backend. When unspecified, the local
	// namespace is inferred.
	//
	// Note that when a namespace different than the local namespace is specified,
	// a ReferenceGrant object is required in the referent namespace to allow that
	// namespace's owner to accept the reference. See the ReferenceGrant
	// documentation for details.
	//
	// Support: Core
	Namespace *string `pulumi:"namespace"`
	// Port specifies the destination port number to use for this resource.
	// Port is required when the referent is a Kubernetes Service. In this
	// case, the port number is the service port number, not the target port.
	// For other resources, destination port might be derived from the referent
	// resource or this field.
	Port *int `pulumi:"port"`
}

// GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefInput is an input type that accepts GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs and GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefInput` via:
//
//	GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs{...}
type GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput
	ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput
}

// BackendRef references a resource where mirrored requests are sent.
//
// Mirrored requests must be sent only to a single destination endpoint
// within this BackendRef, irrespective of how many endpoints are present
// within this BackendRef.
//
// If the referent cannot be found, this BackendRef is invalid and must be
// dropped from the Gateway. The controller must ensure the "ResolvedRefs"
// condition on the Route status is set to `status: False` and not configure
// this backend in the underlying implementation.
//
// If there is a cross-namespace reference to an *existing* object
// that is not allowed by a ReferenceGrant, the controller must ensure the
// "ResolvedRefs"  condition on the Route is set to `status: False`,
// with the "RefNotPermitted" reason and not configure this backend in the
// underlying implementation.
//
// In either error case, the Message of the `ResolvedRefs` Condition
// should be used to provide more detail about the problem.
//
// Support: Extended for Kubernetes Service
//
// Support: Implementation-specific for any other resource
type GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is the Kubernetes resource kind of the referent. For example
	// "Service".
	//
	// Defaults to "Service" when not specified.
	//
	// ExternalName services can refer to CNAME DNS records that may live
	// outside of the cluster and as such are difficult to reason about in
	// terms of conformance. They also may not be safe to forward to (see
	// CVE-2021-25740 for more information). Implementations SHOULD NOT
	// support ExternalName Services.
	//
	// Support: Core (Services with a type other than ExternalName)
	//
	// Support: Implementation-specific (Services with type ExternalName)
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace is the namespace of the backend. When unspecified, the local
	// namespace is inferred.
	//
	// Note that when a namespace different than the local namespace is specified,
	// a ReferenceGrant object is required in the referent namespace to allow that
	// namespace's owner to accept the reference. See the ReferenceGrant
	// documentation for details.
	//
	// Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Port specifies the destination port number to use for this resource.
	// Port is required when the referent is a Kubernetes Service. In this
	// case, the port number is the service port number, not the target port.
	// For other resources, destination port might be derived from the referent
	// resource or this field.
	Port pulumi.IntPtrInput `pulumi:"port"`
}

func (GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef)(nil)).Elem()
}

func (i GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput)
}

func (i GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput).ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutputWithContext(ctx)
}

// GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrInput is an input type that accepts GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs, GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtr and GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrInput` via:
//
//	        GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs{...}
//
//	or:
//
//	        nil
type GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput
	ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput
}

type grpcrouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrType GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs

func GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtr(v *GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs) GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrInput {
	return (*grpcrouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrType)(v)
}

func (*grpcrouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef)(nil)).Elem()
}

func (i *grpcrouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrType) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutputWithContext(context.Background())
}

func (i *grpcrouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrType) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput)
}

// BackendRef references a resource where mirrored requests are sent.
//
// Mirrored requests must be sent only to a single destination endpoint
// within this BackendRef, irrespective of how many endpoints are present
// within this BackendRef.
//
// If the referent cannot be found, this BackendRef is invalid and must be
// dropped from the Gateway. The controller must ensure the "ResolvedRefs"
// condition on the Route status is set to `status: False` and not configure
// this backend in the underlying implementation.
//
// If there is a cross-namespace reference to an *existing* object
// that is not allowed by a ReferenceGrant, the controller must ensure the
// "ResolvedRefs"  condition on the Route is set to `status: False`,
// with the "RefNotPermitted" reason and not configure this backend in the
// underlying implementation.
//
// In either error case, the Message of the `ResolvedRefs` Condition
// should be used to provide more detail about the problem.
//
// Support: Extended for Kubernetes Service
//
// Support: Implementation-specific for any other resource
type GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput {
	return o.ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutputWithContext(context.Background())
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef) *GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef {
		return &v
	}).(GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is the Kubernetes resource kind of the referent. For example
// "Service".
//
// Defaults to "Service" when not specified.
//
// ExternalName services can refer to CNAME DNS records that may live
// outside of the cluster and as such are difficult to reason about in
// terms of conformance. They also may not be safe to forward to (see
// CVE-2021-25740 for more information). Implementations SHOULD NOT
// support ExternalName Services.
//
// Support: Core (Services with a type other than ExternalName)
//
// Support: Implementation-specific (Services with type ExternalName)
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the backend. When unspecified, the local
// namespace is inferred.
//
// Note that when a namespace different than the local namespace is specified,
// a ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// Support: Core
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Port specifies the destination port number to use for this resource.
// Port is required when the referent is a Kubernetes Service. In this
// case, the port number is the service port number, not the target port.
// For other resources, destination port might be derived from the referent
// resource or this field.
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef) *int { return v.Port }).(pulumi.IntPtrOutput)
}

type GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput) Elem() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef) GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef {
		if v != nil {
			return *v
		}
		var ret GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef
		return ret
	}).(GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef) *string {
		if v == nil {
			return nil
		}
		return v.Group
	}).(pulumi.StringPtrOutput)
}

// Kind is the Kubernetes resource kind of the referent. For example
// "Service".
//
// Defaults to "Service" when not specified.
//
// ExternalName services can refer to CNAME DNS records that may live
// outside of the cluster and as such are difficult to reason about in
// terms of conformance. They also may not be safe to forward to (see
// CVE-2021-25740 for more information). Implementations SHOULD NOT
// support ExternalName Services.
//
// Support: Core (Services with a type other than ExternalName)
//
// Support: Implementation-specific (Services with type ExternalName)
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef) *string {
		if v == nil {
			return nil
		}
		return v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the backend. When unspecified, the local
// namespace is inferred.
//
// Note that when a namespace different than the local namespace is specified,
// a ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// Support: Core
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

// Port specifies the destination port number to use for this resource.
// Port is required when the referent is a Kubernetes Service. In this
// case, the port number is the service port number, not the target port.
// For other resources, destination port might be derived from the referent
// resource or this field.
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef) *int {
		if v == nil {
			return nil
		}
		return v.Port
	}).(pulumi.IntPtrOutput)
}

// BackendRef references a resource where mirrored requests are sent.
//
// Mirrored requests must be sent only to a single destination endpoint
// within this BackendRef, irrespective of how many endpoints are present
// within this BackendRef.
//
// If the referent cannot be found, this BackendRef is invalid and must be
// dropped from the Gateway. The controller must ensure the "ResolvedRefs"
// condition on the Route status is set to `status: False` and not configure
// this backend in the underlying implementation.
//
// If there is a cross-namespace reference to an *existing* object
// that is not allowed by a ReferenceGrant, the controller must ensure the
// "ResolvedRefs"  condition on the Route is set to `status: False`,
// with the "RefNotPermitted" reason and not configure this backend in the
// underlying implementation.
//
// In either error case, the Message of the `ResolvedRefs` Condition
// should be used to provide more detail about the problem.
//
// Support: Extended for Kubernetes Service
//
// Support: Implementation-specific for any other resource
type GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatch struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group *string `pulumi:"group"`
	// Kind is the Kubernetes resource kind of the referent. For example
	// "Service".
	//
	// Defaults to "Service" when not specified.
	//
	// ExternalName services can refer to CNAME DNS records that may live
	// outside of the cluster and as such are difficult to reason about in
	// terms of conformance. They also may not be safe to forward to (see
	// CVE-2021-25740 for more information). Implementations SHOULD NOT
	// support ExternalName Services.
	//
	// Support: Core (Services with a type other than ExternalName)
	//
	// Support: Implementation-specific (Services with type ExternalName)
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	Name *string `pulumi:"name"`
	// Namespace is the namespace of the backend. When unspecified, the local
	// namespace is inferred.
	//
	// Note that when a namespace different than the local namespace is specified,
	// a ReferenceGrant object is required in the referent namespace to allow that
	// namespace's owner to accept the reference. See the ReferenceGrant
	// documentation for details.
	//
	// Support: Core
	Namespace *string `pulumi:"namespace"`
	// Port specifies the destination port number to use for this resource.
	// Port is required when the referent is a Kubernetes Service. In this
	// case, the port number is the service port number, not the target port.
	// For other resources, destination port might be derived from the referent
	// resource or this field.
	Port *int `pulumi:"port"`
}

// GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchInput is an input type that accepts GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchArgs and GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchInput` via:
//
//	GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchArgs{...}
type GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutput
	ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutput
}

// BackendRef references a resource where mirrored requests are sent.
//
// Mirrored requests must be sent only to a single destination endpoint
// within this BackendRef, irrespective of how many endpoints are present
// within this BackendRef.
//
// If the referent cannot be found, this BackendRef is invalid and must be
// dropped from the Gateway. The controller must ensure the "ResolvedRefs"
// condition on the Route status is set to `status: False` and not configure
// this backend in the underlying implementation.
//
// If there is a cross-namespace reference to an *existing* object
// that is not allowed by a ReferenceGrant, the controller must ensure the
// "ResolvedRefs"  condition on the Route is set to `status: False`,
// with the "RefNotPermitted" reason and not configure this backend in the
// underlying implementation.
//
// In either error case, the Message of the `ResolvedRefs` Condition
// should be used to provide more detail about the problem.
//
// Support: Extended for Kubernetes Service
//
// Support: Implementation-specific for any other resource
type GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchArgs struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is the Kubernetes resource kind of the referent. For example
	// "Service".
	//
	// Defaults to "Service" when not specified.
	//
	// ExternalName services can refer to CNAME DNS records that may live
	// outside of the cluster and as such are difficult to reason about in
	// terms of conformance. They also may not be safe to forward to (see
	// CVE-2021-25740 for more information). Implementations SHOULD NOT
	// support ExternalName Services.
	//
	// Support: Core (Services with a type other than ExternalName)
	//
	// Support: Implementation-specific (Services with type ExternalName)
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace is the namespace of the backend. When unspecified, the local
	// namespace is inferred.
	//
	// Note that when a namespace different than the local namespace is specified,
	// a ReferenceGrant object is required in the referent namespace to allow that
	// namespace's owner to accept the reference. See the ReferenceGrant
	// documentation for details.
	//
	// Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Port specifies the destination port number to use for this resource.
	// Port is required when the referent is a Kubernetes Service. In this
	// case, the port number is the service port number, not the target port.
	// For other resources, destination port might be derived from the referent
	// resource or this field.
	Port pulumi.IntPtrInput `pulumi:"port"`
}

func (GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatch)(nil)).Elem()
}

func (i GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchArgs) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchArgs) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutput)
}

func (i GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchArgs) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchArgs) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutput).ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutputWithContext(ctx)
}

// GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrInput is an input type that accepts GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchArgs, GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtr and GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrInput` via:
//
//	        GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchArgs{...}
//
//	or:
//
//	        nil
type GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput
	ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput
}

type grpcrouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrType GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchArgs

func GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtr(v *GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchArgs) GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrInput {
	return (*grpcrouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrType)(v)
}

func (*grpcrouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatch)(nil)).Elem()
}

func (i *grpcrouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrType) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutputWithContext(context.Background())
}

func (i *grpcrouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrType) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput)
}

// BackendRef references a resource where mirrored requests are sent.
//
// Mirrored requests must be sent only to a single destination endpoint
// within this BackendRef, irrespective of how many endpoints are present
// within this BackendRef.
//
// If the referent cannot be found, this BackendRef is invalid and must be
// dropped from the Gateway. The controller must ensure the "ResolvedRefs"
// condition on the Route status is set to `status: False` and not configure
// this backend in the underlying implementation.
//
// If there is a cross-namespace reference to an *existing* object
// that is not allowed by a ReferenceGrant, the controller must ensure the
// "ResolvedRefs"  condition on the Route is set to `status: False`,
// with the "RefNotPermitted" reason and not configure this backend in the
// underlying implementation.
//
// In either error case, the Message of the `ResolvedRefs` Condition
// should be used to provide more detail about the problem.
//
// Support: Extended for Kubernetes Service
//
// Support: Implementation-specific for any other resource
type GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatch)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput {
	return o.ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutputWithContext(context.Background())
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatch) *GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatch {
		return &v
	}).(GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatch) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is the Kubernetes resource kind of the referent. For example
// "Service".
//
// Defaults to "Service" when not specified.
//
// ExternalName services can refer to CNAME DNS records that may live
// outside of the cluster and as such are difficult to reason about in
// terms of conformance. They also may not be safe to forward to (see
// CVE-2021-25740 for more information). Implementations SHOULD NOT
// support ExternalName Services.
//
// Support: Core (Services with a type other than ExternalName)
//
// Support: Implementation-specific (Services with type ExternalName)
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatch) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the backend. When unspecified, the local
// namespace is inferred.
//
// Note that when a namespace different than the local namespace is specified,
// a ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// Support: Core
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatch) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Port specifies the destination port number to use for this resource.
// Port is required when the referent is a Kubernetes Service. In this
// case, the port number is the service port number, not the target port.
// For other resources, destination port might be derived from the referent
// resource or this field.
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatch) *int { return v.Port }).(pulumi.IntPtrOutput)
}

type GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatch)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput) Elem() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatch) GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatch {
		if v != nil {
			return *v
		}
		var ret GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatch
		return ret
	}).(GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Group
	}).(pulumi.StringPtrOutput)
}

// Kind is the Kubernetes resource kind of the referent. For example
// "Service".
//
// Defaults to "Service" when not specified.
//
// ExternalName services can refer to CNAME DNS records that may live
// outside of the cluster and as such are difficult to reason about in
// terms of conformance. They also may not be safe to forward to (see
// CVE-2021-25740 for more information). Implementations SHOULD NOT
// support ExternalName Services.
//
// Support: Core (Services with a type other than ExternalName)
//
// Support: Implementation-specific (Services with type ExternalName)
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the backend. When unspecified, the local
// namespace is inferred.
//
// Note that when a namespace different than the local namespace is specified,
// a ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// Support: Core
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

// Port specifies the destination port number to use for this resource.
// Port is required when the referent is a Kubernetes Service. In this
// case, the port number is the service port number, not the target port.
// For other resources, destination port might be derived from the referent
// resource or this field.
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatch) *int {
		if v == nil {
			return nil
		}
		return v.Port
	}).(pulumi.IntPtrOutput)
}

// RequestMirror defines a schema for a filter that mirrors requests.
// Requests are sent to the specified destination, but responses from
// that destination are ignored.
//
// This filter can be used multiple times within the same rule. Note that
// not all implementations will be able to support mirroring to multiple
// backends.
//
// Support: Extended
type GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatch struct {
	BackendRef *GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatch `pulumi:"backendRef"`
}

// GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchInput is an input type that accepts GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchArgs and GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchInput` via:
//
//	GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchArgs{...}
type GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchOutput
	ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchOutput
}

// RequestMirror defines a schema for a filter that mirrors requests.
// Requests are sent to the specified destination, but responses from
// that destination are ignored.
//
// This filter can be used multiple times within the same rule. Note that
// not all implementations will be able to support mirroring to multiple
// backends.
//
// Support: Extended
type GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchArgs struct {
	BackendRef GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrInput `pulumi:"backendRef"`
}

func (GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatch)(nil)).Elem()
}

func (i GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchArgs) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchArgs) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchOutput)
}

func (i GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchArgs) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchArgs) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchOutput).ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutputWithContext(ctx)
}

// GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrInput is an input type that accepts GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchArgs, GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtr and GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrInput` via:
//
//	        GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchArgs{...}
//
//	or:
//
//	        nil
type GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput
	ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput
}

type grpcrouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrType GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchArgs

func GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtr(v *GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchArgs) GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrInput {
	return (*grpcrouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrType)(v)
}

func (*grpcrouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatch)(nil)).Elem()
}

func (i *grpcrouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrType) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutputWithContext(context.Background())
}

func (i *grpcrouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrType) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput)
}

// RequestMirror defines a schema for a filter that mirrors requests.
// Requests are sent to the specified destination, but responses from
// that destination are ignored.
//
// This filter can be used multiple times within the same rule. Note that
// not all implementations will be able to support mirroring to multiple
// backends.
//
// Support: Extended
type GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatch)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput {
	return o.ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutputWithContext(context.Background())
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatch) *GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatch {
		return &v
	}).(GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput)
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchOutput) BackendRef() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatch) *GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatch {
		return v.BackendRef
	}).(GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput)
}

type GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatch)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput) Elem() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatch) GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatch {
		if v != nil {
			return *v
		}
		var ret GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatch
		return ret
	}).(GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchOutput)
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput) BackendRef() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatch) *GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatch {
		if v == nil {
			return nil
		}
		return v.BackendRef
	}).(GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput)
}

// ResponseHeaderModifier defines a schema for a filter that modifies response
// headers.
//
// Support: Extended
type GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifier struct {
	// Add adds the given header(s) (name, value) to the request
	// before the action. It appends to any existing values associated
	// with the header name.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   add:
	//   - name: "my-header"
	//     value: "bar,baz"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: foo,bar,baz
	Add []GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd `pulumi:"add"`
	// Remove the given header(s) from the HTTP request before the action. The
	// value of Remove is a list of HTTP header names. Note that the header
	// names are case-insensitive (see
	// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header1: foo
	//   my-header2: bar
	//   my-header3: baz
	//
	// Config:
	//   remove: ["my-header1", "my-header3"]
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header2: bar
	Remove []string `pulumi:"remove"`
	// Set overwrites the request with the given header (name, value)
	// before the action.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   set:
	//   - name: "my-header"
	//     value: "bar"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: bar
	Set []GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet `pulumi:"set"`
}

// GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierInput is an input type that accepts GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs and GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierInput` via:
//
//	GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs{...}
type GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput
	ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput
}

// ResponseHeaderModifier defines a schema for a filter that modifies response
// headers.
//
// Support: Extended
type GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs struct {
	// Add adds the given header(s) (name, value) to the request
	// before the action. It appends to any existing values associated
	// with the header name.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   add:
	//   - name: "my-header"
	//     value: "bar,baz"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: foo,bar,baz
	Add GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayInput `pulumi:"add"`
	// Remove the given header(s) from the HTTP request before the action. The
	// value of Remove is a list of HTTP header names. Note that the header
	// names are case-insensitive (see
	// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header1: foo
	//   my-header2: bar
	//   my-header3: baz
	//
	// Config:
	//   remove: ["my-header1", "my-header3"]
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header2: bar
	Remove pulumi.StringArrayInput `pulumi:"remove"`
	// Set overwrites the request with the given header (name, value)
	// before the action.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   set:
	//   - name: "my-header"
	//     value: "bar"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: bar
	Set GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayInput `pulumi:"set"`
}

func (GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifier)(nil)).Elem()
}

func (i GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput)
}

func (i GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput).ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutputWithContext(ctx)
}

// GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrInput is an input type that accepts GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs, GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtr and GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrInput` via:
//
//	        GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs{...}
//
//	or:
//
//	        nil
type GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput
	ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput
}

type grpcrouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrType GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs

func GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtr(v *GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrInput {
	return (*grpcrouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrType)(v)
}

func (*grpcrouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifier)(nil)).Elem()
}

func (i *grpcrouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrType) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutputWithContext(context.Background())
}

func (i *grpcrouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrType) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput)
}

// ResponseHeaderModifier defines a schema for a filter that modifies response
// headers.
//
// Support: Extended
type GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifier)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput {
	return o.ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutputWithContext(context.Background())
}

func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifier) *GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifier {
		return &v
	}).(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput)
}

// Add adds the given header(s) (name, value) to the request
// before the action. It appends to any existing values associated
// with the header name.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	add:
//	- name: "my-header"
//	  value: "bar,baz"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: foo,bar,baz
func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput) Add() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifier) []GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd {
		return v.Add
	}).(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput)
}

// Remove the given header(s) from the HTTP request before the action. The
// value of Remove is a list of HTTP header names. Note that the header
// names are case-insensitive (see
// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header1: foo
//	my-header2: bar
//	my-header3: baz
//
// Config:
//
//	remove: ["my-header1", "my-header3"]
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header2: bar
func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput) Remove() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifier) []string { return v.Remove }).(pulumi.StringArrayOutput)
}

// Set overwrites the request with the given header (name, value)
// before the action.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	set:
//	- name: "my-header"
//	  value: "bar"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: bar
func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput) Set() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifier) []GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet {
		return v.Set
	}).(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput)
}

type GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifier)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput) Elem() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifier) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifier {
		if v != nil {
			return *v
		}
		var ret GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifier
		return ret
	}).(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput)
}

// Add adds the given header(s) (name, value) to the request
// before the action. It appends to any existing values associated
// with the header name.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	add:
//	- name: "my-header"
//	  value: "bar,baz"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: foo,bar,baz
func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput) Add() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifier) []GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd {
		if v == nil {
			return nil
		}
		return v.Add
	}).(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput)
}

// Remove the given header(s) from the HTTP request before the action. The
// value of Remove is a list of HTTP header names. Note that the header
// names are case-insensitive (see
// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header1: foo
//	my-header2: bar
//	my-header3: baz
//
// Config:
//
//	remove: ["my-header1", "my-header3"]
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header2: bar
func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput) Remove() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifier) []string {
		if v == nil {
			return nil
		}
		return v.Remove
	}).(pulumi.StringArrayOutput)
}

// Set overwrites the request with the given header (name, value)
// before the action.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	set:
//	- name: "my-header"
//	  value: "bar"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: bar
func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput) Set() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifier) []GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet {
		if v == nil {
			return nil
		}
		return v.Set
	}).(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name *string `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value *string `pulumi:"value"`
}

// GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddInput is an input type that accepts GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArgs and GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddInput` via:
//
//	GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArgs{...}
type GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput
	ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArgs struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd)(nil)).Elem()
}

func (i GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArgs) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArgs) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput)
}

// GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayInput is an input type that accepts GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArray and GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayInput` via:
//
//	GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArray{ GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArgs{...} }
type GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput
	ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput
}

type GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArray []GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddInput

func (GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd)(nil)).Elem()
}

func (i GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArray) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArray) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput {
	return o
}

// Name is the name of the HTTP Header to be matched. Name matching MUST be
// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
//
// If multiple entries specify equivalent header names, the first entry with
// an equivalent name MUST be considered for a match. Subsequent entries
// with an equivalent header name MUST be ignored. Due to the
// case-insensitivity of header names, "foo" and "Foo" are considered
// equivalent.
func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Value is the value of HTTP Header to be matched.
func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput) Index(i pulumi.IntInput) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd {
		return vs[0].([]GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd)[vs[1].(int)]
	}).(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatch struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name *string `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value *string `pulumi:"value"`
}

// GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchInput is an input type that accepts GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArgs and GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchInput` via:
//
//	GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArgs{...}
type GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchOutput() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchOutput
	ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchOutput
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArgs struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatch)(nil)).Elem()
}

func (i GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArgs) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchOutput() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArgs) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchOutput)
}

// GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayInput is an input type that accepts GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArray and GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayInput` via:
//
//	GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArray{ GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArgs{...} }
type GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayOutput() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayOutput
	ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayOutput
}

type GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArray []GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchInput

func (GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatch)(nil)).Elem()
}

func (i GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArray) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayOutput() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArray) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatch)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchOutput) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchOutput() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchOutput) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchOutput {
	return o
}

// Name is the name of the HTTP Header to be matched. Name matching MUST be
// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
//
// If multiple entries specify equivalent header names, the first entry with
// an equivalent name MUST be considered for a match. Subsequent entries
// with an equivalent header name MUST be ignored. Due to the
// case-insensitivity of header names, "foo" and "Foo" are considered
// equivalent.
func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Value is the value of HTTP Header to be matched.
func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatch) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatch)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayOutput) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayOutput() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayOutput) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayOutput) Index(i pulumi.IntInput) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatch {
		return vs[0].([]GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatch)[vs[1].(int)]
	}).(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchOutput)
}

// ResponseHeaderModifier defines a schema for a filter that modifies response
// headers.
//
// Support: Extended
type GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatch struct {
	// Add adds the given header(s) (name, value) to the request
	// before the action. It appends to any existing values associated
	// with the header name.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   add:
	//   - name: "my-header"
	//     value: "bar,baz"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: foo,bar,baz
	Add []GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatch `pulumi:"add"`
	// Remove the given header(s) from the HTTP request before the action. The
	// value of Remove is a list of HTTP header names. Note that the header
	// names are case-insensitive (see
	// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header1: foo
	//   my-header2: bar
	//   my-header3: baz
	//
	// Config:
	//   remove: ["my-header1", "my-header3"]
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header2: bar
	Remove []string `pulumi:"remove"`
	// Set overwrites the request with the given header (name, value)
	// before the action.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   set:
	//   - name: "my-header"
	//     value: "bar"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: bar
	Set []GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatch `pulumi:"set"`
}

// GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchInput is an input type that accepts GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchArgs and GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchInput` via:
//
//	GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchArgs{...}
type GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutput() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutput
	ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutput
}

// ResponseHeaderModifier defines a schema for a filter that modifies response
// headers.
//
// Support: Extended
type GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchArgs struct {
	// Add adds the given header(s) (name, value) to the request
	// before the action. It appends to any existing values associated
	// with the header name.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   add:
	//   - name: "my-header"
	//     value: "bar,baz"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: foo,bar,baz
	Add GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayInput `pulumi:"add"`
	// Remove the given header(s) from the HTTP request before the action. The
	// value of Remove is a list of HTTP header names. Note that the header
	// names are case-insensitive (see
	// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header1: foo
	//   my-header2: bar
	//   my-header3: baz
	//
	// Config:
	//   remove: ["my-header1", "my-header3"]
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header2: bar
	Remove pulumi.StringArrayInput `pulumi:"remove"`
	// Set overwrites the request with the given header (name, value)
	// before the action.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   set:
	//   - name: "my-header"
	//     value: "bar"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: bar
	Set GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayInput `pulumi:"set"`
}

func (GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatch)(nil)).Elem()
}

func (i GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchArgs) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutput() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchArgs) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutput)
}

func (i GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchArgs) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchArgs) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutput).ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutputWithContext(ctx)
}

// GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrInput is an input type that accepts GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchArgs, GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtr and GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrInput` via:
//
//	        GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchArgs{...}
//
//	or:
//
//	        nil
type GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput
	ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput
}

type grpcrouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrType GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchArgs

func GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtr(v *GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchArgs) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrInput {
	return (*grpcrouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrType)(v)
}

func (*grpcrouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatch)(nil)).Elem()
}

func (i *grpcrouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrType) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutputWithContext(context.Background())
}

func (i *grpcrouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrType) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput)
}

// ResponseHeaderModifier defines a schema for a filter that modifies response
// headers.
//
// Support: Extended
type GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatch)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutput) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutput() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutput) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutput) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput {
	return o.ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutputWithContext(context.Background())
}

func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutput) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatch) *GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatch {
		return &v
	}).(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput)
}

// Add adds the given header(s) (name, value) to the request
// before the action. It appends to any existing values associated
// with the header name.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	add:
//	- name: "my-header"
//	  value: "bar,baz"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: foo,bar,baz
func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutput) Add() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatch) []GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatch {
		return v.Add
	}).(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayOutput)
}

// Remove the given header(s) from the HTTP request before the action. The
// value of Remove is a list of HTTP header names. Note that the header
// names are case-insensitive (see
// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header1: foo
//	my-header2: bar
//	my-header3: baz
//
// Config:
//
//	remove: ["my-header1", "my-header3"]
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header2: bar
func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutput) Remove() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatch) []string { return v.Remove }).(pulumi.StringArrayOutput)
}

// Set overwrites the request with the given header (name, value)
// before the action.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	set:
//	- name: "my-header"
//	  value: "bar"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: bar
func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutput) Set() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatch) []GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatch {
		return v.Set
	}).(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayOutput)
}

type GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatch)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput) Elem() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatch) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatch {
		if v != nil {
			return *v
		}
		var ret GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatch
		return ret
	}).(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutput)
}

// Add adds the given header(s) (name, value) to the request
// before the action. It appends to any existing values associated
// with the header name.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	add:
//	- name: "my-header"
//	  value: "bar,baz"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: foo,bar,baz
func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput) Add() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatch) []GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatch {
		if v == nil {
			return nil
		}
		return v.Add
	}).(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayOutput)
}

// Remove the given header(s) from the HTTP request before the action. The
// value of Remove is a list of HTTP header names. Note that the header
// names are case-insensitive (see
// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header1: foo
//	my-header2: bar
//	my-header3: baz
//
// Config:
//
//	remove: ["my-header1", "my-header3"]
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header2: bar
func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput) Remove() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatch) []string {
		if v == nil {
			return nil
		}
		return v.Remove
	}).(pulumi.StringArrayOutput)
}

// Set overwrites the request with the given header (name, value)
// before the action.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	set:
//	- name: "my-header"
//	  value: "bar"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: bar
func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput) Set() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatch) []GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatch {
		if v == nil {
			return nil
		}
		return v.Set
	}).(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name *string `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value *string `pulumi:"value"`
}

// GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetInput is an input type that accepts GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArgs and GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetInput` via:
//
//	GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArgs{...}
type GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput
	ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArgs struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet)(nil)).Elem()
}

func (i GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArgs) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArgs) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput)
}

// GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayInput is an input type that accepts GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArray and GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayInput` via:
//
//	GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArray{ GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArgs{...} }
type GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput
	ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput
}

type GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArray []GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetInput

func (GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet)(nil)).Elem()
}

func (i GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArray) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArray) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput {
	return o
}

// Name is the name of the HTTP Header to be matched. Name matching MUST be
// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
//
// If multiple entries specify equivalent header names, the first entry with
// an equivalent name MUST be considered for a match. Subsequent entries
// with an equivalent header name MUST be ignored. Due to the
// case-insensitivity of header names, "foo" and "Foo" are considered
// equivalent.
func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Value is the value of HTTP Header to be matched.
func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput) Index(i pulumi.IntInput) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet {
		return vs[0].([]GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet)[vs[1].(int)]
	}).(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatch struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name *string `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value *string `pulumi:"value"`
}

// GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchInput is an input type that accepts GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArgs and GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchInput` via:
//
//	GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArgs{...}
type GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchOutput() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchOutput
	ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchOutput
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArgs struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatch)(nil)).Elem()
}

func (i GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArgs) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchOutput() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArgs) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchOutput)
}

// GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayInput is an input type that accepts GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArray and GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayInput` via:
//
//	GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArray{ GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArgs{...} }
type GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayOutput() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayOutput
	ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayOutput
}

type GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArray []GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchInput

func (GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatch)(nil)).Elem()
}

func (i GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArray) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayOutput() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArray) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatch)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchOutput) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchOutput() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchOutput) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchOutput {
	return o
}

// Name is the name of the HTTP Header to be matched. Name matching MUST be
// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
//
// If multiple entries specify equivalent header names, the first entry with
// an equivalent name MUST be considered for a match. Subsequent entries
// with an equivalent header name MUST be ignored. Due to the
// case-insensitivity of header names, "foo" and "Foo" are considered
// equivalent.
func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Value is the value of HTTP Header to be matched.
func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatch) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatch)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayOutput) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayOutput() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayOutput) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayOutput) Index(i pulumi.IntInput) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatch {
		return vs[0].([]GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatch)[vs[1].(int)]
	}).(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchOutput)
}

// GRPCBackendRef defines how a GRPCRoute forwards a gRPC request.
//
// Note that when a namespace different than the local namespace is specified, a
// ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// <gateway:experimental:description>
//
// When the BackendRef points to a Kubernetes Service, implementations SHOULD
// honor the appProtocol field if it is set for the target Service Port.
//
// Implementations supporting appProtocol SHOULD recognize the Kubernetes
// Standard Application Protocols defined in KEP-3726.
//
// If a Service appProtocol isn't specified, an implementation MAY infer the
// backend protocol through its own means. Implementations MAY infer the
// protocol from the Route type referring to the backend Service.
//
// If a Route is not able to send traffic to the backend using the specified
// protocol then the backend is considered invalid. Implementations MUST set the
// "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.
//
// </gateway:experimental:description>
type GRPCRouteSpecRulesBackendRefsPatch struct {
	// Filters defined at this level MUST be executed if and only if the
	// request is being forwarded to the backend defined here.
	//
	// Support: Implementation-specific (For broader support of filters, use the
	// Filters field in GRPCRouteRule.)
	Filters []GRPCRouteSpecRulesBackendRefsFiltersPatch `pulumi:"filters"`
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group *string `pulumi:"group"`
	// Kind is the Kubernetes resource kind of the referent. For example
	// "Service".
	//
	// Defaults to "Service" when not specified.
	//
	// ExternalName services can refer to CNAME DNS records that may live
	// outside of the cluster and as such are difficult to reason about in
	// terms of conformance. They also may not be safe to forward to (see
	// CVE-2021-25740 for more information). Implementations SHOULD NOT
	// support ExternalName Services.
	//
	// Support: Core (Services with a type other than ExternalName)
	//
	// Support: Implementation-specific (Services with type ExternalName)
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	Name *string `pulumi:"name"`
	// Namespace is the namespace of the backend. When unspecified, the local
	// namespace is inferred.
	//
	// Note that when a namespace different than the local namespace is specified,
	// a ReferenceGrant object is required in the referent namespace to allow that
	// namespace's owner to accept the reference. See the ReferenceGrant
	// documentation for details.
	//
	// Support: Core
	Namespace *string `pulumi:"namespace"`
	// Port specifies the destination port number to use for this resource.
	// Port is required when the referent is a Kubernetes Service. In this
	// case, the port number is the service port number, not the target port.
	// For other resources, destination port might be derived from the referent
	// resource or this field.
	Port *int `pulumi:"port"`
	// Weight specifies the proportion of requests forwarded to the referenced
	// backend. This is computed as weight/(sum of all weights in this
	// BackendRefs list). For non-zero values, there may be some epsilon from
	// the exact proportion defined here depending on the precision an
	// implementation supports. Weight is not a percentage and the sum of
	// weights does not need to equal 100.
	//
	// If only one backend is specified and it has a weight greater than 0, 100%
	// of the traffic is forwarded to that backend. If weight is set to 0, no
	// traffic should be forwarded for this entry. If unspecified, weight
	// defaults to 1.
	//
	// Support for this field varies based on the context where used.
	Weight *int `pulumi:"weight"`
}

// GRPCRouteSpecRulesBackendRefsPatchInput is an input type that accepts GRPCRouteSpecRulesBackendRefsPatchArgs and GRPCRouteSpecRulesBackendRefsPatchOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsPatchInput` via:
//
//	GRPCRouteSpecRulesBackendRefsPatchArgs{...}
type GRPCRouteSpecRulesBackendRefsPatchInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsPatchOutput() GRPCRouteSpecRulesBackendRefsPatchOutput
	ToGRPCRouteSpecRulesBackendRefsPatchOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsPatchOutput
}

// GRPCBackendRef defines how a GRPCRoute forwards a gRPC request.
//
// Note that when a namespace different than the local namespace is specified, a
// ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// <gateway:experimental:description>
//
// When the BackendRef points to a Kubernetes Service, implementations SHOULD
// honor the appProtocol field if it is set for the target Service Port.
//
// Implementations supporting appProtocol SHOULD recognize the Kubernetes
// Standard Application Protocols defined in KEP-3726.
//
// If a Service appProtocol isn't specified, an implementation MAY infer the
// backend protocol through its own means. Implementations MAY infer the
// protocol from the Route type referring to the backend Service.
//
// If a Route is not able to send traffic to the backend using the specified
// protocol then the backend is considered invalid. Implementations MUST set the
// "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.
//
// </gateway:experimental:description>
type GRPCRouteSpecRulesBackendRefsPatchArgs struct {
	// Filters defined at this level MUST be executed if and only if the
	// request is being forwarded to the backend defined here.
	//
	// Support: Implementation-specific (For broader support of filters, use the
	// Filters field in GRPCRouteRule.)
	Filters GRPCRouteSpecRulesBackendRefsFiltersPatchArrayInput `pulumi:"filters"`
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is the Kubernetes resource kind of the referent. For example
	// "Service".
	//
	// Defaults to "Service" when not specified.
	//
	// ExternalName services can refer to CNAME DNS records that may live
	// outside of the cluster and as such are difficult to reason about in
	// terms of conformance. They also may not be safe to forward to (see
	// CVE-2021-25740 for more information). Implementations SHOULD NOT
	// support ExternalName Services.
	//
	// Support: Core (Services with a type other than ExternalName)
	//
	// Support: Implementation-specific (Services with type ExternalName)
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace is the namespace of the backend. When unspecified, the local
	// namespace is inferred.
	//
	// Note that when a namespace different than the local namespace is specified,
	// a ReferenceGrant object is required in the referent namespace to allow that
	// namespace's owner to accept the reference. See the ReferenceGrant
	// documentation for details.
	//
	// Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Port specifies the destination port number to use for this resource.
	// Port is required when the referent is a Kubernetes Service. In this
	// case, the port number is the service port number, not the target port.
	// For other resources, destination port might be derived from the referent
	// resource or this field.
	Port pulumi.IntPtrInput `pulumi:"port"`
	// Weight specifies the proportion of requests forwarded to the referenced
	// backend. This is computed as weight/(sum of all weights in this
	// BackendRefs list). For non-zero values, there may be some epsilon from
	// the exact proportion defined here depending on the precision an
	// implementation supports. Weight is not a percentage and the sum of
	// weights does not need to equal 100.
	//
	// If only one backend is specified and it has a weight greater than 0, 100%
	// of the traffic is forwarded to that backend. If weight is set to 0, no
	// traffic should be forwarded for this entry. If unspecified, weight
	// defaults to 1.
	//
	// Support for this field varies based on the context where used.
	Weight pulumi.IntPtrInput `pulumi:"weight"`
}

func (GRPCRouteSpecRulesBackendRefsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsPatch)(nil)).Elem()
}

func (i GRPCRouteSpecRulesBackendRefsPatchArgs) ToGRPCRouteSpecRulesBackendRefsPatchOutput() GRPCRouteSpecRulesBackendRefsPatchOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsPatchOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsPatchArgs) ToGRPCRouteSpecRulesBackendRefsPatchOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsPatchOutput)
}

// GRPCRouteSpecRulesBackendRefsPatchArrayInput is an input type that accepts GRPCRouteSpecRulesBackendRefsPatchArray and GRPCRouteSpecRulesBackendRefsPatchArrayOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsPatchArrayInput` via:
//
//	GRPCRouteSpecRulesBackendRefsPatchArray{ GRPCRouteSpecRulesBackendRefsPatchArgs{...} }
type GRPCRouteSpecRulesBackendRefsPatchArrayInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsPatchArrayOutput() GRPCRouteSpecRulesBackendRefsPatchArrayOutput
	ToGRPCRouteSpecRulesBackendRefsPatchArrayOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsPatchArrayOutput
}

type GRPCRouteSpecRulesBackendRefsPatchArray []GRPCRouteSpecRulesBackendRefsPatchInput

func (GRPCRouteSpecRulesBackendRefsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesBackendRefsPatch)(nil)).Elem()
}

func (i GRPCRouteSpecRulesBackendRefsPatchArray) ToGRPCRouteSpecRulesBackendRefsPatchArrayOutput() GRPCRouteSpecRulesBackendRefsPatchArrayOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsPatchArrayOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsPatchArray) ToGRPCRouteSpecRulesBackendRefsPatchArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsPatchArrayOutput)
}

// GRPCBackendRef defines how a GRPCRoute forwards a gRPC request.
//
// Note that when a namespace different than the local namespace is specified, a
// ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// <gateway:experimental:description>
//
// When the BackendRef points to a Kubernetes Service, implementations SHOULD
// honor the appProtocol field if it is set for the target Service Port.
//
// Implementations supporting appProtocol SHOULD recognize the Kubernetes
// Standard Application Protocols defined in KEP-3726.
//
// If a Service appProtocol isn't specified, an implementation MAY infer the
// backend protocol through its own means. Implementations MAY infer the
// protocol from the Route type referring to the backend Service.
//
// If a Route is not able to send traffic to the backend using the specified
// protocol then the backend is considered invalid. Implementations MUST set the
// "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.
//
// </gateway:experimental:description>
type GRPCRouteSpecRulesBackendRefsPatchOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsPatch)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsPatchOutput) ToGRPCRouteSpecRulesBackendRefsPatchOutput() GRPCRouteSpecRulesBackendRefsPatchOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsPatchOutput) ToGRPCRouteSpecRulesBackendRefsPatchOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsPatchOutput {
	return o
}

// Filters defined at this level MUST be executed if and only if the
// request is being forwarded to the backend defined here.
//
// Support: Implementation-specific (For broader support of filters, use the
// Filters field in GRPCRouteRule.)
func (o GRPCRouteSpecRulesBackendRefsPatchOutput) Filters() GRPCRouteSpecRulesBackendRefsFiltersPatchArrayOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsPatch) []GRPCRouteSpecRulesBackendRefsFiltersPatch {
		return v.Filters
	}).(GRPCRouteSpecRulesBackendRefsFiltersPatchArrayOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o GRPCRouteSpecRulesBackendRefsPatchOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsPatch) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is the Kubernetes resource kind of the referent. For example
// "Service".
//
// Defaults to "Service" when not specified.
//
// ExternalName services can refer to CNAME DNS records that may live
// outside of the cluster and as such are difficult to reason about in
// terms of conformance. They also may not be safe to forward to (see
// CVE-2021-25740 for more information). Implementations SHOULD NOT
// support ExternalName Services.
//
// Support: Core (Services with a type other than ExternalName)
//
// Support: Implementation-specific (Services with type ExternalName)
func (o GRPCRouteSpecRulesBackendRefsPatchOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsPatch) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o GRPCRouteSpecRulesBackendRefsPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the backend. When unspecified, the local
// namespace is inferred.
//
// Note that when a namespace different than the local namespace is specified,
// a ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// Support: Core
func (o GRPCRouteSpecRulesBackendRefsPatchOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsPatch) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Port specifies the destination port number to use for this resource.
// Port is required when the referent is a Kubernetes Service. In this
// case, the port number is the service port number, not the target port.
// For other resources, destination port might be derived from the referent
// resource or this field.
func (o GRPCRouteSpecRulesBackendRefsPatchOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsPatch) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// Weight specifies the proportion of requests forwarded to the referenced
// backend. This is computed as weight/(sum of all weights in this
// BackendRefs list). For non-zero values, there may be some epsilon from
// the exact proportion defined here depending on the precision an
// implementation supports. Weight is not a percentage and the sum of
// weights does not need to equal 100.
//
// If only one backend is specified and it has a weight greater than 0, 100%
// of the traffic is forwarded to that backend. If weight is set to 0, no
// traffic should be forwarded for this entry. If unspecified, weight
// defaults to 1.
//
// Support for this field varies based on the context where used.
func (o GRPCRouteSpecRulesBackendRefsPatchOutput) Weight() pulumi.IntPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsPatch) *int { return v.Weight }).(pulumi.IntPtrOutput)
}

type GRPCRouteSpecRulesBackendRefsPatchArrayOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesBackendRefsPatch)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsPatchArrayOutput) ToGRPCRouteSpecRulesBackendRefsPatchArrayOutput() GRPCRouteSpecRulesBackendRefsPatchArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsPatchArrayOutput) ToGRPCRouteSpecRulesBackendRefsPatchArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsPatchArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsPatchArrayOutput) Index(i pulumi.IntInput) GRPCRouteSpecRulesBackendRefsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GRPCRouteSpecRulesBackendRefsPatch {
		return vs[0].([]GRPCRouteSpecRulesBackendRefsPatch)[vs[1].(int)]
	}).(GRPCRouteSpecRulesBackendRefsPatchOutput)
}

// GRPCRouteFilter defines processing steps that must be completed during the
// request or response lifecycle. GRPCRouteFilters are meant as an extension
// point to express processing that may be done in Gateway implementations. Some
// examples include request or response modification, implementing
// authentication strategies, rate-limiting, and traffic shaping. API
// guarantee/conformance is defined based on the type of the filter.
type GRPCRouteSpecRulesFilters struct {
	ExtensionRef           *GRPCRouteSpecRulesFiltersExtensionRef           `pulumi:"extensionRef"`
	RequestHeaderModifier  *GRPCRouteSpecRulesFiltersRequestHeaderModifier  `pulumi:"requestHeaderModifier"`
	RequestMirror          *GRPCRouteSpecRulesFiltersRequestMirror          `pulumi:"requestMirror"`
	ResponseHeaderModifier *GRPCRouteSpecRulesFiltersResponseHeaderModifier `pulumi:"responseHeaderModifier"`
	// Type identifies the type of filter to apply. As with other API fields,
	// types are classified into three conformance levels:
	//
	// - Core: Filter types and their corresponding configuration defined by
	// "Support: Core" in this package, e.g. "RequestHeaderModifier". All
	// implementations supporting GRPCRoute MUST support core filters.
	//
	// - Extended: Filter types and their corresponding configuration defined by
	// "Support: Extended" in this package, e.g. "RequestMirror". Implementers
	// are encouraged to support extended filters.
	//
	// - Implementation-specific: Filters that are defined and supported by specific vendors.
	// In the future, filters showing convergence in behavior across multiple
	// implementations will be considered for inclusion in extended or core
	// conformance levels. Filter-specific configuration for such filters
	// is specified using the ExtensionRef field. `Type` MUST be set to
	// "ExtensionRef" for custom filters.
	//
	// Implementers are encouraged to define custom implementation types to
	// extend the core API with implementation-specific behavior.
	//
	// If a reference to a custom filter type cannot be resolved, the filter
	// MUST NOT be skipped. Instead, requests that would have been processed by
	// that filter MUST receive a HTTP error response.
	Type *string `pulumi:"type"`
}

// GRPCRouteSpecRulesFiltersInput is an input type that accepts GRPCRouteSpecRulesFiltersArgs and GRPCRouteSpecRulesFiltersOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesFiltersInput` via:
//
//	GRPCRouteSpecRulesFiltersArgs{...}
type GRPCRouteSpecRulesFiltersInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesFiltersOutput() GRPCRouteSpecRulesFiltersOutput
	ToGRPCRouteSpecRulesFiltersOutputWithContext(context.Context) GRPCRouteSpecRulesFiltersOutput
}

// GRPCRouteFilter defines processing steps that must be completed during the
// request or response lifecycle. GRPCRouteFilters are meant as an extension
// point to express processing that may be done in Gateway implementations. Some
// examples include request or response modification, implementing
// authentication strategies, rate-limiting, and traffic shaping. API
// guarantee/conformance is defined based on the type of the filter.
type GRPCRouteSpecRulesFiltersArgs struct {
	ExtensionRef           GRPCRouteSpecRulesFiltersExtensionRefPtrInput           `pulumi:"extensionRef"`
	RequestHeaderModifier  GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrInput  `pulumi:"requestHeaderModifier"`
	RequestMirror          GRPCRouteSpecRulesFiltersRequestMirrorPtrInput          `pulumi:"requestMirror"`
	ResponseHeaderModifier GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrInput `pulumi:"responseHeaderModifier"`
	// Type identifies the type of filter to apply. As with other API fields,
	// types are classified into three conformance levels:
	//
	// - Core: Filter types and their corresponding configuration defined by
	// "Support: Core" in this package, e.g. "RequestHeaderModifier". All
	// implementations supporting GRPCRoute MUST support core filters.
	//
	// - Extended: Filter types and their corresponding configuration defined by
	// "Support: Extended" in this package, e.g. "RequestMirror". Implementers
	// are encouraged to support extended filters.
	//
	// - Implementation-specific: Filters that are defined and supported by specific vendors.
	// In the future, filters showing convergence in behavior across multiple
	// implementations will be considered for inclusion in extended or core
	// conformance levels. Filter-specific configuration for such filters
	// is specified using the ExtensionRef field. `Type` MUST be set to
	// "ExtensionRef" for custom filters.
	//
	// Implementers are encouraged to define custom implementation types to
	// extend the core API with implementation-specific behavior.
	//
	// If a reference to a custom filter type cannot be resolved, the filter
	// MUST NOT be skipped. Instead, requests that would have been processed by
	// that filter MUST receive a HTTP error response.
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (GRPCRouteSpecRulesFiltersArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesFilters)(nil)).Elem()
}

func (i GRPCRouteSpecRulesFiltersArgs) ToGRPCRouteSpecRulesFiltersOutput() GRPCRouteSpecRulesFiltersOutput {
	return i.ToGRPCRouteSpecRulesFiltersOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesFiltersArgs) ToGRPCRouteSpecRulesFiltersOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersOutput)
}

// GRPCRouteSpecRulesFiltersArrayInput is an input type that accepts GRPCRouteSpecRulesFiltersArray and GRPCRouteSpecRulesFiltersArrayOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesFiltersArrayInput` via:
//
//	GRPCRouteSpecRulesFiltersArray{ GRPCRouteSpecRulesFiltersArgs{...} }
type GRPCRouteSpecRulesFiltersArrayInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesFiltersArrayOutput() GRPCRouteSpecRulesFiltersArrayOutput
	ToGRPCRouteSpecRulesFiltersArrayOutputWithContext(context.Context) GRPCRouteSpecRulesFiltersArrayOutput
}

type GRPCRouteSpecRulesFiltersArray []GRPCRouteSpecRulesFiltersInput

func (GRPCRouteSpecRulesFiltersArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesFilters)(nil)).Elem()
}

func (i GRPCRouteSpecRulesFiltersArray) ToGRPCRouteSpecRulesFiltersArrayOutput() GRPCRouteSpecRulesFiltersArrayOutput {
	return i.ToGRPCRouteSpecRulesFiltersArrayOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesFiltersArray) ToGRPCRouteSpecRulesFiltersArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersArrayOutput)
}

// GRPCRouteFilter defines processing steps that must be completed during the
// request or response lifecycle. GRPCRouteFilters are meant as an extension
// point to express processing that may be done in Gateway implementations. Some
// examples include request or response modification, implementing
// authentication strategies, rate-limiting, and traffic shaping. API
// guarantee/conformance is defined based on the type of the filter.
type GRPCRouteSpecRulesFiltersOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesFiltersOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesFilters)(nil)).Elem()
}

func (o GRPCRouteSpecRulesFiltersOutput) ToGRPCRouteSpecRulesFiltersOutput() GRPCRouteSpecRulesFiltersOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersOutput) ToGRPCRouteSpecRulesFiltersOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersOutput) ExtensionRef() GRPCRouteSpecRulesFiltersExtensionRefPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFilters) *GRPCRouteSpecRulesFiltersExtensionRef { return v.ExtensionRef }).(GRPCRouteSpecRulesFiltersExtensionRefPtrOutput)
}

func (o GRPCRouteSpecRulesFiltersOutput) RequestHeaderModifier() GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFilters) *GRPCRouteSpecRulesFiltersRequestHeaderModifier {
		return v.RequestHeaderModifier
	}).(GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput)
}

func (o GRPCRouteSpecRulesFiltersOutput) RequestMirror() GRPCRouteSpecRulesFiltersRequestMirrorPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFilters) *GRPCRouteSpecRulesFiltersRequestMirror { return v.RequestMirror }).(GRPCRouteSpecRulesFiltersRequestMirrorPtrOutput)
}

func (o GRPCRouteSpecRulesFiltersOutput) ResponseHeaderModifier() GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFilters) *GRPCRouteSpecRulesFiltersResponseHeaderModifier {
		return v.ResponseHeaderModifier
	}).(GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput)
}

// Type identifies the type of filter to apply. As with other API fields,
// types are classified into three conformance levels:
//
// - Core: Filter types and their corresponding configuration defined by
// "Support: Core" in this package, e.g. "RequestHeaderModifier". All
// implementations supporting GRPCRoute MUST support core filters.
//
// - Extended: Filter types and their corresponding configuration defined by
// "Support: Extended" in this package, e.g. "RequestMirror". Implementers
// are encouraged to support extended filters.
//
// - Implementation-specific: Filters that are defined and supported by specific vendors.
// In the future, filters showing convergence in behavior across multiple
// implementations will be considered for inclusion in extended or core
// conformance levels. Filter-specific configuration for such filters
// is specified using the ExtensionRef field. `Type` MUST be set to
// "ExtensionRef" for custom filters.
//
// Implementers are encouraged to define custom implementation types to
// extend the core API with implementation-specific behavior.
//
// If a reference to a custom filter type cannot be resolved, the filter
// MUST NOT be skipped. Instead, requests that would have been processed by
// that filter MUST receive a HTTP error response.
func (o GRPCRouteSpecRulesFiltersOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFilters) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type GRPCRouteSpecRulesFiltersArrayOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesFiltersArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesFilters)(nil)).Elem()
}

func (o GRPCRouteSpecRulesFiltersArrayOutput) ToGRPCRouteSpecRulesFiltersArrayOutput() GRPCRouteSpecRulesFiltersArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersArrayOutput) ToGRPCRouteSpecRulesFiltersArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersArrayOutput) Index(i pulumi.IntInput) GRPCRouteSpecRulesFiltersOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GRPCRouteSpecRulesFilters {
		return vs[0].([]GRPCRouteSpecRulesFilters)[vs[1].(int)]
	}).(GRPCRouteSpecRulesFiltersOutput)
}

// ExtensionRef is an optional, implementation-specific extension to the
// "filter" behavior.  For example, resource "myroutefilter" in group
// "networking.example.net"). ExtensionRef MUST NOT be used for core and
// extended filters.
//
// Support: Implementation-specific
//
// This filter can be used multiple times within the same rule.
type GRPCRouteSpecRulesFiltersExtensionRef struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group *string `pulumi:"group"`
	// Kind is kind of the referent. For example "HTTPRoute" or "Service".
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	Name *string `pulumi:"name"`
}

// GRPCRouteSpecRulesFiltersExtensionRefInput is an input type that accepts GRPCRouteSpecRulesFiltersExtensionRefArgs and GRPCRouteSpecRulesFiltersExtensionRefOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesFiltersExtensionRefInput` via:
//
//	GRPCRouteSpecRulesFiltersExtensionRefArgs{...}
type GRPCRouteSpecRulesFiltersExtensionRefInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesFiltersExtensionRefOutput() GRPCRouteSpecRulesFiltersExtensionRefOutput
	ToGRPCRouteSpecRulesFiltersExtensionRefOutputWithContext(context.Context) GRPCRouteSpecRulesFiltersExtensionRefOutput
}

// ExtensionRef is an optional, implementation-specific extension to the
// "filter" behavior.  For example, resource "myroutefilter" in group
// "networking.example.net"). ExtensionRef MUST NOT be used for core and
// extended filters.
//
// Support: Implementation-specific
//
// This filter can be used multiple times within the same rule.
type GRPCRouteSpecRulesFiltersExtensionRefArgs struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is kind of the referent. For example "HTTPRoute" or "Service".
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (GRPCRouteSpecRulesFiltersExtensionRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesFiltersExtensionRef)(nil)).Elem()
}

func (i GRPCRouteSpecRulesFiltersExtensionRefArgs) ToGRPCRouteSpecRulesFiltersExtensionRefOutput() GRPCRouteSpecRulesFiltersExtensionRefOutput {
	return i.ToGRPCRouteSpecRulesFiltersExtensionRefOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesFiltersExtensionRefArgs) ToGRPCRouteSpecRulesFiltersExtensionRefOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersExtensionRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersExtensionRefOutput)
}

func (i GRPCRouteSpecRulesFiltersExtensionRefArgs) ToGRPCRouteSpecRulesFiltersExtensionRefPtrOutput() GRPCRouteSpecRulesFiltersExtensionRefPtrOutput {
	return i.ToGRPCRouteSpecRulesFiltersExtensionRefPtrOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesFiltersExtensionRefArgs) ToGRPCRouteSpecRulesFiltersExtensionRefPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersExtensionRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersExtensionRefOutput).ToGRPCRouteSpecRulesFiltersExtensionRefPtrOutputWithContext(ctx)
}

// GRPCRouteSpecRulesFiltersExtensionRefPtrInput is an input type that accepts GRPCRouteSpecRulesFiltersExtensionRefArgs, GRPCRouteSpecRulesFiltersExtensionRefPtr and GRPCRouteSpecRulesFiltersExtensionRefPtrOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesFiltersExtensionRefPtrInput` via:
//
//	        GRPCRouteSpecRulesFiltersExtensionRefArgs{...}
//
//	or:
//
//	        nil
type GRPCRouteSpecRulesFiltersExtensionRefPtrInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesFiltersExtensionRefPtrOutput() GRPCRouteSpecRulesFiltersExtensionRefPtrOutput
	ToGRPCRouteSpecRulesFiltersExtensionRefPtrOutputWithContext(context.Context) GRPCRouteSpecRulesFiltersExtensionRefPtrOutput
}

type grpcrouteSpecRulesFiltersExtensionRefPtrType GRPCRouteSpecRulesFiltersExtensionRefArgs

func GRPCRouteSpecRulesFiltersExtensionRefPtr(v *GRPCRouteSpecRulesFiltersExtensionRefArgs) GRPCRouteSpecRulesFiltersExtensionRefPtrInput {
	return (*grpcrouteSpecRulesFiltersExtensionRefPtrType)(v)
}

func (*grpcrouteSpecRulesFiltersExtensionRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesFiltersExtensionRef)(nil)).Elem()
}

func (i *grpcrouteSpecRulesFiltersExtensionRefPtrType) ToGRPCRouteSpecRulesFiltersExtensionRefPtrOutput() GRPCRouteSpecRulesFiltersExtensionRefPtrOutput {
	return i.ToGRPCRouteSpecRulesFiltersExtensionRefPtrOutputWithContext(context.Background())
}

func (i *grpcrouteSpecRulesFiltersExtensionRefPtrType) ToGRPCRouteSpecRulesFiltersExtensionRefPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersExtensionRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersExtensionRefPtrOutput)
}

// ExtensionRef is an optional, implementation-specific extension to the
// "filter" behavior.  For example, resource "myroutefilter" in group
// "networking.example.net"). ExtensionRef MUST NOT be used for core and
// extended filters.
//
// Support: Implementation-specific
//
// This filter can be used multiple times within the same rule.
type GRPCRouteSpecRulesFiltersExtensionRefOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesFiltersExtensionRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesFiltersExtensionRef)(nil)).Elem()
}

func (o GRPCRouteSpecRulesFiltersExtensionRefOutput) ToGRPCRouteSpecRulesFiltersExtensionRefOutput() GRPCRouteSpecRulesFiltersExtensionRefOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersExtensionRefOutput) ToGRPCRouteSpecRulesFiltersExtensionRefOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersExtensionRefOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersExtensionRefOutput) ToGRPCRouteSpecRulesFiltersExtensionRefPtrOutput() GRPCRouteSpecRulesFiltersExtensionRefPtrOutput {
	return o.ToGRPCRouteSpecRulesFiltersExtensionRefPtrOutputWithContext(context.Background())
}

func (o GRPCRouteSpecRulesFiltersExtensionRefOutput) ToGRPCRouteSpecRulesFiltersExtensionRefPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersExtensionRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GRPCRouteSpecRulesFiltersExtensionRef) *GRPCRouteSpecRulesFiltersExtensionRef {
		return &v
	}).(GRPCRouteSpecRulesFiltersExtensionRefPtrOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o GRPCRouteSpecRulesFiltersExtensionRefOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersExtensionRef) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent. For example "HTTPRoute" or "Service".
func (o GRPCRouteSpecRulesFiltersExtensionRefOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersExtensionRef) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o GRPCRouteSpecRulesFiltersExtensionRefOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersExtensionRef) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type GRPCRouteSpecRulesFiltersExtensionRefPtrOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesFiltersExtensionRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesFiltersExtensionRef)(nil)).Elem()
}

func (o GRPCRouteSpecRulesFiltersExtensionRefPtrOutput) ToGRPCRouteSpecRulesFiltersExtensionRefPtrOutput() GRPCRouteSpecRulesFiltersExtensionRefPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersExtensionRefPtrOutput) ToGRPCRouteSpecRulesFiltersExtensionRefPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersExtensionRefPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersExtensionRefPtrOutput) Elem() GRPCRouteSpecRulesFiltersExtensionRefOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesFiltersExtensionRef) GRPCRouteSpecRulesFiltersExtensionRef {
		if v != nil {
			return *v
		}
		var ret GRPCRouteSpecRulesFiltersExtensionRef
		return ret
	}).(GRPCRouteSpecRulesFiltersExtensionRefOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o GRPCRouteSpecRulesFiltersExtensionRefPtrOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesFiltersExtensionRef) *string {
		if v == nil {
			return nil
		}
		return v.Group
	}).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent. For example "HTTPRoute" or "Service".
func (o GRPCRouteSpecRulesFiltersExtensionRefPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesFiltersExtensionRef) *string {
		if v == nil {
			return nil
		}
		return v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o GRPCRouteSpecRulesFiltersExtensionRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesFiltersExtensionRef) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// ExtensionRef is an optional, implementation-specific extension to the
// "filter" behavior.  For example, resource "myroutefilter" in group
// "networking.example.net"). ExtensionRef MUST NOT be used for core and
// extended filters.
//
// Support: Implementation-specific
//
// This filter can be used multiple times within the same rule.
type GRPCRouteSpecRulesFiltersExtensionRefPatch struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group *string `pulumi:"group"`
	// Kind is kind of the referent. For example "HTTPRoute" or "Service".
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	Name *string `pulumi:"name"`
}

// GRPCRouteSpecRulesFiltersExtensionRefPatchInput is an input type that accepts GRPCRouteSpecRulesFiltersExtensionRefPatchArgs and GRPCRouteSpecRulesFiltersExtensionRefPatchOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesFiltersExtensionRefPatchInput` via:
//
//	GRPCRouteSpecRulesFiltersExtensionRefPatchArgs{...}
type GRPCRouteSpecRulesFiltersExtensionRefPatchInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesFiltersExtensionRefPatchOutput() GRPCRouteSpecRulesFiltersExtensionRefPatchOutput
	ToGRPCRouteSpecRulesFiltersExtensionRefPatchOutputWithContext(context.Context) GRPCRouteSpecRulesFiltersExtensionRefPatchOutput
}

// ExtensionRef is an optional, implementation-specific extension to the
// "filter" behavior.  For example, resource "myroutefilter" in group
// "networking.example.net"). ExtensionRef MUST NOT be used for core and
// extended filters.
//
// Support: Implementation-specific
//
// This filter can be used multiple times within the same rule.
type GRPCRouteSpecRulesFiltersExtensionRefPatchArgs struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is kind of the referent. For example "HTTPRoute" or "Service".
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (GRPCRouteSpecRulesFiltersExtensionRefPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesFiltersExtensionRefPatch)(nil)).Elem()
}

func (i GRPCRouteSpecRulesFiltersExtensionRefPatchArgs) ToGRPCRouteSpecRulesFiltersExtensionRefPatchOutput() GRPCRouteSpecRulesFiltersExtensionRefPatchOutput {
	return i.ToGRPCRouteSpecRulesFiltersExtensionRefPatchOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesFiltersExtensionRefPatchArgs) ToGRPCRouteSpecRulesFiltersExtensionRefPatchOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersExtensionRefPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersExtensionRefPatchOutput)
}

func (i GRPCRouteSpecRulesFiltersExtensionRefPatchArgs) ToGRPCRouteSpecRulesFiltersExtensionRefPatchPtrOutput() GRPCRouteSpecRulesFiltersExtensionRefPatchPtrOutput {
	return i.ToGRPCRouteSpecRulesFiltersExtensionRefPatchPtrOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesFiltersExtensionRefPatchArgs) ToGRPCRouteSpecRulesFiltersExtensionRefPatchPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersExtensionRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersExtensionRefPatchOutput).ToGRPCRouteSpecRulesFiltersExtensionRefPatchPtrOutputWithContext(ctx)
}

// GRPCRouteSpecRulesFiltersExtensionRefPatchPtrInput is an input type that accepts GRPCRouteSpecRulesFiltersExtensionRefPatchArgs, GRPCRouteSpecRulesFiltersExtensionRefPatchPtr and GRPCRouteSpecRulesFiltersExtensionRefPatchPtrOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesFiltersExtensionRefPatchPtrInput` via:
//
//	        GRPCRouteSpecRulesFiltersExtensionRefPatchArgs{...}
//
//	or:
//
//	        nil
type GRPCRouteSpecRulesFiltersExtensionRefPatchPtrInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesFiltersExtensionRefPatchPtrOutput() GRPCRouteSpecRulesFiltersExtensionRefPatchPtrOutput
	ToGRPCRouteSpecRulesFiltersExtensionRefPatchPtrOutputWithContext(context.Context) GRPCRouteSpecRulesFiltersExtensionRefPatchPtrOutput
}

type grpcrouteSpecRulesFiltersExtensionRefPatchPtrType GRPCRouteSpecRulesFiltersExtensionRefPatchArgs

func GRPCRouteSpecRulesFiltersExtensionRefPatchPtr(v *GRPCRouteSpecRulesFiltersExtensionRefPatchArgs) GRPCRouteSpecRulesFiltersExtensionRefPatchPtrInput {
	return (*grpcrouteSpecRulesFiltersExtensionRefPatchPtrType)(v)
}

func (*grpcrouteSpecRulesFiltersExtensionRefPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesFiltersExtensionRefPatch)(nil)).Elem()
}

func (i *grpcrouteSpecRulesFiltersExtensionRefPatchPtrType) ToGRPCRouteSpecRulesFiltersExtensionRefPatchPtrOutput() GRPCRouteSpecRulesFiltersExtensionRefPatchPtrOutput {
	return i.ToGRPCRouteSpecRulesFiltersExtensionRefPatchPtrOutputWithContext(context.Background())
}

func (i *grpcrouteSpecRulesFiltersExtensionRefPatchPtrType) ToGRPCRouteSpecRulesFiltersExtensionRefPatchPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersExtensionRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersExtensionRefPatchPtrOutput)
}

// ExtensionRef is an optional, implementation-specific extension to the
// "filter" behavior.  For example, resource "myroutefilter" in group
// "networking.example.net"). ExtensionRef MUST NOT be used for core and
// extended filters.
//
// Support: Implementation-specific
//
// This filter can be used multiple times within the same rule.
type GRPCRouteSpecRulesFiltersExtensionRefPatchOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesFiltersExtensionRefPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesFiltersExtensionRefPatch)(nil)).Elem()
}

func (o GRPCRouteSpecRulesFiltersExtensionRefPatchOutput) ToGRPCRouteSpecRulesFiltersExtensionRefPatchOutput() GRPCRouteSpecRulesFiltersExtensionRefPatchOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersExtensionRefPatchOutput) ToGRPCRouteSpecRulesFiltersExtensionRefPatchOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersExtensionRefPatchOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersExtensionRefPatchOutput) ToGRPCRouteSpecRulesFiltersExtensionRefPatchPtrOutput() GRPCRouteSpecRulesFiltersExtensionRefPatchPtrOutput {
	return o.ToGRPCRouteSpecRulesFiltersExtensionRefPatchPtrOutputWithContext(context.Background())
}

func (o GRPCRouteSpecRulesFiltersExtensionRefPatchOutput) ToGRPCRouteSpecRulesFiltersExtensionRefPatchPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersExtensionRefPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GRPCRouteSpecRulesFiltersExtensionRefPatch) *GRPCRouteSpecRulesFiltersExtensionRefPatch {
		return &v
	}).(GRPCRouteSpecRulesFiltersExtensionRefPatchPtrOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o GRPCRouteSpecRulesFiltersExtensionRefPatchOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersExtensionRefPatch) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent. For example "HTTPRoute" or "Service".
func (o GRPCRouteSpecRulesFiltersExtensionRefPatchOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersExtensionRefPatch) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o GRPCRouteSpecRulesFiltersExtensionRefPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersExtensionRefPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type GRPCRouteSpecRulesFiltersExtensionRefPatchPtrOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesFiltersExtensionRefPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesFiltersExtensionRefPatch)(nil)).Elem()
}

func (o GRPCRouteSpecRulesFiltersExtensionRefPatchPtrOutput) ToGRPCRouteSpecRulesFiltersExtensionRefPatchPtrOutput() GRPCRouteSpecRulesFiltersExtensionRefPatchPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersExtensionRefPatchPtrOutput) ToGRPCRouteSpecRulesFiltersExtensionRefPatchPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersExtensionRefPatchPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersExtensionRefPatchPtrOutput) Elem() GRPCRouteSpecRulesFiltersExtensionRefPatchOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesFiltersExtensionRefPatch) GRPCRouteSpecRulesFiltersExtensionRefPatch {
		if v != nil {
			return *v
		}
		var ret GRPCRouteSpecRulesFiltersExtensionRefPatch
		return ret
	}).(GRPCRouteSpecRulesFiltersExtensionRefPatchOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o GRPCRouteSpecRulesFiltersExtensionRefPatchPtrOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesFiltersExtensionRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Group
	}).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent. For example "HTTPRoute" or "Service".
func (o GRPCRouteSpecRulesFiltersExtensionRefPatchPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesFiltersExtensionRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o GRPCRouteSpecRulesFiltersExtensionRefPatchPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesFiltersExtensionRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// GRPCRouteFilter defines processing steps that must be completed during the
// request or response lifecycle. GRPCRouteFilters are meant as an extension
// point to express processing that may be done in Gateway implementations. Some
// examples include request or response modification, implementing
// authentication strategies, rate-limiting, and traffic shaping. API
// guarantee/conformance is defined based on the type of the filter.
type GRPCRouteSpecRulesFiltersPatch struct {
	ExtensionRef           *GRPCRouteSpecRulesFiltersExtensionRefPatch           `pulumi:"extensionRef"`
	RequestHeaderModifier  *GRPCRouteSpecRulesFiltersRequestHeaderModifierPatch  `pulumi:"requestHeaderModifier"`
	RequestMirror          *GRPCRouteSpecRulesFiltersRequestMirrorPatch          `pulumi:"requestMirror"`
	ResponseHeaderModifier *GRPCRouteSpecRulesFiltersResponseHeaderModifierPatch `pulumi:"responseHeaderModifier"`
	// Type identifies the type of filter to apply. As with other API fields,
	// types are classified into three conformance levels:
	//
	// - Core: Filter types and their corresponding configuration defined by
	// "Support: Core" in this package, e.g. "RequestHeaderModifier". All
	// implementations supporting GRPCRoute MUST support core filters.
	//
	// - Extended: Filter types and their corresponding configuration defined by
	// "Support: Extended" in this package, e.g. "RequestMirror". Implementers
	// are encouraged to support extended filters.
	//
	// - Implementation-specific: Filters that are defined and supported by specific vendors.
	// In the future, filters showing convergence in behavior across multiple
	// implementations will be considered for inclusion in extended or core
	// conformance levels. Filter-specific configuration for such filters
	// is specified using the ExtensionRef field. `Type` MUST be set to
	// "ExtensionRef" for custom filters.
	//
	// Implementers are encouraged to define custom implementation types to
	// extend the core API with implementation-specific behavior.
	//
	// If a reference to a custom filter type cannot be resolved, the filter
	// MUST NOT be skipped. Instead, requests that would have been processed by
	// that filter MUST receive a HTTP error response.
	Type *string `pulumi:"type"`
}

// GRPCRouteSpecRulesFiltersPatchInput is an input type that accepts GRPCRouteSpecRulesFiltersPatchArgs and GRPCRouteSpecRulesFiltersPatchOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesFiltersPatchInput` via:
//
//	GRPCRouteSpecRulesFiltersPatchArgs{...}
type GRPCRouteSpecRulesFiltersPatchInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesFiltersPatchOutput() GRPCRouteSpecRulesFiltersPatchOutput
	ToGRPCRouteSpecRulesFiltersPatchOutputWithContext(context.Context) GRPCRouteSpecRulesFiltersPatchOutput
}

// GRPCRouteFilter defines processing steps that must be completed during the
// request or response lifecycle. GRPCRouteFilters are meant as an extension
// point to express processing that may be done in Gateway implementations. Some
// examples include request or response modification, implementing
// authentication strategies, rate-limiting, and traffic shaping. API
// guarantee/conformance is defined based on the type of the filter.
type GRPCRouteSpecRulesFiltersPatchArgs struct {
	ExtensionRef           GRPCRouteSpecRulesFiltersExtensionRefPatchPtrInput           `pulumi:"extensionRef"`
	RequestHeaderModifier  GRPCRouteSpecRulesFiltersRequestHeaderModifierPatchPtrInput  `pulumi:"requestHeaderModifier"`
	RequestMirror          GRPCRouteSpecRulesFiltersRequestMirrorPatchPtrInput          `pulumi:"requestMirror"`
	ResponseHeaderModifier GRPCRouteSpecRulesFiltersResponseHeaderModifierPatchPtrInput `pulumi:"responseHeaderModifier"`
	// Type identifies the type of filter to apply. As with other API fields,
	// types are classified into three conformance levels:
	//
	// - Core: Filter types and their corresponding configuration defined by
	// "Support: Core" in this package, e.g. "RequestHeaderModifier". All
	// implementations supporting GRPCRoute MUST support core filters.
	//
	// - Extended: Filter types and their corresponding configuration defined by
	// "Support: Extended" in this package, e.g. "RequestMirror". Implementers
	// are encouraged to support extended filters.
	//
	// - Implementation-specific: Filters that are defined and supported by specific vendors.
	// In the future, filters showing convergence in behavior across multiple
	// implementations will be considered for inclusion in extended or core
	// conformance levels. Filter-specific configuration for such filters
	// is specified using the ExtensionRef field. `Type` MUST be set to
	// "ExtensionRef" for custom filters.
	//
	// Implementers are encouraged to define custom implementation types to
	// extend the core API with implementation-specific behavior.
	//
	// If a reference to a custom filter type cannot be resolved, the filter
	// MUST NOT be skipped. Instead, requests that would have been processed by
	// that filter MUST receive a HTTP error response.
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (GRPCRouteSpecRulesFiltersPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesFiltersPatch)(nil)).Elem()
}

func (i GRPCRouteSpecRulesFiltersPatchArgs) ToGRPCRouteSpecRulesFiltersPatchOutput() GRPCRouteSpecRulesFiltersPatchOutput {
	return i.ToGRPCRouteSpecRulesFiltersPatchOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesFiltersPatchArgs) ToGRPCRouteSpecRulesFiltersPatchOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersPatchOutput)
}

// GRPCRouteSpecRulesFiltersPatchArrayInput is an input type that accepts GRPCRouteSpecRulesFiltersPatchArray and GRPCRouteSpecRulesFiltersPatchArrayOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesFiltersPatchArrayInput` via:
//
//	GRPCRouteSpecRulesFiltersPatchArray{ GRPCRouteSpecRulesFiltersPatchArgs{...} }
type GRPCRouteSpecRulesFiltersPatchArrayInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesFiltersPatchArrayOutput() GRPCRouteSpecRulesFiltersPatchArrayOutput
	ToGRPCRouteSpecRulesFiltersPatchArrayOutputWithContext(context.Context) GRPCRouteSpecRulesFiltersPatchArrayOutput
}

type GRPCRouteSpecRulesFiltersPatchArray []GRPCRouteSpecRulesFiltersPatchInput

func (GRPCRouteSpecRulesFiltersPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesFiltersPatch)(nil)).Elem()
}

func (i GRPCRouteSpecRulesFiltersPatchArray) ToGRPCRouteSpecRulesFiltersPatchArrayOutput() GRPCRouteSpecRulesFiltersPatchArrayOutput {
	return i.ToGRPCRouteSpecRulesFiltersPatchArrayOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesFiltersPatchArray) ToGRPCRouteSpecRulesFiltersPatchArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersPatchArrayOutput)
}

// GRPCRouteFilter defines processing steps that must be completed during the
// request or response lifecycle. GRPCRouteFilters are meant as an extension
// point to express processing that may be done in Gateway implementations. Some
// examples include request or response modification, implementing
// authentication strategies, rate-limiting, and traffic shaping. API
// guarantee/conformance is defined based on the type of the filter.
type GRPCRouteSpecRulesFiltersPatchOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesFiltersPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesFiltersPatch)(nil)).Elem()
}

func (o GRPCRouteSpecRulesFiltersPatchOutput) ToGRPCRouteSpecRulesFiltersPatchOutput() GRPCRouteSpecRulesFiltersPatchOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersPatchOutput) ToGRPCRouteSpecRulesFiltersPatchOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersPatchOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersPatchOutput) ExtensionRef() GRPCRouteSpecRulesFiltersExtensionRefPatchPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersPatch) *GRPCRouteSpecRulesFiltersExtensionRefPatch {
		return v.ExtensionRef
	}).(GRPCRouteSpecRulesFiltersExtensionRefPatchPtrOutput)
}

func (o GRPCRouteSpecRulesFiltersPatchOutput) RequestHeaderModifier() GRPCRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersPatch) *GRPCRouteSpecRulesFiltersRequestHeaderModifierPatch {
		return v.RequestHeaderModifier
	}).(GRPCRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput)
}

func (o GRPCRouteSpecRulesFiltersPatchOutput) RequestMirror() GRPCRouteSpecRulesFiltersRequestMirrorPatchPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersPatch) *GRPCRouteSpecRulesFiltersRequestMirrorPatch {
		return v.RequestMirror
	}).(GRPCRouteSpecRulesFiltersRequestMirrorPatchPtrOutput)
}

func (o GRPCRouteSpecRulesFiltersPatchOutput) ResponseHeaderModifier() GRPCRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersPatch) *GRPCRouteSpecRulesFiltersResponseHeaderModifierPatch {
		return v.ResponseHeaderModifier
	}).(GRPCRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput)
}

// Type identifies the type of filter to apply. As with other API fields,
// types are classified into three conformance levels:
//
// - Core: Filter types and their corresponding configuration defined by
// "Support: Core" in this package, e.g. "RequestHeaderModifier". All
// implementations supporting GRPCRoute MUST support core filters.
//
// - Extended: Filter types and their corresponding configuration defined by
// "Support: Extended" in this package, e.g. "RequestMirror". Implementers
// are encouraged to support extended filters.
//
// - Implementation-specific: Filters that are defined and supported by specific vendors.
// In the future, filters showing convergence in behavior across multiple
// implementations will be considered for inclusion in extended or core
// conformance levels. Filter-specific configuration for such filters
// is specified using the ExtensionRef field. `Type` MUST be set to
// "ExtensionRef" for custom filters.
//
// Implementers are encouraged to define custom implementation types to
// extend the core API with implementation-specific behavior.
//
// If a reference to a custom filter type cannot be resolved, the filter
// MUST NOT be skipped. Instead, requests that would have been processed by
// that filter MUST receive a HTTP error response.
func (o GRPCRouteSpecRulesFiltersPatchOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersPatch) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type GRPCRouteSpecRulesFiltersPatchArrayOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesFiltersPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesFiltersPatch)(nil)).Elem()
}

func (o GRPCRouteSpecRulesFiltersPatchArrayOutput) ToGRPCRouteSpecRulesFiltersPatchArrayOutput() GRPCRouteSpecRulesFiltersPatchArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersPatchArrayOutput) ToGRPCRouteSpecRulesFiltersPatchArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersPatchArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersPatchArrayOutput) Index(i pulumi.IntInput) GRPCRouteSpecRulesFiltersPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GRPCRouteSpecRulesFiltersPatch {
		return vs[0].([]GRPCRouteSpecRulesFiltersPatch)[vs[1].(int)]
	}).(GRPCRouteSpecRulesFiltersPatchOutput)
}

// RequestHeaderModifier defines a schema for a filter that modifies request
// headers.
//
// Support: Core
type GRPCRouteSpecRulesFiltersRequestHeaderModifier struct {
	// Add adds the given header(s) (name, value) to the request
	// before the action. It appends to any existing values associated
	// with the header name.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   add:
	//   - name: "my-header"
	//     value: "bar,baz"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: foo,bar,baz
	Add []GRPCRouteSpecRulesFiltersRequestHeaderModifierAdd `pulumi:"add"`
	// Remove the given header(s) from the HTTP request before the action. The
	// value of Remove is a list of HTTP header names. Note that the header
	// names are case-insensitive (see
	// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header1: foo
	//   my-header2: bar
	//   my-header3: baz
	//
	// Config:
	//   remove: ["my-header1", "my-header3"]
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header2: bar
	Remove []string `pulumi:"remove"`
	// Set overwrites the request with the given header (name, value)
	// before the action.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   set:
	//   - name: "my-header"
	//     value: "bar"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: bar
	Set []GRPCRouteSpecRulesFiltersRequestHeaderModifierSet `pulumi:"set"`
}

// GRPCRouteSpecRulesFiltersRequestHeaderModifierInput is an input type that accepts GRPCRouteSpecRulesFiltersRequestHeaderModifierArgs and GRPCRouteSpecRulesFiltersRequestHeaderModifierOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesFiltersRequestHeaderModifierInput` via:
//
//	GRPCRouteSpecRulesFiltersRequestHeaderModifierArgs{...}
type GRPCRouteSpecRulesFiltersRequestHeaderModifierInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesFiltersRequestHeaderModifierOutput() GRPCRouteSpecRulesFiltersRequestHeaderModifierOutput
	ToGRPCRouteSpecRulesFiltersRequestHeaderModifierOutputWithContext(context.Context) GRPCRouteSpecRulesFiltersRequestHeaderModifierOutput
}

// RequestHeaderModifier defines a schema for a filter that modifies request
// headers.
//
// Support: Core
type GRPCRouteSpecRulesFiltersRequestHeaderModifierArgs struct {
	// Add adds the given header(s) (name, value) to the request
	// before the action. It appends to any existing values associated
	// with the header name.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   add:
	//   - name: "my-header"
	//     value: "bar,baz"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: foo,bar,baz
	Add GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayInput `pulumi:"add"`
	// Remove the given header(s) from the HTTP request before the action. The
	// value of Remove is a list of HTTP header names. Note that the header
	// names are case-insensitive (see
	// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header1: foo
	//   my-header2: bar
	//   my-header3: baz
	//
	// Config:
	//   remove: ["my-header1", "my-header3"]
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header2: bar
	Remove pulumi.StringArrayInput `pulumi:"remove"`
	// Set overwrites the request with the given header (name, value)
	// before the action.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   set:
	//   - name: "my-header"
	//     value: "bar"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: bar
	Set GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayInput `pulumi:"set"`
}

func (GRPCRouteSpecRulesFiltersRequestHeaderModifierArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesFiltersRequestHeaderModifier)(nil)).Elem()
}

func (i GRPCRouteSpecRulesFiltersRequestHeaderModifierArgs) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierOutput() GRPCRouteSpecRulesFiltersRequestHeaderModifierOutput {
	return i.ToGRPCRouteSpecRulesFiltersRequestHeaderModifierOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesFiltersRequestHeaderModifierArgs) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestHeaderModifierOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersRequestHeaderModifierOutput)
}

func (i GRPCRouteSpecRulesFiltersRequestHeaderModifierArgs) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput() GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput {
	return i.ToGRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesFiltersRequestHeaderModifierArgs) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersRequestHeaderModifierOutput).ToGRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutputWithContext(ctx)
}

// GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrInput is an input type that accepts GRPCRouteSpecRulesFiltersRequestHeaderModifierArgs, GRPCRouteSpecRulesFiltersRequestHeaderModifierPtr and GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrInput` via:
//
//	        GRPCRouteSpecRulesFiltersRequestHeaderModifierArgs{...}
//
//	or:
//
//	        nil
type GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput() GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput
	ToGRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutputWithContext(context.Context) GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput
}

type grpcrouteSpecRulesFiltersRequestHeaderModifierPtrType GRPCRouteSpecRulesFiltersRequestHeaderModifierArgs

func GRPCRouteSpecRulesFiltersRequestHeaderModifierPtr(v *GRPCRouteSpecRulesFiltersRequestHeaderModifierArgs) GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrInput {
	return (*grpcrouteSpecRulesFiltersRequestHeaderModifierPtrType)(v)
}

func (*grpcrouteSpecRulesFiltersRequestHeaderModifierPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesFiltersRequestHeaderModifier)(nil)).Elem()
}

func (i *grpcrouteSpecRulesFiltersRequestHeaderModifierPtrType) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput() GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput {
	return i.ToGRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutputWithContext(context.Background())
}

func (i *grpcrouteSpecRulesFiltersRequestHeaderModifierPtrType) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput)
}

// RequestHeaderModifier defines a schema for a filter that modifies request
// headers.
//
// Support: Core
type GRPCRouteSpecRulesFiltersRequestHeaderModifierOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesFiltersRequestHeaderModifierOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesFiltersRequestHeaderModifier)(nil)).Elem()
}

func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierOutput) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierOutput() GRPCRouteSpecRulesFiltersRequestHeaderModifierOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierOutput) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestHeaderModifierOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierOutput) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput() GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput {
	return o.ToGRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutputWithContext(context.Background())
}

func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierOutput) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GRPCRouteSpecRulesFiltersRequestHeaderModifier) *GRPCRouteSpecRulesFiltersRequestHeaderModifier {
		return &v
	}).(GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput)
}

// Add adds the given header(s) (name, value) to the request
// before the action. It appends to any existing values associated
// with the header name.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	add:
//	- name: "my-header"
//	  value: "bar,baz"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: foo,bar,baz
func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierOutput) Add() GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersRequestHeaderModifier) []GRPCRouteSpecRulesFiltersRequestHeaderModifierAdd {
		return v.Add
	}).(GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput)
}

// Remove the given header(s) from the HTTP request before the action. The
// value of Remove is a list of HTTP header names. Note that the header
// names are case-insensitive (see
// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header1: foo
//	my-header2: bar
//	my-header3: baz
//
// Config:
//
//	remove: ["my-header1", "my-header3"]
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header2: bar
func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierOutput) Remove() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersRequestHeaderModifier) []string { return v.Remove }).(pulumi.StringArrayOutput)
}

// Set overwrites the request with the given header (name, value)
// before the action.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	set:
//	- name: "my-header"
//	  value: "bar"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: bar
func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierOutput) Set() GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersRequestHeaderModifier) []GRPCRouteSpecRulesFiltersRequestHeaderModifierSet {
		return v.Set
	}).(GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput)
}

type GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesFiltersRequestHeaderModifier)(nil)).Elem()
}

func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput() GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput) Elem() GRPCRouteSpecRulesFiltersRequestHeaderModifierOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesFiltersRequestHeaderModifier) GRPCRouteSpecRulesFiltersRequestHeaderModifier {
		if v != nil {
			return *v
		}
		var ret GRPCRouteSpecRulesFiltersRequestHeaderModifier
		return ret
	}).(GRPCRouteSpecRulesFiltersRequestHeaderModifierOutput)
}

// Add adds the given header(s) (name, value) to the request
// before the action. It appends to any existing values associated
// with the header name.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	add:
//	- name: "my-header"
//	  value: "bar,baz"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: foo,bar,baz
func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput) Add() GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesFiltersRequestHeaderModifier) []GRPCRouteSpecRulesFiltersRequestHeaderModifierAdd {
		if v == nil {
			return nil
		}
		return v.Add
	}).(GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput)
}

// Remove the given header(s) from the HTTP request before the action. The
// value of Remove is a list of HTTP header names. Note that the header
// names are case-insensitive (see
// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header1: foo
//	my-header2: bar
//	my-header3: baz
//
// Config:
//
//	remove: ["my-header1", "my-header3"]
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header2: bar
func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput) Remove() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesFiltersRequestHeaderModifier) []string {
		if v == nil {
			return nil
		}
		return v.Remove
	}).(pulumi.StringArrayOutput)
}

// Set overwrites the request with the given header (name, value)
// before the action.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	set:
//	- name: "my-header"
//	  value: "bar"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: bar
func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput) Set() GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesFiltersRequestHeaderModifier) []GRPCRouteSpecRulesFiltersRequestHeaderModifierSet {
		if v == nil {
			return nil
		}
		return v.Set
	}).(GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesFiltersRequestHeaderModifierAdd struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name *string `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value *string `pulumi:"value"`
}

// GRPCRouteSpecRulesFiltersRequestHeaderModifierAddInput is an input type that accepts GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArgs and GRPCRouteSpecRulesFiltersRequestHeaderModifierAddOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesFiltersRequestHeaderModifierAddInput` via:
//
//	GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArgs{...}
type GRPCRouteSpecRulesFiltersRequestHeaderModifierAddInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesFiltersRequestHeaderModifierAddOutput() GRPCRouteSpecRulesFiltersRequestHeaderModifierAddOutput
	ToGRPCRouteSpecRulesFiltersRequestHeaderModifierAddOutputWithContext(context.Context) GRPCRouteSpecRulesFiltersRequestHeaderModifierAddOutput
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArgs struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesFiltersRequestHeaderModifierAdd)(nil)).Elem()
}

func (i GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArgs) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierAddOutput() GRPCRouteSpecRulesFiltersRequestHeaderModifierAddOutput {
	return i.ToGRPCRouteSpecRulesFiltersRequestHeaderModifierAddOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArgs) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierAddOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestHeaderModifierAddOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersRequestHeaderModifierAddOutput)
}

// GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayInput is an input type that accepts GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArray and GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayInput` via:
//
//	GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArray{ GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArgs{...} }
type GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput() GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput
	ToGRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutputWithContext(context.Context) GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput
}

type GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArray []GRPCRouteSpecRulesFiltersRequestHeaderModifierAddInput

func (GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesFiltersRequestHeaderModifierAdd)(nil)).Elem()
}

func (i GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArray) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput() GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput {
	return i.ToGRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArray) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesFiltersRequestHeaderModifierAddOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesFiltersRequestHeaderModifierAddOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesFiltersRequestHeaderModifierAdd)(nil)).Elem()
}

func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierAddOutput) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierAddOutput() GRPCRouteSpecRulesFiltersRequestHeaderModifierAddOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierAddOutput) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierAddOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestHeaderModifierAddOutput {
	return o
}

// Name is the name of the HTTP Header to be matched. Name matching MUST be
// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
//
// If multiple entries specify equivalent header names, the first entry with
// an equivalent name MUST be considered for a match. Subsequent entries
// with an equivalent header name MUST be ignored. Due to the
// case-insensitivity of header names, "foo" and "Foo" are considered
// equivalent.
func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierAddOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersRequestHeaderModifierAdd) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Value is the value of HTTP Header to be matched.
func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierAddOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersRequestHeaderModifierAdd) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesFiltersRequestHeaderModifierAdd)(nil)).Elem()
}

func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput() GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput) Index(i pulumi.IntInput) GRPCRouteSpecRulesFiltersRequestHeaderModifierAddOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GRPCRouteSpecRulesFiltersRequestHeaderModifierAdd {
		return vs[0].([]GRPCRouteSpecRulesFiltersRequestHeaderModifierAdd)[vs[1].(int)]
	}).(GRPCRouteSpecRulesFiltersRequestHeaderModifierAddOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatch struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name *string `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value *string `pulumi:"value"`
}

// GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchInput is an input type that accepts GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchArgs and GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchInput` via:
//
//	GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchArgs{...}
type GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchOutput() GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchOutput
	ToGRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchOutputWithContext(context.Context) GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchOutput
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchArgs struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatch)(nil)).Elem()
}

func (i GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchArgs) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchOutput() GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchOutput {
	return i.ToGRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchArgs) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchOutput)
}

// GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayInput is an input type that accepts GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchArray and GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayInput` via:
//
//	GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchArray{ GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchArgs{...} }
type GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayOutput() GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayOutput
	ToGRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayOutputWithContext(context.Context) GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayOutput
}

type GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchArray []GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchInput

func (GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatch)(nil)).Elem()
}

func (i GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchArray) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayOutput() GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayOutput {
	return i.ToGRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchArray) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatch)(nil)).Elem()
}

func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchOutput) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchOutput() GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchOutput) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchOutput {
	return o
}

// Name is the name of the HTTP Header to be matched. Name matching MUST be
// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
//
// If multiple entries specify equivalent header names, the first entry with
// an equivalent name MUST be considered for a match. Subsequent entries
// with an equivalent header name MUST be ignored. Due to the
// case-insensitivity of header names, "foo" and "Foo" are considered
// equivalent.
func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Value is the value of HTTP Header to be matched.
func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatch) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatch)(nil)).Elem()
}

func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayOutput) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayOutput() GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayOutput) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayOutput) Index(i pulumi.IntInput) GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatch {
		return vs[0].([]GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatch)[vs[1].(int)]
	}).(GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchOutput)
}

// RequestHeaderModifier defines a schema for a filter that modifies request
// headers.
//
// Support: Core
type GRPCRouteSpecRulesFiltersRequestHeaderModifierPatch struct {
	// Add adds the given header(s) (name, value) to the request
	// before the action. It appends to any existing values associated
	// with the header name.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   add:
	//   - name: "my-header"
	//     value: "bar,baz"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: foo,bar,baz
	Add []GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatch `pulumi:"add"`
	// Remove the given header(s) from the HTTP request before the action. The
	// value of Remove is a list of HTTP header names. Note that the header
	// names are case-insensitive (see
	// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header1: foo
	//   my-header2: bar
	//   my-header3: baz
	//
	// Config:
	//   remove: ["my-header1", "my-header3"]
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header2: bar
	Remove []string `pulumi:"remove"`
	// Set overwrites the request with the given header (name, value)
	// before the action.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   set:
	//   - name: "my-header"
	//     value: "bar"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: bar
	Set []GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatch `pulumi:"set"`
}

// GRPCRouteSpecRulesFiltersRequestHeaderModifierPatchInput is an input type that accepts GRPCRouteSpecRulesFiltersRequestHeaderModifierPatchArgs and GRPCRouteSpecRulesFiltersRequestHeaderModifierPatchOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesFiltersRequestHeaderModifierPatchInput` via:
//
//	GRPCRouteSpecRulesFiltersRequestHeaderModifierPatchArgs{...}
type GRPCRouteSpecRulesFiltersRequestHeaderModifierPatchInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesFiltersRequestHeaderModifierPatchOutput() GRPCRouteSpecRulesFiltersRequestHeaderModifierPatchOutput
	ToGRPCRouteSpecRulesFiltersRequestHeaderModifierPatchOutputWithContext(context.Context) GRPCRouteSpecRulesFiltersRequestHeaderModifierPatchOutput
}

// RequestHeaderModifier defines a schema for a filter that modifies request
// headers.
//
// Support: Core
type GRPCRouteSpecRulesFiltersRequestHeaderModifierPatchArgs struct {
	// Add adds the given header(s) (name, value) to the request
	// before the action. It appends to any existing values associated
	// with the header name.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   add:
	//   - name: "my-header"
	//     value: "bar,baz"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: foo,bar,baz
	Add GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayInput `pulumi:"add"`
	// Remove the given header(s) from the HTTP request before the action. The
	// value of Remove is a list of HTTP header names. Note that the header
	// names are case-insensitive (see
	// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header1: foo
	//   my-header2: bar
	//   my-header3: baz
	//
	// Config:
	//   remove: ["my-header1", "my-header3"]
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header2: bar
	Remove pulumi.StringArrayInput `pulumi:"remove"`
	// Set overwrites the request with the given header (name, value)
	// before the action.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   set:
	//   - name: "my-header"
	//     value: "bar"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: bar
	Set GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayInput `pulumi:"set"`
}

func (GRPCRouteSpecRulesFiltersRequestHeaderModifierPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesFiltersRequestHeaderModifierPatch)(nil)).Elem()
}

func (i GRPCRouteSpecRulesFiltersRequestHeaderModifierPatchArgs) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierPatchOutput() GRPCRouteSpecRulesFiltersRequestHeaderModifierPatchOutput {
	return i.ToGRPCRouteSpecRulesFiltersRequestHeaderModifierPatchOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesFiltersRequestHeaderModifierPatchArgs) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierPatchOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestHeaderModifierPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersRequestHeaderModifierPatchOutput)
}

func (i GRPCRouteSpecRulesFiltersRequestHeaderModifierPatchArgs) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput() GRPCRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput {
	return i.ToGRPCRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesFiltersRequestHeaderModifierPatchArgs) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersRequestHeaderModifierPatchOutput).ToGRPCRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutputWithContext(ctx)
}

// GRPCRouteSpecRulesFiltersRequestHeaderModifierPatchPtrInput is an input type that accepts GRPCRouteSpecRulesFiltersRequestHeaderModifierPatchArgs, GRPCRouteSpecRulesFiltersRequestHeaderModifierPatchPtr and GRPCRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesFiltersRequestHeaderModifierPatchPtrInput` via:
//
//	        GRPCRouteSpecRulesFiltersRequestHeaderModifierPatchArgs{...}
//
//	or:
//
//	        nil
type GRPCRouteSpecRulesFiltersRequestHeaderModifierPatchPtrInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput() GRPCRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput
	ToGRPCRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutputWithContext(context.Context) GRPCRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput
}

type grpcrouteSpecRulesFiltersRequestHeaderModifierPatchPtrType GRPCRouteSpecRulesFiltersRequestHeaderModifierPatchArgs

func GRPCRouteSpecRulesFiltersRequestHeaderModifierPatchPtr(v *GRPCRouteSpecRulesFiltersRequestHeaderModifierPatchArgs) GRPCRouteSpecRulesFiltersRequestHeaderModifierPatchPtrInput {
	return (*grpcrouteSpecRulesFiltersRequestHeaderModifierPatchPtrType)(v)
}

func (*grpcrouteSpecRulesFiltersRequestHeaderModifierPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesFiltersRequestHeaderModifierPatch)(nil)).Elem()
}

func (i *grpcrouteSpecRulesFiltersRequestHeaderModifierPatchPtrType) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput() GRPCRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput {
	return i.ToGRPCRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutputWithContext(context.Background())
}

func (i *grpcrouteSpecRulesFiltersRequestHeaderModifierPatchPtrType) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput)
}

// RequestHeaderModifier defines a schema for a filter that modifies request
// headers.
//
// Support: Core
type GRPCRouteSpecRulesFiltersRequestHeaderModifierPatchOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesFiltersRequestHeaderModifierPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesFiltersRequestHeaderModifierPatch)(nil)).Elem()
}

func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierPatchOutput) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierPatchOutput() GRPCRouteSpecRulesFiltersRequestHeaderModifierPatchOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierPatchOutput) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierPatchOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestHeaderModifierPatchOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierPatchOutput) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput() GRPCRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput {
	return o.ToGRPCRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutputWithContext(context.Background())
}

func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierPatchOutput) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GRPCRouteSpecRulesFiltersRequestHeaderModifierPatch) *GRPCRouteSpecRulesFiltersRequestHeaderModifierPatch {
		return &v
	}).(GRPCRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput)
}

// Add adds the given header(s) (name, value) to the request
// before the action. It appends to any existing values associated
// with the header name.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	add:
//	- name: "my-header"
//	  value: "bar,baz"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: foo,bar,baz
func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierPatchOutput) Add() GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersRequestHeaderModifierPatch) []GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatch {
		return v.Add
	}).(GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayOutput)
}

// Remove the given header(s) from the HTTP request before the action. The
// value of Remove is a list of HTTP header names. Note that the header
// names are case-insensitive (see
// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header1: foo
//	my-header2: bar
//	my-header3: baz
//
// Config:
//
//	remove: ["my-header1", "my-header3"]
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header2: bar
func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierPatchOutput) Remove() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersRequestHeaderModifierPatch) []string { return v.Remove }).(pulumi.StringArrayOutput)
}

// Set overwrites the request with the given header (name, value)
// before the action.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	set:
//	- name: "my-header"
//	  value: "bar"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: bar
func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierPatchOutput) Set() GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersRequestHeaderModifierPatch) []GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatch {
		return v.Set
	}).(GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayOutput)
}

type GRPCRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesFiltersRequestHeaderModifierPatch)(nil)).Elem()
}

func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput() GRPCRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput) Elem() GRPCRouteSpecRulesFiltersRequestHeaderModifierPatchOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesFiltersRequestHeaderModifierPatch) GRPCRouteSpecRulesFiltersRequestHeaderModifierPatch {
		if v != nil {
			return *v
		}
		var ret GRPCRouteSpecRulesFiltersRequestHeaderModifierPatch
		return ret
	}).(GRPCRouteSpecRulesFiltersRequestHeaderModifierPatchOutput)
}

// Add adds the given header(s) (name, value) to the request
// before the action. It appends to any existing values associated
// with the header name.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	add:
//	- name: "my-header"
//	  value: "bar,baz"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: foo,bar,baz
func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput) Add() GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesFiltersRequestHeaderModifierPatch) []GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatch {
		if v == nil {
			return nil
		}
		return v.Add
	}).(GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayOutput)
}

// Remove the given header(s) from the HTTP request before the action. The
// value of Remove is a list of HTTP header names. Note that the header
// names are case-insensitive (see
// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header1: foo
//	my-header2: bar
//	my-header3: baz
//
// Config:
//
//	remove: ["my-header1", "my-header3"]
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header2: bar
func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput) Remove() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesFiltersRequestHeaderModifierPatch) []string {
		if v == nil {
			return nil
		}
		return v.Remove
	}).(pulumi.StringArrayOutput)
}

// Set overwrites the request with the given header (name, value)
// before the action.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	set:
//	- name: "my-header"
//	  value: "bar"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: bar
func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput) Set() GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesFiltersRequestHeaderModifierPatch) []GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatch {
		if v == nil {
			return nil
		}
		return v.Set
	}).(GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesFiltersRequestHeaderModifierSet struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name *string `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value *string `pulumi:"value"`
}

// GRPCRouteSpecRulesFiltersRequestHeaderModifierSetInput is an input type that accepts GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArgs and GRPCRouteSpecRulesFiltersRequestHeaderModifierSetOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesFiltersRequestHeaderModifierSetInput` via:
//
//	GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArgs{...}
type GRPCRouteSpecRulesFiltersRequestHeaderModifierSetInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesFiltersRequestHeaderModifierSetOutput() GRPCRouteSpecRulesFiltersRequestHeaderModifierSetOutput
	ToGRPCRouteSpecRulesFiltersRequestHeaderModifierSetOutputWithContext(context.Context) GRPCRouteSpecRulesFiltersRequestHeaderModifierSetOutput
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArgs struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesFiltersRequestHeaderModifierSet)(nil)).Elem()
}

func (i GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArgs) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierSetOutput() GRPCRouteSpecRulesFiltersRequestHeaderModifierSetOutput {
	return i.ToGRPCRouteSpecRulesFiltersRequestHeaderModifierSetOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArgs) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierSetOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestHeaderModifierSetOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersRequestHeaderModifierSetOutput)
}

// GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayInput is an input type that accepts GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArray and GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayInput` via:
//
//	GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArray{ GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArgs{...} }
type GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput() GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput
	ToGRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutputWithContext(context.Context) GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput
}

type GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArray []GRPCRouteSpecRulesFiltersRequestHeaderModifierSetInput

func (GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesFiltersRequestHeaderModifierSet)(nil)).Elem()
}

func (i GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArray) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput() GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput {
	return i.ToGRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArray) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesFiltersRequestHeaderModifierSetOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesFiltersRequestHeaderModifierSetOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesFiltersRequestHeaderModifierSet)(nil)).Elem()
}

func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierSetOutput) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierSetOutput() GRPCRouteSpecRulesFiltersRequestHeaderModifierSetOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierSetOutput) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierSetOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestHeaderModifierSetOutput {
	return o
}

// Name is the name of the HTTP Header to be matched. Name matching MUST be
// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
//
// If multiple entries specify equivalent header names, the first entry with
// an equivalent name MUST be considered for a match. Subsequent entries
// with an equivalent header name MUST be ignored. Due to the
// case-insensitivity of header names, "foo" and "Foo" are considered
// equivalent.
func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierSetOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersRequestHeaderModifierSet) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Value is the value of HTTP Header to be matched.
func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierSetOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersRequestHeaderModifierSet) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesFiltersRequestHeaderModifierSet)(nil)).Elem()
}

func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput() GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput) Index(i pulumi.IntInput) GRPCRouteSpecRulesFiltersRequestHeaderModifierSetOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GRPCRouteSpecRulesFiltersRequestHeaderModifierSet {
		return vs[0].([]GRPCRouteSpecRulesFiltersRequestHeaderModifierSet)[vs[1].(int)]
	}).(GRPCRouteSpecRulesFiltersRequestHeaderModifierSetOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatch struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name *string `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value *string `pulumi:"value"`
}

// GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchInput is an input type that accepts GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchArgs and GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchInput` via:
//
//	GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchArgs{...}
type GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchOutput() GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchOutput
	ToGRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchOutputWithContext(context.Context) GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchOutput
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchArgs struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatch)(nil)).Elem()
}

func (i GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchArgs) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchOutput() GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchOutput {
	return i.ToGRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchArgs) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchOutput)
}

// GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayInput is an input type that accepts GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchArray and GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayInput` via:
//
//	GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchArray{ GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchArgs{...} }
type GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayOutput() GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayOutput
	ToGRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayOutputWithContext(context.Context) GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayOutput
}

type GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchArray []GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchInput

func (GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatch)(nil)).Elem()
}

func (i GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchArray) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayOutput() GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayOutput {
	return i.ToGRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchArray) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatch)(nil)).Elem()
}

func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchOutput) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchOutput() GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchOutput) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchOutput {
	return o
}

// Name is the name of the HTTP Header to be matched. Name matching MUST be
// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
//
// If multiple entries specify equivalent header names, the first entry with
// an equivalent name MUST be considered for a match. Subsequent entries
// with an equivalent header name MUST be ignored. Due to the
// case-insensitivity of header names, "foo" and "Foo" are considered
// equivalent.
func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Value is the value of HTTP Header to be matched.
func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatch) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatch)(nil)).Elem()
}

func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayOutput) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayOutput() GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayOutput) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayOutput) Index(i pulumi.IntInput) GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatch {
		return vs[0].([]GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatch)[vs[1].(int)]
	}).(GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchOutput)
}

// RequestMirror defines a schema for a filter that mirrors requests.
// Requests are sent to the specified destination, but responses from
// that destination are ignored.
//
// This filter can be used multiple times within the same rule. Note that
// not all implementations will be able to support mirroring to multiple
// backends.
//
// Support: Extended
type GRPCRouteSpecRulesFiltersRequestMirror struct {
	BackendRef *GRPCRouteSpecRulesFiltersRequestMirrorBackendRef `pulumi:"backendRef"`
}

// GRPCRouteSpecRulesFiltersRequestMirrorInput is an input type that accepts GRPCRouteSpecRulesFiltersRequestMirrorArgs and GRPCRouteSpecRulesFiltersRequestMirrorOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesFiltersRequestMirrorInput` via:
//
//	GRPCRouteSpecRulesFiltersRequestMirrorArgs{...}
type GRPCRouteSpecRulesFiltersRequestMirrorInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesFiltersRequestMirrorOutput() GRPCRouteSpecRulesFiltersRequestMirrorOutput
	ToGRPCRouteSpecRulesFiltersRequestMirrorOutputWithContext(context.Context) GRPCRouteSpecRulesFiltersRequestMirrorOutput
}

// RequestMirror defines a schema for a filter that mirrors requests.
// Requests are sent to the specified destination, but responses from
// that destination are ignored.
//
// This filter can be used multiple times within the same rule. Note that
// not all implementations will be able to support mirroring to multiple
// backends.
//
// Support: Extended
type GRPCRouteSpecRulesFiltersRequestMirrorArgs struct {
	BackendRef GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrInput `pulumi:"backendRef"`
}

func (GRPCRouteSpecRulesFiltersRequestMirrorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesFiltersRequestMirror)(nil)).Elem()
}

func (i GRPCRouteSpecRulesFiltersRequestMirrorArgs) ToGRPCRouteSpecRulesFiltersRequestMirrorOutput() GRPCRouteSpecRulesFiltersRequestMirrorOutput {
	return i.ToGRPCRouteSpecRulesFiltersRequestMirrorOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesFiltersRequestMirrorArgs) ToGRPCRouteSpecRulesFiltersRequestMirrorOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestMirrorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersRequestMirrorOutput)
}

func (i GRPCRouteSpecRulesFiltersRequestMirrorArgs) ToGRPCRouteSpecRulesFiltersRequestMirrorPtrOutput() GRPCRouteSpecRulesFiltersRequestMirrorPtrOutput {
	return i.ToGRPCRouteSpecRulesFiltersRequestMirrorPtrOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesFiltersRequestMirrorArgs) ToGRPCRouteSpecRulesFiltersRequestMirrorPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestMirrorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersRequestMirrorOutput).ToGRPCRouteSpecRulesFiltersRequestMirrorPtrOutputWithContext(ctx)
}

// GRPCRouteSpecRulesFiltersRequestMirrorPtrInput is an input type that accepts GRPCRouteSpecRulesFiltersRequestMirrorArgs, GRPCRouteSpecRulesFiltersRequestMirrorPtr and GRPCRouteSpecRulesFiltersRequestMirrorPtrOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesFiltersRequestMirrorPtrInput` via:
//
//	        GRPCRouteSpecRulesFiltersRequestMirrorArgs{...}
//
//	or:
//
//	        nil
type GRPCRouteSpecRulesFiltersRequestMirrorPtrInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesFiltersRequestMirrorPtrOutput() GRPCRouteSpecRulesFiltersRequestMirrorPtrOutput
	ToGRPCRouteSpecRulesFiltersRequestMirrorPtrOutputWithContext(context.Context) GRPCRouteSpecRulesFiltersRequestMirrorPtrOutput
}

type grpcrouteSpecRulesFiltersRequestMirrorPtrType GRPCRouteSpecRulesFiltersRequestMirrorArgs

func GRPCRouteSpecRulesFiltersRequestMirrorPtr(v *GRPCRouteSpecRulesFiltersRequestMirrorArgs) GRPCRouteSpecRulesFiltersRequestMirrorPtrInput {
	return (*grpcrouteSpecRulesFiltersRequestMirrorPtrType)(v)
}

func (*grpcrouteSpecRulesFiltersRequestMirrorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesFiltersRequestMirror)(nil)).Elem()
}

func (i *grpcrouteSpecRulesFiltersRequestMirrorPtrType) ToGRPCRouteSpecRulesFiltersRequestMirrorPtrOutput() GRPCRouteSpecRulesFiltersRequestMirrorPtrOutput {
	return i.ToGRPCRouteSpecRulesFiltersRequestMirrorPtrOutputWithContext(context.Background())
}

func (i *grpcrouteSpecRulesFiltersRequestMirrorPtrType) ToGRPCRouteSpecRulesFiltersRequestMirrorPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestMirrorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersRequestMirrorPtrOutput)
}

// RequestMirror defines a schema for a filter that mirrors requests.
// Requests are sent to the specified destination, but responses from
// that destination are ignored.
//
// This filter can be used multiple times within the same rule. Note that
// not all implementations will be able to support mirroring to multiple
// backends.
//
// Support: Extended
type GRPCRouteSpecRulesFiltersRequestMirrorOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesFiltersRequestMirrorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesFiltersRequestMirror)(nil)).Elem()
}

func (o GRPCRouteSpecRulesFiltersRequestMirrorOutput) ToGRPCRouteSpecRulesFiltersRequestMirrorOutput() GRPCRouteSpecRulesFiltersRequestMirrorOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersRequestMirrorOutput) ToGRPCRouteSpecRulesFiltersRequestMirrorOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestMirrorOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersRequestMirrorOutput) ToGRPCRouteSpecRulesFiltersRequestMirrorPtrOutput() GRPCRouteSpecRulesFiltersRequestMirrorPtrOutput {
	return o.ToGRPCRouteSpecRulesFiltersRequestMirrorPtrOutputWithContext(context.Background())
}

func (o GRPCRouteSpecRulesFiltersRequestMirrorOutput) ToGRPCRouteSpecRulesFiltersRequestMirrorPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestMirrorPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GRPCRouteSpecRulesFiltersRequestMirror) *GRPCRouteSpecRulesFiltersRequestMirror {
		return &v
	}).(GRPCRouteSpecRulesFiltersRequestMirrorPtrOutput)
}

func (o GRPCRouteSpecRulesFiltersRequestMirrorOutput) BackendRef() GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersRequestMirror) *GRPCRouteSpecRulesFiltersRequestMirrorBackendRef {
		return v.BackendRef
	}).(GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput)
}

type GRPCRouteSpecRulesFiltersRequestMirrorPtrOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesFiltersRequestMirrorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesFiltersRequestMirror)(nil)).Elem()
}

func (o GRPCRouteSpecRulesFiltersRequestMirrorPtrOutput) ToGRPCRouteSpecRulesFiltersRequestMirrorPtrOutput() GRPCRouteSpecRulesFiltersRequestMirrorPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersRequestMirrorPtrOutput) ToGRPCRouteSpecRulesFiltersRequestMirrorPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestMirrorPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersRequestMirrorPtrOutput) Elem() GRPCRouteSpecRulesFiltersRequestMirrorOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesFiltersRequestMirror) GRPCRouteSpecRulesFiltersRequestMirror {
		if v != nil {
			return *v
		}
		var ret GRPCRouteSpecRulesFiltersRequestMirror
		return ret
	}).(GRPCRouteSpecRulesFiltersRequestMirrorOutput)
}

func (o GRPCRouteSpecRulesFiltersRequestMirrorPtrOutput) BackendRef() GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesFiltersRequestMirror) *GRPCRouteSpecRulesFiltersRequestMirrorBackendRef {
		if v == nil {
			return nil
		}
		return v.BackendRef
	}).(GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput)
}

// BackendRef references a resource where mirrored requests are sent.
//
// Mirrored requests must be sent only to a single destination endpoint
// within this BackendRef, irrespective of how many endpoints are present
// within this BackendRef.
//
// If the referent cannot be found, this BackendRef is invalid and must be
// dropped from the Gateway. The controller must ensure the "ResolvedRefs"
// condition on the Route status is set to `status: False` and not configure
// this backend in the underlying implementation.
//
// If there is a cross-namespace reference to an *existing* object
// that is not allowed by a ReferenceGrant, the controller must ensure the
// "ResolvedRefs"  condition on the Route is set to `status: False`,
// with the "RefNotPermitted" reason and not configure this backend in the
// underlying implementation.
//
// In either error case, the Message of the `ResolvedRefs` Condition
// should be used to provide more detail about the problem.
//
// Support: Extended for Kubernetes Service
//
// Support: Implementation-specific for any other resource
type GRPCRouteSpecRulesFiltersRequestMirrorBackendRef struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group *string `pulumi:"group"`
	// Kind is the Kubernetes resource kind of the referent. For example
	// "Service".
	//
	// Defaults to "Service" when not specified.
	//
	// ExternalName services can refer to CNAME DNS records that may live
	// outside of the cluster and as such are difficult to reason about in
	// terms of conformance. They also may not be safe to forward to (see
	// CVE-2021-25740 for more information). Implementations SHOULD NOT
	// support ExternalName Services.
	//
	// Support: Core (Services with a type other than ExternalName)
	//
	// Support: Implementation-specific (Services with type ExternalName)
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	Name *string `pulumi:"name"`
	// Namespace is the namespace of the backend. When unspecified, the local
	// namespace is inferred.
	//
	// Note that when a namespace different than the local namespace is specified,
	// a ReferenceGrant object is required in the referent namespace to allow that
	// namespace's owner to accept the reference. See the ReferenceGrant
	// documentation for details.
	//
	// Support: Core
	Namespace *string `pulumi:"namespace"`
	// Port specifies the destination port number to use for this resource.
	// Port is required when the referent is a Kubernetes Service. In this
	// case, the port number is the service port number, not the target port.
	// For other resources, destination port might be derived from the referent
	// resource or this field.
	Port *int `pulumi:"port"`
}

// GRPCRouteSpecRulesFiltersRequestMirrorBackendRefInput is an input type that accepts GRPCRouteSpecRulesFiltersRequestMirrorBackendRefArgs and GRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesFiltersRequestMirrorBackendRefInput` via:
//
//	GRPCRouteSpecRulesFiltersRequestMirrorBackendRefArgs{...}
type GRPCRouteSpecRulesFiltersRequestMirrorBackendRefInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput() GRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput
	ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutputWithContext(context.Context) GRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput
}

// BackendRef references a resource where mirrored requests are sent.
//
// Mirrored requests must be sent only to a single destination endpoint
// within this BackendRef, irrespective of how many endpoints are present
// within this BackendRef.
//
// If the referent cannot be found, this BackendRef is invalid and must be
// dropped from the Gateway. The controller must ensure the "ResolvedRefs"
// condition on the Route status is set to `status: False` and not configure
// this backend in the underlying implementation.
//
// If there is a cross-namespace reference to an *existing* object
// that is not allowed by a ReferenceGrant, the controller must ensure the
// "ResolvedRefs"  condition on the Route is set to `status: False`,
// with the "RefNotPermitted" reason and not configure this backend in the
// underlying implementation.
//
// In either error case, the Message of the `ResolvedRefs` Condition
// should be used to provide more detail about the problem.
//
// Support: Extended for Kubernetes Service
//
// Support: Implementation-specific for any other resource
type GRPCRouteSpecRulesFiltersRequestMirrorBackendRefArgs struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is the Kubernetes resource kind of the referent. For example
	// "Service".
	//
	// Defaults to "Service" when not specified.
	//
	// ExternalName services can refer to CNAME DNS records that may live
	// outside of the cluster and as such are difficult to reason about in
	// terms of conformance. They also may not be safe to forward to (see
	// CVE-2021-25740 for more information). Implementations SHOULD NOT
	// support ExternalName Services.
	//
	// Support: Core (Services with a type other than ExternalName)
	//
	// Support: Implementation-specific (Services with type ExternalName)
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace is the namespace of the backend. When unspecified, the local
	// namespace is inferred.
	//
	// Note that when a namespace different than the local namespace is specified,
	// a ReferenceGrant object is required in the referent namespace to allow that
	// namespace's owner to accept the reference. See the ReferenceGrant
	// documentation for details.
	//
	// Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Port specifies the destination port number to use for this resource.
	// Port is required when the referent is a Kubernetes Service. In this
	// case, the port number is the service port number, not the target port.
	// For other resources, destination port might be derived from the referent
	// resource or this field.
	Port pulumi.IntPtrInput `pulumi:"port"`
}

func (GRPCRouteSpecRulesFiltersRequestMirrorBackendRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesFiltersRequestMirrorBackendRef)(nil)).Elem()
}

func (i GRPCRouteSpecRulesFiltersRequestMirrorBackendRefArgs) ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput() GRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput {
	return i.ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesFiltersRequestMirrorBackendRefArgs) ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput)
}

func (i GRPCRouteSpecRulesFiltersRequestMirrorBackendRefArgs) ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput() GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput {
	return i.ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesFiltersRequestMirrorBackendRefArgs) ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput).ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutputWithContext(ctx)
}

// GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrInput is an input type that accepts GRPCRouteSpecRulesFiltersRequestMirrorBackendRefArgs, GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtr and GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrInput` via:
//
//	        GRPCRouteSpecRulesFiltersRequestMirrorBackendRefArgs{...}
//
//	or:
//
//	        nil
type GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput() GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput
	ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutputWithContext(context.Context) GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput
}

type grpcrouteSpecRulesFiltersRequestMirrorBackendRefPtrType GRPCRouteSpecRulesFiltersRequestMirrorBackendRefArgs

func GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtr(v *GRPCRouteSpecRulesFiltersRequestMirrorBackendRefArgs) GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrInput {
	return (*grpcrouteSpecRulesFiltersRequestMirrorBackendRefPtrType)(v)
}

func (*grpcrouteSpecRulesFiltersRequestMirrorBackendRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesFiltersRequestMirrorBackendRef)(nil)).Elem()
}

func (i *grpcrouteSpecRulesFiltersRequestMirrorBackendRefPtrType) ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput() GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput {
	return i.ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutputWithContext(context.Background())
}

func (i *grpcrouteSpecRulesFiltersRequestMirrorBackendRefPtrType) ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput)
}

// BackendRef references a resource where mirrored requests are sent.
//
// Mirrored requests must be sent only to a single destination endpoint
// within this BackendRef, irrespective of how many endpoints are present
// within this BackendRef.
//
// If the referent cannot be found, this BackendRef is invalid and must be
// dropped from the Gateway. The controller must ensure the "ResolvedRefs"
// condition on the Route status is set to `status: False` and not configure
// this backend in the underlying implementation.
//
// If there is a cross-namespace reference to an *existing* object
// that is not allowed by a ReferenceGrant, the controller must ensure the
// "ResolvedRefs"  condition on the Route is set to `status: False`,
// with the "RefNotPermitted" reason and not configure this backend in the
// underlying implementation.
//
// In either error case, the Message of the `ResolvedRefs` Condition
// should be used to provide more detail about the problem.
//
// Support: Extended for Kubernetes Service
//
// Support: Implementation-specific for any other resource
type GRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesFiltersRequestMirrorBackendRef)(nil)).Elem()
}

func (o GRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput) ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput() GRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput) ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput) ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput() GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput {
	return o.ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutputWithContext(context.Background())
}

func (o GRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput) ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GRPCRouteSpecRulesFiltersRequestMirrorBackendRef) *GRPCRouteSpecRulesFiltersRequestMirrorBackendRef {
		return &v
	}).(GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o GRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersRequestMirrorBackendRef) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is the Kubernetes resource kind of the referent. For example
// "Service".
//
// Defaults to "Service" when not specified.
//
// ExternalName services can refer to CNAME DNS records that may live
// outside of the cluster and as such are difficult to reason about in
// terms of conformance. They also may not be safe to forward to (see
// CVE-2021-25740 for more information). Implementations SHOULD NOT
// support ExternalName Services.
//
// Support: Core (Services with a type other than ExternalName)
//
// Support: Implementation-specific (Services with type ExternalName)
func (o GRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersRequestMirrorBackendRef) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o GRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersRequestMirrorBackendRef) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the backend. When unspecified, the local
// namespace is inferred.
//
// Note that when a namespace different than the local namespace is specified,
// a ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// Support: Core
func (o GRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersRequestMirrorBackendRef) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Port specifies the destination port number to use for this resource.
// Port is required when the referent is a Kubernetes Service. In this
// case, the port number is the service port number, not the target port.
// For other resources, destination port might be derived from the referent
// resource or this field.
func (o GRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersRequestMirrorBackendRef) *int { return v.Port }).(pulumi.IntPtrOutput)
}

type GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesFiltersRequestMirrorBackendRef)(nil)).Elem()
}

func (o GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput) ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput() GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput) ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput) Elem() GRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesFiltersRequestMirrorBackendRef) GRPCRouteSpecRulesFiltersRequestMirrorBackendRef {
		if v != nil {
			return *v
		}
		var ret GRPCRouteSpecRulesFiltersRequestMirrorBackendRef
		return ret
	}).(GRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesFiltersRequestMirrorBackendRef) *string {
		if v == nil {
			return nil
		}
		return v.Group
	}).(pulumi.StringPtrOutput)
}

// Kind is the Kubernetes resource kind of the referent. For example
// "Service".
//
// Defaults to "Service" when not specified.
//
// ExternalName services can refer to CNAME DNS records that may live
// outside of the cluster and as such are difficult to reason about in
// terms of conformance. They also may not be safe to forward to (see
// CVE-2021-25740 for more information). Implementations SHOULD NOT
// support ExternalName Services.
//
// Support: Core (Services with a type other than ExternalName)
//
// Support: Implementation-specific (Services with type ExternalName)
func (o GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesFiltersRequestMirrorBackendRef) *string {
		if v == nil {
			return nil
		}
		return v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesFiltersRequestMirrorBackendRef) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the backend. When unspecified, the local
// namespace is inferred.
//
// Note that when a namespace different than the local namespace is specified,
// a ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// Support: Core
func (o GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesFiltersRequestMirrorBackendRef) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

// Port specifies the destination port number to use for this resource.
// Port is required when the referent is a Kubernetes Service. In this
// case, the port number is the service port number, not the target port.
// For other resources, destination port might be derived from the referent
// resource or this field.
func (o GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesFiltersRequestMirrorBackendRef) *int {
		if v == nil {
			return nil
		}
		return v.Port
	}).(pulumi.IntPtrOutput)
}

// BackendRef references a resource where mirrored requests are sent.
//
// Mirrored requests must be sent only to a single destination endpoint
// within this BackendRef, irrespective of how many endpoints are present
// within this BackendRef.
//
// If the referent cannot be found, this BackendRef is invalid and must be
// dropped from the Gateway. The controller must ensure the "ResolvedRefs"
// condition on the Route status is set to `status: False` and not configure
// this backend in the underlying implementation.
//
// If there is a cross-namespace reference to an *existing* object
// that is not allowed by a ReferenceGrant, the controller must ensure the
// "ResolvedRefs"  condition on the Route is set to `status: False`,
// with the "RefNotPermitted" reason and not configure this backend in the
// underlying implementation.
//
// In either error case, the Message of the `ResolvedRefs` Condition
// should be used to provide more detail about the problem.
//
// Support: Extended for Kubernetes Service
//
// Support: Implementation-specific for any other resource
type GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatch struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group *string `pulumi:"group"`
	// Kind is the Kubernetes resource kind of the referent. For example
	// "Service".
	//
	// Defaults to "Service" when not specified.
	//
	// ExternalName services can refer to CNAME DNS records that may live
	// outside of the cluster and as such are difficult to reason about in
	// terms of conformance. They also may not be safe to forward to (see
	// CVE-2021-25740 for more information). Implementations SHOULD NOT
	// support ExternalName Services.
	//
	// Support: Core (Services with a type other than ExternalName)
	//
	// Support: Implementation-specific (Services with type ExternalName)
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	Name *string `pulumi:"name"`
	// Namespace is the namespace of the backend. When unspecified, the local
	// namespace is inferred.
	//
	// Note that when a namespace different than the local namespace is specified,
	// a ReferenceGrant object is required in the referent namespace to allow that
	// namespace's owner to accept the reference. See the ReferenceGrant
	// documentation for details.
	//
	// Support: Core
	Namespace *string `pulumi:"namespace"`
	// Port specifies the destination port number to use for this resource.
	// Port is required when the referent is a Kubernetes Service. In this
	// case, the port number is the service port number, not the target port.
	// For other resources, destination port might be derived from the referent
	// resource or this field.
	Port *int `pulumi:"port"`
}

// GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchInput is an input type that accepts GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchArgs and GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchInput` via:
//
//	GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchArgs{...}
type GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutput() GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutput
	ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutputWithContext(context.Context) GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutput
}

// BackendRef references a resource where mirrored requests are sent.
//
// Mirrored requests must be sent only to a single destination endpoint
// within this BackendRef, irrespective of how many endpoints are present
// within this BackendRef.
//
// If the referent cannot be found, this BackendRef is invalid and must be
// dropped from the Gateway. The controller must ensure the "ResolvedRefs"
// condition on the Route status is set to `status: False` and not configure
// this backend in the underlying implementation.
//
// If there is a cross-namespace reference to an *existing* object
// that is not allowed by a ReferenceGrant, the controller must ensure the
// "ResolvedRefs"  condition on the Route is set to `status: False`,
// with the "RefNotPermitted" reason and not configure this backend in the
// underlying implementation.
//
// In either error case, the Message of the `ResolvedRefs` Condition
// should be used to provide more detail about the problem.
//
// Support: Extended for Kubernetes Service
//
// Support: Implementation-specific for any other resource
type GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchArgs struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is the Kubernetes resource kind of the referent. For example
	// "Service".
	//
	// Defaults to "Service" when not specified.
	//
	// ExternalName services can refer to CNAME DNS records that may live
	// outside of the cluster and as such are difficult to reason about in
	// terms of conformance. They also may not be safe to forward to (see
	// CVE-2021-25740 for more information). Implementations SHOULD NOT
	// support ExternalName Services.
	//
	// Support: Core (Services with a type other than ExternalName)
	//
	// Support: Implementation-specific (Services with type ExternalName)
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace is the namespace of the backend. When unspecified, the local
	// namespace is inferred.
	//
	// Note that when a namespace different than the local namespace is specified,
	// a ReferenceGrant object is required in the referent namespace to allow that
	// namespace's owner to accept the reference. See the ReferenceGrant
	// documentation for details.
	//
	// Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Port specifies the destination port number to use for this resource.
	// Port is required when the referent is a Kubernetes Service. In this
	// case, the port number is the service port number, not the target port.
	// For other resources, destination port might be derived from the referent
	// resource or this field.
	Port pulumi.IntPtrInput `pulumi:"port"`
}

func (GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatch)(nil)).Elem()
}

func (i GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchArgs) ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutput() GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutput {
	return i.ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchArgs) ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutput)
}

func (i GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchArgs) ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput() GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput {
	return i.ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchArgs) ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutput).ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutputWithContext(ctx)
}

// GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrInput is an input type that accepts GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchArgs, GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtr and GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrInput` via:
//
//	        GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchArgs{...}
//
//	or:
//
//	        nil
type GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput() GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput
	ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutputWithContext(context.Context) GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput
}

type grpcrouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrType GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchArgs

func GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtr(v *GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchArgs) GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrInput {
	return (*grpcrouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrType)(v)
}

func (*grpcrouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatch)(nil)).Elem()
}

func (i *grpcrouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrType) ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput() GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput {
	return i.ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutputWithContext(context.Background())
}

func (i *grpcrouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrType) ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput)
}

// BackendRef references a resource where mirrored requests are sent.
//
// Mirrored requests must be sent only to a single destination endpoint
// within this BackendRef, irrespective of how many endpoints are present
// within this BackendRef.
//
// If the referent cannot be found, this BackendRef is invalid and must be
// dropped from the Gateway. The controller must ensure the "ResolvedRefs"
// condition on the Route status is set to `status: False` and not configure
// this backend in the underlying implementation.
//
// If there is a cross-namespace reference to an *existing* object
// that is not allowed by a ReferenceGrant, the controller must ensure the
// "ResolvedRefs"  condition on the Route is set to `status: False`,
// with the "RefNotPermitted" reason and not configure this backend in the
// underlying implementation.
//
// In either error case, the Message of the `ResolvedRefs` Condition
// should be used to provide more detail about the problem.
//
// Support: Extended for Kubernetes Service
//
// Support: Implementation-specific for any other resource
type GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatch)(nil)).Elem()
}

func (o GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutput) ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutput() GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutput) ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutput) ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput() GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput {
	return o.ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutputWithContext(context.Background())
}

func (o GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutput) ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatch) *GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatch {
		return &v
	}).(GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatch) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is the Kubernetes resource kind of the referent. For example
// "Service".
//
// Defaults to "Service" when not specified.
//
// ExternalName services can refer to CNAME DNS records that may live
// outside of the cluster and as such are difficult to reason about in
// terms of conformance. They also may not be safe to forward to (see
// CVE-2021-25740 for more information). Implementations SHOULD NOT
// support ExternalName Services.
//
// Support: Core (Services with a type other than ExternalName)
//
// Support: Implementation-specific (Services with type ExternalName)
func (o GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatch) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the backend. When unspecified, the local
// namespace is inferred.
//
// Note that when a namespace different than the local namespace is specified,
// a ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// Support: Core
func (o GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatch) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Port specifies the destination port number to use for this resource.
// Port is required when the referent is a Kubernetes Service. In this
// case, the port number is the service port number, not the target port.
// For other resources, destination port might be derived from the referent
// resource or this field.
func (o GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatch) *int { return v.Port }).(pulumi.IntPtrOutput)
}

type GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatch)(nil)).Elem()
}

func (o GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput) ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput() GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput) ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput) Elem() GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatch) GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatch {
		if v != nil {
			return *v
		}
		var ret GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatch
		return ret
	}).(GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Group
	}).(pulumi.StringPtrOutput)
}

// Kind is the Kubernetes resource kind of the referent. For example
// "Service".
//
// Defaults to "Service" when not specified.
//
// ExternalName services can refer to CNAME DNS records that may live
// outside of the cluster and as such are difficult to reason about in
// terms of conformance. They also may not be safe to forward to (see
// CVE-2021-25740 for more information). Implementations SHOULD NOT
// support ExternalName Services.
//
// Support: Core (Services with a type other than ExternalName)
//
// Support: Implementation-specific (Services with type ExternalName)
func (o GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the backend. When unspecified, the local
// namespace is inferred.
//
// Note that when a namespace different than the local namespace is specified,
// a ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// Support: Core
func (o GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

// Port specifies the destination port number to use for this resource.
// Port is required when the referent is a Kubernetes Service. In this
// case, the port number is the service port number, not the target port.
// For other resources, destination port might be derived from the referent
// resource or this field.
func (o GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatch) *int {
		if v == nil {
			return nil
		}
		return v.Port
	}).(pulumi.IntPtrOutput)
}

// RequestMirror defines a schema for a filter that mirrors requests.
// Requests are sent to the specified destination, but responses from
// that destination are ignored.
//
// This filter can be used multiple times within the same rule. Note that
// not all implementations will be able to support mirroring to multiple
// backends.
//
// Support: Extended
type GRPCRouteSpecRulesFiltersRequestMirrorPatch struct {
	BackendRef *GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatch `pulumi:"backendRef"`
}

// GRPCRouteSpecRulesFiltersRequestMirrorPatchInput is an input type that accepts GRPCRouteSpecRulesFiltersRequestMirrorPatchArgs and GRPCRouteSpecRulesFiltersRequestMirrorPatchOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesFiltersRequestMirrorPatchInput` via:
//
//	GRPCRouteSpecRulesFiltersRequestMirrorPatchArgs{...}
type GRPCRouteSpecRulesFiltersRequestMirrorPatchInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesFiltersRequestMirrorPatchOutput() GRPCRouteSpecRulesFiltersRequestMirrorPatchOutput
	ToGRPCRouteSpecRulesFiltersRequestMirrorPatchOutputWithContext(context.Context) GRPCRouteSpecRulesFiltersRequestMirrorPatchOutput
}

// RequestMirror defines a schema for a filter that mirrors requests.
// Requests are sent to the specified destination, but responses from
// that destination are ignored.
//
// This filter can be used multiple times within the same rule. Note that
// not all implementations will be able to support mirroring to multiple
// backends.
//
// Support: Extended
type GRPCRouteSpecRulesFiltersRequestMirrorPatchArgs struct {
	BackendRef GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrInput `pulumi:"backendRef"`
}

func (GRPCRouteSpecRulesFiltersRequestMirrorPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesFiltersRequestMirrorPatch)(nil)).Elem()
}

func (i GRPCRouteSpecRulesFiltersRequestMirrorPatchArgs) ToGRPCRouteSpecRulesFiltersRequestMirrorPatchOutput() GRPCRouteSpecRulesFiltersRequestMirrorPatchOutput {
	return i.ToGRPCRouteSpecRulesFiltersRequestMirrorPatchOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesFiltersRequestMirrorPatchArgs) ToGRPCRouteSpecRulesFiltersRequestMirrorPatchOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestMirrorPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersRequestMirrorPatchOutput)
}

func (i GRPCRouteSpecRulesFiltersRequestMirrorPatchArgs) ToGRPCRouteSpecRulesFiltersRequestMirrorPatchPtrOutput() GRPCRouteSpecRulesFiltersRequestMirrorPatchPtrOutput {
	return i.ToGRPCRouteSpecRulesFiltersRequestMirrorPatchPtrOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesFiltersRequestMirrorPatchArgs) ToGRPCRouteSpecRulesFiltersRequestMirrorPatchPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestMirrorPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersRequestMirrorPatchOutput).ToGRPCRouteSpecRulesFiltersRequestMirrorPatchPtrOutputWithContext(ctx)
}

// GRPCRouteSpecRulesFiltersRequestMirrorPatchPtrInput is an input type that accepts GRPCRouteSpecRulesFiltersRequestMirrorPatchArgs, GRPCRouteSpecRulesFiltersRequestMirrorPatchPtr and GRPCRouteSpecRulesFiltersRequestMirrorPatchPtrOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesFiltersRequestMirrorPatchPtrInput` via:
//
//	        GRPCRouteSpecRulesFiltersRequestMirrorPatchArgs{...}
//
//	or:
//
//	        nil
type GRPCRouteSpecRulesFiltersRequestMirrorPatchPtrInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesFiltersRequestMirrorPatchPtrOutput() GRPCRouteSpecRulesFiltersRequestMirrorPatchPtrOutput
	ToGRPCRouteSpecRulesFiltersRequestMirrorPatchPtrOutputWithContext(context.Context) GRPCRouteSpecRulesFiltersRequestMirrorPatchPtrOutput
}

type grpcrouteSpecRulesFiltersRequestMirrorPatchPtrType GRPCRouteSpecRulesFiltersRequestMirrorPatchArgs

func GRPCRouteSpecRulesFiltersRequestMirrorPatchPtr(v *GRPCRouteSpecRulesFiltersRequestMirrorPatchArgs) GRPCRouteSpecRulesFiltersRequestMirrorPatchPtrInput {
	return (*grpcrouteSpecRulesFiltersRequestMirrorPatchPtrType)(v)
}

func (*grpcrouteSpecRulesFiltersRequestMirrorPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesFiltersRequestMirrorPatch)(nil)).Elem()
}

func (i *grpcrouteSpecRulesFiltersRequestMirrorPatchPtrType) ToGRPCRouteSpecRulesFiltersRequestMirrorPatchPtrOutput() GRPCRouteSpecRulesFiltersRequestMirrorPatchPtrOutput {
	return i.ToGRPCRouteSpecRulesFiltersRequestMirrorPatchPtrOutputWithContext(context.Background())
}

func (i *grpcrouteSpecRulesFiltersRequestMirrorPatchPtrType) ToGRPCRouteSpecRulesFiltersRequestMirrorPatchPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestMirrorPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersRequestMirrorPatchPtrOutput)
}

// RequestMirror defines a schema for a filter that mirrors requests.
// Requests are sent to the specified destination, but responses from
// that destination are ignored.
//
// This filter can be used multiple times within the same rule. Note that
// not all implementations will be able to support mirroring to multiple
// backends.
//
// Support: Extended
type GRPCRouteSpecRulesFiltersRequestMirrorPatchOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesFiltersRequestMirrorPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesFiltersRequestMirrorPatch)(nil)).Elem()
}

func (o GRPCRouteSpecRulesFiltersRequestMirrorPatchOutput) ToGRPCRouteSpecRulesFiltersRequestMirrorPatchOutput() GRPCRouteSpecRulesFiltersRequestMirrorPatchOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersRequestMirrorPatchOutput) ToGRPCRouteSpecRulesFiltersRequestMirrorPatchOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestMirrorPatchOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersRequestMirrorPatchOutput) ToGRPCRouteSpecRulesFiltersRequestMirrorPatchPtrOutput() GRPCRouteSpecRulesFiltersRequestMirrorPatchPtrOutput {
	return o.ToGRPCRouteSpecRulesFiltersRequestMirrorPatchPtrOutputWithContext(context.Background())
}

func (o GRPCRouteSpecRulesFiltersRequestMirrorPatchOutput) ToGRPCRouteSpecRulesFiltersRequestMirrorPatchPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestMirrorPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GRPCRouteSpecRulesFiltersRequestMirrorPatch) *GRPCRouteSpecRulesFiltersRequestMirrorPatch {
		return &v
	}).(GRPCRouteSpecRulesFiltersRequestMirrorPatchPtrOutput)
}

func (o GRPCRouteSpecRulesFiltersRequestMirrorPatchOutput) BackendRef() GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersRequestMirrorPatch) *GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatch {
		return v.BackendRef
	}).(GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput)
}

type GRPCRouteSpecRulesFiltersRequestMirrorPatchPtrOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesFiltersRequestMirrorPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesFiltersRequestMirrorPatch)(nil)).Elem()
}

func (o GRPCRouteSpecRulesFiltersRequestMirrorPatchPtrOutput) ToGRPCRouteSpecRulesFiltersRequestMirrorPatchPtrOutput() GRPCRouteSpecRulesFiltersRequestMirrorPatchPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersRequestMirrorPatchPtrOutput) ToGRPCRouteSpecRulesFiltersRequestMirrorPatchPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestMirrorPatchPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersRequestMirrorPatchPtrOutput) Elem() GRPCRouteSpecRulesFiltersRequestMirrorPatchOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesFiltersRequestMirrorPatch) GRPCRouteSpecRulesFiltersRequestMirrorPatch {
		if v != nil {
			return *v
		}
		var ret GRPCRouteSpecRulesFiltersRequestMirrorPatch
		return ret
	}).(GRPCRouteSpecRulesFiltersRequestMirrorPatchOutput)
}

func (o GRPCRouteSpecRulesFiltersRequestMirrorPatchPtrOutput) BackendRef() GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesFiltersRequestMirrorPatch) *GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatch {
		if v == nil {
			return nil
		}
		return v.BackendRef
	}).(GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput)
}

// ResponseHeaderModifier defines a schema for a filter that modifies response
// headers.
//
// Support: Extended
type GRPCRouteSpecRulesFiltersResponseHeaderModifier struct {
	// Add adds the given header(s) (name, value) to the request
	// before the action. It appends to any existing values associated
	// with the header name.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   add:
	//   - name: "my-header"
	//     value: "bar,baz"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: foo,bar,baz
	Add []GRPCRouteSpecRulesFiltersResponseHeaderModifierAdd `pulumi:"add"`
	// Remove the given header(s) from the HTTP request before the action. The
	// value of Remove is a list of HTTP header names. Note that the header
	// names are case-insensitive (see
	// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header1: foo
	//   my-header2: bar
	//   my-header3: baz
	//
	// Config:
	//   remove: ["my-header1", "my-header3"]
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header2: bar
	Remove []string `pulumi:"remove"`
	// Set overwrites the request with the given header (name, value)
	// before the action.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   set:
	//   - name: "my-header"
	//     value: "bar"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: bar
	Set []GRPCRouteSpecRulesFiltersResponseHeaderModifierSet `pulumi:"set"`
}

// GRPCRouteSpecRulesFiltersResponseHeaderModifierInput is an input type that accepts GRPCRouteSpecRulesFiltersResponseHeaderModifierArgs and GRPCRouteSpecRulesFiltersResponseHeaderModifierOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesFiltersResponseHeaderModifierInput` via:
//
//	GRPCRouteSpecRulesFiltersResponseHeaderModifierArgs{...}
type GRPCRouteSpecRulesFiltersResponseHeaderModifierInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesFiltersResponseHeaderModifierOutput() GRPCRouteSpecRulesFiltersResponseHeaderModifierOutput
	ToGRPCRouteSpecRulesFiltersResponseHeaderModifierOutputWithContext(context.Context) GRPCRouteSpecRulesFiltersResponseHeaderModifierOutput
}

// ResponseHeaderModifier defines a schema for a filter that modifies response
// headers.
//
// Support: Extended
type GRPCRouteSpecRulesFiltersResponseHeaderModifierArgs struct {
	// Add adds the given header(s) (name, value) to the request
	// before the action. It appends to any existing values associated
	// with the header name.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   add:
	//   - name: "my-header"
	//     value: "bar,baz"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: foo,bar,baz
	Add GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayInput `pulumi:"add"`
	// Remove the given header(s) from the HTTP request before the action. The
	// value of Remove is a list of HTTP header names. Note that the header
	// names are case-insensitive (see
	// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header1: foo
	//   my-header2: bar
	//   my-header3: baz
	//
	// Config:
	//   remove: ["my-header1", "my-header3"]
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header2: bar
	Remove pulumi.StringArrayInput `pulumi:"remove"`
	// Set overwrites the request with the given header (name, value)
	// before the action.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   set:
	//   - name: "my-header"
	//     value: "bar"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: bar
	Set GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayInput `pulumi:"set"`
}

func (GRPCRouteSpecRulesFiltersResponseHeaderModifierArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesFiltersResponseHeaderModifier)(nil)).Elem()
}

func (i GRPCRouteSpecRulesFiltersResponseHeaderModifierArgs) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierOutput() GRPCRouteSpecRulesFiltersResponseHeaderModifierOutput {
	return i.ToGRPCRouteSpecRulesFiltersResponseHeaderModifierOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesFiltersResponseHeaderModifierArgs) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersResponseHeaderModifierOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersResponseHeaderModifierOutput)
}

func (i GRPCRouteSpecRulesFiltersResponseHeaderModifierArgs) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput() GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput {
	return i.ToGRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesFiltersResponseHeaderModifierArgs) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersResponseHeaderModifierOutput).ToGRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutputWithContext(ctx)
}

// GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrInput is an input type that accepts GRPCRouteSpecRulesFiltersResponseHeaderModifierArgs, GRPCRouteSpecRulesFiltersResponseHeaderModifierPtr and GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrInput` via:
//
//	        GRPCRouteSpecRulesFiltersResponseHeaderModifierArgs{...}
//
//	or:
//
//	        nil
type GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput() GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput
	ToGRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutputWithContext(context.Context) GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput
}

type grpcrouteSpecRulesFiltersResponseHeaderModifierPtrType GRPCRouteSpecRulesFiltersResponseHeaderModifierArgs

func GRPCRouteSpecRulesFiltersResponseHeaderModifierPtr(v *GRPCRouteSpecRulesFiltersResponseHeaderModifierArgs) GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrInput {
	return (*grpcrouteSpecRulesFiltersResponseHeaderModifierPtrType)(v)
}

func (*grpcrouteSpecRulesFiltersResponseHeaderModifierPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesFiltersResponseHeaderModifier)(nil)).Elem()
}

func (i *grpcrouteSpecRulesFiltersResponseHeaderModifierPtrType) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput() GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput {
	return i.ToGRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutputWithContext(context.Background())
}

func (i *grpcrouteSpecRulesFiltersResponseHeaderModifierPtrType) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput)
}

// ResponseHeaderModifier defines a schema for a filter that modifies response
// headers.
//
// Support: Extended
type GRPCRouteSpecRulesFiltersResponseHeaderModifierOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesFiltersResponseHeaderModifierOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesFiltersResponseHeaderModifier)(nil)).Elem()
}

func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierOutput) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierOutput() GRPCRouteSpecRulesFiltersResponseHeaderModifierOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierOutput) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersResponseHeaderModifierOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierOutput) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput() GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput {
	return o.ToGRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutputWithContext(context.Background())
}

func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierOutput) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GRPCRouteSpecRulesFiltersResponseHeaderModifier) *GRPCRouteSpecRulesFiltersResponseHeaderModifier {
		return &v
	}).(GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput)
}

// Add adds the given header(s) (name, value) to the request
// before the action. It appends to any existing values associated
// with the header name.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	add:
//	- name: "my-header"
//	  value: "bar,baz"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: foo,bar,baz
func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierOutput) Add() GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersResponseHeaderModifier) []GRPCRouteSpecRulesFiltersResponseHeaderModifierAdd {
		return v.Add
	}).(GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput)
}

// Remove the given header(s) from the HTTP request before the action. The
// value of Remove is a list of HTTP header names. Note that the header
// names are case-insensitive (see
// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header1: foo
//	my-header2: bar
//	my-header3: baz
//
// Config:
//
//	remove: ["my-header1", "my-header3"]
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header2: bar
func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierOutput) Remove() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersResponseHeaderModifier) []string { return v.Remove }).(pulumi.StringArrayOutput)
}

// Set overwrites the request with the given header (name, value)
// before the action.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	set:
//	- name: "my-header"
//	  value: "bar"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: bar
func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierOutput) Set() GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersResponseHeaderModifier) []GRPCRouteSpecRulesFiltersResponseHeaderModifierSet {
		return v.Set
	}).(GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput)
}

type GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesFiltersResponseHeaderModifier)(nil)).Elem()
}

func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput() GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput) Elem() GRPCRouteSpecRulesFiltersResponseHeaderModifierOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesFiltersResponseHeaderModifier) GRPCRouteSpecRulesFiltersResponseHeaderModifier {
		if v != nil {
			return *v
		}
		var ret GRPCRouteSpecRulesFiltersResponseHeaderModifier
		return ret
	}).(GRPCRouteSpecRulesFiltersResponseHeaderModifierOutput)
}

// Add adds the given header(s) (name, value) to the request
// before the action. It appends to any existing values associated
// with the header name.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	add:
//	- name: "my-header"
//	  value: "bar,baz"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: foo,bar,baz
func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput) Add() GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesFiltersResponseHeaderModifier) []GRPCRouteSpecRulesFiltersResponseHeaderModifierAdd {
		if v == nil {
			return nil
		}
		return v.Add
	}).(GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput)
}

// Remove the given header(s) from the HTTP request before the action. The
// value of Remove is a list of HTTP header names. Note that the header
// names are case-insensitive (see
// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header1: foo
//	my-header2: bar
//	my-header3: baz
//
// Config:
//
//	remove: ["my-header1", "my-header3"]
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header2: bar
func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput) Remove() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesFiltersResponseHeaderModifier) []string {
		if v == nil {
			return nil
		}
		return v.Remove
	}).(pulumi.StringArrayOutput)
}

// Set overwrites the request with the given header (name, value)
// before the action.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	set:
//	- name: "my-header"
//	  value: "bar"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: bar
func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput) Set() GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesFiltersResponseHeaderModifier) []GRPCRouteSpecRulesFiltersResponseHeaderModifierSet {
		if v == nil {
			return nil
		}
		return v.Set
	}).(GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesFiltersResponseHeaderModifierAdd struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name *string `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value *string `pulumi:"value"`
}

// GRPCRouteSpecRulesFiltersResponseHeaderModifierAddInput is an input type that accepts GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArgs and GRPCRouteSpecRulesFiltersResponseHeaderModifierAddOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesFiltersResponseHeaderModifierAddInput` via:
//
//	GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArgs{...}
type GRPCRouteSpecRulesFiltersResponseHeaderModifierAddInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesFiltersResponseHeaderModifierAddOutput() GRPCRouteSpecRulesFiltersResponseHeaderModifierAddOutput
	ToGRPCRouteSpecRulesFiltersResponseHeaderModifierAddOutputWithContext(context.Context) GRPCRouteSpecRulesFiltersResponseHeaderModifierAddOutput
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArgs struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesFiltersResponseHeaderModifierAdd)(nil)).Elem()
}

func (i GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArgs) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierAddOutput() GRPCRouteSpecRulesFiltersResponseHeaderModifierAddOutput {
	return i.ToGRPCRouteSpecRulesFiltersResponseHeaderModifierAddOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArgs) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierAddOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersResponseHeaderModifierAddOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersResponseHeaderModifierAddOutput)
}

// GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayInput is an input type that accepts GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArray and GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayInput` via:
//
//	GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArray{ GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArgs{...} }
type GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput() GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput
	ToGRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutputWithContext(context.Context) GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput
}

type GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArray []GRPCRouteSpecRulesFiltersResponseHeaderModifierAddInput

func (GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesFiltersResponseHeaderModifierAdd)(nil)).Elem()
}

func (i GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArray) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput() GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput {
	return i.ToGRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArray) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesFiltersResponseHeaderModifierAddOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesFiltersResponseHeaderModifierAddOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesFiltersResponseHeaderModifierAdd)(nil)).Elem()
}

func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierAddOutput) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierAddOutput() GRPCRouteSpecRulesFiltersResponseHeaderModifierAddOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierAddOutput) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierAddOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersResponseHeaderModifierAddOutput {
	return o
}

// Name is the name of the HTTP Header to be matched. Name matching MUST be
// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
//
// If multiple entries specify equivalent header names, the first entry with
// an equivalent name MUST be considered for a match. Subsequent entries
// with an equivalent header name MUST be ignored. Due to the
// case-insensitivity of header names, "foo" and "Foo" are considered
// equivalent.
func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierAddOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersResponseHeaderModifierAdd) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Value is the value of HTTP Header to be matched.
func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierAddOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersResponseHeaderModifierAdd) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesFiltersResponseHeaderModifierAdd)(nil)).Elem()
}

func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput() GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput) Index(i pulumi.IntInput) GRPCRouteSpecRulesFiltersResponseHeaderModifierAddOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GRPCRouteSpecRulesFiltersResponseHeaderModifierAdd {
		return vs[0].([]GRPCRouteSpecRulesFiltersResponseHeaderModifierAdd)[vs[1].(int)]
	}).(GRPCRouteSpecRulesFiltersResponseHeaderModifierAddOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatch struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name *string `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value *string `pulumi:"value"`
}

// GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchInput is an input type that accepts GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchArgs and GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchInput` via:
//
//	GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchArgs{...}
type GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchOutput() GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchOutput
	ToGRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchOutputWithContext(context.Context) GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchOutput
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchArgs struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatch)(nil)).Elem()
}

func (i GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchArgs) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchOutput() GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchOutput {
	return i.ToGRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchArgs) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchOutput)
}

// GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayInput is an input type that accepts GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchArray and GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayInput` via:
//
//	GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchArray{ GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchArgs{...} }
type GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayOutput() GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayOutput
	ToGRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayOutputWithContext(context.Context) GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayOutput
}

type GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchArray []GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchInput

func (GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatch)(nil)).Elem()
}

func (i GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchArray) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayOutput() GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayOutput {
	return i.ToGRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchArray) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatch)(nil)).Elem()
}

func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchOutput) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchOutput() GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchOutput) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchOutput {
	return o
}

// Name is the name of the HTTP Header to be matched. Name matching MUST be
// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
//
// If multiple entries specify equivalent header names, the first entry with
// an equivalent name MUST be considered for a match. Subsequent entries
// with an equivalent header name MUST be ignored. Due to the
// case-insensitivity of header names, "foo" and "Foo" are considered
// equivalent.
func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Value is the value of HTTP Header to be matched.
func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatch) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatch)(nil)).Elem()
}

func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayOutput) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayOutput() GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayOutput) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayOutput) Index(i pulumi.IntInput) GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatch {
		return vs[0].([]GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatch)[vs[1].(int)]
	}).(GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchOutput)
}

// ResponseHeaderModifier defines a schema for a filter that modifies response
// headers.
//
// Support: Extended
type GRPCRouteSpecRulesFiltersResponseHeaderModifierPatch struct {
	// Add adds the given header(s) (name, value) to the request
	// before the action. It appends to any existing values associated
	// with the header name.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   add:
	//   - name: "my-header"
	//     value: "bar,baz"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: foo,bar,baz
	Add []GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatch `pulumi:"add"`
	// Remove the given header(s) from the HTTP request before the action. The
	// value of Remove is a list of HTTP header names. Note that the header
	// names are case-insensitive (see
	// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header1: foo
	//   my-header2: bar
	//   my-header3: baz
	//
	// Config:
	//   remove: ["my-header1", "my-header3"]
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header2: bar
	Remove []string `pulumi:"remove"`
	// Set overwrites the request with the given header (name, value)
	// before the action.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   set:
	//   - name: "my-header"
	//     value: "bar"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: bar
	Set []GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatch `pulumi:"set"`
}

// GRPCRouteSpecRulesFiltersResponseHeaderModifierPatchInput is an input type that accepts GRPCRouteSpecRulesFiltersResponseHeaderModifierPatchArgs and GRPCRouteSpecRulesFiltersResponseHeaderModifierPatchOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesFiltersResponseHeaderModifierPatchInput` via:
//
//	GRPCRouteSpecRulesFiltersResponseHeaderModifierPatchArgs{...}
type GRPCRouteSpecRulesFiltersResponseHeaderModifierPatchInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesFiltersResponseHeaderModifierPatchOutput() GRPCRouteSpecRulesFiltersResponseHeaderModifierPatchOutput
	ToGRPCRouteSpecRulesFiltersResponseHeaderModifierPatchOutputWithContext(context.Context) GRPCRouteSpecRulesFiltersResponseHeaderModifierPatchOutput
}

// ResponseHeaderModifier defines a schema for a filter that modifies response
// headers.
//
// Support: Extended
type GRPCRouteSpecRulesFiltersResponseHeaderModifierPatchArgs struct {
	// Add adds the given header(s) (name, value) to the request
	// before the action. It appends to any existing values associated
	// with the header name.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   add:
	//   - name: "my-header"
	//     value: "bar,baz"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: foo,bar,baz
	Add GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayInput `pulumi:"add"`
	// Remove the given header(s) from the HTTP request before the action. The
	// value of Remove is a list of HTTP header names. Note that the header
	// names are case-insensitive (see
	// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header1: foo
	//   my-header2: bar
	//   my-header3: baz
	//
	// Config:
	//   remove: ["my-header1", "my-header3"]
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header2: bar
	Remove pulumi.StringArrayInput `pulumi:"remove"`
	// Set overwrites the request with the given header (name, value)
	// before the action.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   set:
	//   - name: "my-header"
	//     value: "bar"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: bar
	Set GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayInput `pulumi:"set"`
}

func (GRPCRouteSpecRulesFiltersResponseHeaderModifierPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesFiltersResponseHeaderModifierPatch)(nil)).Elem()
}

func (i GRPCRouteSpecRulesFiltersResponseHeaderModifierPatchArgs) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierPatchOutput() GRPCRouteSpecRulesFiltersResponseHeaderModifierPatchOutput {
	return i.ToGRPCRouteSpecRulesFiltersResponseHeaderModifierPatchOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesFiltersResponseHeaderModifierPatchArgs) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierPatchOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersResponseHeaderModifierPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersResponseHeaderModifierPatchOutput)
}

func (i GRPCRouteSpecRulesFiltersResponseHeaderModifierPatchArgs) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput() GRPCRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput {
	return i.ToGRPCRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesFiltersResponseHeaderModifierPatchArgs) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersResponseHeaderModifierPatchOutput).ToGRPCRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutputWithContext(ctx)
}

// GRPCRouteSpecRulesFiltersResponseHeaderModifierPatchPtrInput is an input type that accepts GRPCRouteSpecRulesFiltersResponseHeaderModifierPatchArgs, GRPCRouteSpecRulesFiltersResponseHeaderModifierPatchPtr and GRPCRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesFiltersResponseHeaderModifierPatchPtrInput` via:
//
//	        GRPCRouteSpecRulesFiltersResponseHeaderModifierPatchArgs{...}
//
//	or:
//
//	        nil
type GRPCRouteSpecRulesFiltersResponseHeaderModifierPatchPtrInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput() GRPCRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput
	ToGRPCRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutputWithContext(context.Context) GRPCRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput
}

type grpcrouteSpecRulesFiltersResponseHeaderModifierPatchPtrType GRPCRouteSpecRulesFiltersResponseHeaderModifierPatchArgs

func GRPCRouteSpecRulesFiltersResponseHeaderModifierPatchPtr(v *GRPCRouteSpecRulesFiltersResponseHeaderModifierPatchArgs) GRPCRouteSpecRulesFiltersResponseHeaderModifierPatchPtrInput {
	return (*grpcrouteSpecRulesFiltersResponseHeaderModifierPatchPtrType)(v)
}

func (*grpcrouteSpecRulesFiltersResponseHeaderModifierPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesFiltersResponseHeaderModifierPatch)(nil)).Elem()
}

func (i *grpcrouteSpecRulesFiltersResponseHeaderModifierPatchPtrType) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput() GRPCRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput {
	return i.ToGRPCRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutputWithContext(context.Background())
}

func (i *grpcrouteSpecRulesFiltersResponseHeaderModifierPatchPtrType) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput)
}

// ResponseHeaderModifier defines a schema for a filter that modifies response
// headers.
//
// Support: Extended
type GRPCRouteSpecRulesFiltersResponseHeaderModifierPatchOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesFiltersResponseHeaderModifierPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesFiltersResponseHeaderModifierPatch)(nil)).Elem()
}

func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierPatchOutput) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierPatchOutput() GRPCRouteSpecRulesFiltersResponseHeaderModifierPatchOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierPatchOutput) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierPatchOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersResponseHeaderModifierPatchOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierPatchOutput) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput() GRPCRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput {
	return o.ToGRPCRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutputWithContext(context.Background())
}

func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierPatchOutput) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GRPCRouteSpecRulesFiltersResponseHeaderModifierPatch) *GRPCRouteSpecRulesFiltersResponseHeaderModifierPatch {
		return &v
	}).(GRPCRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput)
}

// Add adds the given header(s) (name, value) to the request
// before the action. It appends to any existing values associated
// with the header name.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	add:
//	- name: "my-header"
//	  value: "bar,baz"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: foo,bar,baz
func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierPatchOutput) Add() GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersResponseHeaderModifierPatch) []GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatch {
		return v.Add
	}).(GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayOutput)
}

// Remove the given header(s) from the HTTP request before the action. The
// value of Remove is a list of HTTP header names. Note that the header
// names are case-insensitive (see
// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header1: foo
//	my-header2: bar
//	my-header3: baz
//
// Config:
//
//	remove: ["my-header1", "my-header3"]
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header2: bar
func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierPatchOutput) Remove() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersResponseHeaderModifierPatch) []string { return v.Remove }).(pulumi.StringArrayOutput)
}

// Set overwrites the request with the given header (name, value)
// before the action.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	set:
//	- name: "my-header"
//	  value: "bar"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: bar
func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierPatchOutput) Set() GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersResponseHeaderModifierPatch) []GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatch {
		return v.Set
	}).(GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayOutput)
}

type GRPCRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesFiltersResponseHeaderModifierPatch)(nil)).Elem()
}

func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput() GRPCRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput) Elem() GRPCRouteSpecRulesFiltersResponseHeaderModifierPatchOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesFiltersResponseHeaderModifierPatch) GRPCRouteSpecRulesFiltersResponseHeaderModifierPatch {
		if v != nil {
			return *v
		}
		var ret GRPCRouteSpecRulesFiltersResponseHeaderModifierPatch
		return ret
	}).(GRPCRouteSpecRulesFiltersResponseHeaderModifierPatchOutput)
}

// Add adds the given header(s) (name, value) to the request
// before the action. It appends to any existing values associated
// with the header name.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	add:
//	- name: "my-header"
//	  value: "bar,baz"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: foo,bar,baz
func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput) Add() GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesFiltersResponseHeaderModifierPatch) []GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatch {
		if v == nil {
			return nil
		}
		return v.Add
	}).(GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayOutput)
}

// Remove the given header(s) from the HTTP request before the action. The
// value of Remove is a list of HTTP header names. Note that the header
// names are case-insensitive (see
// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header1: foo
//	my-header2: bar
//	my-header3: baz
//
// Config:
//
//	remove: ["my-header1", "my-header3"]
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header2: bar
func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput) Remove() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesFiltersResponseHeaderModifierPatch) []string {
		if v == nil {
			return nil
		}
		return v.Remove
	}).(pulumi.StringArrayOutput)
}

// Set overwrites the request with the given header (name, value)
// before the action.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	set:
//	- name: "my-header"
//	  value: "bar"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: bar
func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput) Set() GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesFiltersResponseHeaderModifierPatch) []GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatch {
		if v == nil {
			return nil
		}
		return v.Set
	}).(GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesFiltersResponseHeaderModifierSet struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name *string `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value *string `pulumi:"value"`
}

// GRPCRouteSpecRulesFiltersResponseHeaderModifierSetInput is an input type that accepts GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArgs and GRPCRouteSpecRulesFiltersResponseHeaderModifierSetOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesFiltersResponseHeaderModifierSetInput` via:
//
//	GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArgs{...}
type GRPCRouteSpecRulesFiltersResponseHeaderModifierSetInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesFiltersResponseHeaderModifierSetOutput() GRPCRouteSpecRulesFiltersResponseHeaderModifierSetOutput
	ToGRPCRouteSpecRulesFiltersResponseHeaderModifierSetOutputWithContext(context.Context) GRPCRouteSpecRulesFiltersResponseHeaderModifierSetOutput
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArgs struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesFiltersResponseHeaderModifierSet)(nil)).Elem()
}

func (i GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArgs) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierSetOutput() GRPCRouteSpecRulesFiltersResponseHeaderModifierSetOutput {
	return i.ToGRPCRouteSpecRulesFiltersResponseHeaderModifierSetOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArgs) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierSetOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersResponseHeaderModifierSetOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersResponseHeaderModifierSetOutput)
}

// GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayInput is an input type that accepts GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArray and GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayInput` via:
//
//	GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArray{ GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArgs{...} }
type GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput() GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput
	ToGRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutputWithContext(context.Context) GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput
}

type GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArray []GRPCRouteSpecRulesFiltersResponseHeaderModifierSetInput

func (GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesFiltersResponseHeaderModifierSet)(nil)).Elem()
}

func (i GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArray) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput() GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput {
	return i.ToGRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArray) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesFiltersResponseHeaderModifierSetOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesFiltersResponseHeaderModifierSetOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesFiltersResponseHeaderModifierSet)(nil)).Elem()
}

func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierSetOutput) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierSetOutput() GRPCRouteSpecRulesFiltersResponseHeaderModifierSetOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierSetOutput) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierSetOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersResponseHeaderModifierSetOutput {
	return o
}

// Name is the name of the HTTP Header to be matched. Name matching MUST be
// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
//
// If multiple entries specify equivalent header names, the first entry with
// an equivalent name MUST be considered for a match. Subsequent entries
// with an equivalent header name MUST be ignored. Due to the
// case-insensitivity of header names, "foo" and "Foo" are considered
// equivalent.
func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierSetOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersResponseHeaderModifierSet) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Value is the value of HTTP Header to be matched.
func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierSetOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersResponseHeaderModifierSet) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesFiltersResponseHeaderModifierSet)(nil)).Elem()
}

func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput() GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput) Index(i pulumi.IntInput) GRPCRouteSpecRulesFiltersResponseHeaderModifierSetOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GRPCRouteSpecRulesFiltersResponseHeaderModifierSet {
		return vs[0].([]GRPCRouteSpecRulesFiltersResponseHeaderModifierSet)[vs[1].(int)]
	}).(GRPCRouteSpecRulesFiltersResponseHeaderModifierSetOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatch struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name *string `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value *string `pulumi:"value"`
}

// GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchInput is an input type that accepts GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchArgs and GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchInput` via:
//
//	GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchArgs{...}
type GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchOutput() GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchOutput
	ToGRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchOutputWithContext(context.Context) GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchOutput
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchArgs struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatch)(nil)).Elem()
}

func (i GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchArgs) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchOutput() GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchOutput {
	return i.ToGRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchArgs) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchOutput)
}

// GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayInput is an input type that accepts GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchArray and GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayInput` via:
//
//	GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchArray{ GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchArgs{...} }
type GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayOutput() GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayOutput
	ToGRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayOutputWithContext(context.Context) GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayOutput
}

type GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchArray []GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchInput

func (GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatch)(nil)).Elem()
}

func (i GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchArray) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayOutput() GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayOutput {
	return i.ToGRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchArray) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatch)(nil)).Elem()
}

func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchOutput) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchOutput() GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchOutput) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchOutput {
	return o
}

// Name is the name of the HTTP Header to be matched. Name matching MUST be
// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
//
// If multiple entries specify equivalent header names, the first entry with
// an equivalent name MUST be considered for a match. Subsequent entries
// with an equivalent header name MUST be ignored. Due to the
// case-insensitivity of header names, "foo" and "Foo" are considered
// equivalent.
func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Value is the value of HTTP Header to be matched.
func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatch) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatch)(nil)).Elem()
}

func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayOutput) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayOutput() GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayOutput) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayOutput) Index(i pulumi.IntInput) GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatch {
		return vs[0].([]GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatch)[vs[1].(int)]
	}).(GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchOutput)
}

// GRPCRouteMatch defines the predicate used to match requests to a given
// action. Multiple match types are ANDed together, i.e. the match will
// evaluate to true only if all conditions are satisfied.
//
// For example, the match below will match a gRPC request only if its service
// is `foo` AND it contains the `version: v1` header:
type GRPCRouteSpecRulesMatches struct {
	// Headers specifies gRPC request header matchers. Multiple match values are
	// ANDed together, meaning, a request MUST match all the specified headers
	// to select the route.
	Headers []GRPCRouteSpecRulesMatchesHeaders `pulumi:"headers"`
	Method  *GRPCRouteSpecRulesMatchesMethod   `pulumi:"method"`
}

// GRPCRouteSpecRulesMatchesInput is an input type that accepts GRPCRouteSpecRulesMatchesArgs and GRPCRouteSpecRulesMatchesOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesMatchesInput` via:
//
//	GRPCRouteSpecRulesMatchesArgs{...}
type GRPCRouteSpecRulesMatchesInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesMatchesOutput() GRPCRouteSpecRulesMatchesOutput
	ToGRPCRouteSpecRulesMatchesOutputWithContext(context.Context) GRPCRouteSpecRulesMatchesOutput
}

// GRPCRouteMatch defines the predicate used to match requests to a given
// action. Multiple match types are ANDed together, i.e. the match will
// evaluate to true only if all conditions are satisfied.
//
// For example, the match below will match a gRPC request only if its service
// is `foo` AND it contains the `version: v1` header:
type GRPCRouteSpecRulesMatchesArgs struct {
	// Headers specifies gRPC request header matchers. Multiple match values are
	// ANDed together, meaning, a request MUST match all the specified headers
	// to select the route.
	Headers GRPCRouteSpecRulesMatchesHeadersArrayInput `pulumi:"headers"`
	Method  GRPCRouteSpecRulesMatchesMethodPtrInput    `pulumi:"method"`
}

func (GRPCRouteSpecRulesMatchesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesMatches)(nil)).Elem()
}

func (i GRPCRouteSpecRulesMatchesArgs) ToGRPCRouteSpecRulesMatchesOutput() GRPCRouteSpecRulesMatchesOutput {
	return i.ToGRPCRouteSpecRulesMatchesOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesMatchesArgs) ToGRPCRouteSpecRulesMatchesOutputWithContext(ctx context.Context) GRPCRouteSpecRulesMatchesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesMatchesOutput)
}

// GRPCRouteSpecRulesMatchesArrayInput is an input type that accepts GRPCRouteSpecRulesMatchesArray and GRPCRouteSpecRulesMatchesArrayOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesMatchesArrayInput` via:
//
//	GRPCRouteSpecRulesMatchesArray{ GRPCRouteSpecRulesMatchesArgs{...} }
type GRPCRouteSpecRulesMatchesArrayInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesMatchesArrayOutput() GRPCRouteSpecRulesMatchesArrayOutput
	ToGRPCRouteSpecRulesMatchesArrayOutputWithContext(context.Context) GRPCRouteSpecRulesMatchesArrayOutput
}

type GRPCRouteSpecRulesMatchesArray []GRPCRouteSpecRulesMatchesInput

func (GRPCRouteSpecRulesMatchesArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesMatches)(nil)).Elem()
}

func (i GRPCRouteSpecRulesMatchesArray) ToGRPCRouteSpecRulesMatchesArrayOutput() GRPCRouteSpecRulesMatchesArrayOutput {
	return i.ToGRPCRouteSpecRulesMatchesArrayOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesMatchesArray) ToGRPCRouteSpecRulesMatchesArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesMatchesArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesMatchesArrayOutput)
}

// GRPCRouteMatch defines the predicate used to match requests to a given
// action. Multiple match types are ANDed together, i.e. the match will
// evaluate to true only if all conditions are satisfied.
//
// For example, the match below will match a gRPC request only if its service
// is `foo` AND it contains the `version: v1` header:
type GRPCRouteSpecRulesMatchesOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesMatchesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesMatches)(nil)).Elem()
}

func (o GRPCRouteSpecRulesMatchesOutput) ToGRPCRouteSpecRulesMatchesOutput() GRPCRouteSpecRulesMatchesOutput {
	return o
}

func (o GRPCRouteSpecRulesMatchesOutput) ToGRPCRouteSpecRulesMatchesOutputWithContext(ctx context.Context) GRPCRouteSpecRulesMatchesOutput {
	return o
}

// Headers specifies gRPC request header matchers. Multiple match values are
// ANDed together, meaning, a request MUST match all the specified headers
// to select the route.
func (o GRPCRouteSpecRulesMatchesOutput) Headers() GRPCRouteSpecRulesMatchesHeadersArrayOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesMatches) []GRPCRouteSpecRulesMatchesHeaders { return v.Headers }).(GRPCRouteSpecRulesMatchesHeadersArrayOutput)
}

func (o GRPCRouteSpecRulesMatchesOutput) Method() GRPCRouteSpecRulesMatchesMethodPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesMatches) *GRPCRouteSpecRulesMatchesMethod { return v.Method }).(GRPCRouteSpecRulesMatchesMethodPtrOutput)
}

type GRPCRouteSpecRulesMatchesArrayOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesMatchesArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesMatches)(nil)).Elem()
}

func (o GRPCRouteSpecRulesMatchesArrayOutput) ToGRPCRouteSpecRulesMatchesArrayOutput() GRPCRouteSpecRulesMatchesArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesMatchesArrayOutput) ToGRPCRouteSpecRulesMatchesArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesMatchesArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesMatchesArrayOutput) Index(i pulumi.IntInput) GRPCRouteSpecRulesMatchesOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GRPCRouteSpecRulesMatches {
		return vs[0].([]GRPCRouteSpecRulesMatches)[vs[1].(int)]
	}).(GRPCRouteSpecRulesMatchesOutput)
}

// GRPCHeaderMatch describes how to select a gRPC route by matching gRPC request
// headers.
type GRPCRouteSpecRulesMatchesHeaders struct {
	// Name is the name of the gRPC Header to be matched.
	//
	// If multiple entries specify equivalent header names, only the first
	// entry with an equivalent name MUST be considered for a match. Subsequent
	// entries with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name *string `pulumi:"name"`
	// Type specifies how to match against the value of the header.
	Type *string `pulumi:"type"`
	// Value is the value of the gRPC Header to be matched.
	Value *string `pulumi:"value"`
}

// GRPCRouteSpecRulesMatchesHeadersInput is an input type that accepts GRPCRouteSpecRulesMatchesHeadersArgs and GRPCRouteSpecRulesMatchesHeadersOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesMatchesHeadersInput` via:
//
//	GRPCRouteSpecRulesMatchesHeadersArgs{...}
type GRPCRouteSpecRulesMatchesHeadersInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesMatchesHeadersOutput() GRPCRouteSpecRulesMatchesHeadersOutput
	ToGRPCRouteSpecRulesMatchesHeadersOutputWithContext(context.Context) GRPCRouteSpecRulesMatchesHeadersOutput
}

// GRPCHeaderMatch describes how to select a gRPC route by matching gRPC request
// headers.
type GRPCRouteSpecRulesMatchesHeadersArgs struct {
	// Name is the name of the gRPC Header to be matched.
	//
	// If multiple entries specify equivalent header names, only the first
	// entry with an equivalent name MUST be considered for a match. Subsequent
	// entries with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Type specifies how to match against the value of the header.
	Type pulumi.StringPtrInput `pulumi:"type"`
	// Value is the value of the gRPC Header to be matched.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (GRPCRouteSpecRulesMatchesHeadersArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesMatchesHeaders)(nil)).Elem()
}

func (i GRPCRouteSpecRulesMatchesHeadersArgs) ToGRPCRouteSpecRulesMatchesHeadersOutput() GRPCRouteSpecRulesMatchesHeadersOutput {
	return i.ToGRPCRouteSpecRulesMatchesHeadersOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesMatchesHeadersArgs) ToGRPCRouteSpecRulesMatchesHeadersOutputWithContext(ctx context.Context) GRPCRouteSpecRulesMatchesHeadersOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesMatchesHeadersOutput)
}

// GRPCRouteSpecRulesMatchesHeadersArrayInput is an input type that accepts GRPCRouteSpecRulesMatchesHeadersArray and GRPCRouteSpecRulesMatchesHeadersArrayOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesMatchesHeadersArrayInput` via:
//
//	GRPCRouteSpecRulesMatchesHeadersArray{ GRPCRouteSpecRulesMatchesHeadersArgs{...} }
type GRPCRouteSpecRulesMatchesHeadersArrayInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesMatchesHeadersArrayOutput() GRPCRouteSpecRulesMatchesHeadersArrayOutput
	ToGRPCRouteSpecRulesMatchesHeadersArrayOutputWithContext(context.Context) GRPCRouteSpecRulesMatchesHeadersArrayOutput
}

type GRPCRouteSpecRulesMatchesHeadersArray []GRPCRouteSpecRulesMatchesHeadersInput

func (GRPCRouteSpecRulesMatchesHeadersArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesMatchesHeaders)(nil)).Elem()
}

func (i GRPCRouteSpecRulesMatchesHeadersArray) ToGRPCRouteSpecRulesMatchesHeadersArrayOutput() GRPCRouteSpecRulesMatchesHeadersArrayOutput {
	return i.ToGRPCRouteSpecRulesMatchesHeadersArrayOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesMatchesHeadersArray) ToGRPCRouteSpecRulesMatchesHeadersArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesMatchesHeadersArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesMatchesHeadersArrayOutput)
}

// GRPCHeaderMatch describes how to select a gRPC route by matching gRPC request
// headers.
type GRPCRouteSpecRulesMatchesHeadersOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesMatchesHeadersOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesMatchesHeaders)(nil)).Elem()
}

func (o GRPCRouteSpecRulesMatchesHeadersOutput) ToGRPCRouteSpecRulesMatchesHeadersOutput() GRPCRouteSpecRulesMatchesHeadersOutput {
	return o
}

func (o GRPCRouteSpecRulesMatchesHeadersOutput) ToGRPCRouteSpecRulesMatchesHeadersOutputWithContext(ctx context.Context) GRPCRouteSpecRulesMatchesHeadersOutput {
	return o
}

// Name is the name of the gRPC Header to be matched.
//
// If multiple entries specify equivalent header names, only the first
// entry with an equivalent name MUST be considered for a match. Subsequent
// entries with an equivalent header name MUST be ignored. Due to the
// case-insensitivity of header names, "foo" and "Foo" are considered
// equivalent.
func (o GRPCRouteSpecRulesMatchesHeadersOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesMatchesHeaders) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Type specifies how to match against the value of the header.
func (o GRPCRouteSpecRulesMatchesHeadersOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesMatchesHeaders) *string { return v.Type }).(pulumi.StringPtrOutput)
}

// Value is the value of the gRPC Header to be matched.
func (o GRPCRouteSpecRulesMatchesHeadersOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesMatchesHeaders) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type GRPCRouteSpecRulesMatchesHeadersArrayOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesMatchesHeadersArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesMatchesHeaders)(nil)).Elem()
}

func (o GRPCRouteSpecRulesMatchesHeadersArrayOutput) ToGRPCRouteSpecRulesMatchesHeadersArrayOutput() GRPCRouteSpecRulesMatchesHeadersArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesMatchesHeadersArrayOutput) ToGRPCRouteSpecRulesMatchesHeadersArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesMatchesHeadersArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesMatchesHeadersArrayOutput) Index(i pulumi.IntInput) GRPCRouteSpecRulesMatchesHeadersOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GRPCRouteSpecRulesMatchesHeaders {
		return vs[0].([]GRPCRouteSpecRulesMatchesHeaders)[vs[1].(int)]
	}).(GRPCRouteSpecRulesMatchesHeadersOutput)
}

// GRPCHeaderMatch describes how to select a gRPC route by matching gRPC request
// headers.
type GRPCRouteSpecRulesMatchesHeadersPatch struct {
	// Name is the name of the gRPC Header to be matched.
	//
	// If multiple entries specify equivalent header names, only the first
	// entry with an equivalent name MUST be considered for a match. Subsequent
	// entries with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name *string `pulumi:"name"`
	// Type specifies how to match against the value of the header.
	Type *string `pulumi:"type"`
	// Value is the value of the gRPC Header to be matched.
	Value *string `pulumi:"value"`
}

// GRPCRouteSpecRulesMatchesHeadersPatchInput is an input type that accepts GRPCRouteSpecRulesMatchesHeadersPatchArgs and GRPCRouteSpecRulesMatchesHeadersPatchOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesMatchesHeadersPatchInput` via:
//
//	GRPCRouteSpecRulesMatchesHeadersPatchArgs{...}
type GRPCRouteSpecRulesMatchesHeadersPatchInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesMatchesHeadersPatchOutput() GRPCRouteSpecRulesMatchesHeadersPatchOutput
	ToGRPCRouteSpecRulesMatchesHeadersPatchOutputWithContext(context.Context) GRPCRouteSpecRulesMatchesHeadersPatchOutput
}

// GRPCHeaderMatch describes how to select a gRPC route by matching gRPC request
// headers.
type GRPCRouteSpecRulesMatchesHeadersPatchArgs struct {
	// Name is the name of the gRPC Header to be matched.
	//
	// If multiple entries specify equivalent header names, only the first
	// entry with an equivalent name MUST be considered for a match. Subsequent
	// entries with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Type specifies how to match against the value of the header.
	Type pulumi.StringPtrInput `pulumi:"type"`
	// Value is the value of the gRPC Header to be matched.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (GRPCRouteSpecRulesMatchesHeadersPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesMatchesHeadersPatch)(nil)).Elem()
}

func (i GRPCRouteSpecRulesMatchesHeadersPatchArgs) ToGRPCRouteSpecRulesMatchesHeadersPatchOutput() GRPCRouteSpecRulesMatchesHeadersPatchOutput {
	return i.ToGRPCRouteSpecRulesMatchesHeadersPatchOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesMatchesHeadersPatchArgs) ToGRPCRouteSpecRulesMatchesHeadersPatchOutputWithContext(ctx context.Context) GRPCRouteSpecRulesMatchesHeadersPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesMatchesHeadersPatchOutput)
}

// GRPCRouteSpecRulesMatchesHeadersPatchArrayInput is an input type that accepts GRPCRouteSpecRulesMatchesHeadersPatchArray and GRPCRouteSpecRulesMatchesHeadersPatchArrayOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesMatchesHeadersPatchArrayInput` via:
//
//	GRPCRouteSpecRulesMatchesHeadersPatchArray{ GRPCRouteSpecRulesMatchesHeadersPatchArgs{...} }
type GRPCRouteSpecRulesMatchesHeadersPatchArrayInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesMatchesHeadersPatchArrayOutput() GRPCRouteSpecRulesMatchesHeadersPatchArrayOutput
	ToGRPCRouteSpecRulesMatchesHeadersPatchArrayOutputWithContext(context.Context) GRPCRouteSpecRulesMatchesHeadersPatchArrayOutput
}

type GRPCRouteSpecRulesMatchesHeadersPatchArray []GRPCRouteSpecRulesMatchesHeadersPatchInput

func (GRPCRouteSpecRulesMatchesHeadersPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesMatchesHeadersPatch)(nil)).Elem()
}

func (i GRPCRouteSpecRulesMatchesHeadersPatchArray) ToGRPCRouteSpecRulesMatchesHeadersPatchArrayOutput() GRPCRouteSpecRulesMatchesHeadersPatchArrayOutput {
	return i.ToGRPCRouteSpecRulesMatchesHeadersPatchArrayOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesMatchesHeadersPatchArray) ToGRPCRouteSpecRulesMatchesHeadersPatchArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesMatchesHeadersPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesMatchesHeadersPatchArrayOutput)
}

// GRPCHeaderMatch describes how to select a gRPC route by matching gRPC request
// headers.
type GRPCRouteSpecRulesMatchesHeadersPatchOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesMatchesHeadersPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesMatchesHeadersPatch)(nil)).Elem()
}

func (o GRPCRouteSpecRulesMatchesHeadersPatchOutput) ToGRPCRouteSpecRulesMatchesHeadersPatchOutput() GRPCRouteSpecRulesMatchesHeadersPatchOutput {
	return o
}

func (o GRPCRouteSpecRulesMatchesHeadersPatchOutput) ToGRPCRouteSpecRulesMatchesHeadersPatchOutputWithContext(ctx context.Context) GRPCRouteSpecRulesMatchesHeadersPatchOutput {
	return o
}

// Name is the name of the gRPC Header to be matched.
//
// If multiple entries specify equivalent header names, only the first
// entry with an equivalent name MUST be considered for a match. Subsequent
// entries with an equivalent header name MUST be ignored. Due to the
// case-insensitivity of header names, "foo" and "Foo" are considered
// equivalent.
func (o GRPCRouteSpecRulesMatchesHeadersPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesMatchesHeadersPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Type specifies how to match against the value of the header.
func (o GRPCRouteSpecRulesMatchesHeadersPatchOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesMatchesHeadersPatch) *string { return v.Type }).(pulumi.StringPtrOutput)
}

// Value is the value of the gRPC Header to be matched.
func (o GRPCRouteSpecRulesMatchesHeadersPatchOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesMatchesHeadersPatch) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type GRPCRouteSpecRulesMatchesHeadersPatchArrayOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesMatchesHeadersPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesMatchesHeadersPatch)(nil)).Elem()
}

func (o GRPCRouteSpecRulesMatchesHeadersPatchArrayOutput) ToGRPCRouteSpecRulesMatchesHeadersPatchArrayOutput() GRPCRouteSpecRulesMatchesHeadersPatchArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesMatchesHeadersPatchArrayOutput) ToGRPCRouteSpecRulesMatchesHeadersPatchArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesMatchesHeadersPatchArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesMatchesHeadersPatchArrayOutput) Index(i pulumi.IntInput) GRPCRouteSpecRulesMatchesHeadersPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GRPCRouteSpecRulesMatchesHeadersPatch {
		return vs[0].([]GRPCRouteSpecRulesMatchesHeadersPatch)[vs[1].(int)]
	}).(GRPCRouteSpecRulesMatchesHeadersPatchOutput)
}

// Method specifies a gRPC request service/method matcher. If this field is
// not specified, all services and methods will match.
type GRPCRouteSpecRulesMatchesMethod struct {
	// Value of the method to match against. If left empty or omitted, will
	// match all services.
	//
	// At least one of Service and Method MUST be a non-empty string.
	Method *string `pulumi:"method"`
	// Value of the service to match against. If left empty or omitted, will
	// match any service.
	//
	// At least one of Service and Method MUST be a non-empty string.
	Service *string `pulumi:"service"`
	// Type specifies how to match against the service and/or method.
	// Support: Core (Exact with service and method specified)
	//
	// Support: Implementation-specific (Exact with method specified but no service specified)
	//
	// Support: Implementation-specific (RegularExpression)
	Type *string `pulumi:"type"`
}

// GRPCRouteSpecRulesMatchesMethodInput is an input type that accepts GRPCRouteSpecRulesMatchesMethodArgs and GRPCRouteSpecRulesMatchesMethodOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesMatchesMethodInput` via:
//
//	GRPCRouteSpecRulesMatchesMethodArgs{...}
type GRPCRouteSpecRulesMatchesMethodInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesMatchesMethodOutput() GRPCRouteSpecRulesMatchesMethodOutput
	ToGRPCRouteSpecRulesMatchesMethodOutputWithContext(context.Context) GRPCRouteSpecRulesMatchesMethodOutput
}

// Method specifies a gRPC request service/method matcher. If this field is
// not specified, all services and methods will match.
type GRPCRouteSpecRulesMatchesMethodArgs struct {
	// Value of the method to match against. If left empty or omitted, will
	// match all services.
	//
	// At least one of Service and Method MUST be a non-empty string.
	Method pulumi.StringPtrInput `pulumi:"method"`
	// Value of the service to match against. If left empty or omitted, will
	// match any service.
	//
	// At least one of Service and Method MUST be a non-empty string.
	Service pulumi.StringPtrInput `pulumi:"service"`
	// Type specifies how to match against the service and/or method.
	// Support: Core (Exact with service and method specified)
	//
	// Support: Implementation-specific (Exact with method specified but no service specified)
	//
	// Support: Implementation-specific (RegularExpression)
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (GRPCRouteSpecRulesMatchesMethodArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesMatchesMethod)(nil)).Elem()
}

func (i GRPCRouteSpecRulesMatchesMethodArgs) ToGRPCRouteSpecRulesMatchesMethodOutput() GRPCRouteSpecRulesMatchesMethodOutput {
	return i.ToGRPCRouteSpecRulesMatchesMethodOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesMatchesMethodArgs) ToGRPCRouteSpecRulesMatchesMethodOutputWithContext(ctx context.Context) GRPCRouteSpecRulesMatchesMethodOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesMatchesMethodOutput)
}

func (i GRPCRouteSpecRulesMatchesMethodArgs) ToGRPCRouteSpecRulesMatchesMethodPtrOutput() GRPCRouteSpecRulesMatchesMethodPtrOutput {
	return i.ToGRPCRouteSpecRulesMatchesMethodPtrOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesMatchesMethodArgs) ToGRPCRouteSpecRulesMatchesMethodPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesMatchesMethodPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesMatchesMethodOutput).ToGRPCRouteSpecRulesMatchesMethodPtrOutputWithContext(ctx)
}

// GRPCRouteSpecRulesMatchesMethodPtrInput is an input type that accepts GRPCRouteSpecRulesMatchesMethodArgs, GRPCRouteSpecRulesMatchesMethodPtr and GRPCRouteSpecRulesMatchesMethodPtrOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesMatchesMethodPtrInput` via:
//
//	        GRPCRouteSpecRulesMatchesMethodArgs{...}
//
//	or:
//
//	        nil
type GRPCRouteSpecRulesMatchesMethodPtrInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesMatchesMethodPtrOutput() GRPCRouteSpecRulesMatchesMethodPtrOutput
	ToGRPCRouteSpecRulesMatchesMethodPtrOutputWithContext(context.Context) GRPCRouteSpecRulesMatchesMethodPtrOutput
}

type grpcrouteSpecRulesMatchesMethodPtrType GRPCRouteSpecRulesMatchesMethodArgs

func GRPCRouteSpecRulesMatchesMethodPtr(v *GRPCRouteSpecRulesMatchesMethodArgs) GRPCRouteSpecRulesMatchesMethodPtrInput {
	return (*grpcrouteSpecRulesMatchesMethodPtrType)(v)
}

func (*grpcrouteSpecRulesMatchesMethodPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesMatchesMethod)(nil)).Elem()
}

func (i *grpcrouteSpecRulesMatchesMethodPtrType) ToGRPCRouteSpecRulesMatchesMethodPtrOutput() GRPCRouteSpecRulesMatchesMethodPtrOutput {
	return i.ToGRPCRouteSpecRulesMatchesMethodPtrOutputWithContext(context.Background())
}

func (i *grpcrouteSpecRulesMatchesMethodPtrType) ToGRPCRouteSpecRulesMatchesMethodPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesMatchesMethodPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesMatchesMethodPtrOutput)
}

// Method specifies a gRPC request service/method matcher. If this field is
// not specified, all services and methods will match.
type GRPCRouteSpecRulesMatchesMethodOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesMatchesMethodOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesMatchesMethod)(nil)).Elem()
}

func (o GRPCRouteSpecRulesMatchesMethodOutput) ToGRPCRouteSpecRulesMatchesMethodOutput() GRPCRouteSpecRulesMatchesMethodOutput {
	return o
}

func (o GRPCRouteSpecRulesMatchesMethodOutput) ToGRPCRouteSpecRulesMatchesMethodOutputWithContext(ctx context.Context) GRPCRouteSpecRulesMatchesMethodOutput {
	return o
}

func (o GRPCRouteSpecRulesMatchesMethodOutput) ToGRPCRouteSpecRulesMatchesMethodPtrOutput() GRPCRouteSpecRulesMatchesMethodPtrOutput {
	return o.ToGRPCRouteSpecRulesMatchesMethodPtrOutputWithContext(context.Background())
}

func (o GRPCRouteSpecRulesMatchesMethodOutput) ToGRPCRouteSpecRulesMatchesMethodPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesMatchesMethodPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GRPCRouteSpecRulesMatchesMethod) *GRPCRouteSpecRulesMatchesMethod {
		return &v
	}).(GRPCRouteSpecRulesMatchesMethodPtrOutput)
}

// Value of the method to match against. If left empty or omitted, will
// match all services.
//
// At least one of Service and Method MUST be a non-empty string.
func (o GRPCRouteSpecRulesMatchesMethodOutput) Method() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesMatchesMethod) *string { return v.Method }).(pulumi.StringPtrOutput)
}

// Value of the service to match against. If left empty or omitted, will
// match any service.
//
// At least one of Service and Method MUST be a non-empty string.
func (o GRPCRouteSpecRulesMatchesMethodOutput) Service() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesMatchesMethod) *string { return v.Service }).(pulumi.StringPtrOutput)
}

// Type specifies how to match against the service and/or method.
// Support: Core (Exact with service and method specified)
//
// Support: Implementation-specific (Exact with method specified but no service specified)
//
// Support: Implementation-specific (RegularExpression)
func (o GRPCRouteSpecRulesMatchesMethodOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesMatchesMethod) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type GRPCRouteSpecRulesMatchesMethodPtrOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesMatchesMethodPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesMatchesMethod)(nil)).Elem()
}

func (o GRPCRouteSpecRulesMatchesMethodPtrOutput) ToGRPCRouteSpecRulesMatchesMethodPtrOutput() GRPCRouteSpecRulesMatchesMethodPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesMatchesMethodPtrOutput) ToGRPCRouteSpecRulesMatchesMethodPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesMatchesMethodPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesMatchesMethodPtrOutput) Elem() GRPCRouteSpecRulesMatchesMethodOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesMatchesMethod) GRPCRouteSpecRulesMatchesMethod {
		if v != nil {
			return *v
		}
		var ret GRPCRouteSpecRulesMatchesMethod
		return ret
	}).(GRPCRouteSpecRulesMatchesMethodOutput)
}

// Value of the method to match against. If left empty or omitted, will
// match all services.
//
// At least one of Service and Method MUST be a non-empty string.
func (o GRPCRouteSpecRulesMatchesMethodPtrOutput) Method() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesMatchesMethod) *string {
		if v == nil {
			return nil
		}
		return v.Method
	}).(pulumi.StringPtrOutput)
}

// Value of the service to match against. If left empty or omitted, will
// match any service.
//
// At least one of Service and Method MUST be a non-empty string.
func (o GRPCRouteSpecRulesMatchesMethodPtrOutput) Service() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesMatchesMethod) *string {
		if v == nil {
			return nil
		}
		return v.Service
	}).(pulumi.StringPtrOutput)
}

// Type specifies how to match against the service and/or method.
// Support: Core (Exact with service and method specified)
//
// Support: Implementation-specific (Exact with method specified but no service specified)
//
// Support: Implementation-specific (RegularExpression)
func (o GRPCRouteSpecRulesMatchesMethodPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesMatchesMethod) *string {
		if v == nil {
			return nil
		}
		return v.Type
	}).(pulumi.StringPtrOutput)
}

// Method specifies a gRPC request service/method matcher. If this field is
// not specified, all services and methods will match.
type GRPCRouteSpecRulesMatchesMethodPatch struct {
	// Value of the method to match against. If left empty or omitted, will
	// match all services.
	//
	// At least one of Service and Method MUST be a non-empty string.
	Method *string `pulumi:"method"`
	// Value of the service to match against. If left empty or omitted, will
	// match any service.
	//
	// At least one of Service and Method MUST be a non-empty string.
	Service *string `pulumi:"service"`
	// Type specifies how to match against the service and/or method.
	// Support: Core (Exact with service and method specified)
	//
	// Support: Implementation-specific (Exact with method specified but no service specified)
	//
	// Support: Implementation-specific (RegularExpression)
	Type *string `pulumi:"type"`
}

// GRPCRouteSpecRulesMatchesMethodPatchInput is an input type that accepts GRPCRouteSpecRulesMatchesMethodPatchArgs and GRPCRouteSpecRulesMatchesMethodPatchOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesMatchesMethodPatchInput` via:
//
//	GRPCRouteSpecRulesMatchesMethodPatchArgs{...}
type GRPCRouteSpecRulesMatchesMethodPatchInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesMatchesMethodPatchOutput() GRPCRouteSpecRulesMatchesMethodPatchOutput
	ToGRPCRouteSpecRulesMatchesMethodPatchOutputWithContext(context.Context) GRPCRouteSpecRulesMatchesMethodPatchOutput
}

// Method specifies a gRPC request service/method matcher. If this field is
// not specified, all services and methods will match.
type GRPCRouteSpecRulesMatchesMethodPatchArgs struct {
	// Value of the method to match against. If left empty or omitted, will
	// match all services.
	//
	// At least one of Service and Method MUST be a non-empty string.
	Method pulumi.StringPtrInput `pulumi:"method"`
	// Value of the service to match against. If left empty or omitted, will
	// match any service.
	//
	// At least one of Service and Method MUST be a non-empty string.
	Service pulumi.StringPtrInput `pulumi:"service"`
	// Type specifies how to match against the service and/or method.
	// Support: Core (Exact with service and method specified)
	//
	// Support: Implementation-specific (Exact with method specified but no service specified)
	//
	// Support: Implementation-specific (RegularExpression)
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (GRPCRouteSpecRulesMatchesMethodPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesMatchesMethodPatch)(nil)).Elem()
}

func (i GRPCRouteSpecRulesMatchesMethodPatchArgs) ToGRPCRouteSpecRulesMatchesMethodPatchOutput() GRPCRouteSpecRulesMatchesMethodPatchOutput {
	return i.ToGRPCRouteSpecRulesMatchesMethodPatchOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesMatchesMethodPatchArgs) ToGRPCRouteSpecRulesMatchesMethodPatchOutputWithContext(ctx context.Context) GRPCRouteSpecRulesMatchesMethodPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesMatchesMethodPatchOutput)
}

func (i GRPCRouteSpecRulesMatchesMethodPatchArgs) ToGRPCRouteSpecRulesMatchesMethodPatchPtrOutput() GRPCRouteSpecRulesMatchesMethodPatchPtrOutput {
	return i.ToGRPCRouteSpecRulesMatchesMethodPatchPtrOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesMatchesMethodPatchArgs) ToGRPCRouteSpecRulesMatchesMethodPatchPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesMatchesMethodPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesMatchesMethodPatchOutput).ToGRPCRouteSpecRulesMatchesMethodPatchPtrOutputWithContext(ctx)
}

// GRPCRouteSpecRulesMatchesMethodPatchPtrInput is an input type that accepts GRPCRouteSpecRulesMatchesMethodPatchArgs, GRPCRouteSpecRulesMatchesMethodPatchPtr and GRPCRouteSpecRulesMatchesMethodPatchPtrOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesMatchesMethodPatchPtrInput` via:
//
//	        GRPCRouteSpecRulesMatchesMethodPatchArgs{...}
//
//	or:
//
//	        nil
type GRPCRouteSpecRulesMatchesMethodPatchPtrInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesMatchesMethodPatchPtrOutput() GRPCRouteSpecRulesMatchesMethodPatchPtrOutput
	ToGRPCRouteSpecRulesMatchesMethodPatchPtrOutputWithContext(context.Context) GRPCRouteSpecRulesMatchesMethodPatchPtrOutput
}

type grpcrouteSpecRulesMatchesMethodPatchPtrType GRPCRouteSpecRulesMatchesMethodPatchArgs

func GRPCRouteSpecRulesMatchesMethodPatchPtr(v *GRPCRouteSpecRulesMatchesMethodPatchArgs) GRPCRouteSpecRulesMatchesMethodPatchPtrInput {
	return (*grpcrouteSpecRulesMatchesMethodPatchPtrType)(v)
}

func (*grpcrouteSpecRulesMatchesMethodPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesMatchesMethodPatch)(nil)).Elem()
}

func (i *grpcrouteSpecRulesMatchesMethodPatchPtrType) ToGRPCRouteSpecRulesMatchesMethodPatchPtrOutput() GRPCRouteSpecRulesMatchesMethodPatchPtrOutput {
	return i.ToGRPCRouteSpecRulesMatchesMethodPatchPtrOutputWithContext(context.Background())
}

func (i *grpcrouteSpecRulesMatchesMethodPatchPtrType) ToGRPCRouteSpecRulesMatchesMethodPatchPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesMatchesMethodPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesMatchesMethodPatchPtrOutput)
}

// Method specifies a gRPC request service/method matcher. If this field is
// not specified, all services and methods will match.
type GRPCRouteSpecRulesMatchesMethodPatchOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesMatchesMethodPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesMatchesMethodPatch)(nil)).Elem()
}

func (o GRPCRouteSpecRulesMatchesMethodPatchOutput) ToGRPCRouteSpecRulesMatchesMethodPatchOutput() GRPCRouteSpecRulesMatchesMethodPatchOutput {
	return o
}

func (o GRPCRouteSpecRulesMatchesMethodPatchOutput) ToGRPCRouteSpecRulesMatchesMethodPatchOutputWithContext(ctx context.Context) GRPCRouteSpecRulesMatchesMethodPatchOutput {
	return o
}

func (o GRPCRouteSpecRulesMatchesMethodPatchOutput) ToGRPCRouteSpecRulesMatchesMethodPatchPtrOutput() GRPCRouteSpecRulesMatchesMethodPatchPtrOutput {
	return o.ToGRPCRouteSpecRulesMatchesMethodPatchPtrOutputWithContext(context.Background())
}

func (o GRPCRouteSpecRulesMatchesMethodPatchOutput) ToGRPCRouteSpecRulesMatchesMethodPatchPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesMatchesMethodPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GRPCRouteSpecRulesMatchesMethodPatch) *GRPCRouteSpecRulesMatchesMethodPatch {
		return &v
	}).(GRPCRouteSpecRulesMatchesMethodPatchPtrOutput)
}

// Value of the method to match against. If left empty or omitted, will
// match all services.
//
// At least one of Service and Method MUST be a non-empty string.
func (o GRPCRouteSpecRulesMatchesMethodPatchOutput) Method() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesMatchesMethodPatch) *string { return v.Method }).(pulumi.StringPtrOutput)
}

// Value of the service to match against. If left empty or omitted, will
// match any service.
//
// At least one of Service and Method MUST be a non-empty string.
func (o GRPCRouteSpecRulesMatchesMethodPatchOutput) Service() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesMatchesMethodPatch) *string { return v.Service }).(pulumi.StringPtrOutput)
}

// Type specifies how to match against the service and/or method.
// Support: Core (Exact with service and method specified)
//
// Support: Implementation-specific (Exact with method specified but no service specified)
//
// Support: Implementation-specific (RegularExpression)
func (o GRPCRouteSpecRulesMatchesMethodPatchOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesMatchesMethodPatch) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type GRPCRouteSpecRulesMatchesMethodPatchPtrOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesMatchesMethodPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesMatchesMethodPatch)(nil)).Elem()
}

func (o GRPCRouteSpecRulesMatchesMethodPatchPtrOutput) ToGRPCRouteSpecRulesMatchesMethodPatchPtrOutput() GRPCRouteSpecRulesMatchesMethodPatchPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesMatchesMethodPatchPtrOutput) ToGRPCRouteSpecRulesMatchesMethodPatchPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesMatchesMethodPatchPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesMatchesMethodPatchPtrOutput) Elem() GRPCRouteSpecRulesMatchesMethodPatchOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesMatchesMethodPatch) GRPCRouteSpecRulesMatchesMethodPatch {
		if v != nil {
			return *v
		}
		var ret GRPCRouteSpecRulesMatchesMethodPatch
		return ret
	}).(GRPCRouteSpecRulesMatchesMethodPatchOutput)
}

// Value of the method to match against. If left empty or omitted, will
// match all services.
//
// At least one of Service and Method MUST be a non-empty string.
func (o GRPCRouteSpecRulesMatchesMethodPatchPtrOutput) Method() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesMatchesMethodPatch) *string {
		if v == nil {
			return nil
		}
		return v.Method
	}).(pulumi.StringPtrOutput)
}

// Value of the service to match against. If left empty or omitted, will
// match any service.
//
// At least one of Service and Method MUST be a non-empty string.
func (o GRPCRouteSpecRulesMatchesMethodPatchPtrOutput) Service() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesMatchesMethodPatch) *string {
		if v == nil {
			return nil
		}
		return v.Service
	}).(pulumi.StringPtrOutput)
}

// Type specifies how to match against the service and/or method.
// Support: Core (Exact with service and method specified)
//
// Support: Implementation-specific (Exact with method specified but no service specified)
//
// Support: Implementation-specific (RegularExpression)
func (o GRPCRouteSpecRulesMatchesMethodPatchPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesMatchesMethodPatch) *string {
		if v == nil {
			return nil
		}
		return v.Type
	}).(pulumi.StringPtrOutput)
}

// GRPCRouteMatch defines the predicate used to match requests to a given
// action. Multiple match types are ANDed together, i.e. the match will
// evaluate to true only if all conditions are satisfied.
//
// For example, the match below will match a gRPC request only if its service
// is `foo` AND it contains the `version: v1` header:
type GRPCRouteSpecRulesMatchesPatch struct {
	// Headers specifies gRPC request header matchers. Multiple match values are
	// ANDed together, meaning, a request MUST match all the specified headers
	// to select the route.
	Headers []GRPCRouteSpecRulesMatchesHeadersPatch `pulumi:"headers"`
	Method  *GRPCRouteSpecRulesMatchesMethodPatch   `pulumi:"method"`
}

// GRPCRouteSpecRulesMatchesPatchInput is an input type that accepts GRPCRouteSpecRulesMatchesPatchArgs and GRPCRouteSpecRulesMatchesPatchOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesMatchesPatchInput` via:
//
//	GRPCRouteSpecRulesMatchesPatchArgs{...}
type GRPCRouteSpecRulesMatchesPatchInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesMatchesPatchOutput() GRPCRouteSpecRulesMatchesPatchOutput
	ToGRPCRouteSpecRulesMatchesPatchOutputWithContext(context.Context) GRPCRouteSpecRulesMatchesPatchOutput
}

// GRPCRouteMatch defines the predicate used to match requests to a given
// action. Multiple match types are ANDed together, i.e. the match will
// evaluate to true only if all conditions are satisfied.
//
// For example, the match below will match a gRPC request only if its service
// is `foo` AND it contains the `version: v1` header:
type GRPCRouteSpecRulesMatchesPatchArgs struct {
	// Headers specifies gRPC request header matchers. Multiple match values are
	// ANDed together, meaning, a request MUST match all the specified headers
	// to select the route.
	Headers GRPCRouteSpecRulesMatchesHeadersPatchArrayInput `pulumi:"headers"`
	Method  GRPCRouteSpecRulesMatchesMethodPatchPtrInput    `pulumi:"method"`
}

func (GRPCRouteSpecRulesMatchesPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesMatchesPatch)(nil)).Elem()
}

func (i GRPCRouteSpecRulesMatchesPatchArgs) ToGRPCRouteSpecRulesMatchesPatchOutput() GRPCRouteSpecRulesMatchesPatchOutput {
	return i.ToGRPCRouteSpecRulesMatchesPatchOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesMatchesPatchArgs) ToGRPCRouteSpecRulesMatchesPatchOutputWithContext(ctx context.Context) GRPCRouteSpecRulesMatchesPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesMatchesPatchOutput)
}

// GRPCRouteSpecRulesMatchesPatchArrayInput is an input type that accepts GRPCRouteSpecRulesMatchesPatchArray and GRPCRouteSpecRulesMatchesPatchArrayOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesMatchesPatchArrayInput` via:
//
//	GRPCRouteSpecRulesMatchesPatchArray{ GRPCRouteSpecRulesMatchesPatchArgs{...} }
type GRPCRouteSpecRulesMatchesPatchArrayInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesMatchesPatchArrayOutput() GRPCRouteSpecRulesMatchesPatchArrayOutput
	ToGRPCRouteSpecRulesMatchesPatchArrayOutputWithContext(context.Context) GRPCRouteSpecRulesMatchesPatchArrayOutput
}

type GRPCRouteSpecRulesMatchesPatchArray []GRPCRouteSpecRulesMatchesPatchInput

func (GRPCRouteSpecRulesMatchesPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesMatchesPatch)(nil)).Elem()
}

func (i GRPCRouteSpecRulesMatchesPatchArray) ToGRPCRouteSpecRulesMatchesPatchArrayOutput() GRPCRouteSpecRulesMatchesPatchArrayOutput {
	return i.ToGRPCRouteSpecRulesMatchesPatchArrayOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesMatchesPatchArray) ToGRPCRouteSpecRulesMatchesPatchArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesMatchesPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesMatchesPatchArrayOutput)
}

// GRPCRouteMatch defines the predicate used to match requests to a given
// action. Multiple match types are ANDed together, i.e. the match will
// evaluate to true only if all conditions are satisfied.
//
// For example, the match below will match a gRPC request only if its service
// is `foo` AND it contains the `version: v1` header:
type GRPCRouteSpecRulesMatchesPatchOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesMatchesPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesMatchesPatch)(nil)).Elem()
}

func (o GRPCRouteSpecRulesMatchesPatchOutput) ToGRPCRouteSpecRulesMatchesPatchOutput() GRPCRouteSpecRulesMatchesPatchOutput {
	return o
}

func (o GRPCRouteSpecRulesMatchesPatchOutput) ToGRPCRouteSpecRulesMatchesPatchOutputWithContext(ctx context.Context) GRPCRouteSpecRulesMatchesPatchOutput {
	return o
}

// Headers specifies gRPC request header matchers. Multiple match values are
// ANDed together, meaning, a request MUST match all the specified headers
// to select the route.
func (o GRPCRouteSpecRulesMatchesPatchOutput) Headers() GRPCRouteSpecRulesMatchesHeadersPatchArrayOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesMatchesPatch) []GRPCRouteSpecRulesMatchesHeadersPatch { return v.Headers }).(GRPCRouteSpecRulesMatchesHeadersPatchArrayOutput)
}

func (o GRPCRouteSpecRulesMatchesPatchOutput) Method() GRPCRouteSpecRulesMatchesMethodPatchPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesMatchesPatch) *GRPCRouteSpecRulesMatchesMethodPatch { return v.Method }).(GRPCRouteSpecRulesMatchesMethodPatchPtrOutput)
}

type GRPCRouteSpecRulesMatchesPatchArrayOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesMatchesPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesMatchesPatch)(nil)).Elem()
}

func (o GRPCRouteSpecRulesMatchesPatchArrayOutput) ToGRPCRouteSpecRulesMatchesPatchArrayOutput() GRPCRouteSpecRulesMatchesPatchArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesMatchesPatchArrayOutput) ToGRPCRouteSpecRulesMatchesPatchArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesMatchesPatchArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesMatchesPatchArrayOutput) Index(i pulumi.IntInput) GRPCRouteSpecRulesMatchesPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GRPCRouteSpecRulesMatchesPatch {
		return vs[0].([]GRPCRouteSpecRulesMatchesPatch)[vs[1].(int)]
	}).(GRPCRouteSpecRulesMatchesPatchOutput)
}

// GRPCRouteRule defines the semantics for matching a gRPC request based on
// conditions (matches), processing it (filters), and forwarding the request to
// an API object (backendRefs).
type GRPCRouteSpecRulesPatch struct {
	// BackendRefs defines the backend(s) where matching requests should be
	// sent.
	//
	// Failure behavior here depends on how many BackendRefs are specified and
	// how many are invalid.
	//
	// If *all* entries in BackendRefs are invalid, and there are also no filters
	// specified in this route rule, *all* traffic which matches this rule MUST
	// receive an `UNAVAILABLE` status.
	//
	// See the GRPCBackendRef definition for the rules about what makes a single
	// GRPCBackendRef invalid.
	//
	// When a GRPCBackendRef is invalid, `UNAVAILABLE` statuses MUST be returned for
	// requests that would have otherwise been routed to an invalid backend. If
	// multiple backends are specified, and some are invalid, the proportion of
	// requests that would otherwise have been routed to an invalid backend
	// MUST receive an `UNAVAILABLE` status.
	//
	// For example, if two backends are specified with equal weights, and one is
	// invalid, 50 percent of traffic MUST receive an `UNAVAILABLE` status.
	// Implementations may choose how that 50 percent is determined.
	//
	// Support: Core for Kubernetes Service
	//
	// Support: Implementation-specific for any other resource
	//
	// Support for weight: Core
	BackendRefs []GRPCRouteSpecRulesBackendRefsPatch `pulumi:"backendRefs"`
	// Filters define the filters that are applied to requests that match
	// this rule.
	//
	// The effects of ordering of multiple behaviors are currently unspecified.
	// This can change in the future based on feedback during the alpha stage.
	//
	// Conformance-levels at this level are defined based on the type of filter:
	//
	// - ALL core filters MUST be supported by all implementations that support
	//   GRPCRoute.
	// - Implementers are encouraged to support extended filters.
	// - Implementation-specific custom filters have no API guarantees across
	//   implementations.
	//
	// Specifying the same filter multiple times is not supported unless explicitly
	// indicated in the filter.
	//
	// If an implementation can not support a combination of filters, it must clearly
	// document that limitation. In cases where incompatible or unsupported
	// filters are specified and cause the `Accepted` condition to be set to status
	// `False`, implementations may use the `IncompatibleFilters` reason to specify
	// this configuration error.
	//
	// Support: Core
	Filters []GRPCRouteSpecRulesFiltersPatch `pulumi:"filters"`
	// Matches define conditions used for matching the rule against incoming
	// gRPC requests. Each match is independent, i.e. this rule will be matched
	// if **any** one of the matches is satisfied.
	//
	// For example, take the following matches configuration:
	//
	// For a request to match against this rule, it MUST satisfy
	// EITHER of the two conditions:
	//
	// - service of foo.bar AND contains the header `version: 2`
	// - service of foo.bar.v2
	//
	// See the documentation for GRPCRouteMatch on how to specify multiple
	// match conditions to be ANDed together.
	//
	// If no matches are specified, the implementation MUST match every gRPC request.
	//
	// Proxy or Load Balancer routing configuration generated from GRPCRoutes
	// MUST prioritize rules based on the following criteria, continuing on
	// ties. Merging MUST not be done between GRPCRoutes and HTTPRoutes.
	// Precedence MUST be given to the rule with the largest number of:
	//
	// * Characters in a matching non-wildcard hostname.
	// * Characters in a matching hostname.
	// * Characters in a matching service.
	// * Characters in a matching method.
	// * Header matches.
	//
	// If ties still exist across multiple Routes, matching precedence MUST be
	// determined in order of the following criteria, continuing on ties:
	//
	// * The oldest Route based on creation timestamp.
	// * The Route appearing first in alphabetical order by
	//   "{namespace}/{name}".
	//
	// If ties still exist within the Route that has been given precedence,
	// matching precedence MUST be granted to the first matching rule meeting
	// the above criteria.
	Matches []GRPCRouteSpecRulesMatchesPatch `pulumi:"matches"`
}

// GRPCRouteSpecRulesPatchInput is an input type that accepts GRPCRouteSpecRulesPatchArgs and GRPCRouteSpecRulesPatchOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesPatchInput` via:
//
//	GRPCRouteSpecRulesPatchArgs{...}
type GRPCRouteSpecRulesPatchInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesPatchOutput() GRPCRouteSpecRulesPatchOutput
	ToGRPCRouteSpecRulesPatchOutputWithContext(context.Context) GRPCRouteSpecRulesPatchOutput
}

// GRPCRouteRule defines the semantics for matching a gRPC request based on
// conditions (matches), processing it (filters), and forwarding the request to
// an API object (backendRefs).
type GRPCRouteSpecRulesPatchArgs struct {
	// BackendRefs defines the backend(s) where matching requests should be
	// sent.
	//
	// Failure behavior here depends on how many BackendRefs are specified and
	// how many are invalid.
	//
	// If *all* entries in BackendRefs are invalid, and there are also no filters
	// specified in this route rule, *all* traffic which matches this rule MUST
	// receive an `UNAVAILABLE` status.
	//
	// See the GRPCBackendRef definition for the rules about what makes a single
	// GRPCBackendRef invalid.
	//
	// When a GRPCBackendRef is invalid, `UNAVAILABLE` statuses MUST be returned for
	// requests that would have otherwise been routed to an invalid backend. If
	// multiple backends are specified, and some are invalid, the proportion of
	// requests that would otherwise have been routed to an invalid backend
	// MUST receive an `UNAVAILABLE` status.
	//
	// For example, if two backends are specified with equal weights, and one is
	// invalid, 50 percent of traffic MUST receive an `UNAVAILABLE` status.
	// Implementations may choose how that 50 percent is determined.
	//
	// Support: Core for Kubernetes Service
	//
	// Support: Implementation-specific for any other resource
	//
	// Support for weight: Core
	BackendRefs GRPCRouteSpecRulesBackendRefsPatchArrayInput `pulumi:"backendRefs"`
	// Filters define the filters that are applied to requests that match
	// this rule.
	//
	// The effects of ordering of multiple behaviors are currently unspecified.
	// This can change in the future based on feedback during the alpha stage.
	//
	// Conformance-levels at this level are defined based on the type of filter:
	//
	// - ALL core filters MUST be supported by all implementations that support
	//   GRPCRoute.
	// - Implementers are encouraged to support extended filters.
	// - Implementation-specific custom filters have no API guarantees across
	//   implementations.
	//
	// Specifying the same filter multiple times is not supported unless explicitly
	// indicated in the filter.
	//
	// If an implementation can not support a combination of filters, it must clearly
	// document that limitation. In cases where incompatible or unsupported
	// filters are specified and cause the `Accepted` condition to be set to status
	// `False`, implementations may use the `IncompatibleFilters` reason to specify
	// this configuration error.
	//
	// Support: Core
	Filters GRPCRouteSpecRulesFiltersPatchArrayInput `pulumi:"filters"`
	// Matches define conditions used for matching the rule against incoming
	// gRPC requests. Each match is independent, i.e. this rule will be matched
	// if **any** one of the matches is satisfied.
	//
	// For example, take the following matches configuration:
	//
	// For a request to match against this rule, it MUST satisfy
	// EITHER of the two conditions:
	//
	// - service of foo.bar AND contains the header `version: 2`
	// - service of foo.bar.v2
	//
	// See the documentation for GRPCRouteMatch on how to specify multiple
	// match conditions to be ANDed together.
	//
	// If no matches are specified, the implementation MUST match every gRPC request.
	//
	// Proxy or Load Balancer routing configuration generated from GRPCRoutes
	// MUST prioritize rules based on the following criteria, continuing on
	// ties. Merging MUST not be done between GRPCRoutes and HTTPRoutes.
	// Precedence MUST be given to the rule with the largest number of:
	//
	// * Characters in a matching non-wildcard hostname.
	// * Characters in a matching hostname.
	// * Characters in a matching service.
	// * Characters in a matching method.
	// * Header matches.
	//
	// If ties still exist across multiple Routes, matching precedence MUST be
	// determined in order of the following criteria, continuing on ties:
	//
	// * The oldest Route based on creation timestamp.
	// * The Route appearing first in alphabetical order by
	//   "{namespace}/{name}".
	//
	// If ties still exist within the Route that has been given precedence,
	// matching precedence MUST be granted to the first matching rule meeting
	// the above criteria.
	Matches GRPCRouteSpecRulesMatchesPatchArrayInput `pulumi:"matches"`
}

func (GRPCRouteSpecRulesPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesPatch)(nil)).Elem()
}

func (i GRPCRouteSpecRulesPatchArgs) ToGRPCRouteSpecRulesPatchOutput() GRPCRouteSpecRulesPatchOutput {
	return i.ToGRPCRouteSpecRulesPatchOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesPatchArgs) ToGRPCRouteSpecRulesPatchOutputWithContext(ctx context.Context) GRPCRouteSpecRulesPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesPatchOutput)
}

// GRPCRouteSpecRulesPatchArrayInput is an input type that accepts GRPCRouteSpecRulesPatchArray and GRPCRouteSpecRulesPatchArrayOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesPatchArrayInput` via:
//
//	GRPCRouteSpecRulesPatchArray{ GRPCRouteSpecRulesPatchArgs{...} }
type GRPCRouteSpecRulesPatchArrayInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesPatchArrayOutput() GRPCRouteSpecRulesPatchArrayOutput
	ToGRPCRouteSpecRulesPatchArrayOutputWithContext(context.Context) GRPCRouteSpecRulesPatchArrayOutput
}

type GRPCRouteSpecRulesPatchArray []GRPCRouteSpecRulesPatchInput

func (GRPCRouteSpecRulesPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesPatch)(nil)).Elem()
}

func (i GRPCRouteSpecRulesPatchArray) ToGRPCRouteSpecRulesPatchArrayOutput() GRPCRouteSpecRulesPatchArrayOutput {
	return i.ToGRPCRouteSpecRulesPatchArrayOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesPatchArray) ToGRPCRouteSpecRulesPatchArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesPatchArrayOutput)
}

// GRPCRouteRule defines the semantics for matching a gRPC request based on
// conditions (matches), processing it (filters), and forwarding the request to
// an API object (backendRefs).
type GRPCRouteSpecRulesPatchOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesPatch)(nil)).Elem()
}

func (o GRPCRouteSpecRulesPatchOutput) ToGRPCRouteSpecRulesPatchOutput() GRPCRouteSpecRulesPatchOutput {
	return o
}

func (o GRPCRouteSpecRulesPatchOutput) ToGRPCRouteSpecRulesPatchOutputWithContext(ctx context.Context) GRPCRouteSpecRulesPatchOutput {
	return o
}

// BackendRefs defines the backend(s) where matching requests should be
// sent.
//
// Failure behavior here depends on how many BackendRefs are specified and
// how many are invalid.
//
// If *all* entries in BackendRefs are invalid, and there are also no filters
// specified in this route rule, *all* traffic which matches this rule MUST
// receive an `UNAVAILABLE` status.
//
// See the GRPCBackendRef definition for the rules about what makes a single
// GRPCBackendRef invalid.
//
// When a GRPCBackendRef is invalid, `UNAVAILABLE` statuses MUST be returned for
// requests that would have otherwise been routed to an invalid backend. If
// multiple backends are specified, and some are invalid, the proportion of
// requests that would otherwise have been routed to an invalid backend
// MUST receive an `UNAVAILABLE` status.
//
// For example, if two backends are specified with equal weights, and one is
// invalid, 50 percent of traffic MUST receive an `UNAVAILABLE` status.
// Implementations may choose how that 50 percent is determined.
//
// Support: Core for Kubernetes Service
//
// Support: Implementation-specific for any other resource
//
// Support for weight: Core
func (o GRPCRouteSpecRulesPatchOutput) BackendRefs() GRPCRouteSpecRulesBackendRefsPatchArrayOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesPatch) []GRPCRouteSpecRulesBackendRefsPatch { return v.BackendRefs }).(GRPCRouteSpecRulesBackendRefsPatchArrayOutput)
}

// Filters define the filters that are applied to requests that match
// this rule.
//
// The effects of ordering of multiple behaviors are currently unspecified.
// This can change in the future based on feedback during the alpha stage.
//
// Conformance-levels at this level are defined based on the type of filter:
//
//   - ALL core filters MUST be supported by all implementations that support
//     GRPCRoute.
//   - Implementers are encouraged to support extended filters.
//   - Implementation-specific custom filters have no API guarantees across
//     implementations.
//
// Specifying the same filter multiple times is not supported unless explicitly
// indicated in the filter.
//
// If an implementation can not support a combination of filters, it must clearly
// document that limitation. In cases where incompatible or unsupported
// filters are specified and cause the `Accepted` condition to be set to status
// `False`, implementations may use the `IncompatibleFilters` reason to specify
// this configuration error.
//
// Support: Core
func (o GRPCRouteSpecRulesPatchOutput) Filters() GRPCRouteSpecRulesFiltersPatchArrayOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesPatch) []GRPCRouteSpecRulesFiltersPatch { return v.Filters }).(GRPCRouteSpecRulesFiltersPatchArrayOutput)
}

// Matches define conditions used for matching the rule against incoming
// gRPC requests. Each match is independent, i.e. this rule will be matched
// if **any** one of the matches is satisfied.
//
// For example, take the following matches configuration:
//
// For a request to match against this rule, it MUST satisfy
// EITHER of the two conditions:
//
// - service of foo.bar AND contains the header `version: 2`
// - service of foo.bar.v2
//
// See the documentation for GRPCRouteMatch on how to specify multiple
// match conditions to be ANDed together.
//
// If no matches are specified, the implementation MUST match every gRPC request.
//
// Proxy or Load Balancer routing configuration generated from GRPCRoutes
// MUST prioritize rules based on the following criteria, continuing on
// ties. Merging MUST not be done between GRPCRoutes and HTTPRoutes.
// Precedence MUST be given to the rule with the largest number of:
//
// * Characters in a matching non-wildcard hostname.
// * Characters in a matching hostname.
// * Characters in a matching service.
// * Characters in a matching method.
// * Header matches.
//
// If ties still exist across multiple Routes, matching precedence MUST be
// determined in order of the following criteria, continuing on ties:
//
//   - The oldest Route based on creation timestamp.
//   - The Route appearing first in alphabetical order by
//     "{namespace}/{name}".
//
// If ties still exist within the Route that has been given precedence,
// matching precedence MUST be granted to the first matching rule meeting
// the above criteria.
func (o GRPCRouteSpecRulesPatchOutput) Matches() GRPCRouteSpecRulesMatchesPatchArrayOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesPatch) []GRPCRouteSpecRulesMatchesPatch { return v.Matches }).(GRPCRouteSpecRulesMatchesPatchArrayOutput)
}

type GRPCRouteSpecRulesPatchArrayOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesPatch)(nil)).Elem()
}

func (o GRPCRouteSpecRulesPatchArrayOutput) ToGRPCRouteSpecRulesPatchArrayOutput() GRPCRouteSpecRulesPatchArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesPatchArrayOutput) ToGRPCRouteSpecRulesPatchArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesPatchArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesPatchArrayOutput) Index(i pulumi.IntInput) GRPCRouteSpecRulesPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GRPCRouteSpecRulesPatch {
		return vs[0].([]GRPCRouteSpecRulesPatch)[vs[1].(int)]
	}).(GRPCRouteSpecRulesPatchOutput)
}

// Status defines the current state of GRPCRoute.
type GRPCRouteStatus struct {
	// Parents is a list of parent resources (usually Gateways) that are
	// associated with the route, and the status of the route with respect to
	// each parent. When this route attaches to a parent, the controller that
	// manages the parent must add an entry to this list when the controller
	// first sees the route and should update the entry as appropriate when the
	// route or gateway is modified.
	//
	// Note that parent references that cannot be resolved by an implementation
	// of this API will not be added to this list. Implementations of this API
	// can only populate Route status for the Gateways/parent resources they are
	// responsible for.
	//
	// A maximum of 32 Gateways will be represented in this list. An empty list
	// means the route has not been attached to any Gateway.
	Parents []GRPCRouteStatusParents `pulumi:"parents"`
}

// GRPCRouteStatusInput is an input type that accepts GRPCRouteStatusArgs and GRPCRouteStatusOutput values.
// You can construct a concrete instance of `GRPCRouteStatusInput` via:
//
//	GRPCRouteStatusArgs{...}
type GRPCRouteStatusInput interface {
	pulumi.Input

	ToGRPCRouteStatusOutput() GRPCRouteStatusOutput
	ToGRPCRouteStatusOutputWithContext(context.Context) GRPCRouteStatusOutput
}

// Status defines the current state of GRPCRoute.
type GRPCRouteStatusArgs struct {
	// Parents is a list of parent resources (usually Gateways) that are
	// associated with the route, and the status of the route with respect to
	// each parent. When this route attaches to a parent, the controller that
	// manages the parent must add an entry to this list when the controller
	// first sees the route and should update the entry as appropriate when the
	// route or gateway is modified.
	//
	// Note that parent references that cannot be resolved by an implementation
	// of this API will not be added to this list. Implementations of this API
	// can only populate Route status for the Gateways/parent resources they are
	// responsible for.
	//
	// A maximum of 32 Gateways will be represented in this list. An empty list
	// means the route has not been attached to any Gateway.
	Parents GRPCRouteStatusParentsArrayInput `pulumi:"parents"`
}

func (GRPCRouteStatusArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteStatus)(nil)).Elem()
}

func (i GRPCRouteStatusArgs) ToGRPCRouteStatusOutput() GRPCRouteStatusOutput {
	return i.ToGRPCRouteStatusOutputWithContext(context.Background())
}

func (i GRPCRouteStatusArgs) ToGRPCRouteStatusOutputWithContext(ctx context.Context) GRPCRouteStatusOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteStatusOutput)
}

func (i GRPCRouteStatusArgs) ToGRPCRouteStatusPtrOutput() GRPCRouteStatusPtrOutput {
	return i.ToGRPCRouteStatusPtrOutputWithContext(context.Background())
}

func (i GRPCRouteStatusArgs) ToGRPCRouteStatusPtrOutputWithContext(ctx context.Context) GRPCRouteStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteStatusOutput).ToGRPCRouteStatusPtrOutputWithContext(ctx)
}

// GRPCRouteStatusPtrInput is an input type that accepts GRPCRouteStatusArgs, GRPCRouteStatusPtr and GRPCRouteStatusPtrOutput values.
// You can construct a concrete instance of `GRPCRouteStatusPtrInput` via:
//
//	        GRPCRouteStatusArgs{...}
//
//	or:
//
//	        nil
type GRPCRouteStatusPtrInput interface {
	pulumi.Input

	ToGRPCRouteStatusPtrOutput() GRPCRouteStatusPtrOutput
	ToGRPCRouteStatusPtrOutputWithContext(context.Context) GRPCRouteStatusPtrOutput
}

type grpcrouteStatusPtrType GRPCRouteStatusArgs

func GRPCRouteStatusPtr(v *GRPCRouteStatusArgs) GRPCRouteStatusPtrInput {
	return (*grpcrouteStatusPtrType)(v)
}

func (*grpcrouteStatusPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteStatus)(nil)).Elem()
}

func (i *grpcrouteStatusPtrType) ToGRPCRouteStatusPtrOutput() GRPCRouteStatusPtrOutput {
	return i.ToGRPCRouteStatusPtrOutputWithContext(context.Background())
}

func (i *grpcrouteStatusPtrType) ToGRPCRouteStatusPtrOutputWithContext(ctx context.Context) GRPCRouteStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteStatusPtrOutput)
}

// Status defines the current state of GRPCRoute.
type GRPCRouteStatusOutput struct{ *pulumi.OutputState }

func (GRPCRouteStatusOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteStatus)(nil)).Elem()
}

func (o GRPCRouteStatusOutput) ToGRPCRouteStatusOutput() GRPCRouteStatusOutput {
	return o
}

func (o GRPCRouteStatusOutput) ToGRPCRouteStatusOutputWithContext(ctx context.Context) GRPCRouteStatusOutput {
	return o
}

func (o GRPCRouteStatusOutput) ToGRPCRouteStatusPtrOutput() GRPCRouteStatusPtrOutput {
	return o.ToGRPCRouteStatusPtrOutputWithContext(context.Background())
}

func (o GRPCRouteStatusOutput) ToGRPCRouteStatusPtrOutputWithContext(ctx context.Context) GRPCRouteStatusPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GRPCRouteStatus) *GRPCRouteStatus {
		return &v
	}).(GRPCRouteStatusPtrOutput)
}

// Parents is a list of parent resources (usually Gateways) that are
// associated with the route, and the status of the route with respect to
// each parent. When this route attaches to a parent, the controller that
// manages the parent must add an entry to this list when the controller
// first sees the route and should update the entry as appropriate when the
// route or gateway is modified.
//
// Note that parent references that cannot be resolved by an implementation
// of this API will not be added to this list. Implementations of this API
// can only populate Route status for the Gateways/parent resources they are
// responsible for.
//
// A maximum of 32 Gateways will be represented in this list. An empty list
// means the route has not been attached to any Gateway.
func (o GRPCRouteStatusOutput) Parents() GRPCRouteStatusParentsArrayOutput {
	return o.ApplyT(func(v GRPCRouteStatus) []GRPCRouteStatusParents { return v.Parents }).(GRPCRouteStatusParentsArrayOutput)
}

type GRPCRouteStatusPtrOutput struct{ *pulumi.OutputState }

func (GRPCRouteStatusPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteStatus)(nil)).Elem()
}

func (o GRPCRouteStatusPtrOutput) ToGRPCRouteStatusPtrOutput() GRPCRouteStatusPtrOutput {
	return o
}

func (o GRPCRouteStatusPtrOutput) ToGRPCRouteStatusPtrOutputWithContext(ctx context.Context) GRPCRouteStatusPtrOutput {
	return o
}

func (o GRPCRouteStatusPtrOutput) Elem() GRPCRouteStatusOutput {
	return o.ApplyT(func(v *GRPCRouteStatus) GRPCRouteStatus {
		if v != nil {
			return *v
		}
		var ret GRPCRouteStatus
		return ret
	}).(GRPCRouteStatusOutput)
}

// Parents is a list of parent resources (usually Gateways) that are
// associated with the route, and the status of the route with respect to
// each parent. When this route attaches to a parent, the controller that
// manages the parent must add an entry to this list when the controller
// first sees the route and should update the entry as appropriate when the
// route or gateway is modified.
//
// Note that parent references that cannot be resolved by an implementation
// of this API will not be added to this list. Implementations of this API
// can only populate Route status for the Gateways/parent resources they are
// responsible for.
//
// A maximum of 32 Gateways will be represented in this list. An empty list
// means the route has not been attached to any Gateway.
func (o GRPCRouteStatusPtrOutput) Parents() GRPCRouteStatusParentsArrayOutput {
	return o.ApplyT(func(v *GRPCRouteStatus) []GRPCRouteStatusParents {
		if v == nil {
			return nil
		}
		return v.Parents
	}).(GRPCRouteStatusParentsArrayOutput)
}

// RouteParentStatus describes the status of a route with respect to an
// associated Parent.
type GRPCRouteStatusParents struct {
	// Conditions describes the status of the route with respect to the Gateway.
	// Note that the route's availability is also subject to the Gateway's own
	// status conditions and listener status.
	//
	// If the Route's ParentRef specifies an existing Gateway that supports
	// Routes of this kind AND that Gateway's controller has sufficient access,
	// then that Gateway's controller MUST set the "Accepted" condition on the
	// Route, to indicate whether the route has been accepted or rejected by the
	// Gateway, and why.
	//
	// A Route MUST be considered "Accepted" if at least one of the Route's
	// rules is implemented by the Gateway.
	//
	// There are a number of cases where the "Accepted" condition may not be set
	// due to lack of controller visibility, that includes when:
	//
	// * The Route refers to a non-existent parent.
	// * The Route is of a type that the controller does not support.
	// * The Route is in a namespace the controller does not have access to.
	Conditions []GRPCRouteStatusParentsConditions `pulumi:"conditions"`
	// ControllerName is a domain/path string that indicates the name of the
	// controller that wrote this status. This corresponds with the
	// controllerName field on GatewayClass.
	//
	// Example: "example.net/gateway-controller".
	//
	// The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
	// valid Kubernetes names
	// (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
	//
	// Controllers MUST populate this field when writing status. Controllers should ensure that
	// entries to status populated with their ControllerName are cleaned up when they are no
	// longer necessary.
	ControllerName *string                          `pulumi:"controllerName"`
	ParentRef      *GRPCRouteStatusParentsParentRef `pulumi:"parentRef"`
}

// GRPCRouteStatusParentsInput is an input type that accepts GRPCRouteStatusParentsArgs and GRPCRouteStatusParentsOutput values.
// You can construct a concrete instance of `GRPCRouteStatusParentsInput` via:
//
//	GRPCRouteStatusParentsArgs{...}
type GRPCRouteStatusParentsInput interface {
	pulumi.Input

	ToGRPCRouteStatusParentsOutput() GRPCRouteStatusParentsOutput
	ToGRPCRouteStatusParentsOutputWithContext(context.Context) GRPCRouteStatusParentsOutput
}

// RouteParentStatus describes the status of a route with respect to an
// associated Parent.
type GRPCRouteStatusParentsArgs struct {
	// Conditions describes the status of the route with respect to the Gateway.
	// Note that the route's availability is also subject to the Gateway's own
	// status conditions and listener status.
	//
	// If the Route's ParentRef specifies an existing Gateway that supports
	// Routes of this kind AND that Gateway's controller has sufficient access,
	// then that Gateway's controller MUST set the "Accepted" condition on the
	// Route, to indicate whether the route has been accepted or rejected by the
	// Gateway, and why.
	//
	// A Route MUST be considered "Accepted" if at least one of the Route's
	// rules is implemented by the Gateway.
	//
	// There are a number of cases where the "Accepted" condition may not be set
	// due to lack of controller visibility, that includes when:
	//
	// * The Route refers to a non-existent parent.
	// * The Route is of a type that the controller does not support.
	// * The Route is in a namespace the controller does not have access to.
	Conditions GRPCRouteStatusParentsConditionsArrayInput `pulumi:"conditions"`
	// ControllerName is a domain/path string that indicates the name of the
	// controller that wrote this status. This corresponds with the
	// controllerName field on GatewayClass.
	//
	// Example: "example.net/gateway-controller".
	//
	// The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
	// valid Kubernetes names
	// (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
	//
	// Controllers MUST populate this field when writing status. Controllers should ensure that
	// entries to status populated with their ControllerName are cleaned up when they are no
	// longer necessary.
	ControllerName pulumi.StringPtrInput                   `pulumi:"controllerName"`
	ParentRef      GRPCRouteStatusParentsParentRefPtrInput `pulumi:"parentRef"`
}

func (GRPCRouteStatusParentsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteStatusParents)(nil)).Elem()
}

func (i GRPCRouteStatusParentsArgs) ToGRPCRouteStatusParentsOutput() GRPCRouteStatusParentsOutput {
	return i.ToGRPCRouteStatusParentsOutputWithContext(context.Background())
}

func (i GRPCRouteStatusParentsArgs) ToGRPCRouteStatusParentsOutputWithContext(ctx context.Context) GRPCRouteStatusParentsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteStatusParentsOutput)
}

// GRPCRouteStatusParentsArrayInput is an input type that accepts GRPCRouteStatusParentsArray and GRPCRouteStatusParentsArrayOutput values.
// You can construct a concrete instance of `GRPCRouteStatusParentsArrayInput` via:
//
//	GRPCRouteStatusParentsArray{ GRPCRouteStatusParentsArgs{...} }
type GRPCRouteStatusParentsArrayInput interface {
	pulumi.Input

	ToGRPCRouteStatusParentsArrayOutput() GRPCRouteStatusParentsArrayOutput
	ToGRPCRouteStatusParentsArrayOutputWithContext(context.Context) GRPCRouteStatusParentsArrayOutput
}

type GRPCRouteStatusParentsArray []GRPCRouteStatusParentsInput

func (GRPCRouteStatusParentsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteStatusParents)(nil)).Elem()
}

func (i GRPCRouteStatusParentsArray) ToGRPCRouteStatusParentsArrayOutput() GRPCRouteStatusParentsArrayOutput {
	return i.ToGRPCRouteStatusParentsArrayOutputWithContext(context.Background())
}

func (i GRPCRouteStatusParentsArray) ToGRPCRouteStatusParentsArrayOutputWithContext(ctx context.Context) GRPCRouteStatusParentsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteStatusParentsArrayOutput)
}

// RouteParentStatus describes the status of a route with respect to an
// associated Parent.
type GRPCRouteStatusParentsOutput struct{ *pulumi.OutputState }

func (GRPCRouteStatusParentsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteStatusParents)(nil)).Elem()
}

func (o GRPCRouteStatusParentsOutput) ToGRPCRouteStatusParentsOutput() GRPCRouteStatusParentsOutput {
	return o
}

func (o GRPCRouteStatusParentsOutput) ToGRPCRouteStatusParentsOutputWithContext(ctx context.Context) GRPCRouteStatusParentsOutput {
	return o
}

// Conditions describes the status of the route with respect to the Gateway.
// Note that the route's availability is also subject to the Gateway's own
// status conditions and listener status.
//
// If the Route's ParentRef specifies an existing Gateway that supports
// Routes of this kind AND that Gateway's controller has sufficient access,
// then that Gateway's controller MUST set the "Accepted" condition on the
// Route, to indicate whether the route has been accepted or rejected by the
// Gateway, and why.
//
// A Route MUST be considered "Accepted" if at least one of the Route's
// rules is implemented by the Gateway.
//
// There are a number of cases where the "Accepted" condition may not be set
// due to lack of controller visibility, that includes when:
//
// * The Route refers to a non-existent parent.
// * The Route is of a type that the controller does not support.
// * The Route is in a namespace the controller does not have access to.
func (o GRPCRouteStatusParentsOutput) Conditions() GRPCRouteStatusParentsConditionsArrayOutput {
	return o.ApplyT(func(v GRPCRouteStatusParents) []GRPCRouteStatusParentsConditions { return v.Conditions }).(GRPCRouteStatusParentsConditionsArrayOutput)
}

// ControllerName is a domain/path string that indicates the name of the
// controller that wrote this status. This corresponds with the
// controllerName field on GatewayClass.
//
// Example: "example.net/gateway-controller".
//
// The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
// valid Kubernetes names
// (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
//
// Controllers MUST populate this field when writing status. Controllers should ensure that
// entries to status populated with their ControllerName are cleaned up when they are no
// longer necessary.
func (o GRPCRouteStatusParentsOutput) ControllerName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteStatusParents) *string { return v.ControllerName }).(pulumi.StringPtrOutput)
}

func (o GRPCRouteStatusParentsOutput) ParentRef() GRPCRouteStatusParentsParentRefPtrOutput {
	return o.ApplyT(func(v GRPCRouteStatusParents) *GRPCRouteStatusParentsParentRef { return v.ParentRef }).(GRPCRouteStatusParentsParentRefPtrOutput)
}

type GRPCRouteStatusParentsArrayOutput struct{ *pulumi.OutputState }

func (GRPCRouteStatusParentsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteStatusParents)(nil)).Elem()
}

func (o GRPCRouteStatusParentsArrayOutput) ToGRPCRouteStatusParentsArrayOutput() GRPCRouteStatusParentsArrayOutput {
	return o
}

func (o GRPCRouteStatusParentsArrayOutput) ToGRPCRouteStatusParentsArrayOutputWithContext(ctx context.Context) GRPCRouteStatusParentsArrayOutput {
	return o
}

func (o GRPCRouteStatusParentsArrayOutput) Index(i pulumi.IntInput) GRPCRouteStatusParentsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GRPCRouteStatusParents {
		return vs[0].([]GRPCRouteStatusParents)[vs[1].(int)]
	}).(GRPCRouteStatusParentsOutput)
}

// Condition contains details for one aspect of the current state of this API Resource.
// ---
// This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{
//	    // Represents the observations of a foo's current state.
//	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
//	    // +patchMergeKey=type
//	    // +patchStrategy=merge
//	    // +listType=map
//	    // +listMapKey=type
//	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//
//
//	    // other fields
//	}
type GRPCRouteStatusParentsConditions struct {
	// lastTransitionTime is the last time the condition transitioned from one status to another.
	// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	LastTransitionTime *string `pulumi:"lastTransitionTime"`
	// message is a human readable message indicating details about the transition.
	// This may be an empty string.
	Message *string `pulumi:"message"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon.
	// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
	// with respect to the current state of the instance.
	ObservedGeneration *int `pulumi:"observedGeneration"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition.
	// Producers of specific condition types may define expected values and meanings for this field,
	// and whether the values are considered a guaranteed API.
	// The value should be a CamelCase string.
	// This field may not be empty.
	Reason *string `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status *string `pulumi:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase.
	// ---
	// Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
	// useful (see .node.status.conditions), the ability to deconflict is important.
	// The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
	Type *string `pulumi:"type"`
}

// GRPCRouteStatusParentsConditionsInput is an input type that accepts GRPCRouteStatusParentsConditionsArgs and GRPCRouteStatusParentsConditionsOutput values.
// You can construct a concrete instance of `GRPCRouteStatusParentsConditionsInput` via:
//
//	GRPCRouteStatusParentsConditionsArgs{...}
type GRPCRouteStatusParentsConditionsInput interface {
	pulumi.Input

	ToGRPCRouteStatusParentsConditionsOutput() GRPCRouteStatusParentsConditionsOutput
	ToGRPCRouteStatusParentsConditionsOutputWithContext(context.Context) GRPCRouteStatusParentsConditionsOutput
}

// Condition contains details for one aspect of the current state of this API Resource.
// ---
// This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{
//	    // Represents the observations of a foo's current state.
//	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
//	    // +patchMergeKey=type
//	    // +patchStrategy=merge
//	    // +listType=map
//	    // +listMapKey=type
//	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//
//
//	    // other fields
//	}
type GRPCRouteStatusParentsConditionsArgs struct {
	// lastTransitionTime is the last time the condition transitioned from one status to another.
	// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	LastTransitionTime pulumi.StringPtrInput `pulumi:"lastTransitionTime"`
	// message is a human readable message indicating details about the transition.
	// This may be an empty string.
	Message pulumi.StringPtrInput `pulumi:"message"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon.
	// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
	// with respect to the current state of the instance.
	ObservedGeneration pulumi.IntPtrInput `pulumi:"observedGeneration"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition.
	// Producers of specific condition types may define expected values and meanings for this field,
	// and whether the values are considered a guaranteed API.
	// The value should be a CamelCase string.
	// This field may not be empty.
	Reason pulumi.StringPtrInput `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status pulumi.StringPtrInput `pulumi:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase.
	// ---
	// Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
	// useful (see .node.status.conditions), the ability to deconflict is important.
	// The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (GRPCRouteStatusParentsConditionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteStatusParentsConditions)(nil)).Elem()
}

func (i GRPCRouteStatusParentsConditionsArgs) ToGRPCRouteStatusParentsConditionsOutput() GRPCRouteStatusParentsConditionsOutput {
	return i.ToGRPCRouteStatusParentsConditionsOutputWithContext(context.Background())
}

func (i GRPCRouteStatusParentsConditionsArgs) ToGRPCRouteStatusParentsConditionsOutputWithContext(ctx context.Context) GRPCRouteStatusParentsConditionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteStatusParentsConditionsOutput)
}

// GRPCRouteStatusParentsConditionsArrayInput is an input type that accepts GRPCRouteStatusParentsConditionsArray and GRPCRouteStatusParentsConditionsArrayOutput values.
// You can construct a concrete instance of `GRPCRouteStatusParentsConditionsArrayInput` via:
//
//	GRPCRouteStatusParentsConditionsArray{ GRPCRouteStatusParentsConditionsArgs{...} }
type GRPCRouteStatusParentsConditionsArrayInput interface {
	pulumi.Input

	ToGRPCRouteStatusParentsConditionsArrayOutput() GRPCRouteStatusParentsConditionsArrayOutput
	ToGRPCRouteStatusParentsConditionsArrayOutputWithContext(context.Context) GRPCRouteStatusParentsConditionsArrayOutput
}

type GRPCRouteStatusParentsConditionsArray []GRPCRouteStatusParentsConditionsInput

func (GRPCRouteStatusParentsConditionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteStatusParentsConditions)(nil)).Elem()
}

func (i GRPCRouteStatusParentsConditionsArray) ToGRPCRouteStatusParentsConditionsArrayOutput() GRPCRouteStatusParentsConditionsArrayOutput {
	return i.ToGRPCRouteStatusParentsConditionsArrayOutputWithContext(context.Background())
}

func (i GRPCRouteStatusParentsConditionsArray) ToGRPCRouteStatusParentsConditionsArrayOutputWithContext(ctx context.Context) GRPCRouteStatusParentsConditionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteStatusParentsConditionsArrayOutput)
}

// Condition contains details for one aspect of the current state of this API Resource.
// ---
// This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{
//	    // Represents the observations of a foo's current state.
//	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
//	    // +patchMergeKey=type
//	    // +patchStrategy=merge
//	    // +listType=map
//	    // +listMapKey=type
//	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//
//
//	    // other fields
//	}
type GRPCRouteStatusParentsConditionsOutput struct{ *pulumi.OutputState }

func (GRPCRouteStatusParentsConditionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteStatusParentsConditions)(nil)).Elem()
}

func (o GRPCRouteStatusParentsConditionsOutput) ToGRPCRouteStatusParentsConditionsOutput() GRPCRouteStatusParentsConditionsOutput {
	return o
}

func (o GRPCRouteStatusParentsConditionsOutput) ToGRPCRouteStatusParentsConditionsOutputWithContext(ctx context.Context) GRPCRouteStatusParentsConditionsOutput {
	return o
}

// lastTransitionTime is the last time the condition transitioned from one status to another.
// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
func (o GRPCRouteStatusParentsConditionsOutput) LastTransitionTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteStatusParentsConditions) *string { return v.LastTransitionTime }).(pulumi.StringPtrOutput)
}

// message is a human readable message indicating details about the transition.
// This may be an empty string.
func (o GRPCRouteStatusParentsConditionsOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteStatusParentsConditions) *string { return v.Message }).(pulumi.StringPtrOutput)
}

// observedGeneration represents the .metadata.generation that the condition was set based upon.
// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
// with respect to the current state of the instance.
func (o GRPCRouteStatusParentsConditionsOutput) ObservedGeneration() pulumi.IntPtrOutput {
	return o.ApplyT(func(v GRPCRouteStatusParentsConditions) *int { return v.ObservedGeneration }).(pulumi.IntPtrOutput)
}

// reason contains a programmatic identifier indicating the reason for the condition's last transition.
// Producers of specific condition types may define expected values and meanings for this field,
// and whether the values are considered a guaranteed API.
// The value should be a CamelCase string.
// This field may not be empty.
func (o GRPCRouteStatusParentsConditionsOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteStatusParentsConditions) *string { return v.Reason }).(pulumi.StringPtrOutput)
}

// status of the condition, one of True, False, Unknown.
func (o GRPCRouteStatusParentsConditionsOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteStatusParentsConditions) *string { return v.Status }).(pulumi.StringPtrOutput)
}

// type of condition in CamelCase or in foo.example.com/CamelCase.
// ---
// Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
// useful (see .node.status.conditions), the ability to deconflict is important.
// The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
func (o GRPCRouteStatusParentsConditionsOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteStatusParentsConditions) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type GRPCRouteStatusParentsConditionsArrayOutput struct{ *pulumi.OutputState }

func (GRPCRouteStatusParentsConditionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteStatusParentsConditions)(nil)).Elem()
}

func (o GRPCRouteStatusParentsConditionsArrayOutput) ToGRPCRouteStatusParentsConditionsArrayOutput() GRPCRouteStatusParentsConditionsArrayOutput {
	return o
}

func (o GRPCRouteStatusParentsConditionsArrayOutput) ToGRPCRouteStatusParentsConditionsArrayOutputWithContext(ctx context.Context) GRPCRouteStatusParentsConditionsArrayOutput {
	return o
}

func (o GRPCRouteStatusParentsConditionsArrayOutput) Index(i pulumi.IntInput) GRPCRouteStatusParentsConditionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GRPCRouteStatusParentsConditions {
		return vs[0].([]GRPCRouteStatusParentsConditions)[vs[1].(int)]
	}).(GRPCRouteStatusParentsConditionsOutput)
}

// Condition contains details for one aspect of the current state of this API Resource.
// ---
// This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{
//	    // Represents the observations of a foo's current state.
//	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
//	    // +patchMergeKey=type
//	    // +patchStrategy=merge
//	    // +listType=map
//	    // +listMapKey=type
//	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//
//
//	    // other fields
//	}
type GRPCRouteStatusParentsConditionsPatch struct {
	// lastTransitionTime is the last time the condition transitioned from one status to another.
	// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	LastTransitionTime *string `pulumi:"lastTransitionTime"`
	// message is a human readable message indicating details about the transition.
	// This may be an empty string.
	Message *string `pulumi:"message"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon.
	// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
	// with respect to the current state of the instance.
	ObservedGeneration *int `pulumi:"observedGeneration"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition.
	// Producers of specific condition types may define expected values and meanings for this field,
	// and whether the values are considered a guaranteed API.
	// The value should be a CamelCase string.
	// This field may not be empty.
	Reason *string `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status *string `pulumi:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase.
	// ---
	// Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
	// useful (see .node.status.conditions), the ability to deconflict is important.
	// The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
	Type *string `pulumi:"type"`
}

// GRPCRouteStatusParentsConditionsPatchInput is an input type that accepts GRPCRouteStatusParentsConditionsPatchArgs and GRPCRouteStatusParentsConditionsPatchOutput values.
// You can construct a concrete instance of `GRPCRouteStatusParentsConditionsPatchInput` via:
//
//	GRPCRouteStatusParentsConditionsPatchArgs{...}
type GRPCRouteStatusParentsConditionsPatchInput interface {
	pulumi.Input

	ToGRPCRouteStatusParentsConditionsPatchOutput() GRPCRouteStatusParentsConditionsPatchOutput
	ToGRPCRouteStatusParentsConditionsPatchOutputWithContext(context.Context) GRPCRouteStatusParentsConditionsPatchOutput
}

// Condition contains details for one aspect of the current state of this API Resource.
// ---
// This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{
//	    // Represents the observations of a foo's current state.
//	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
//	    // +patchMergeKey=type
//	    // +patchStrategy=merge
//	    // +listType=map
//	    // +listMapKey=type
//	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//
//
//	    // other fields
//	}
type GRPCRouteStatusParentsConditionsPatchArgs struct {
	// lastTransitionTime is the last time the condition transitioned from one status to another.
	// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	LastTransitionTime pulumi.StringPtrInput `pulumi:"lastTransitionTime"`
	// message is a human readable message indicating details about the transition.
	// This may be an empty string.
	Message pulumi.StringPtrInput `pulumi:"message"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon.
	// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
	// with respect to the current state of the instance.
	ObservedGeneration pulumi.IntPtrInput `pulumi:"observedGeneration"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition.
	// Producers of specific condition types may define expected values and meanings for this field,
	// and whether the values are considered a guaranteed API.
	// The value should be a CamelCase string.
	// This field may not be empty.
	Reason pulumi.StringPtrInput `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status pulumi.StringPtrInput `pulumi:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase.
	// ---
	// Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
	// useful (see .node.status.conditions), the ability to deconflict is important.
	// The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (GRPCRouteStatusParentsConditionsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteStatusParentsConditionsPatch)(nil)).Elem()
}

func (i GRPCRouteStatusParentsConditionsPatchArgs) ToGRPCRouteStatusParentsConditionsPatchOutput() GRPCRouteStatusParentsConditionsPatchOutput {
	return i.ToGRPCRouteStatusParentsConditionsPatchOutputWithContext(context.Background())
}

func (i GRPCRouteStatusParentsConditionsPatchArgs) ToGRPCRouteStatusParentsConditionsPatchOutputWithContext(ctx context.Context) GRPCRouteStatusParentsConditionsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteStatusParentsConditionsPatchOutput)
}

// GRPCRouteStatusParentsConditionsPatchArrayInput is an input type that accepts GRPCRouteStatusParentsConditionsPatchArray and GRPCRouteStatusParentsConditionsPatchArrayOutput values.
// You can construct a concrete instance of `GRPCRouteStatusParentsConditionsPatchArrayInput` via:
//
//	GRPCRouteStatusParentsConditionsPatchArray{ GRPCRouteStatusParentsConditionsPatchArgs{...} }
type GRPCRouteStatusParentsConditionsPatchArrayInput interface {
	pulumi.Input

	ToGRPCRouteStatusParentsConditionsPatchArrayOutput() GRPCRouteStatusParentsConditionsPatchArrayOutput
	ToGRPCRouteStatusParentsConditionsPatchArrayOutputWithContext(context.Context) GRPCRouteStatusParentsConditionsPatchArrayOutput
}

type GRPCRouteStatusParentsConditionsPatchArray []GRPCRouteStatusParentsConditionsPatchInput

func (GRPCRouteStatusParentsConditionsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteStatusParentsConditionsPatch)(nil)).Elem()
}

func (i GRPCRouteStatusParentsConditionsPatchArray) ToGRPCRouteStatusParentsConditionsPatchArrayOutput() GRPCRouteStatusParentsConditionsPatchArrayOutput {
	return i.ToGRPCRouteStatusParentsConditionsPatchArrayOutputWithContext(context.Background())
}

func (i GRPCRouteStatusParentsConditionsPatchArray) ToGRPCRouteStatusParentsConditionsPatchArrayOutputWithContext(ctx context.Context) GRPCRouteStatusParentsConditionsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteStatusParentsConditionsPatchArrayOutput)
}

// Condition contains details for one aspect of the current state of this API Resource.
// ---
// This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{
//	    // Represents the observations of a foo's current state.
//	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
//	    // +patchMergeKey=type
//	    // +patchStrategy=merge
//	    // +listType=map
//	    // +listMapKey=type
//	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//
//
//	    // other fields
//	}
type GRPCRouteStatusParentsConditionsPatchOutput struct{ *pulumi.OutputState }

func (GRPCRouteStatusParentsConditionsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteStatusParentsConditionsPatch)(nil)).Elem()
}

func (o GRPCRouteStatusParentsConditionsPatchOutput) ToGRPCRouteStatusParentsConditionsPatchOutput() GRPCRouteStatusParentsConditionsPatchOutput {
	return o
}

func (o GRPCRouteStatusParentsConditionsPatchOutput) ToGRPCRouteStatusParentsConditionsPatchOutputWithContext(ctx context.Context) GRPCRouteStatusParentsConditionsPatchOutput {
	return o
}

// lastTransitionTime is the last time the condition transitioned from one status to another.
// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
func (o GRPCRouteStatusParentsConditionsPatchOutput) LastTransitionTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteStatusParentsConditionsPatch) *string { return v.LastTransitionTime }).(pulumi.StringPtrOutput)
}

// message is a human readable message indicating details about the transition.
// This may be an empty string.
func (o GRPCRouteStatusParentsConditionsPatchOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteStatusParentsConditionsPatch) *string { return v.Message }).(pulumi.StringPtrOutput)
}

// observedGeneration represents the .metadata.generation that the condition was set based upon.
// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
// with respect to the current state of the instance.
func (o GRPCRouteStatusParentsConditionsPatchOutput) ObservedGeneration() pulumi.IntPtrOutput {
	return o.ApplyT(func(v GRPCRouteStatusParentsConditionsPatch) *int { return v.ObservedGeneration }).(pulumi.IntPtrOutput)
}

// reason contains a programmatic identifier indicating the reason for the condition's last transition.
// Producers of specific condition types may define expected values and meanings for this field,
// and whether the values are considered a guaranteed API.
// The value should be a CamelCase string.
// This field may not be empty.
func (o GRPCRouteStatusParentsConditionsPatchOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteStatusParentsConditionsPatch) *string { return v.Reason }).(pulumi.StringPtrOutput)
}

// status of the condition, one of True, False, Unknown.
func (o GRPCRouteStatusParentsConditionsPatchOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteStatusParentsConditionsPatch) *string { return v.Status }).(pulumi.StringPtrOutput)
}

// type of condition in CamelCase or in foo.example.com/CamelCase.
// ---
// Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
// useful (see .node.status.conditions), the ability to deconflict is important.
// The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
func (o GRPCRouteStatusParentsConditionsPatchOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteStatusParentsConditionsPatch) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type GRPCRouteStatusParentsConditionsPatchArrayOutput struct{ *pulumi.OutputState }

func (GRPCRouteStatusParentsConditionsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteStatusParentsConditionsPatch)(nil)).Elem()
}

func (o GRPCRouteStatusParentsConditionsPatchArrayOutput) ToGRPCRouteStatusParentsConditionsPatchArrayOutput() GRPCRouteStatusParentsConditionsPatchArrayOutput {
	return o
}

func (o GRPCRouteStatusParentsConditionsPatchArrayOutput) ToGRPCRouteStatusParentsConditionsPatchArrayOutputWithContext(ctx context.Context) GRPCRouteStatusParentsConditionsPatchArrayOutput {
	return o
}

func (o GRPCRouteStatusParentsConditionsPatchArrayOutput) Index(i pulumi.IntInput) GRPCRouteStatusParentsConditionsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GRPCRouteStatusParentsConditionsPatch {
		return vs[0].([]GRPCRouteStatusParentsConditionsPatch)[vs[1].(int)]
	}).(GRPCRouteStatusParentsConditionsPatchOutput)
}

// ParentRef corresponds with a ParentRef in the spec that this
// RouteParentStatus struct describes the status of.
type GRPCRouteStatusParentsParentRef struct {
	// Group is the group of the referent.
	// When unspecified, "gateway.networking.k8s.io" is inferred.
	// To set the core API group (such as for a "Service" kind referent),
	// Group must be explicitly set to "" (empty string).
	//
	// Support: Core
	Group *string `pulumi:"group"`
	// Kind is kind of the referent.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// Support for other resources is Implementation-Specific.
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	//
	// Support: Core
	Name *string `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers
	// to the local namespace of the Route.
	//
	// Note that there are specific rules for ParentRefs which cross namespace
	// boundaries. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example:
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable any other kind of cross-namespace reference.
	//
	// Support: Core
	Namespace *string `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted
	// differently based on the type of parent resource.
	//
	// When the parent resource is a Gateway, this targets all listeners
	// listening on the specified port that also support this kind of Route(and
	// select this Route). It's not recommended to set `Port` unless the
	// networking behaviors specified in a Route must apply to a specific port
	// as opposed to a listener(s) whose port(s) may be changed. When both Port
	// and SectionName are specified, the name and port of the selected listener
	// must match both specified values.
	//
	// Implementations MAY choose to support other parent resources.
	// Implementations supporting other types of parent resources MUST clearly
	// document how/if Port is interpreted.
	//
	// For the purpose of status, an attachment is considered successful as
	// long as the parent resource accepts it partially. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
	// from the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route,
	// the Route MUST be considered detached from the Gateway.
	//
	// Support: Extended
	Port *int `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the
	// following resources, SectionName is interpreted as the following:
	//
	// * Gateway: Listener name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	// * Service: Port name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	//
	// Implementations MAY choose to support attaching Routes to other resources.
	// If that is the case, they MUST clearly document how SectionName is
	// interpreted.
	//
	// When unspecified (empty string), this will reference the entire resource.
	// For the purpose of status, an attachment is considered successful if at
	// least one section in the parent resource accepts it. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
	// the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route, the
	// Route MUST be considered detached from the Gateway.
	//
	// Support: Core
	SectionName *string `pulumi:"sectionName"`
}

// GRPCRouteStatusParentsParentRefInput is an input type that accepts GRPCRouteStatusParentsParentRefArgs and GRPCRouteStatusParentsParentRefOutput values.
// You can construct a concrete instance of `GRPCRouteStatusParentsParentRefInput` via:
//
//	GRPCRouteStatusParentsParentRefArgs{...}
type GRPCRouteStatusParentsParentRefInput interface {
	pulumi.Input

	ToGRPCRouteStatusParentsParentRefOutput() GRPCRouteStatusParentsParentRefOutput
	ToGRPCRouteStatusParentsParentRefOutputWithContext(context.Context) GRPCRouteStatusParentsParentRefOutput
}

// ParentRef corresponds with a ParentRef in the spec that this
// RouteParentStatus struct describes the status of.
type GRPCRouteStatusParentsParentRefArgs struct {
	// Group is the group of the referent.
	// When unspecified, "gateway.networking.k8s.io" is inferred.
	// To set the core API group (such as for a "Service" kind referent),
	// Group must be explicitly set to "" (empty string).
	//
	// Support: Core
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is kind of the referent.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// Support for other resources is Implementation-Specific.
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	//
	// Support: Core
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers
	// to the local namespace of the Route.
	//
	// Note that there are specific rules for ParentRefs which cross namespace
	// boundaries. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example:
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable any other kind of cross-namespace reference.
	//
	// Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted
	// differently based on the type of parent resource.
	//
	// When the parent resource is a Gateway, this targets all listeners
	// listening on the specified port that also support this kind of Route(and
	// select this Route). It's not recommended to set `Port` unless the
	// networking behaviors specified in a Route must apply to a specific port
	// as opposed to a listener(s) whose port(s) may be changed. When both Port
	// and SectionName are specified, the name and port of the selected listener
	// must match both specified values.
	//
	// Implementations MAY choose to support other parent resources.
	// Implementations supporting other types of parent resources MUST clearly
	// document how/if Port is interpreted.
	//
	// For the purpose of status, an attachment is considered successful as
	// long as the parent resource accepts it partially. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
	// from the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route,
	// the Route MUST be considered detached from the Gateway.
	//
	// Support: Extended
	Port pulumi.IntPtrInput `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the
	// following resources, SectionName is interpreted as the following:
	//
	// * Gateway: Listener name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	// * Service: Port name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	//
	// Implementations MAY choose to support attaching Routes to other resources.
	// If that is the case, they MUST clearly document how SectionName is
	// interpreted.
	//
	// When unspecified (empty string), this will reference the entire resource.
	// For the purpose of status, an attachment is considered successful if at
	// least one section in the parent resource accepts it. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
	// the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route, the
	// Route MUST be considered detached from the Gateway.
	//
	// Support: Core
	SectionName pulumi.StringPtrInput `pulumi:"sectionName"`
}

func (GRPCRouteStatusParentsParentRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteStatusParentsParentRef)(nil)).Elem()
}

func (i GRPCRouteStatusParentsParentRefArgs) ToGRPCRouteStatusParentsParentRefOutput() GRPCRouteStatusParentsParentRefOutput {
	return i.ToGRPCRouteStatusParentsParentRefOutputWithContext(context.Background())
}

func (i GRPCRouteStatusParentsParentRefArgs) ToGRPCRouteStatusParentsParentRefOutputWithContext(ctx context.Context) GRPCRouteStatusParentsParentRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteStatusParentsParentRefOutput)
}

func (i GRPCRouteStatusParentsParentRefArgs) ToGRPCRouteStatusParentsParentRefPtrOutput() GRPCRouteStatusParentsParentRefPtrOutput {
	return i.ToGRPCRouteStatusParentsParentRefPtrOutputWithContext(context.Background())
}

func (i GRPCRouteStatusParentsParentRefArgs) ToGRPCRouteStatusParentsParentRefPtrOutputWithContext(ctx context.Context) GRPCRouteStatusParentsParentRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteStatusParentsParentRefOutput).ToGRPCRouteStatusParentsParentRefPtrOutputWithContext(ctx)
}

// GRPCRouteStatusParentsParentRefPtrInput is an input type that accepts GRPCRouteStatusParentsParentRefArgs, GRPCRouteStatusParentsParentRefPtr and GRPCRouteStatusParentsParentRefPtrOutput values.
// You can construct a concrete instance of `GRPCRouteStatusParentsParentRefPtrInput` via:
//
//	        GRPCRouteStatusParentsParentRefArgs{...}
//
//	or:
//
//	        nil
type GRPCRouteStatusParentsParentRefPtrInput interface {
	pulumi.Input

	ToGRPCRouteStatusParentsParentRefPtrOutput() GRPCRouteStatusParentsParentRefPtrOutput
	ToGRPCRouteStatusParentsParentRefPtrOutputWithContext(context.Context) GRPCRouteStatusParentsParentRefPtrOutput
}

type grpcrouteStatusParentsParentRefPtrType GRPCRouteStatusParentsParentRefArgs

func GRPCRouteStatusParentsParentRefPtr(v *GRPCRouteStatusParentsParentRefArgs) GRPCRouteStatusParentsParentRefPtrInput {
	return (*grpcrouteStatusParentsParentRefPtrType)(v)
}

func (*grpcrouteStatusParentsParentRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteStatusParentsParentRef)(nil)).Elem()
}

func (i *grpcrouteStatusParentsParentRefPtrType) ToGRPCRouteStatusParentsParentRefPtrOutput() GRPCRouteStatusParentsParentRefPtrOutput {
	return i.ToGRPCRouteStatusParentsParentRefPtrOutputWithContext(context.Background())
}

func (i *grpcrouteStatusParentsParentRefPtrType) ToGRPCRouteStatusParentsParentRefPtrOutputWithContext(ctx context.Context) GRPCRouteStatusParentsParentRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteStatusParentsParentRefPtrOutput)
}

// ParentRef corresponds with a ParentRef in the spec that this
// RouteParentStatus struct describes the status of.
type GRPCRouteStatusParentsParentRefOutput struct{ *pulumi.OutputState }

func (GRPCRouteStatusParentsParentRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteStatusParentsParentRef)(nil)).Elem()
}

func (o GRPCRouteStatusParentsParentRefOutput) ToGRPCRouteStatusParentsParentRefOutput() GRPCRouteStatusParentsParentRefOutput {
	return o
}

func (o GRPCRouteStatusParentsParentRefOutput) ToGRPCRouteStatusParentsParentRefOutputWithContext(ctx context.Context) GRPCRouteStatusParentsParentRefOutput {
	return o
}

func (o GRPCRouteStatusParentsParentRefOutput) ToGRPCRouteStatusParentsParentRefPtrOutput() GRPCRouteStatusParentsParentRefPtrOutput {
	return o.ToGRPCRouteStatusParentsParentRefPtrOutputWithContext(context.Background())
}

func (o GRPCRouteStatusParentsParentRefOutput) ToGRPCRouteStatusParentsParentRefPtrOutputWithContext(ctx context.Context) GRPCRouteStatusParentsParentRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GRPCRouteStatusParentsParentRef) *GRPCRouteStatusParentsParentRef {
		return &v
	}).(GRPCRouteStatusParentsParentRefPtrOutput)
}

// Group is the group of the referent.
// When unspecified, "gateway.networking.k8s.io" is inferred.
// To set the core API group (such as for a "Service" kind referent),
// Group must be explicitly set to "" (empty string).
//
// Support: Core
func (o GRPCRouteStatusParentsParentRefOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteStatusParentsParentRef) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent.
//
// There are two kinds of parent resources with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// Support for other resources is Implementation-Specific.
func (o GRPCRouteStatusParentsParentRefOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteStatusParentsParentRef) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
//
// Support: Core
func (o GRPCRouteStatusParentsParentRefOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteStatusParentsParentRef) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the referent. When unspecified, this refers
// to the local namespace of the Route.
//
// Note that there are specific rules for ParentRefs which cross namespace
// boundaries. Cross-namespace references are only valid if they are explicitly
// allowed by something in the namespace they are referring to. For example:
// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
// generic way to enable any other kind of cross-namespace reference.
//
// Support: Core
func (o GRPCRouteStatusParentsParentRefOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteStatusParentsParentRef) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Port is the network port this Route targets. It can be interpreted
// differently based on the type of parent resource.
//
// When the parent resource is a Gateway, this targets all listeners
// listening on the specified port that also support this kind of Route(and
// select this Route). It's not recommended to set `Port` unless the
// networking behaviors specified in a Route must apply to a specific port
// as opposed to a listener(s) whose port(s) may be changed. When both Port
// and SectionName are specified, the name and port of the selected listener
// must match both specified values.
//
// Implementations MAY choose to support other parent resources.
// Implementations supporting other types of parent resources MUST clearly
// document how/if Port is interpreted.
//
// For the purpose of status, an attachment is considered successful as
// long as the parent resource accepts it partially. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
// from the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route,
// the Route MUST be considered detached from the Gateway.
//
// Support: Extended
func (o GRPCRouteStatusParentsParentRefOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v GRPCRouteStatusParentsParentRef) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// SectionName is the name of a section within the target resource. In the
// following resources, SectionName is interpreted as the following:
//
//   - Gateway: Listener name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//   - Service: Port name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//
// Implementations MAY choose to support attaching Routes to other resources.
// If that is the case, they MUST clearly document how SectionName is
// interpreted.
//
// When unspecified (empty string), this will reference the entire resource.
// For the purpose of status, an attachment is considered successful if at
// least one section in the parent resource accepts it. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
// the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route, the
// Route MUST be considered detached from the Gateway.
//
// Support: Core
func (o GRPCRouteStatusParentsParentRefOutput) SectionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteStatusParentsParentRef) *string { return v.SectionName }).(pulumi.StringPtrOutput)
}

type GRPCRouteStatusParentsParentRefPtrOutput struct{ *pulumi.OutputState }

func (GRPCRouteStatusParentsParentRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteStatusParentsParentRef)(nil)).Elem()
}

func (o GRPCRouteStatusParentsParentRefPtrOutput) ToGRPCRouteStatusParentsParentRefPtrOutput() GRPCRouteStatusParentsParentRefPtrOutput {
	return o
}

func (o GRPCRouteStatusParentsParentRefPtrOutput) ToGRPCRouteStatusParentsParentRefPtrOutputWithContext(ctx context.Context) GRPCRouteStatusParentsParentRefPtrOutput {
	return o
}

func (o GRPCRouteStatusParentsParentRefPtrOutput) Elem() GRPCRouteStatusParentsParentRefOutput {
	return o.ApplyT(func(v *GRPCRouteStatusParentsParentRef) GRPCRouteStatusParentsParentRef {
		if v != nil {
			return *v
		}
		var ret GRPCRouteStatusParentsParentRef
		return ret
	}).(GRPCRouteStatusParentsParentRefOutput)
}

// Group is the group of the referent.
// When unspecified, "gateway.networking.k8s.io" is inferred.
// To set the core API group (such as for a "Service" kind referent),
// Group must be explicitly set to "" (empty string).
//
// Support: Core
func (o GRPCRouteStatusParentsParentRefPtrOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GRPCRouteStatusParentsParentRef) *string {
		if v == nil {
			return nil
		}
		return v.Group
	}).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent.
//
// There are two kinds of parent resources with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// Support for other resources is Implementation-Specific.
func (o GRPCRouteStatusParentsParentRefPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GRPCRouteStatusParentsParentRef) *string {
		if v == nil {
			return nil
		}
		return v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
//
// Support: Core
func (o GRPCRouteStatusParentsParentRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GRPCRouteStatusParentsParentRef) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the referent. When unspecified, this refers
// to the local namespace of the Route.
//
// Note that there are specific rules for ParentRefs which cross namespace
// boundaries. Cross-namespace references are only valid if they are explicitly
// allowed by something in the namespace they are referring to. For example:
// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
// generic way to enable any other kind of cross-namespace reference.
//
// Support: Core
func (o GRPCRouteStatusParentsParentRefPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GRPCRouteStatusParentsParentRef) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

// Port is the network port this Route targets. It can be interpreted
// differently based on the type of parent resource.
//
// When the parent resource is a Gateway, this targets all listeners
// listening on the specified port that also support this kind of Route(and
// select this Route). It's not recommended to set `Port` unless the
// networking behaviors specified in a Route must apply to a specific port
// as opposed to a listener(s) whose port(s) may be changed. When both Port
// and SectionName are specified, the name and port of the selected listener
// must match both specified values.
//
// Implementations MAY choose to support other parent resources.
// Implementations supporting other types of parent resources MUST clearly
// document how/if Port is interpreted.
//
// For the purpose of status, an attachment is considered successful as
// long as the parent resource accepts it partially. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
// from the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route,
// the Route MUST be considered detached from the Gateway.
//
// Support: Extended
func (o GRPCRouteStatusParentsParentRefPtrOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *GRPCRouteStatusParentsParentRef) *int {
		if v == nil {
			return nil
		}
		return v.Port
	}).(pulumi.IntPtrOutput)
}

// SectionName is the name of a section within the target resource. In the
// following resources, SectionName is interpreted as the following:
//
//   - Gateway: Listener name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//   - Service: Port name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//
// Implementations MAY choose to support attaching Routes to other resources.
// If that is the case, they MUST clearly document how SectionName is
// interpreted.
//
// When unspecified (empty string), this will reference the entire resource.
// For the purpose of status, an attachment is considered successful if at
// least one section in the parent resource accepts it. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
// the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route, the
// Route MUST be considered detached from the Gateway.
//
// Support: Core
func (o GRPCRouteStatusParentsParentRefPtrOutput) SectionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GRPCRouteStatusParentsParentRef) *string {
		if v == nil {
			return nil
		}
		return v.SectionName
	}).(pulumi.StringPtrOutput)
}

// ParentRef corresponds with a ParentRef in the spec that this
// RouteParentStatus struct describes the status of.
type GRPCRouteStatusParentsParentRefPatch struct {
	// Group is the group of the referent.
	// When unspecified, "gateway.networking.k8s.io" is inferred.
	// To set the core API group (such as for a "Service" kind referent),
	// Group must be explicitly set to "" (empty string).
	//
	// Support: Core
	Group *string `pulumi:"group"`
	// Kind is kind of the referent.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// Support for other resources is Implementation-Specific.
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	//
	// Support: Core
	Name *string `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers
	// to the local namespace of the Route.
	//
	// Note that there are specific rules for ParentRefs which cross namespace
	// boundaries. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example:
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable any other kind of cross-namespace reference.
	//
	// Support: Core
	Namespace *string `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted
	// differently based on the type of parent resource.
	//
	// When the parent resource is a Gateway, this targets all listeners
	// listening on the specified port that also support this kind of Route(and
	// select this Route). It's not recommended to set `Port` unless the
	// networking behaviors specified in a Route must apply to a specific port
	// as opposed to a listener(s) whose port(s) may be changed. When both Port
	// and SectionName are specified, the name and port of the selected listener
	// must match both specified values.
	//
	// Implementations MAY choose to support other parent resources.
	// Implementations supporting other types of parent resources MUST clearly
	// document how/if Port is interpreted.
	//
	// For the purpose of status, an attachment is considered successful as
	// long as the parent resource accepts it partially. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
	// from the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route,
	// the Route MUST be considered detached from the Gateway.
	//
	// Support: Extended
	Port *int `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the
	// following resources, SectionName is interpreted as the following:
	//
	// * Gateway: Listener name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	// * Service: Port name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	//
	// Implementations MAY choose to support attaching Routes to other resources.
	// If that is the case, they MUST clearly document how SectionName is
	// interpreted.
	//
	// When unspecified (empty string), this will reference the entire resource.
	// For the purpose of status, an attachment is considered successful if at
	// least one section in the parent resource accepts it. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
	// the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route, the
	// Route MUST be considered detached from the Gateway.
	//
	// Support: Core
	SectionName *string `pulumi:"sectionName"`
}

// GRPCRouteStatusParentsParentRefPatchInput is an input type that accepts GRPCRouteStatusParentsParentRefPatchArgs and GRPCRouteStatusParentsParentRefPatchOutput values.
// You can construct a concrete instance of `GRPCRouteStatusParentsParentRefPatchInput` via:
//
//	GRPCRouteStatusParentsParentRefPatchArgs{...}
type GRPCRouteStatusParentsParentRefPatchInput interface {
	pulumi.Input

	ToGRPCRouteStatusParentsParentRefPatchOutput() GRPCRouteStatusParentsParentRefPatchOutput
	ToGRPCRouteStatusParentsParentRefPatchOutputWithContext(context.Context) GRPCRouteStatusParentsParentRefPatchOutput
}

// ParentRef corresponds with a ParentRef in the spec that this
// RouteParentStatus struct describes the status of.
type GRPCRouteStatusParentsParentRefPatchArgs struct {
	// Group is the group of the referent.
	// When unspecified, "gateway.networking.k8s.io" is inferred.
	// To set the core API group (such as for a "Service" kind referent),
	// Group must be explicitly set to "" (empty string).
	//
	// Support: Core
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is kind of the referent.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// Support for other resources is Implementation-Specific.
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	//
	// Support: Core
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers
	// to the local namespace of the Route.
	//
	// Note that there are specific rules for ParentRefs which cross namespace
	// boundaries. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example:
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable any other kind of cross-namespace reference.
	//
	// Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted
	// differently based on the type of parent resource.
	//
	// When the parent resource is a Gateway, this targets all listeners
	// listening on the specified port that also support this kind of Route(and
	// select this Route). It's not recommended to set `Port` unless the
	// networking behaviors specified in a Route must apply to a specific port
	// as opposed to a listener(s) whose port(s) may be changed. When both Port
	// and SectionName are specified, the name and port of the selected listener
	// must match both specified values.
	//
	// Implementations MAY choose to support other parent resources.
	// Implementations supporting other types of parent resources MUST clearly
	// document how/if Port is interpreted.
	//
	// For the purpose of status, an attachment is considered successful as
	// long as the parent resource accepts it partially. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
	// from the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route,
	// the Route MUST be considered detached from the Gateway.
	//
	// Support: Extended
	Port pulumi.IntPtrInput `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the
	// following resources, SectionName is interpreted as the following:
	//
	// * Gateway: Listener name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	// * Service: Port name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	//
	// Implementations MAY choose to support attaching Routes to other resources.
	// If that is the case, they MUST clearly document how SectionName is
	// interpreted.
	//
	// When unspecified (empty string), this will reference the entire resource.
	// For the purpose of status, an attachment is considered successful if at
	// least one section in the parent resource accepts it. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
	// the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route, the
	// Route MUST be considered detached from the Gateway.
	//
	// Support: Core
	SectionName pulumi.StringPtrInput `pulumi:"sectionName"`
}

func (GRPCRouteStatusParentsParentRefPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteStatusParentsParentRefPatch)(nil)).Elem()
}

func (i GRPCRouteStatusParentsParentRefPatchArgs) ToGRPCRouteStatusParentsParentRefPatchOutput() GRPCRouteStatusParentsParentRefPatchOutput {
	return i.ToGRPCRouteStatusParentsParentRefPatchOutputWithContext(context.Background())
}

func (i GRPCRouteStatusParentsParentRefPatchArgs) ToGRPCRouteStatusParentsParentRefPatchOutputWithContext(ctx context.Context) GRPCRouteStatusParentsParentRefPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteStatusParentsParentRefPatchOutput)
}

func (i GRPCRouteStatusParentsParentRefPatchArgs) ToGRPCRouteStatusParentsParentRefPatchPtrOutput() GRPCRouteStatusParentsParentRefPatchPtrOutput {
	return i.ToGRPCRouteStatusParentsParentRefPatchPtrOutputWithContext(context.Background())
}

func (i GRPCRouteStatusParentsParentRefPatchArgs) ToGRPCRouteStatusParentsParentRefPatchPtrOutputWithContext(ctx context.Context) GRPCRouteStatusParentsParentRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteStatusParentsParentRefPatchOutput).ToGRPCRouteStatusParentsParentRefPatchPtrOutputWithContext(ctx)
}

// GRPCRouteStatusParentsParentRefPatchPtrInput is an input type that accepts GRPCRouteStatusParentsParentRefPatchArgs, GRPCRouteStatusParentsParentRefPatchPtr and GRPCRouteStatusParentsParentRefPatchPtrOutput values.
// You can construct a concrete instance of `GRPCRouteStatusParentsParentRefPatchPtrInput` via:
//
//	        GRPCRouteStatusParentsParentRefPatchArgs{...}
//
//	or:
//
//	        nil
type GRPCRouteStatusParentsParentRefPatchPtrInput interface {
	pulumi.Input

	ToGRPCRouteStatusParentsParentRefPatchPtrOutput() GRPCRouteStatusParentsParentRefPatchPtrOutput
	ToGRPCRouteStatusParentsParentRefPatchPtrOutputWithContext(context.Context) GRPCRouteStatusParentsParentRefPatchPtrOutput
}

type grpcrouteStatusParentsParentRefPatchPtrType GRPCRouteStatusParentsParentRefPatchArgs

func GRPCRouteStatusParentsParentRefPatchPtr(v *GRPCRouteStatusParentsParentRefPatchArgs) GRPCRouteStatusParentsParentRefPatchPtrInput {
	return (*grpcrouteStatusParentsParentRefPatchPtrType)(v)
}

func (*grpcrouteStatusParentsParentRefPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteStatusParentsParentRefPatch)(nil)).Elem()
}

func (i *grpcrouteStatusParentsParentRefPatchPtrType) ToGRPCRouteStatusParentsParentRefPatchPtrOutput() GRPCRouteStatusParentsParentRefPatchPtrOutput {
	return i.ToGRPCRouteStatusParentsParentRefPatchPtrOutputWithContext(context.Background())
}

func (i *grpcrouteStatusParentsParentRefPatchPtrType) ToGRPCRouteStatusParentsParentRefPatchPtrOutputWithContext(ctx context.Context) GRPCRouteStatusParentsParentRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteStatusParentsParentRefPatchPtrOutput)
}

// ParentRef corresponds with a ParentRef in the spec that this
// RouteParentStatus struct describes the status of.
type GRPCRouteStatusParentsParentRefPatchOutput struct{ *pulumi.OutputState }

func (GRPCRouteStatusParentsParentRefPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteStatusParentsParentRefPatch)(nil)).Elem()
}

func (o GRPCRouteStatusParentsParentRefPatchOutput) ToGRPCRouteStatusParentsParentRefPatchOutput() GRPCRouteStatusParentsParentRefPatchOutput {
	return o
}

func (o GRPCRouteStatusParentsParentRefPatchOutput) ToGRPCRouteStatusParentsParentRefPatchOutputWithContext(ctx context.Context) GRPCRouteStatusParentsParentRefPatchOutput {
	return o
}

func (o GRPCRouteStatusParentsParentRefPatchOutput) ToGRPCRouteStatusParentsParentRefPatchPtrOutput() GRPCRouteStatusParentsParentRefPatchPtrOutput {
	return o.ToGRPCRouteStatusParentsParentRefPatchPtrOutputWithContext(context.Background())
}

func (o GRPCRouteStatusParentsParentRefPatchOutput) ToGRPCRouteStatusParentsParentRefPatchPtrOutputWithContext(ctx context.Context) GRPCRouteStatusParentsParentRefPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GRPCRouteStatusParentsParentRefPatch) *GRPCRouteStatusParentsParentRefPatch {
		return &v
	}).(GRPCRouteStatusParentsParentRefPatchPtrOutput)
}

// Group is the group of the referent.
// When unspecified, "gateway.networking.k8s.io" is inferred.
// To set the core API group (such as for a "Service" kind referent),
// Group must be explicitly set to "" (empty string).
//
// Support: Core
func (o GRPCRouteStatusParentsParentRefPatchOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteStatusParentsParentRefPatch) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent.
//
// There are two kinds of parent resources with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// Support for other resources is Implementation-Specific.
func (o GRPCRouteStatusParentsParentRefPatchOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteStatusParentsParentRefPatch) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
//
// Support: Core
func (o GRPCRouteStatusParentsParentRefPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteStatusParentsParentRefPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the referent. When unspecified, this refers
// to the local namespace of the Route.
//
// Note that there are specific rules for ParentRefs which cross namespace
// boundaries. Cross-namespace references are only valid if they are explicitly
// allowed by something in the namespace they are referring to. For example:
// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
// generic way to enable any other kind of cross-namespace reference.
//
// Support: Core
func (o GRPCRouteStatusParentsParentRefPatchOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteStatusParentsParentRefPatch) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Port is the network port this Route targets. It can be interpreted
// differently based on the type of parent resource.
//
// When the parent resource is a Gateway, this targets all listeners
// listening on the specified port that also support this kind of Route(and
// select this Route). It's not recommended to set `Port` unless the
// networking behaviors specified in a Route must apply to a specific port
// as opposed to a listener(s) whose port(s) may be changed. When both Port
// and SectionName are specified, the name and port of the selected listener
// must match both specified values.
//
// Implementations MAY choose to support other parent resources.
// Implementations supporting other types of parent resources MUST clearly
// document how/if Port is interpreted.
//
// For the purpose of status, an attachment is considered successful as
// long as the parent resource accepts it partially. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
// from the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route,
// the Route MUST be considered detached from the Gateway.
//
// Support: Extended
func (o GRPCRouteStatusParentsParentRefPatchOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v GRPCRouteStatusParentsParentRefPatch) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// SectionName is the name of a section within the target resource. In the
// following resources, SectionName is interpreted as the following:
//
//   - Gateway: Listener name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//   - Service: Port name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//
// Implementations MAY choose to support attaching Routes to other resources.
// If that is the case, they MUST clearly document how SectionName is
// interpreted.
//
// When unspecified (empty string), this will reference the entire resource.
// For the purpose of status, an attachment is considered successful if at
// least one section in the parent resource accepts it. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
// the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route, the
// Route MUST be considered detached from the Gateway.
//
// Support: Core
func (o GRPCRouteStatusParentsParentRefPatchOutput) SectionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteStatusParentsParentRefPatch) *string { return v.SectionName }).(pulumi.StringPtrOutput)
}

type GRPCRouteStatusParentsParentRefPatchPtrOutput struct{ *pulumi.OutputState }

func (GRPCRouteStatusParentsParentRefPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteStatusParentsParentRefPatch)(nil)).Elem()
}

func (o GRPCRouteStatusParentsParentRefPatchPtrOutput) ToGRPCRouteStatusParentsParentRefPatchPtrOutput() GRPCRouteStatusParentsParentRefPatchPtrOutput {
	return o
}

func (o GRPCRouteStatusParentsParentRefPatchPtrOutput) ToGRPCRouteStatusParentsParentRefPatchPtrOutputWithContext(ctx context.Context) GRPCRouteStatusParentsParentRefPatchPtrOutput {
	return o
}

func (o GRPCRouteStatusParentsParentRefPatchPtrOutput) Elem() GRPCRouteStatusParentsParentRefPatchOutput {
	return o.ApplyT(func(v *GRPCRouteStatusParentsParentRefPatch) GRPCRouteStatusParentsParentRefPatch {
		if v != nil {
			return *v
		}
		var ret GRPCRouteStatusParentsParentRefPatch
		return ret
	}).(GRPCRouteStatusParentsParentRefPatchOutput)
}

// Group is the group of the referent.
// When unspecified, "gateway.networking.k8s.io" is inferred.
// To set the core API group (such as for a "Service" kind referent),
// Group must be explicitly set to "" (empty string).
//
// Support: Core
func (o GRPCRouteStatusParentsParentRefPatchPtrOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GRPCRouteStatusParentsParentRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Group
	}).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent.
//
// There are two kinds of parent resources with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// Support for other resources is Implementation-Specific.
func (o GRPCRouteStatusParentsParentRefPatchPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GRPCRouteStatusParentsParentRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
//
// Support: Core
func (o GRPCRouteStatusParentsParentRefPatchPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GRPCRouteStatusParentsParentRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the referent. When unspecified, this refers
// to the local namespace of the Route.
//
// Note that there are specific rules for ParentRefs which cross namespace
// boundaries. Cross-namespace references are only valid if they are explicitly
// allowed by something in the namespace they are referring to. For example:
// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
// generic way to enable any other kind of cross-namespace reference.
//
// Support: Core
func (o GRPCRouteStatusParentsParentRefPatchPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GRPCRouteStatusParentsParentRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

// Port is the network port this Route targets. It can be interpreted
// differently based on the type of parent resource.
//
// When the parent resource is a Gateway, this targets all listeners
// listening on the specified port that also support this kind of Route(and
// select this Route). It's not recommended to set `Port` unless the
// networking behaviors specified in a Route must apply to a specific port
// as opposed to a listener(s) whose port(s) may be changed. When both Port
// and SectionName are specified, the name and port of the selected listener
// must match both specified values.
//
// Implementations MAY choose to support other parent resources.
// Implementations supporting other types of parent resources MUST clearly
// document how/if Port is interpreted.
//
// For the purpose of status, an attachment is considered successful as
// long as the parent resource accepts it partially. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
// from the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route,
// the Route MUST be considered detached from the Gateway.
//
// Support: Extended
func (o GRPCRouteStatusParentsParentRefPatchPtrOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *GRPCRouteStatusParentsParentRefPatch) *int {
		if v == nil {
			return nil
		}
		return v.Port
	}).(pulumi.IntPtrOutput)
}

// SectionName is the name of a section within the target resource. In the
// following resources, SectionName is interpreted as the following:
//
//   - Gateway: Listener name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//   - Service: Port name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//
// Implementations MAY choose to support attaching Routes to other resources.
// If that is the case, they MUST clearly document how SectionName is
// interpreted.
//
// When unspecified (empty string), this will reference the entire resource.
// For the purpose of status, an attachment is considered successful if at
// least one section in the parent resource accepts it. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
// the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route, the
// Route MUST be considered detached from the Gateway.
//
// Support: Core
func (o GRPCRouteStatusParentsParentRefPatchPtrOutput) SectionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GRPCRouteStatusParentsParentRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.SectionName
	}).(pulumi.StringPtrOutput)
}

// RouteParentStatus describes the status of a route with respect to an
// associated Parent.
type GRPCRouteStatusParentsPatch struct {
	// Conditions describes the status of the route with respect to the Gateway.
	// Note that the route's availability is also subject to the Gateway's own
	// status conditions and listener status.
	//
	// If the Route's ParentRef specifies an existing Gateway that supports
	// Routes of this kind AND that Gateway's controller has sufficient access,
	// then that Gateway's controller MUST set the "Accepted" condition on the
	// Route, to indicate whether the route has been accepted or rejected by the
	// Gateway, and why.
	//
	// A Route MUST be considered "Accepted" if at least one of the Route's
	// rules is implemented by the Gateway.
	//
	// There are a number of cases where the "Accepted" condition may not be set
	// due to lack of controller visibility, that includes when:
	//
	// * The Route refers to a non-existent parent.
	// * The Route is of a type that the controller does not support.
	// * The Route is in a namespace the controller does not have access to.
	Conditions []GRPCRouteStatusParentsConditionsPatch `pulumi:"conditions"`
	// ControllerName is a domain/path string that indicates the name of the
	// controller that wrote this status. This corresponds with the
	// controllerName field on GatewayClass.
	//
	// Example: "example.net/gateway-controller".
	//
	// The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
	// valid Kubernetes names
	// (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
	//
	// Controllers MUST populate this field when writing status. Controllers should ensure that
	// entries to status populated with their ControllerName are cleaned up when they are no
	// longer necessary.
	ControllerName *string                               `pulumi:"controllerName"`
	ParentRef      *GRPCRouteStatusParentsParentRefPatch `pulumi:"parentRef"`
}

// GRPCRouteStatusParentsPatchInput is an input type that accepts GRPCRouteStatusParentsPatchArgs and GRPCRouteStatusParentsPatchOutput values.
// You can construct a concrete instance of `GRPCRouteStatusParentsPatchInput` via:
//
//	GRPCRouteStatusParentsPatchArgs{...}
type GRPCRouteStatusParentsPatchInput interface {
	pulumi.Input

	ToGRPCRouteStatusParentsPatchOutput() GRPCRouteStatusParentsPatchOutput
	ToGRPCRouteStatusParentsPatchOutputWithContext(context.Context) GRPCRouteStatusParentsPatchOutput
}

// RouteParentStatus describes the status of a route with respect to an
// associated Parent.
type GRPCRouteStatusParentsPatchArgs struct {
	// Conditions describes the status of the route with respect to the Gateway.
	// Note that the route's availability is also subject to the Gateway's own
	// status conditions and listener status.
	//
	// If the Route's ParentRef specifies an existing Gateway that supports
	// Routes of this kind AND that Gateway's controller has sufficient access,
	// then that Gateway's controller MUST set the "Accepted" condition on the
	// Route, to indicate whether the route has been accepted or rejected by the
	// Gateway, and why.
	//
	// A Route MUST be considered "Accepted" if at least one of the Route's
	// rules is implemented by the Gateway.
	//
	// There are a number of cases where the "Accepted" condition may not be set
	// due to lack of controller visibility, that includes when:
	//
	// * The Route refers to a non-existent parent.
	// * The Route is of a type that the controller does not support.
	// * The Route is in a namespace the controller does not have access to.
	Conditions GRPCRouteStatusParentsConditionsPatchArrayInput `pulumi:"conditions"`
	// ControllerName is a domain/path string that indicates the name of the
	// controller that wrote this status. This corresponds with the
	// controllerName field on GatewayClass.
	//
	// Example: "example.net/gateway-controller".
	//
	// The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
	// valid Kubernetes names
	// (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
	//
	// Controllers MUST populate this field when writing status. Controllers should ensure that
	// entries to status populated with their ControllerName are cleaned up when they are no
	// longer necessary.
	ControllerName pulumi.StringPtrInput                        `pulumi:"controllerName"`
	ParentRef      GRPCRouteStatusParentsParentRefPatchPtrInput `pulumi:"parentRef"`
}

func (GRPCRouteStatusParentsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteStatusParentsPatch)(nil)).Elem()
}

func (i GRPCRouteStatusParentsPatchArgs) ToGRPCRouteStatusParentsPatchOutput() GRPCRouteStatusParentsPatchOutput {
	return i.ToGRPCRouteStatusParentsPatchOutputWithContext(context.Background())
}

func (i GRPCRouteStatusParentsPatchArgs) ToGRPCRouteStatusParentsPatchOutputWithContext(ctx context.Context) GRPCRouteStatusParentsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteStatusParentsPatchOutput)
}

// GRPCRouteStatusParentsPatchArrayInput is an input type that accepts GRPCRouteStatusParentsPatchArray and GRPCRouteStatusParentsPatchArrayOutput values.
// You can construct a concrete instance of `GRPCRouteStatusParentsPatchArrayInput` via:
//
//	GRPCRouteStatusParentsPatchArray{ GRPCRouteStatusParentsPatchArgs{...} }
type GRPCRouteStatusParentsPatchArrayInput interface {
	pulumi.Input

	ToGRPCRouteStatusParentsPatchArrayOutput() GRPCRouteStatusParentsPatchArrayOutput
	ToGRPCRouteStatusParentsPatchArrayOutputWithContext(context.Context) GRPCRouteStatusParentsPatchArrayOutput
}

type GRPCRouteStatusParentsPatchArray []GRPCRouteStatusParentsPatchInput

func (GRPCRouteStatusParentsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteStatusParentsPatch)(nil)).Elem()
}

func (i GRPCRouteStatusParentsPatchArray) ToGRPCRouteStatusParentsPatchArrayOutput() GRPCRouteStatusParentsPatchArrayOutput {
	return i.ToGRPCRouteStatusParentsPatchArrayOutputWithContext(context.Background())
}

func (i GRPCRouteStatusParentsPatchArray) ToGRPCRouteStatusParentsPatchArrayOutputWithContext(ctx context.Context) GRPCRouteStatusParentsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteStatusParentsPatchArrayOutput)
}

// RouteParentStatus describes the status of a route with respect to an
// associated Parent.
type GRPCRouteStatusParentsPatchOutput struct{ *pulumi.OutputState }

func (GRPCRouteStatusParentsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteStatusParentsPatch)(nil)).Elem()
}

func (o GRPCRouteStatusParentsPatchOutput) ToGRPCRouteStatusParentsPatchOutput() GRPCRouteStatusParentsPatchOutput {
	return o
}

func (o GRPCRouteStatusParentsPatchOutput) ToGRPCRouteStatusParentsPatchOutputWithContext(ctx context.Context) GRPCRouteStatusParentsPatchOutput {
	return o
}

// Conditions describes the status of the route with respect to the Gateway.
// Note that the route's availability is also subject to the Gateway's own
// status conditions and listener status.
//
// If the Route's ParentRef specifies an existing Gateway that supports
// Routes of this kind AND that Gateway's controller has sufficient access,
// then that Gateway's controller MUST set the "Accepted" condition on the
// Route, to indicate whether the route has been accepted or rejected by the
// Gateway, and why.
//
// A Route MUST be considered "Accepted" if at least one of the Route's
// rules is implemented by the Gateway.
//
// There are a number of cases where the "Accepted" condition may not be set
// due to lack of controller visibility, that includes when:
//
// * The Route refers to a non-existent parent.
// * The Route is of a type that the controller does not support.
// * The Route is in a namespace the controller does not have access to.
func (o GRPCRouteStatusParentsPatchOutput) Conditions() GRPCRouteStatusParentsConditionsPatchArrayOutput {
	return o.ApplyT(func(v GRPCRouteStatusParentsPatch) []GRPCRouteStatusParentsConditionsPatch { return v.Conditions }).(GRPCRouteStatusParentsConditionsPatchArrayOutput)
}

// ControllerName is a domain/path string that indicates the name of the
// controller that wrote this status. This corresponds with the
// controllerName field on GatewayClass.
//
// Example: "example.net/gateway-controller".
//
// The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
// valid Kubernetes names
// (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
//
// Controllers MUST populate this field when writing status. Controllers should ensure that
// entries to status populated with their ControllerName are cleaned up when they are no
// longer necessary.
func (o GRPCRouteStatusParentsPatchOutput) ControllerName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteStatusParentsPatch) *string { return v.ControllerName }).(pulumi.StringPtrOutput)
}

func (o GRPCRouteStatusParentsPatchOutput) ParentRef() GRPCRouteStatusParentsParentRefPatchPtrOutput {
	return o.ApplyT(func(v GRPCRouteStatusParentsPatch) *GRPCRouteStatusParentsParentRefPatch { return v.ParentRef }).(GRPCRouteStatusParentsParentRefPatchPtrOutput)
}

type GRPCRouteStatusParentsPatchArrayOutput struct{ *pulumi.OutputState }

func (GRPCRouteStatusParentsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteStatusParentsPatch)(nil)).Elem()
}

func (o GRPCRouteStatusParentsPatchArrayOutput) ToGRPCRouteStatusParentsPatchArrayOutput() GRPCRouteStatusParentsPatchArrayOutput {
	return o
}

func (o GRPCRouteStatusParentsPatchArrayOutput) ToGRPCRouteStatusParentsPatchArrayOutputWithContext(ctx context.Context) GRPCRouteStatusParentsPatchArrayOutput {
	return o
}

func (o GRPCRouteStatusParentsPatchArrayOutput) Index(i pulumi.IntInput) GRPCRouteStatusParentsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GRPCRouteStatusParentsPatch {
		return vs[0].([]GRPCRouteStatusParentsPatch)[vs[1].(int)]
	}).(GRPCRouteStatusParentsPatchOutput)
}

// Status defines the current state of GRPCRoute.
type GRPCRouteStatusPatch struct {
	// Parents is a list of parent resources (usually Gateways) that are
	// associated with the route, and the status of the route with respect to
	// each parent. When this route attaches to a parent, the controller that
	// manages the parent must add an entry to this list when the controller
	// first sees the route and should update the entry as appropriate when the
	// route or gateway is modified.
	//
	// Note that parent references that cannot be resolved by an implementation
	// of this API will not be added to this list. Implementations of this API
	// can only populate Route status for the Gateways/parent resources they are
	// responsible for.
	//
	// A maximum of 32 Gateways will be represented in this list. An empty list
	// means the route has not been attached to any Gateway.
	Parents []GRPCRouteStatusParentsPatch `pulumi:"parents"`
}

// GRPCRouteStatusPatchInput is an input type that accepts GRPCRouteStatusPatchArgs and GRPCRouteStatusPatchOutput values.
// You can construct a concrete instance of `GRPCRouteStatusPatchInput` via:
//
//	GRPCRouteStatusPatchArgs{...}
type GRPCRouteStatusPatchInput interface {
	pulumi.Input

	ToGRPCRouteStatusPatchOutput() GRPCRouteStatusPatchOutput
	ToGRPCRouteStatusPatchOutputWithContext(context.Context) GRPCRouteStatusPatchOutput
}

// Status defines the current state of GRPCRoute.
type GRPCRouteStatusPatchArgs struct {
	// Parents is a list of parent resources (usually Gateways) that are
	// associated with the route, and the status of the route with respect to
	// each parent. When this route attaches to a parent, the controller that
	// manages the parent must add an entry to this list when the controller
	// first sees the route and should update the entry as appropriate when the
	// route or gateway is modified.
	//
	// Note that parent references that cannot be resolved by an implementation
	// of this API will not be added to this list. Implementations of this API
	// can only populate Route status for the Gateways/parent resources they are
	// responsible for.
	//
	// A maximum of 32 Gateways will be represented in this list. An empty list
	// means the route has not been attached to any Gateway.
	Parents GRPCRouteStatusParentsPatchArrayInput `pulumi:"parents"`
}

func (GRPCRouteStatusPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteStatusPatch)(nil)).Elem()
}

func (i GRPCRouteStatusPatchArgs) ToGRPCRouteStatusPatchOutput() GRPCRouteStatusPatchOutput {
	return i.ToGRPCRouteStatusPatchOutputWithContext(context.Background())
}

func (i GRPCRouteStatusPatchArgs) ToGRPCRouteStatusPatchOutputWithContext(ctx context.Context) GRPCRouteStatusPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteStatusPatchOutput)
}

func (i GRPCRouteStatusPatchArgs) ToGRPCRouteStatusPatchPtrOutput() GRPCRouteStatusPatchPtrOutput {
	return i.ToGRPCRouteStatusPatchPtrOutputWithContext(context.Background())
}

func (i GRPCRouteStatusPatchArgs) ToGRPCRouteStatusPatchPtrOutputWithContext(ctx context.Context) GRPCRouteStatusPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteStatusPatchOutput).ToGRPCRouteStatusPatchPtrOutputWithContext(ctx)
}

// GRPCRouteStatusPatchPtrInput is an input type that accepts GRPCRouteStatusPatchArgs, GRPCRouteStatusPatchPtr and GRPCRouteStatusPatchPtrOutput values.
// You can construct a concrete instance of `GRPCRouteStatusPatchPtrInput` via:
//
//	        GRPCRouteStatusPatchArgs{...}
//
//	or:
//
//	        nil
type GRPCRouteStatusPatchPtrInput interface {
	pulumi.Input

	ToGRPCRouteStatusPatchPtrOutput() GRPCRouteStatusPatchPtrOutput
	ToGRPCRouteStatusPatchPtrOutputWithContext(context.Context) GRPCRouteStatusPatchPtrOutput
}

type grpcrouteStatusPatchPtrType GRPCRouteStatusPatchArgs

func GRPCRouteStatusPatchPtr(v *GRPCRouteStatusPatchArgs) GRPCRouteStatusPatchPtrInput {
	return (*grpcrouteStatusPatchPtrType)(v)
}

func (*grpcrouteStatusPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteStatusPatch)(nil)).Elem()
}

func (i *grpcrouteStatusPatchPtrType) ToGRPCRouteStatusPatchPtrOutput() GRPCRouteStatusPatchPtrOutput {
	return i.ToGRPCRouteStatusPatchPtrOutputWithContext(context.Background())
}

func (i *grpcrouteStatusPatchPtrType) ToGRPCRouteStatusPatchPtrOutputWithContext(ctx context.Context) GRPCRouteStatusPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteStatusPatchPtrOutput)
}

// Status defines the current state of GRPCRoute.
type GRPCRouteStatusPatchOutput struct{ *pulumi.OutputState }

func (GRPCRouteStatusPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteStatusPatch)(nil)).Elem()
}

func (o GRPCRouteStatusPatchOutput) ToGRPCRouteStatusPatchOutput() GRPCRouteStatusPatchOutput {
	return o
}

func (o GRPCRouteStatusPatchOutput) ToGRPCRouteStatusPatchOutputWithContext(ctx context.Context) GRPCRouteStatusPatchOutput {
	return o
}

func (o GRPCRouteStatusPatchOutput) ToGRPCRouteStatusPatchPtrOutput() GRPCRouteStatusPatchPtrOutput {
	return o.ToGRPCRouteStatusPatchPtrOutputWithContext(context.Background())
}

func (o GRPCRouteStatusPatchOutput) ToGRPCRouteStatusPatchPtrOutputWithContext(ctx context.Context) GRPCRouteStatusPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GRPCRouteStatusPatch) *GRPCRouteStatusPatch {
		return &v
	}).(GRPCRouteStatusPatchPtrOutput)
}

// Parents is a list of parent resources (usually Gateways) that are
// associated with the route, and the status of the route with respect to
// each parent. When this route attaches to a parent, the controller that
// manages the parent must add an entry to this list when the controller
// first sees the route and should update the entry as appropriate when the
// route or gateway is modified.
//
// Note that parent references that cannot be resolved by an implementation
// of this API will not be added to this list. Implementations of this API
// can only populate Route status for the Gateways/parent resources they are
// responsible for.
//
// A maximum of 32 Gateways will be represented in this list. An empty list
// means the route has not been attached to any Gateway.
func (o GRPCRouteStatusPatchOutput) Parents() GRPCRouteStatusParentsPatchArrayOutput {
	return o.ApplyT(func(v GRPCRouteStatusPatch) []GRPCRouteStatusParentsPatch { return v.Parents }).(GRPCRouteStatusParentsPatchArrayOutput)
}

type GRPCRouteStatusPatchPtrOutput struct{ *pulumi.OutputState }

func (GRPCRouteStatusPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteStatusPatch)(nil)).Elem()
}

func (o GRPCRouteStatusPatchPtrOutput) ToGRPCRouteStatusPatchPtrOutput() GRPCRouteStatusPatchPtrOutput {
	return o
}

func (o GRPCRouteStatusPatchPtrOutput) ToGRPCRouteStatusPatchPtrOutputWithContext(ctx context.Context) GRPCRouteStatusPatchPtrOutput {
	return o
}

func (o GRPCRouteStatusPatchPtrOutput) Elem() GRPCRouteStatusPatchOutput {
	return o.ApplyT(func(v *GRPCRouteStatusPatch) GRPCRouteStatusPatch {
		if v != nil {
			return *v
		}
		var ret GRPCRouteStatusPatch
		return ret
	}).(GRPCRouteStatusPatchOutput)
}

// Parents is a list of parent resources (usually Gateways) that are
// associated with the route, and the status of the route with respect to
// each parent. When this route attaches to a parent, the controller that
// manages the parent must add an entry to this list when the controller
// first sees the route and should update the entry as appropriate when the
// route or gateway is modified.
//
// Note that parent references that cannot be resolved by an implementation
// of this API will not be added to this list. Implementations of this API
// can only populate Route status for the Gateways/parent resources they are
// responsible for.
//
// A maximum of 32 Gateways will be represented in this list. An empty list
// means the route has not been attached to any Gateway.
func (o GRPCRouteStatusPatchPtrOutput) Parents() GRPCRouteStatusParentsPatchArrayOutput {
	return o.ApplyT(func(v *GRPCRouteStatusPatch) []GRPCRouteStatusParentsPatch {
		if v == nil {
			return nil
		}
		return v.Parents
	}).(GRPCRouteStatusParentsPatchArrayOutput)
}

// Gateway represents an instance of a service-traffic handling infrastructure
// by binding Listeners to a set of IP addresses.
type GatewayType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata *metav1.ObjectMeta `pulumi:"metadata"`
	Spec     *GatewaySpec       `pulumi:"spec"`
	Status   *GatewayStatus     `pulumi:"status"`
}

// GatewayTypeInput is an input type that accepts GatewayTypeArgs and GatewayTypeOutput values.
// You can construct a concrete instance of `GatewayTypeInput` via:
//
//	GatewayTypeArgs{...}
type GatewayTypeInput interface {
	pulumi.Input

	ToGatewayTypeOutput() GatewayTypeOutput
	ToGatewayTypeOutputWithContext(context.Context) GatewayTypeOutput
}

// Gateway represents an instance of a service-traffic handling infrastructure
// by binding Listeners to a set of IP addresses.
type GatewayTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata metav1.ObjectMetaPtrInput `pulumi:"metadata"`
	Spec     GatewaySpecPtrInput       `pulumi:"spec"`
	Status   GatewayStatusPtrInput     `pulumi:"status"`
}

func (GatewayTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayType)(nil)).Elem()
}

func (i GatewayTypeArgs) ToGatewayTypeOutput() GatewayTypeOutput {
	return i.ToGatewayTypeOutputWithContext(context.Background())
}

func (i GatewayTypeArgs) ToGatewayTypeOutputWithContext(ctx context.Context) GatewayTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayTypeOutput)
}

// GatewayTypeArrayInput is an input type that accepts GatewayTypeArray and GatewayTypeArrayOutput values.
// You can construct a concrete instance of `GatewayTypeArrayInput` via:
//
//	GatewayTypeArray{ GatewayTypeArgs{...} }
type GatewayTypeArrayInput interface {
	pulumi.Input

	ToGatewayTypeArrayOutput() GatewayTypeArrayOutput
	ToGatewayTypeArrayOutputWithContext(context.Context) GatewayTypeArrayOutput
}

type GatewayTypeArray []GatewayTypeInput

func (GatewayTypeArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewayType)(nil)).Elem()
}

func (i GatewayTypeArray) ToGatewayTypeArrayOutput() GatewayTypeArrayOutput {
	return i.ToGatewayTypeArrayOutputWithContext(context.Background())
}

func (i GatewayTypeArray) ToGatewayTypeArrayOutputWithContext(ctx context.Context) GatewayTypeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayTypeArrayOutput)
}

// Gateway represents an instance of a service-traffic handling infrastructure
// by binding Listeners to a set of IP addresses.
type GatewayTypeOutput struct{ *pulumi.OutputState }

func (GatewayTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayType)(nil)).Elem()
}

func (o GatewayTypeOutput) ToGatewayTypeOutput() GatewayTypeOutput {
	return o
}

func (o GatewayTypeOutput) ToGatewayTypeOutputWithContext(ctx context.Context) GatewayTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o GatewayTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o GatewayTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
func (o GatewayTypeOutput) Metadata() metav1.ObjectMetaPtrOutput {
	return o.ApplyT(func(v GatewayType) *metav1.ObjectMeta { return v.Metadata }).(metav1.ObjectMetaPtrOutput)
}

func (o GatewayTypeOutput) Spec() GatewaySpecPtrOutput {
	return o.ApplyT(func(v GatewayType) *GatewaySpec { return v.Spec }).(GatewaySpecPtrOutput)
}

func (o GatewayTypeOutput) Status() GatewayStatusPtrOutput {
	return o.ApplyT(func(v GatewayType) *GatewayStatus { return v.Status }).(GatewayStatusPtrOutput)
}

type GatewayTypeArrayOutput struct{ *pulumi.OutputState }

func (GatewayTypeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewayType)(nil)).Elem()
}

func (o GatewayTypeArrayOutput) ToGatewayTypeArrayOutput() GatewayTypeArrayOutput {
	return o
}

func (o GatewayTypeArrayOutput) ToGatewayTypeArrayOutputWithContext(ctx context.Context) GatewayTypeArrayOutput {
	return o
}

func (o GatewayTypeArrayOutput) Index(i pulumi.IntInput) GatewayTypeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GatewayType {
		return vs[0].([]GatewayType)[vs[1].(int)]
	}).(GatewayTypeOutput)
}

// GatewayClass describes a class of Gateways available to the user for creating
// Gateway resources.
//
// It is recommended that this resource be used as a template for Gateways. This
// means that a Gateway is based on the state of the GatewayClass at the time it
// was created and changes to the GatewayClass or associated parameters are not
// propagated down to existing Gateways. This recommendation is intended to
// limit the blast radius of changes to GatewayClass or associated parameters.
// If implementations choose to propagate GatewayClass changes to existing
// Gateways, that MUST be clearly documented by the implementation.
//
// Whenever one or more Gateways are using a GatewayClass, implementations SHOULD
// add the `gateway-exists-finalizer.gateway.networking.k8s.io` finalizer on the
// associated GatewayClass. This ensures that a GatewayClass associated with a
// Gateway is not deleted while in use.
//
// GatewayClass is a Cluster level resource.
type GatewayClassType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata *metav1.ObjectMeta  `pulumi:"metadata"`
	Spec     *GatewayClassSpec   `pulumi:"spec"`
	Status   *GatewayClassStatus `pulumi:"status"`
}

// GatewayClassTypeInput is an input type that accepts GatewayClassTypeArgs and GatewayClassTypeOutput values.
// You can construct a concrete instance of `GatewayClassTypeInput` via:
//
//	GatewayClassTypeArgs{...}
type GatewayClassTypeInput interface {
	pulumi.Input

	ToGatewayClassTypeOutput() GatewayClassTypeOutput
	ToGatewayClassTypeOutputWithContext(context.Context) GatewayClassTypeOutput
}

// GatewayClass describes a class of Gateways available to the user for creating
// Gateway resources.
//
// It is recommended that this resource be used as a template for Gateways. This
// means that a Gateway is based on the state of the GatewayClass at the time it
// was created and changes to the GatewayClass or associated parameters are not
// propagated down to existing Gateways. This recommendation is intended to
// limit the blast radius of changes to GatewayClass or associated parameters.
// If implementations choose to propagate GatewayClass changes to existing
// Gateways, that MUST be clearly documented by the implementation.
//
// Whenever one or more Gateways are using a GatewayClass, implementations SHOULD
// add the `gateway-exists-finalizer.gateway.networking.k8s.io` finalizer on the
// associated GatewayClass. This ensures that a GatewayClass associated with a
// Gateway is not deleted while in use.
//
// GatewayClass is a Cluster level resource.
type GatewayClassTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata metav1.ObjectMetaPtrInput  `pulumi:"metadata"`
	Spec     GatewayClassSpecPtrInput   `pulumi:"spec"`
	Status   GatewayClassStatusPtrInput `pulumi:"status"`
}

func (GatewayClassTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayClassType)(nil)).Elem()
}

func (i GatewayClassTypeArgs) ToGatewayClassTypeOutput() GatewayClassTypeOutput {
	return i.ToGatewayClassTypeOutputWithContext(context.Background())
}

func (i GatewayClassTypeArgs) ToGatewayClassTypeOutputWithContext(ctx context.Context) GatewayClassTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayClassTypeOutput)
}

// GatewayClassTypeArrayInput is an input type that accepts GatewayClassTypeArray and GatewayClassTypeArrayOutput values.
// You can construct a concrete instance of `GatewayClassTypeArrayInput` via:
//
//	GatewayClassTypeArray{ GatewayClassTypeArgs{...} }
type GatewayClassTypeArrayInput interface {
	pulumi.Input

	ToGatewayClassTypeArrayOutput() GatewayClassTypeArrayOutput
	ToGatewayClassTypeArrayOutputWithContext(context.Context) GatewayClassTypeArrayOutput
}

type GatewayClassTypeArray []GatewayClassTypeInput

func (GatewayClassTypeArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewayClassType)(nil)).Elem()
}

func (i GatewayClassTypeArray) ToGatewayClassTypeArrayOutput() GatewayClassTypeArrayOutput {
	return i.ToGatewayClassTypeArrayOutputWithContext(context.Background())
}

func (i GatewayClassTypeArray) ToGatewayClassTypeArrayOutputWithContext(ctx context.Context) GatewayClassTypeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayClassTypeArrayOutput)
}

// GatewayClass describes a class of Gateways available to the user for creating
// Gateway resources.
//
// It is recommended that this resource be used as a template for Gateways. This
// means that a Gateway is based on the state of the GatewayClass at the time it
// was created and changes to the GatewayClass or associated parameters are not
// propagated down to existing Gateways. This recommendation is intended to
// limit the blast radius of changes to GatewayClass or associated parameters.
// If implementations choose to propagate GatewayClass changes to existing
// Gateways, that MUST be clearly documented by the implementation.
//
// Whenever one or more Gateways are using a GatewayClass, implementations SHOULD
// add the `gateway-exists-finalizer.gateway.networking.k8s.io` finalizer on the
// associated GatewayClass. This ensures that a GatewayClass associated with a
// Gateway is not deleted while in use.
//
// GatewayClass is a Cluster level resource.
type GatewayClassTypeOutput struct{ *pulumi.OutputState }

func (GatewayClassTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayClassType)(nil)).Elem()
}

func (o GatewayClassTypeOutput) ToGatewayClassTypeOutput() GatewayClassTypeOutput {
	return o
}

func (o GatewayClassTypeOutput) ToGatewayClassTypeOutputWithContext(ctx context.Context) GatewayClassTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o GatewayClassTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayClassType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o GatewayClassTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayClassType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
func (o GatewayClassTypeOutput) Metadata() metav1.ObjectMetaPtrOutput {
	return o.ApplyT(func(v GatewayClassType) *metav1.ObjectMeta { return v.Metadata }).(metav1.ObjectMetaPtrOutput)
}

func (o GatewayClassTypeOutput) Spec() GatewayClassSpecPtrOutput {
	return o.ApplyT(func(v GatewayClassType) *GatewayClassSpec { return v.Spec }).(GatewayClassSpecPtrOutput)
}

func (o GatewayClassTypeOutput) Status() GatewayClassStatusPtrOutput {
	return o.ApplyT(func(v GatewayClassType) *GatewayClassStatus { return v.Status }).(GatewayClassStatusPtrOutput)
}

type GatewayClassTypeArrayOutput struct{ *pulumi.OutputState }

func (GatewayClassTypeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewayClassType)(nil)).Elem()
}

func (o GatewayClassTypeArrayOutput) ToGatewayClassTypeArrayOutput() GatewayClassTypeArrayOutput {
	return o
}

func (o GatewayClassTypeArrayOutput) ToGatewayClassTypeArrayOutputWithContext(ctx context.Context) GatewayClassTypeArrayOutput {
	return o
}

func (o GatewayClassTypeArrayOutput) Index(i pulumi.IntInput) GatewayClassTypeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GatewayClassType {
		return vs[0].([]GatewayClassType)[vs[1].(int)]
	}).(GatewayClassTypeOutput)
}

// GatewayClassList is a list of GatewayClass
type GatewayClassListType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// List of gatewayclasses. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md
	Items []GatewayClassType `pulumi:"items"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Metadata *metav1.ListMeta `pulumi:"metadata"`
}

// GatewayClassListTypeInput is an input type that accepts GatewayClassListTypeArgs and GatewayClassListTypeOutput values.
// You can construct a concrete instance of `GatewayClassListTypeInput` via:
//
//	GatewayClassListTypeArgs{...}
type GatewayClassListTypeInput interface {
	pulumi.Input

	ToGatewayClassListTypeOutput() GatewayClassListTypeOutput
	ToGatewayClassListTypeOutputWithContext(context.Context) GatewayClassListTypeOutput
}

// GatewayClassList is a list of GatewayClass
type GatewayClassListTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// List of gatewayclasses. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md
	Items GatewayClassTypeArrayInput `pulumi:"items"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Metadata metav1.ListMetaPtrInput `pulumi:"metadata"`
}

func (GatewayClassListTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayClassListType)(nil)).Elem()
}

func (i GatewayClassListTypeArgs) ToGatewayClassListTypeOutput() GatewayClassListTypeOutput {
	return i.ToGatewayClassListTypeOutputWithContext(context.Background())
}

func (i GatewayClassListTypeArgs) ToGatewayClassListTypeOutputWithContext(ctx context.Context) GatewayClassListTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayClassListTypeOutput)
}

// GatewayClassList is a list of GatewayClass
type GatewayClassListTypeOutput struct{ *pulumi.OutputState }

func (GatewayClassListTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayClassListType)(nil)).Elem()
}

func (o GatewayClassListTypeOutput) ToGatewayClassListTypeOutput() GatewayClassListTypeOutput {
	return o
}

func (o GatewayClassListTypeOutput) ToGatewayClassListTypeOutputWithContext(ctx context.Context) GatewayClassListTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o GatewayClassListTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayClassListType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// List of gatewayclasses. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md
func (o GatewayClassListTypeOutput) Items() GatewayClassTypeArrayOutput {
	return o.ApplyT(func(v GatewayClassListType) []GatewayClassType { return v.Items }).(GatewayClassTypeArrayOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o GatewayClassListTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayClassListType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o GatewayClassListTypeOutput) Metadata() metav1.ListMetaPtrOutput {
	return o.ApplyT(func(v GatewayClassListType) *metav1.ListMeta { return v.Metadata }).(metav1.ListMetaPtrOutput)
}

// GatewayClass describes a class of Gateways available to the user for creating
// Gateway resources.
//
// It is recommended that this resource be used as a template for Gateways. This
// means that a Gateway is based on the state of the GatewayClass at the time it
// was created and changes to the GatewayClass or associated parameters are not
// propagated down to existing Gateways. This recommendation is intended to
// limit the blast radius of changes to GatewayClass or associated parameters.
// If implementations choose to propagate GatewayClass changes to existing
// Gateways, that MUST be clearly documented by the implementation.
//
// Whenever one or more Gateways are using a GatewayClass, implementations SHOULD
// add the `gateway-exists-finalizer.gateway.networking.k8s.io` finalizer on the
// associated GatewayClass. This ensures that a GatewayClass associated with a
// Gateway is not deleted while in use.
//
// GatewayClass is a Cluster level resource.
type GatewayClassPatchType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata *metav1.ObjectMetaPatch  `pulumi:"metadata"`
	Spec     *GatewayClassSpecPatch   `pulumi:"spec"`
	Status   *GatewayClassStatusPatch `pulumi:"status"`
}

// GatewayClassPatchTypeInput is an input type that accepts GatewayClassPatchTypeArgs and GatewayClassPatchTypeOutput values.
// You can construct a concrete instance of `GatewayClassPatchTypeInput` via:
//
//	GatewayClassPatchTypeArgs{...}
type GatewayClassPatchTypeInput interface {
	pulumi.Input

	ToGatewayClassPatchTypeOutput() GatewayClassPatchTypeOutput
	ToGatewayClassPatchTypeOutputWithContext(context.Context) GatewayClassPatchTypeOutput
}

// GatewayClass describes a class of Gateways available to the user for creating
// Gateway resources.
//
// It is recommended that this resource be used as a template for Gateways. This
// means that a Gateway is based on the state of the GatewayClass at the time it
// was created and changes to the GatewayClass or associated parameters are not
// propagated down to existing Gateways. This recommendation is intended to
// limit the blast radius of changes to GatewayClass or associated parameters.
// If implementations choose to propagate GatewayClass changes to existing
// Gateways, that MUST be clearly documented by the implementation.
//
// Whenever one or more Gateways are using a GatewayClass, implementations SHOULD
// add the `gateway-exists-finalizer.gateway.networking.k8s.io` finalizer on the
// associated GatewayClass. This ensures that a GatewayClass associated with a
// Gateway is not deleted while in use.
//
// GatewayClass is a Cluster level resource.
type GatewayClassPatchTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata metav1.ObjectMetaPatchPtrInput  `pulumi:"metadata"`
	Spec     GatewayClassSpecPatchPtrInput   `pulumi:"spec"`
	Status   GatewayClassStatusPatchPtrInput `pulumi:"status"`
}

func (GatewayClassPatchTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayClassPatchType)(nil)).Elem()
}

func (i GatewayClassPatchTypeArgs) ToGatewayClassPatchTypeOutput() GatewayClassPatchTypeOutput {
	return i.ToGatewayClassPatchTypeOutputWithContext(context.Background())
}

func (i GatewayClassPatchTypeArgs) ToGatewayClassPatchTypeOutputWithContext(ctx context.Context) GatewayClassPatchTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayClassPatchTypeOutput)
}

// GatewayClass describes a class of Gateways available to the user for creating
// Gateway resources.
//
// It is recommended that this resource be used as a template for Gateways. This
// means that a Gateway is based on the state of the GatewayClass at the time it
// was created and changes to the GatewayClass or associated parameters are not
// propagated down to existing Gateways. This recommendation is intended to
// limit the blast radius of changes to GatewayClass or associated parameters.
// If implementations choose to propagate GatewayClass changes to existing
// Gateways, that MUST be clearly documented by the implementation.
//
// Whenever one or more Gateways are using a GatewayClass, implementations SHOULD
// add the `gateway-exists-finalizer.gateway.networking.k8s.io` finalizer on the
// associated GatewayClass. This ensures that a GatewayClass associated with a
// Gateway is not deleted while in use.
//
// GatewayClass is a Cluster level resource.
type GatewayClassPatchTypeOutput struct{ *pulumi.OutputState }

func (GatewayClassPatchTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayClassPatchType)(nil)).Elem()
}

func (o GatewayClassPatchTypeOutput) ToGatewayClassPatchTypeOutput() GatewayClassPatchTypeOutput {
	return o
}

func (o GatewayClassPatchTypeOutput) ToGatewayClassPatchTypeOutputWithContext(ctx context.Context) GatewayClassPatchTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o GatewayClassPatchTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayClassPatchType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o GatewayClassPatchTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayClassPatchType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
func (o GatewayClassPatchTypeOutput) Metadata() metav1.ObjectMetaPatchPtrOutput {
	return o.ApplyT(func(v GatewayClassPatchType) *metav1.ObjectMetaPatch { return v.Metadata }).(metav1.ObjectMetaPatchPtrOutput)
}

func (o GatewayClassPatchTypeOutput) Spec() GatewayClassSpecPatchPtrOutput {
	return o.ApplyT(func(v GatewayClassPatchType) *GatewayClassSpecPatch { return v.Spec }).(GatewayClassSpecPatchPtrOutput)
}

func (o GatewayClassPatchTypeOutput) Status() GatewayClassStatusPatchPtrOutput {
	return o.ApplyT(func(v GatewayClassPatchType) *GatewayClassStatusPatch { return v.Status }).(GatewayClassStatusPatchPtrOutput)
}

// Spec defines the desired state of GatewayClass.
type GatewayClassSpec struct {
	// ControllerName is the name of the controller that is managing Gateways of
	// this class. The value of this field MUST be a domain prefixed path.
	//
	// Example: "example.net/gateway-controller".
	//
	// This field is not mutable and cannot be empty.
	//
	// Support: Core
	ControllerName *string `pulumi:"controllerName"`
	// Description helps describe a GatewayClass with more details.
	Description   *string                        `pulumi:"description"`
	ParametersRef *GatewayClassSpecParametersRef `pulumi:"parametersRef"`
}

// GatewayClassSpecInput is an input type that accepts GatewayClassSpecArgs and GatewayClassSpecOutput values.
// You can construct a concrete instance of `GatewayClassSpecInput` via:
//
//	GatewayClassSpecArgs{...}
type GatewayClassSpecInput interface {
	pulumi.Input

	ToGatewayClassSpecOutput() GatewayClassSpecOutput
	ToGatewayClassSpecOutputWithContext(context.Context) GatewayClassSpecOutput
}

// Spec defines the desired state of GatewayClass.
type GatewayClassSpecArgs struct {
	// ControllerName is the name of the controller that is managing Gateways of
	// this class. The value of this field MUST be a domain prefixed path.
	//
	// Example: "example.net/gateway-controller".
	//
	// This field is not mutable and cannot be empty.
	//
	// Support: Core
	ControllerName pulumi.StringPtrInput `pulumi:"controllerName"`
	// Description helps describe a GatewayClass with more details.
	Description   pulumi.StringPtrInput                 `pulumi:"description"`
	ParametersRef GatewayClassSpecParametersRefPtrInput `pulumi:"parametersRef"`
}

func (GatewayClassSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayClassSpec)(nil)).Elem()
}

func (i GatewayClassSpecArgs) ToGatewayClassSpecOutput() GatewayClassSpecOutput {
	return i.ToGatewayClassSpecOutputWithContext(context.Background())
}

func (i GatewayClassSpecArgs) ToGatewayClassSpecOutputWithContext(ctx context.Context) GatewayClassSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayClassSpecOutput)
}

func (i GatewayClassSpecArgs) ToGatewayClassSpecPtrOutput() GatewayClassSpecPtrOutput {
	return i.ToGatewayClassSpecPtrOutputWithContext(context.Background())
}

func (i GatewayClassSpecArgs) ToGatewayClassSpecPtrOutputWithContext(ctx context.Context) GatewayClassSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayClassSpecOutput).ToGatewayClassSpecPtrOutputWithContext(ctx)
}

// GatewayClassSpecPtrInput is an input type that accepts GatewayClassSpecArgs, GatewayClassSpecPtr and GatewayClassSpecPtrOutput values.
// You can construct a concrete instance of `GatewayClassSpecPtrInput` via:
//
//	        GatewayClassSpecArgs{...}
//
//	or:
//
//	        nil
type GatewayClassSpecPtrInput interface {
	pulumi.Input

	ToGatewayClassSpecPtrOutput() GatewayClassSpecPtrOutput
	ToGatewayClassSpecPtrOutputWithContext(context.Context) GatewayClassSpecPtrOutput
}

type gatewayClassSpecPtrType GatewayClassSpecArgs

func GatewayClassSpecPtr(v *GatewayClassSpecArgs) GatewayClassSpecPtrInput {
	return (*gatewayClassSpecPtrType)(v)
}

func (*gatewayClassSpecPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewayClassSpec)(nil)).Elem()
}

func (i *gatewayClassSpecPtrType) ToGatewayClassSpecPtrOutput() GatewayClassSpecPtrOutput {
	return i.ToGatewayClassSpecPtrOutputWithContext(context.Background())
}

func (i *gatewayClassSpecPtrType) ToGatewayClassSpecPtrOutputWithContext(ctx context.Context) GatewayClassSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayClassSpecPtrOutput)
}

// Spec defines the desired state of GatewayClass.
type GatewayClassSpecOutput struct{ *pulumi.OutputState }

func (GatewayClassSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayClassSpec)(nil)).Elem()
}

func (o GatewayClassSpecOutput) ToGatewayClassSpecOutput() GatewayClassSpecOutput {
	return o
}

func (o GatewayClassSpecOutput) ToGatewayClassSpecOutputWithContext(ctx context.Context) GatewayClassSpecOutput {
	return o
}

func (o GatewayClassSpecOutput) ToGatewayClassSpecPtrOutput() GatewayClassSpecPtrOutput {
	return o.ToGatewayClassSpecPtrOutputWithContext(context.Background())
}

func (o GatewayClassSpecOutput) ToGatewayClassSpecPtrOutputWithContext(ctx context.Context) GatewayClassSpecPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GatewayClassSpec) *GatewayClassSpec {
		return &v
	}).(GatewayClassSpecPtrOutput)
}

// ControllerName is the name of the controller that is managing Gateways of
// this class. The value of this field MUST be a domain prefixed path.
//
// Example: "example.net/gateway-controller".
//
// This field is not mutable and cannot be empty.
//
// Support: Core
func (o GatewayClassSpecOutput) ControllerName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayClassSpec) *string { return v.ControllerName }).(pulumi.StringPtrOutput)
}

// Description helps describe a GatewayClass with more details.
func (o GatewayClassSpecOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayClassSpec) *string { return v.Description }).(pulumi.StringPtrOutput)
}

func (o GatewayClassSpecOutput) ParametersRef() GatewayClassSpecParametersRefPtrOutput {
	return o.ApplyT(func(v GatewayClassSpec) *GatewayClassSpecParametersRef { return v.ParametersRef }).(GatewayClassSpecParametersRefPtrOutput)
}

type GatewayClassSpecPtrOutput struct{ *pulumi.OutputState }

func (GatewayClassSpecPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewayClassSpec)(nil)).Elem()
}

func (o GatewayClassSpecPtrOutput) ToGatewayClassSpecPtrOutput() GatewayClassSpecPtrOutput {
	return o
}

func (o GatewayClassSpecPtrOutput) ToGatewayClassSpecPtrOutputWithContext(ctx context.Context) GatewayClassSpecPtrOutput {
	return o
}

func (o GatewayClassSpecPtrOutput) Elem() GatewayClassSpecOutput {
	return o.ApplyT(func(v *GatewayClassSpec) GatewayClassSpec {
		if v != nil {
			return *v
		}
		var ret GatewayClassSpec
		return ret
	}).(GatewayClassSpecOutput)
}

// ControllerName is the name of the controller that is managing Gateways of
// this class. The value of this field MUST be a domain prefixed path.
//
// Example: "example.net/gateway-controller".
//
// This field is not mutable and cannot be empty.
//
// Support: Core
func (o GatewayClassSpecPtrOutput) ControllerName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GatewayClassSpec) *string {
		if v == nil {
			return nil
		}
		return v.ControllerName
	}).(pulumi.StringPtrOutput)
}

// Description helps describe a GatewayClass with more details.
func (o GatewayClassSpecPtrOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GatewayClassSpec) *string {
		if v == nil {
			return nil
		}
		return v.Description
	}).(pulumi.StringPtrOutput)
}

func (o GatewayClassSpecPtrOutput) ParametersRef() GatewayClassSpecParametersRefPtrOutput {
	return o.ApplyT(func(v *GatewayClassSpec) *GatewayClassSpecParametersRef {
		if v == nil {
			return nil
		}
		return v.ParametersRef
	}).(GatewayClassSpecParametersRefPtrOutput)
}

// ParametersRef is a reference to a resource that contains the configuration
// parameters corresponding to the GatewayClass. This is optional if the
// controller does not require any additional configuration.
//
// ParametersRef can reference a standard Kubernetes resource, i.e. ConfigMap,
// or an implementation-specific custom resource. The resource can be
// cluster-scoped or namespace-scoped.
//
// If the referent cannot be found, the GatewayClass's "InvalidParameters"
// status condition will be true.
//
// A Gateway for this GatewayClass may provide its own `parametersRef`. When both are specified,
// the merging behavior is implementation specific.
// It is generally recommended that GatewayClass provides defaults that can be overridden by a Gateway.
//
// Support: Implementation-specific
type GatewayClassSpecParametersRef struct {
	// Group is the group of the referent.
	Group *string `pulumi:"group"`
	// Kind is kind of the referent.
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	Name *string `pulumi:"name"`
	// Namespace is the namespace of the referent.
	// This field is required when referring to a Namespace-scoped resource and
	// MUST be unset when referring to a Cluster-scoped resource.
	Namespace *string `pulumi:"namespace"`
}

// GatewayClassSpecParametersRefInput is an input type that accepts GatewayClassSpecParametersRefArgs and GatewayClassSpecParametersRefOutput values.
// You can construct a concrete instance of `GatewayClassSpecParametersRefInput` via:
//
//	GatewayClassSpecParametersRefArgs{...}
type GatewayClassSpecParametersRefInput interface {
	pulumi.Input

	ToGatewayClassSpecParametersRefOutput() GatewayClassSpecParametersRefOutput
	ToGatewayClassSpecParametersRefOutputWithContext(context.Context) GatewayClassSpecParametersRefOutput
}

// ParametersRef is a reference to a resource that contains the configuration
// parameters corresponding to the GatewayClass. This is optional if the
// controller does not require any additional configuration.
//
// ParametersRef can reference a standard Kubernetes resource, i.e. ConfigMap,
// or an implementation-specific custom resource. The resource can be
// cluster-scoped or namespace-scoped.
//
// If the referent cannot be found, the GatewayClass's "InvalidParameters"
// status condition will be true.
//
// A Gateway for this GatewayClass may provide its own `parametersRef`. When both are specified,
// the merging behavior is implementation specific.
// It is generally recommended that GatewayClass provides defaults that can be overridden by a Gateway.
//
// Support: Implementation-specific
type GatewayClassSpecParametersRefArgs struct {
	// Group is the group of the referent.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is kind of the referent.
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace is the namespace of the referent.
	// This field is required when referring to a Namespace-scoped resource and
	// MUST be unset when referring to a Cluster-scoped resource.
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
}

func (GatewayClassSpecParametersRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayClassSpecParametersRef)(nil)).Elem()
}

func (i GatewayClassSpecParametersRefArgs) ToGatewayClassSpecParametersRefOutput() GatewayClassSpecParametersRefOutput {
	return i.ToGatewayClassSpecParametersRefOutputWithContext(context.Background())
}

func (i GatewayClassSpecParametersRefArgs) ToGatewayClassSpecParametersRefOutputWithContext(ctx context.Context) GatewayClassSpecParametersRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayClassSpecParametersRefOutput)
}

func (i GatewayClassSpecParametersRefArgs) ToGatewayClassSpecParametersRefPtrOutput() GatewayClassSpecParametersRefPtrOutput {
	return i.ToGatewayClassSpecParametersRefPtrOutputWithContext(context.Background())
}

func (i GatewayClassSpecParametersRefArgs) ToGatewayClassSpecParametersRefPtrOutputWithContext(ctx context.Context) GatewayClassSpecParametersRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayClassSpecParametersRefOutput).ToGatewayClassSpecParametersRefPtrOutputWithContext(ctx)
}

// GatewayClassSpecParametersRefPtrInput is an input type that accepts GatewayClassSpecParametersRefArgs, GatewayClassSpecParametersRefPtr and GatewayClassSpecParametersRefPtrOutput values.
// You can construct a concrete instance of `GatewayClassSpecParametersRefPtrInput` via:
//
//	        GatewayClassSpecParametersRefArgs{...}
//
//	or:
//
//	        nil
type GatewayClassSpecParametersRefPtrInput interface {
	pulumi.Input

	ToGatewayClassSpecParametersRefPtrOutput() GatewayClassSpecParametersRefPtrOutput
	ToGatewayClassSpecParametersRefPtrOutputWithContext(context.Context) GatewayClassSpecParametersRefPtrOutput
}

type gatewayClassSpecParametersRefPtrType GatewayClassSpecParametersRefArgs

func GatewayClassSpecParametersRefPtr(v *GatewayClassSpecParametersRefArgs) GatewayClassSpecParametersRefPtrInput {
	return (*gatewayClassSpecParametersRefPtrType)(v)
}

func (*gatewayClassSpecParametersRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewayClassSpecParametersRef)(nil)).Elem()
}

func (i *gatewayClassSpecParametersRefPtrType) ToGatewayClassSpecParametersRefPtrOutput() GatewayClassSpecParametersRefPtrOutput {
	return i.ToGatewayClassSpecParametersRefPtrOutputWithContext(context.Background())
}

func (i *gatewayClassSpecParametersRefPtrType) ToGatewayClassSpecParametersRefPtrOutputWithContext(ctx context.Context) GatewayClassSpecParametersRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayClassSpecParametersRefPtrOutput)
}

// ParametersRef is a reference to a resource that contains the configuration
// parameters corresponding to the GatewayClass. This is optional if the
// controller does not require any additional configuration.
//
// ParametersRef can reference a standard Kubernetes resource, i.e. ConfigMap,
// or an implementation-specific custom resource. The resource can be
// cluster-scoped or namespace-scoped.
//
// If the referent cannot be found, the GatewayClass's "InvalidParameters"
// status condition will be true.
//
// A Gateway for this GatewayClass may provide its own `parametersRef`. When both are specified,
// the merging behavior is implementation specific.
// It is generally recommended that GatewayClass provides defaults that can be overridden by a Gateway.
//
// Support: Implementation-specific
type GatewayClassSpecParametersRefOutput struct{ *pulumi.OutputState }

func (GatewayClassSpecParametersRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayClassSpecParametersRef)(nil)).Elem()
}

func (o GatewayClassSpecParametersRefOutput) ToGatewayClassSpecParametersRefOutput() GatewayClassSpecParametersRefOutput {
	return o
}

func (o GatewayClassSpecParametersRefOutput) ToGatewayClassSpecParametersRefOutputWithContext(ctx context.Context) GatewayClassSpecParametersRefOutput {
	return o
}

func (o GatewayClassSpecParametersRefOutput) ToGatewayClassSpecParametersRefPtrOutput() GatewayClassSpecParametersRefPtrOutput {
	return o.ToGatewayClassSpecParametersRefPtrOutputWithContext(context.Background())
}

func (o GatewayClassSpecParametersRefOutput) ToGatewayClassSpecParametersRefPtrOutputWithContext(ctx context.Context) GatewayClassSpecParametersRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GatewayClassSpecParametersRef) *GatewayClassSpecParametersRef {
		return &v
	}).(GatewayClassSpecParametersRefPtrOutput)
}

// Group is the group of the referent.
func (o GatewayClassSpecParametersRefOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayClassSpecParametersRef) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent.
func (o GatewayClassSpecParametersRefOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayClassSpecParametersRef) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o GatewayClassSpecParametersRefOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayClassSpecParametersRef) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the referent.
// This field is required when referring to a Namespace-scoped resource and
// MUST be unset when referring to a Cluster-scoped resource.
func (o GatewayClassSpecParametersRefOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayClassSpecParametersRef) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

type GatewayClassSpecParametersRefPtrOutput struct{ *pulumi.OutputState }

func (GatewayClassSpecParametersRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewayClassSpecParametersRef)(nil)).Elem()
}

func (o GatewayClassSpecParametersRefPtrOutput) ToGatewayClassSpecParametersRefPtrOutput() GatewayClassSpecParametersRefPtrOutput {
	return o
}

func (o GatewayClassSpecParametersRefPtrOutput) ToGatewayClassSpecParametersRefPtrOutputWithContext(ctx context.Context) GatewayClassSpecParametersRefPtrOutput {
	return o
}

func (o GatewayClassSpecParametersRefPtrOutput) Elem() GatewayClassSpecParametersRefOutput {
	return o.ApplyT(func(v *GatewayClassSpecParametersRef) GatewayClassSpecParametersRef {
		if v != nil {
			return *v
		}
		var ret GatewayClassSpecParametersRef
		return ret
	}).(GatewayClassSpecParametersRefOutput)
}

// Group is the group of the referent.
func (o GatewayClassSpecParametersRefPtrOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GatewayClassSpecParametersRef) *string {
		if v == nil {
			return nil
		}
		return v.Group
	}).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent.
func (o GatewayClassSpecParametersRefPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GatewayClassSpecParametersRef) *string {
		if v == nil {
			return nil
		}
		return v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o GatewayClassSpecParametersRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GatewayClassSpecParametersRef) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the referent.
// This field is required when referring to a Namespace-scoped resource and
// MUST be unset when referring to a Cluster-scoped resource.
func (o GatewayClassSpecParametersRefPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GatewayClassSpecParametersRef) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

// ParametersRef is a reference to a resource that contains the configuration
// parameters corresponding to the GatewayClass. This is optional if the
// controller does not require any additional configuration.
//
// ParametersRef can reference a standard Kubernetes resource, i.e. ConfigMap,
// or an implementation-specific custom resource. The resource can be
// cluster-scoped or namespace-scoped.
//
// If the referent cannot be found, the GatewayClass's "InvalidParameters"
// status condition will be true.
//
// A Gateway for this GatewayClass may provide its own `parametersRef`. When both are specified,
// the merging behavior is implementation specific.
// It is generally recommended that GatewayClass provides defaults that can be overridden by a Gateway.
//
// Support: Implementation-specific
type GatewayClassSpecParametersRefPatch struct {
	// Group is the group of the referent.
	Group *string `pulumi:"group"`
	// Kind is kind of the referent.
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	Name *string `pulumi:"name"`
	// Namespace is the namespace of the referent.
	// This field is required when referring to a Namespace-scoped resource and
	// MUST be unset when referring to a Cluster-scoped resource.
	Namespace *string `pulumi:"namespace"`
}

// GatewayClassSpecParametersRefPatchInput is an input type that accepts GatewayClassSpecParametersRefPatchArgs and GatewayClassSpecParametersRefPatchOutput values.
// You can construct a concrete instance of `GatewayClassSpecParametersRefPatchInput` via:
//
//	GatewayClassSpecParametersRefPatchArgs{...}
type GatewayClassSpecParametersRefPatchInput interface {
	pulumi.Input

	ToGatewayClassSpecParametersRefPatchOutput() GatewayClassSpecParametersRefPatchOutput
	ToGatewayClassSpecParametersRefPatchOutputWithContext(context.Context) GatewayClassSpecParametersRefPatchOutput
}

// ParametersRef is a reference to a resource that contains the configuration
// parameters corresponding to the GatewayClass. This is optional if the
// controller does not require any additional configuration.
//
// ParametersRef can reference a standard Kubernetes resource, i.e. ConfigMap,
// or an implementation-specific custom resource. The resource can be
// cluster-scoped or namespace-scoped.
//
// If the referent cannot be found, the GatewayClass's "InvalidParameters"
// status condition will be true.
//
// A Gateway for this GatewayClass may provide its own `parametersRef`. When both are specified,
// the merging behavior is implementation specific.
// It is generally recommended that GatewayClass provides defaults that can be overridden by a Gateway.
//
// Support: Implementation-specific
type GatewayClassSpecParametersRefPatchArgs struct {
	// Group is the group of the referent.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is kind of the referent.
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace is the namespace of the referent.
	// This field is required when referring to a Namespace-scoped resource and
	// MUST be unset when referring to a Cluster-scoped resource.
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
}

func (GatewayClassSpecParametersRefPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayClassSpecParametersRefPatch)(nil)).Elem()
}

func (i GatewayClassSpecParametersRefPatchArgs) ToGatewayClassSpecParametersRefPatchOutput() GatewayClassSpecParametersRefPatchOutput {
	return i.ToGatewayClassSpecParametersRefPatchOutputWithContext(context.Background())
}

func (i GatewayClassSpecParametersRefPatchArgs) ToGatewayClassSpecParametersRefPatchOutputWithContext(ctx context.Context) GatewayClassSpecParametersRefPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayClassSpecParametersRefPatchOutput)
}

func (i GatewayClassSpecParametersRefPatchArgs) ToGatewayClassSpecParametersRefPatchPtrOutput() GatewayClassSpecParametersRefPatchPtrOutput {
	return i.ToGatewayClassSpecParametersRefPatchPtrOutputWithContext(context.Background())
}

func (i GatewayClassSpecParametersRefPatchArgs) ToGatewayClassSpecParametersRefPatchPtrOutputWithContext(ctx context.Context) GatewayClassSpecParametersRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayClassSpecParametersRefPatchOutput).ToGatewayClassSpecParametersRefPatchPtrOutputWithContext(ctx)
}

// GatewayClassSpecParametersRefPatchPtrInput is an input type that accepts GatewayClassSpecParametersRefPatchArgs, GatewayClassSpecParametersRefPatchPtr and GatewayClassSpecParametersRefPatchPtrOutput values.
// You can construct a concrete instance of `GatewayClassSpecParametersRefPatchPtrInput` via:
//
//	        GatewayClassSpecParametersRefPatchArgs{...}
//
//	or:
//
//	        nil
type GatewayClassSpecParametersRefPatchPtrInput interface {
	pulumi.Input

	ToGatewayClassSpecParametersRefPatchPtrOutput() GatewayClassSpecParametersRefPatchPtrOutput
	ToGatewayClassSpecParametersRefPatchPtrOutputWithContext(context.Context) GatewayClassSpecParametersRefPatchPtrOutput
}

type gatewayClassSpecParametersRefPatchPtrType GatewayClassSpecParametersRefPatchArgs

func GatewayClassSpecParametersRefPatchPtr(v *GatewayClassSpecParametersRefPatchArgs) GatewayClassSpecParametersRefPatchPtrInput {
	return (*gatewayClassSpecParametersRefPatchPtrType)(v)
}

func (*gatewayClassSpecParametersRefPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewayClassSpecParametersRefPatch)(nil)).Elem()
}

func (i *gatewayClassSpecParametersRefPatchPtrType) ToGatewayClassSpecParametersRefPatchPtrOutput() GatewayClassSpecParametersRefPatchPtrOutput {
	return i.ToGatewayClassSpecParametersRefPatchPtrOutputWithContext(context.Background())
}

func (i *gatewayClassSpecParametersRefPatchPtrType) ToGatewayClassSpecParametersRefPatchPtrOutputWithContext(ctx context.Context) GatewayClassSpecParametersRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayClassSpecParametersRefPatchPtrOutput)
}

// ParametersRef is a reference to a resource that contains the configuration
// parameters corresponding to the GatewayClass. This is optional if the
// controller does not require any additional configuration.
//
// ParametersRef can reference a standard Kubernetes resource, i.e. ConfigMap,
// or an implementation-specific custom resource. The resource can be
// cluster-scoped or namespace-scoped.
//
// If the referent cannot be found, the GatewayClass's "InvalidParameters"
// status condition will be true.
//
// A Gateway for this GatewayClass may provide its own `parametersRef`. When both are specified,
// the merging behavior is implementation specific.
// It is generally recommended that GatewayClass provides defaults that can be overridden by a Gateway.
//
// Support: Implementation-specific
type GatewayClassSpecParametersRefPatchOutput struct{ *pulumi.OutputState }

func (GatewayClassSpecParametersRefPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayClassSpecParametersRefPatch)(nil)).Elem()
}

func (o GatewayClassSpecParametersRefPatchOutput) ToGatewayClassSpecParametersRefPatchOutput() GatewayClassSpecParametersRefPatchOutput {
	return o
}

func (o GatewayClassSpecParametersRefPatchOutput) ToGatewayClassSpecParametersRefPatchOutputWithContext(ctx context.Context) GatewayClassSpecParametersRefPatchOutput {
	return o
}

func (o GatewayClassSpecParametersRefPatchOutput) ToGatewayClassSpecParametersRefPatchPtrOutput() GatewayClassSpecParametersRefPatchPtrOutput {
	return o.ToGatewayClassSpecParametersRefPatchPtrOutputWithContext(context.Background())
}

func (o GatewayClassSpecParametersRefPatchOutput) ToGatewayClassSpecParametersRefPatchPtrOutputWithContext(ctx context.Context) GatewayClassSpecParametersRefPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GatewayClassSpecParametersRefPatch) *GatewayClassSpecParametersRefPatch {
		return &v
	}).(GatewayClassSpecParametersRefPatchPtrOutput)
}

// Group is the group of the referent.
func (o GatewayClassSpecParametersRefPatchOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayClassSpecParametersRefPatch) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent.
func (o GatewayClassSpecParametersRefPatchOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayClassSpecParametersRefPatch) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o GatewayClassSpecParametersRefPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayClassSpecParametersRefPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the referent.
// This field is required when referring to a Namespace-scoped resource and
// MUST be unset when referring to a Cluster-scoped resource.
func (o GatewayClassSpecParametersRefPatchOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayClassSpecParametersRefPatch) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

type GatewayClassSpecParametersRefPatchPtrOutput struct{ *pulumi.OutputState }

func (GatewayClassSpecParametersRefPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewayClassSpecParametersRefPatch)(nil)).Elem()
}

func (o GatewayClassSpecParametersRefPatchPtrOutput) ToGatewayClassSpecParametersRefPatchPtrOutput() GatewayClassSpecParametersRefPatchPtrOutput {
	return o
}

func (o GatewayClassSpecParametersRefPatchPtrOutput) ToGatewayClassSpecParametersRefPatchPtrOutputWithContext(ctx context.Context) GatewayClassSpecParametersRefPatchPtrOutput {
	return o
}

func (o GatewayClassSpecParametersRefPatchPtrOutput) Elem() GatewayClassSpecParametersRefPatchOutput {
	return o.ApplyT(func(v *GatewayClassSpecParametersRefPatch) GatewayClassSpecParametersRefPatch {
		if v != nil {
			return *v
		}
		var ret GatewayClassSpecParametersRefPatch
		return ret
	}).(GatewayClassSpecParametersRefPatchOutput)
}

// Group is the group of the referent.
func (o GatewayClassSpecParametersRefPatchPtrOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GatewayClassSpecParametersRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Group
	}).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent.
func (o GatewayClassSpecParametersRefPatchPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GatewayClassSpecParametersRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o GatewayClassSpecParametersRefPatchPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GatewayClassSpecParametersRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the referent.
// This field is required when referring to a Namespace-scoped resource and
// MUST be unset when referring to a Cluster-scoped resource.
func (o GatewayClassSpecParametersRefPatchPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GatewayClassSpecParametersRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

// Spec defines the desired state of GatewayClass.
type GatewayClassSpecPatch struct {
	// ControllerName is the name of the controller that is managing Gateways of
	// this class. The value of this field MUST be a domain prefixed path.
	//
	// Example: "example.net/gateway-controller".
	//
	// This field is not mutable and cannot be empty.
	//
	// Support: Core
	ControllerName *string `pulumi:"controllerName"`
	// Description helps describe a GatewayClass with more details.
	Description   *string                             `pulumi:"description"`
	ParametersRef *GatewayClassSpecParametersRefPatch `pulumi:"parametersRef"`
}

// GatewayClassSpecPatchInput is an input type that accepts GatewayClassSpecPatchArgs and GatewayClassSpecPatchOutput values.
// You can construct a concrete instance of `GatewayClassSpecPatchInput` via:
//
//	GatewayClassSpecPatchArgs{...}
type GatewayClassSpecPatchInput interface {
	pulumi.Input

	ToGatewayClassSpecPatchOutput() GatewayClassSpecPatchOutput
	ToGatewayClassSpecPatchOutputWithContext(context.Context) GatewayClassSpecPatchOutput
}

// Spec defines the desired state of GatewayClass.
type GatewayClassSpecPatchArgs struct {
	// ControllerName is the name of the controller that is managing Gateways of
	// this class. The value of this field MUST be a domain prefixed path.
	//
	// Example: "example.net/gateway-controller".
	//
	// This field is not mutable and cannot be empty.
	//
	// Support: Core
	ControllerName pulumi.StringPtrInput `pulumi:"controllerName"`
	// Description helps describe a GatewayClass with more details.
	Description   pulumi.StringPtrInput                      `pulumi:"description"`
	ParametersRef GatewayClassSpecParametersRefPatchPtrInput `pulumi:"parametersRef"`
}

func (GatewayClassSpecPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayClassSpecPatch)(nil)).Elem()
}

func (i GatewayClassSpecPatchArgs) ToGatewayClassSpecPatchOutput() GatewayClassSpecPatchOutput {
	return i.ToGatewayClassSpecPatchOutputWithContext(context.Background())
}

func (i GatewayClassSpecPatchArgs) ToGatewayClassSpecPatchOutputWithContext(ctx context.Context) GatewayClassSpecPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayClassSpecPatchOutput)
}

func (i GatewayClassSpecPatchArgs) ToGatewayClassSpecPatchPtrOutput() GatewayClassSpecPatchPtrOutput {
	return i.ToGatewayClassSpecPatchPtrOutputWithContext(context.Background())
}

func (i GatewayClassSpecPatchArgs) ToGatewayClassSpecPatchPtrOutputWithContext(ctx context.Context) GatewayClassSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayClassSpecPatchOutput).ToGatewayClassSpecPatchPtrOutputWithContext(ctx)
}

// GatewayClassSpecPatchPtrInput is an input type that accepts GatewayClassSpecPatchArgs, GatewayClassSpecPatchPtr and GatewayClassSpecPatchPtrOutput values.
// You can construct a concrete instance of `GatewayClassSpecPatchPtrInput` via:
//
//	        GatewayClassSpecPatchArgs{...}
//
//	or:
//
//	        nil
type GatewayClassSpecPatchPtrInput interface {
	pulumi.Input

	ToGatewayClassSpecPatchPtrOutput() GatewayClassSpecPatchPtrOutput
	ToGatewayClassSpecPatchPtrOutputWithContext(context.Context) GatewayClassSpecPatchPtrOutput
}

type gatewayClassSpecPatchPtrType GatewayClassSpecPatchArgs

func GatewayClassSpecPatchPtr(v *GatewayClassSpecPatchArgs) GatewayClassSpecPatchPtrInput {
	return (*gatewayClassSpecPatchPtrType)(v)
}

func (*gatewayClassSpecPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewayClassSpecPatch)(nil)).Elem()
}

func (i *gatewayClassSpecPatchPtrType) ToGatewayClassSpecPatchPtrOutput() GatewayClassSpecPatchPtrOutput {
	return i.ToGatewayClassSpecPatchPtrOutputWithContext(context.Background())
}

func (i *gatewayClassSpecPatchPtrType) ToGatewayClassSpecPatchPtrOutputWithContext(ctx context.Context) GatewayClassSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayClassSpecPatchPtrOutput)
}

// Spec defines the desired state of GatewayClass.
type GatewayClassSpecPatchOutput struct{ *pulumi.OutputState }

func (GatewayClassSpecPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayClassSpecPatch)(nil)).Elem()
}

func (o GatewayClassSpecPatchOutput) ToGatewayClassSpecPatchOutput() GatewayClassSpecPatchOutput {
	return o
}

func (o GatewayClassSpecPatchOutput) ToGatewayClassSpecPatchOutputWithContext(ctx context.Context) GatewayClassSpecPatchOutput {
	return o
}

func (o GatewayClassSpecPatchOutput) ToGatewayClassSpecPatchPtrOutput() GatewayClassSpecPatchPtrOutput {
	return o.ToGatewayClassSpecPatchPtrOutputWithContext(context.Background())
}

func (o GatewayClassSpecPatchOutput) ToGatewayClassSpecPatchPtrOutputWithContext(ctx context.Context) GatewayClassSpecPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GatewayClassSpecPatch) *GatewayClassSpecPatch {
		return &v
	}).(GatewayClassSpecPatchPtrOutput)
}

// ControllerName is the name of the controller that is managing Gateways of
// this class. The value of this field MUST be a domain prefixed path.
//
// Example: "example.net/gateway-controller".
//
// This field is not mutable and cannot be empty.
//
// Support: Core
func (o GatewayClassSpecPatchOutput) ControllerName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayClassSpecPatch) *string { return v.ControllerName }).(pulumi.StringPtrOutput)
}

// Description helps describe a GatewayClass with more details.
func (o GatewayClassSpecPatchOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayClassSpecPatch) *string { return v.Description }).(pulumi.StringPtrOutput)
}

func (o GatewayClassSpecPatchOutput) ParametersRef() GatewayClassSpecParametersRefPatchPtrOutput {
	return o.ApplyT(func(v GatewayClassSpecPatch) *GatewayClassSpecParametersRefPatch { return v.ParametersRef }).(GatewayClassSpecParametersRefPatchPtrOutput)
}

type GatewayClassSpecPatchPtrOutput struct{ *pulumi.OutputState }

func (GatewayClassSpecPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewayClassSpecPatch)(nil)).Elem()
}

func (o GatewayClassSpecPatchPtrOutput) ToGatewayClassSpecPatchPtrOutput() GatewayClassSpecPatchPtrOutput {
	return o
}

func (o GatewayClassSpecPatchPtrOutput) ToGatewayClassSpecPatchPtrOutputWithContext(ctx context.Context) GatewayClassSpecPatchPtrOutput {
	return o
}

func (o GatewayClassSpecPatchPtrOutput) Elem() GatewayClassSpecPatchOutput {
	return o.ApplyT(func(v *GatewayClassSpecPatch) GatewayClassSpecPatch {
		if v != nil {
			return *v
		}
		var ret GatewayClassSpecPatch
		return ret
	}).(GatewayClassSpecPatchOutput)
}

// ControllerName is the name of the controller that is managing Gateways of
// this class. The value of this field MUST be a domain prefixed path.
//
// Example: "example.net/gateway-controller".
//
// This field is not mutable and cannot be empty.
//
// Support: Core
func (o GatewayClassSpecPatchPtrOutput) ControllerName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GatewayClassSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.ControllerName
	}).(pulumi.StringPtrOutput)
}

// Description helps describe a GatewayClass with more details.
func (o GatewayClassSpecPatchPtrOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GatewayClassSpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.Description
	}).(pulumi.StringPtrOutput)
}

func (o GatewayClassSpecPatchPtrOutput) ParametersRef() GatewayClassSpecParametersRefPatchPtrOutput {
	return o.ApplyT(func(v *GatewayClassSpecPatch) *GatewayClassSpecParametersRefPatch {
		if v == nil {
			return nil
		}
		return v.ParametersRef
	}).(GatewayClassSpecParametersRefPatchPtrOutput)
}

// Status defines the current state of GatewayClass.
//
// Implementations MUST populate status on all GatewayClass resources which
// specify their controller name.
type GatewayClassStatus struct {
	// Conditions is the current status from the controller for
	// this GatewayClass.
	//
	// Controllers should prefer to publish conditions using values
	// of GatewayClassConditionType for the type of each Condition.
	Conditions []GatewayClassStatusConditions `pulumi:"conditions"`
}

// GatewayClassStatusInput is an input type that accepts GatewayClassStatusArgs and GatewayClassStatusOutput values.
// You can construct a concrete instance of `GatewayClassStatusInput` via:
//
//	GatewayClassStatusArgs{...}
type GatewayClassStatusInput interface {
	pulumi.Input

	ToGatewayClassStatusOutput() GatewayClassStatusOutput
	ToGatewayClassStatusOutputWithContext(context.Context) GatewayClassStatusOutput
}

// Status defines the current state of GatewayClass.
//
// Implementations MUST populate status on all GatewayClass resources which
// specify their controller name.
type GatewayClassStatusArgs struct {
	// Conditions is the current status from the controller for
	// this GatewayClass.
	//
	// Controllers should prefer to publish conditions using values
	// of GatewayClassConditionType for the type of each Condition.
	Conditions GatewayClassStatusConditionsArrayInput `pulumi:"conditions"`
}

func (GatewayClassStatusArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayClassStatus)(nil)).Elem()
}

func (i GatewayClassStatusArgs) ToGatewayClassStatusOutput() GatewayClassStatusOutput {
	return i.ToGatewayClassStatusOutputWithContext(context.Background())
}

func (i GatewayClassStatusArgs) ToGatewayClassStatusOutputWithContext(ctx context.Context) GatewayClassStatusOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayClassStatusOutput)
}

func (i GatewayClassStatusArgs) ToGatewayClassStatusPtrOutput() GatewayClassStatusPtrOutput {
	return i.ToGatewayClassStatusPtrOutputWithContext(context.Background())
}

func (i GatewayClassStatusArgs) ToGatewayClassStatusPtrOutputWithContext(ctx context.Context) GatewayClassStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayClassStatusOutput).ToGatewayClassStatusPtrOutputWithContext(ctx)
}

// GatewayClassStatusPtrInput is an input type that accepts GatewayClassStatusArgs, GatewayClassStatusPtr and GatewayClassStatusPtrOutput values.
// You can construct a concrete instance of `GatewayClassStatusPtrInput` via:
//
//	        GatewayClassStatusArgs{...}
//
//	or:
//
//	        nil
type GatewayClassStatusPtrInput interface {
	pulumi.Input

	ToGatewayClassStatusPtrOutput() GatewayClassStatusPtrOutput
	ToGatewayClassStatusPtrOutputWithContext(context.Context) GatewayClassStatusPtrOutput
}

type gatewayClassStatusPtrType GatewayClassStatusArgs

func GatewayClassStatusPtr(v *GatewayClassStatusArgs) GatewayClassStatusPtrInput {
	return (*gatewayClassStatusPtrType)(v)
}

func (*gatewayClassStatusPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewayClassStatus)(nil)).Elem()
}

func (i *gatewayClassStatusPtrType) ToGatewayClassStatusPtrOutput() GatewayClassStatusPtrOutput {
	return i.ToGatewayClassStatusPtrOutputWithContext(context.Background())
}

func (i *gatewayClassStatusPtrType) ToGatewayClassStatusPtrOutputWithContext(ctx context.Context) GatewayClassStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayClassStatusPtrOutput)
}

// Status defines the current state of GatewayClass.
//
// Implementations MUST populate status on all GatewayClass resources which
// specify their controller name.
type GatewayClassStatusOutput struct{ *pulumi.OutputState }

func (GatewayClassStatusOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayClassStatus)(nil)).Elem()
}

func (o GatewayClassStatusOutput) ToGatewayClassStatusOutput() GatewayClassStatusOutput {
	return o
}

func (o GatewayClassStatusOutput) ToGatewayClassStatusOutputWithContext(ctx context.Context) GatewayClassStatusOutput {
	return o
}

func (o GatewayClassStatusOutput) ToGatewayClassStatusPtrOutput() GatewayClassStatusPtrOutput {
	return o.ToGatewayClassStatusPtrOutputWithContext(context.Background())
}

func (o GatewayClassStatusOutput) ToGatewayClassStatusPtrOutputWithContext(ctx context.Context) GatewayClassStatusPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GatewayClassStatus) *GatewayClassStatus {
		return &v
	}).(GatewayClassStatusPtrOutput)
}

// Conditions is the current status from the controller for
// this GatewayClass.
//
// Controllers should prefer to publish conditions using values
// of GatewayClassConditionType for the type of each Condition.
func (o GatewayClassStatusOutput) Conditions() GatewayClassStatusConditionsArrayOutput {
	return o.ApplyT(func(v GatewayClassStatus) []GatewayClassStatusConditions { return v.Conditions }).(GatewayClassStatusConditionsArrayOutput)
}

type GatewayClassStatusPtrOutput struct{ *pulumi.OutputState }

func (GatewayClassStatusPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewayClassStatus)(nil)).Elem()
}

func (o GatewayClassStatusPtrOutput) ToGatewayClassStatusPtrOutput() GatewayClassStatusPtrOutput {
	return o
}

func (o GatewayClassStatusPtrOutput) ToGatewayClassStatusPtrOutputWithContext(ctx context.Context) GatewayClassStatusPtrOutput {
	return o
}

func (o GatewayClassStatusPtrOutput) Elem() GatewayClassStatusOutput {
	return o.ApplyT(func(v *GatewayClassStatus) GatewayClassStatus {
		if v != nil {
			return *v
		}
		var ret GatewayClassStatus
		return ret
	}).(GatewayClassStatusOutput)
}

// Conditions is the current status from the controller for
// this GatewayClass.
//
// Controllers should prefer to publish conditions using values
// of GatewayClassConditionType for the type of each Condition.
func (o GatewayClassStatusPtrOutput) Conditions() GatewayClassStatusConditionsArrayOutput {
	return o.ApplyT(func(v *GatewayClassStatus) []GatewayClassStatusConditions {
		if v == nil {
			return nil
		}
		return v.Conditions
	}).(GatewayClassStatusConditionsArrayOutput)
}

// Condition contains details for one aspect of the current state of this API Resource.
// ---
// This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{
//	    // Represents the observations of a foo's current state.
//	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
//	    // +patchMergeKey=type
//	    // +patchStrategy=merge
//	    // +listType=map
//	    // +listMapKey=type
//	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//
//
//	    // other fields
//	}
type GatewayClassStatusConditions struct {
	// lastTransitionTime is the last time the condition transitioned from one status to another.
	// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	LastTransitionTime *string `pulumi:"lastTransitionTime"`
	// message is a human readable message indicating details about the transition.
	// This may be an empty string.
	Message *string `pulumi:"message"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon.
	// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
	// with respect to the current state of the instance.
	ObservedGeneration *int `pulumi:"observedGeneration"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition.
	// Producers of specific condition types may define expected values and meanings for this field,
	// and whether the values are considered a guaranteed API.
	// The value should be a CamelCase string.
	// This field may not be empty.
	Reason *string `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status *string `pulumi:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase.
	// ---
	// Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
	// useful (see .node.status.conditions), the ability to deconflict is important.
	// The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
	Type *string `pulumi:"type"`
}

// GatewayClassStatusConditionsInput is an input type that accepts GatewayClassStatusConditionsArgs and GatewayClassStatusConditionsOutput values.
// You can construct a concrete instance of `GatewayClassStatusConditionsInput` via:
//
//	GatewayClassStatusConditionsArgs{...}
type GatewayClassStatusConditionsInput interface {
	pulumi.Input

	ToGatewayClassStatusConditionsOutput() GatewayClassStatusConditionsOutput
	ToGatewayClassStatusConditionsOutputWithContext(context.Context) GatewayClassStatusConditionsOutput
}

// Condition contains details for one aspect of the current state of this API Resource.
// ---
// This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{
//	    // Represents the observations of a foo's current state.
//	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
//	    // +patchMergeKey=type
//	    // +patchStrategy=merge
//	    // +listType=map
//	    // +listMapKey=type
//	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//
//
//	    // other fields
//	}
type GatewayClassStatusConditionsArgs struct {
	// lastTransitionTime is the last time the condition transitioned from one status to another.
	// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	LastTransitionTime pulumi.StringPtrInput `pulumi:"lastTransitionTime"`
	// message is a human readable message indicating details about the transition.
	// This may be an empty string.
	Message pulumi.StringPtrInput `pulumi:"message"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon.
	// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
	// with respect to the current state of the instance.
	ObservedGeneration pulumi.IntPtrInput `pulumi:"observedGeneration"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition.
	// Producers of specific condition types may define expected values and meanings for this field,
	// and whether the values are considered a guaranteed API.
	// The value should be a CamelCase string.
	// This field may not be empty.
	Reason pulumi.StringPtrInput `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status pulumi.StringPtrInput `pulumi:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase.
	// ---
	// Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
	// useful (see .node.status.conditions), the ability to deconflict is important.
	// The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (GatewayClassStatusConditionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayClassStatusConditions)(nil)).Elem()
}

func (i GatewayClassStatusConditionsArgs) ToGatewayClassStatusConditionsOutput() GatewayClassStatusConditionsOutput {
	return i.ToGatewayClassStatusConditionsOutputWithContext(context.Background())
}

func (i GatewayClassStatusConditionsArgs) ToGatewayClassStatusConditionsOutputWithContext(ctx context.Context) GatewayClassStatusConditionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayClassStatusConditionsOutput)
}

// GatewayClassStatusConditionsArrayInput is an input type that accepts GatewayClassStatusConditionsArray and GatewayClassStatusConditionsArrayOutput values.
// You can construct a concrete instance of `GatewayClassStatusConditionsArrayInput` via:
//
//	GatewayClassStatusConditionsArray{ GatewayClassStatusConditionsArgs{...} }
type GatewayClassStatusConditionsArrayInput interface {
	pulumi.Input

	ToGatewayClassStatusConditionsArrayOutput() GatewayClassStatusConditionsArrayOutput
	ToGatewayClassStatusConditionsArrayOutputWithContext(context.Context) GatewayClassStatusConditionsArrayOutput
}

type GatewayClassStatusConditionsArray []GatewayClassStatusConditionsInput

func (GatewayClassStatusConditionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewayClassStatusConditions)(nil)).Elem()
}

func (i GatewayClassStatusConditionsArray) ToGatewayClassStatusConditionsArrayOutput() GatewayClassStatusConditionsArrayOutput {
	return i.ToGatewayClassStatusConditionsArrayOutputWithContext(context.Background())
}

func (i GatewayClassStatusConditionsArray) ToGatewayClassStatusConditionsArrayOutputWithContext(ctx context.Context) GatewayClassStatusConditionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayClassStatusConditionsArrayOutput)
}

// Condition contains details for one aspect of the current state of this API Resource.
// ---
// This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{
//	    // Represents the observations of a foo's current state.
//	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
//	    // +patchMergeKey=type
//	    // +patchStrategy=merge
//	    // +listType=map
//	    // +listMapKey=type
//	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//
//
//	    // other fields
//	}
type GatewayClassStatusConditionsOutput struct{ *pulumi.OutputState }

func (GatewayClassStatusConditionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayClassStatusConditions)(nil)).Elem()
}

func (o GatewayClassStatusConditionsOutput) ToGatewayClassStatusConditionsOutput() GatewayClassStatusConditionsOutput {
	return o
}

func (o GatewayClassStatusConditionsOutput) ToGatewayClassStatusConditionsOutputWithContext(ctx context.Context) GatewayClassStatusConditionsOutput {
	return o
}

// lastTransitionTime is the last time the condition transitioned from one status to another.
// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
func (o GatewayClassStatusConditionsOutput) LastTransitionTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayClassStatusConditions) *string { return v.LastTransitionTime }).(pulumi.StringPtrOutput)
}

// message is a human readable message indicating details about the transition.
// This may be an empty string.
func (o GatewayClassStatusConditionsOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayClassStatusConditions) *string { return v.Message }).(pulumi.StringPtrOutput)
}

// observedGeneration represents the .metadata.generation that the condition was set based upon.
// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
// with respect to the current state of the instance.
func (o GatewayClassStatusConditionsOutput) ObservedGeneration() pulumi.IntPtrOutput {
	return o.ApplyT(func(v GatewayClassStatusConditions) *int { return v.ObservedGeneration }).(pulumi.IntPtrOutput)
}

// reason contains a programmatic identifier indicating the reason for the condition's last transition.
// Producers of specific condition types may define expected values and meanings for this field,
// and whether the values are considered a guaranteed API.
// The value should be a CamelCase string.
// This field may not be empty.
func (o GatewayClassStatusConditionsOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayClassStatusConditions) *string { return v.Reason }).(pulumi.StringPtrOutput)
}

// status of the condition, one of True, False, Unknown.
func (o GatewayClassStatusConditionsOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayClassStatusConditions) *string { return v.Status }).(pulumi.StringPtrOutput)
}

// type of condition in CamelCase or in foo.example.com/CamelCase.
// ---
// Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
// useful (see .node.status.conditions), the ability to deconflict is important.
// The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
func (o GatewayClassStatusConditionsOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayClassStatusConditions) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type GatewayClassStatusConditionsArrayOutput struct{ *pulumi.OutputState }

func (GatewayClassStatusConditionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewayClassStatusConditions)(nil)).Elem()
}

func (o GatewayClassStatusConditionsArrayOutput) ToGatewayClassStatusConditionsArrayOutput() GatewayClassStatusConditionsArrayOutput {
	return o
}

func (o GatewayClassStatusConditionsArrayOutput) ToGatewayClassStatusConditionsArrayOutputWithContext(ctx context.Context) GatewayClassStatusConditionsArrayOutput {
	return o
}

func (o GatewayClassStatusConditionsArrayOutput) Index(i pulumi.IntInput) GatewayClassStatusConditionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GatewayClassStatusConditions {
		return vs[0].([]GatewayClassStatusConditions)[vs[1].(int)]
	}).(GatewayClassStatusConditionsOutput)
}

// Condition contains details for one aspect of the current state of this API Resource.
// ---
// This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{
//	    // Represents the observations of a foo's current state.
//	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
//	    // +patchMergeKey=type
//	    // +patchStrategy=merge
//	    // +listType=map
//	    // +listMapKey=type
//	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//
//
//	    // other fields
//	}
type GatewayClassStatusConditionsPatch struct {
	// lastTransitionTime is the last time the condition transitioned from one status to another.
	// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	LastTransitionTime *string `pulumi:"lastTransitionTime"`
	// message is a human readable message indicating details about the transition.
	// This may be an empty string.
	Message *string `pulumi:"message"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon.
	// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
	// with respect to the current state of the instance.
	ObservedGeneration *int `pulumi:"observedGeneration"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition.
	// Producers of specific condition types may define expected values and meanings for this field,
	// and whether the values are considered a guaranteed API.
	// The value should be a CamelCase string.
	// This field may not be empty.
	Reason *string `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status *string `pulumi:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase.
	// ---
	// Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
	// useful (see .node.status.conditions), the ability to deconflict is important.
	// The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
	Type *string `pulumi:"type"`
}

// GatewayClassStatusConditionsPatchInput is an input type that accepts GatewayClassStatusConditionsPatchArgs and GatewayClassStatusConditionsPatchOutput values.
// You can construct a concrete instance of `GatewayClassStatusConditionsPatchInput` via:
//
//	GatewayClassStatusConditionsPatchArgs{...}
type GatewayClassStatusConditionsPatchInput interface {
	pulumi.Input

	ToGatewayClassStatusConditionsPatchOutput() GatewayClassStatusConditionsPatchOutput
	ToGatewayClassStatusConditionsPatchOutputWithContext(context.Context) GatewayClassStatusConditionsPatchOutput
}

// Condition contains details for one aspect of the current state of this API Resource.
// ---
// This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{
//	    // Represents the observations of a foo's current state.
//	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
//	    // +patchMergeKey=type
//	    // +patchStrategy=merge
//	    // +listType=map
//	    // +listMapKey=type
//	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//
//
//	    // other fields
//	}
type GatewayClassStatusConditionsPatchArgs struct {
	// lastTransitionTime is the last time the condition transitioned from one status to another.
	// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	LastTransitionTime pulumi.StringPtrInput `pulumi:"lastTransitionTime"`
	// message is a human readable message indicating details about the transition.
	// This may be an empty string.
	Message pulumi.StringPtrInput `pulumi:"message"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon.
	// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
	// with respect to the current state of the instance.
	ObservedGeneration pulumi.IntPtrInput `pulumi:"observedGeneration"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition.
	// Producers of specific condition types may define expected values and meanings for this field,
	// and whether the values are considered a guaranteed API.
	// The value should be a CamelCase string.
	// This field may not be empty.
	Reason pulumi.StringPtrInput `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status pulumi.StringPtrInput `pulumi:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase.
	// ---
	// Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
	// useful (see .node.status.conditions), the ability to deconflict is important.
	// The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (GatewayClassStatusConditionsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayClassStatusConditionsPatch)(nil)).Elem()
}

func (i GatewayClassStatusConditionsPatchArgs) ToGatewayClassStatusConditionsPatchOutput() GatewayClassStatusConditionsPatchOutput {
	return i.ToGatewayClassStatusConditionsPatchOutputWithContext(context.Background())
}

func (i GatewayClassStatusConditionsPatchArgs) ToGatewayClassStatusConditionsPatchOutputWithContext(ctx context.Context) GatewayClassStatusConditionsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayClassStatusConditionsPatchOutput)
}

// GatewayClassStatusConditionsPatchArrayInput is an input type that accepts GatewayClassStatusConditionsPatchArray and GatewayClassStatusConditionsPatchArrayOutput values.
// You can construct a concrete instance of `GatewayClassStatusConditionsPatchArrayInput` via:
//
//	GatewayClassStatusConditionsPatchArray{ GatewayClassStatusConditionsPatchArgs{...} }
type GatewayClassStatusConditionsPatchArrayInput interface {
	pulumi.Input

	ToGatewayClassStatusConditionsPatchArrayOutput() GatewayClassStatusConditionsPatchArrayOutput
	ToGatewayClassStatusConditionsPatchArrayOutputWithContext(context.Context) GatewayClassStatusConditionsPatchArrayOutput
}

type GatewayClassStatusConditionsPatchArray []GatewayClassStatusConditionsPatchInput

func (GatewayClassStatusConditionsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewayClassStatusConditionsPatch)(nil)).Elem()
}

func (i GatewayClassStatusConditionsPatchArray) ToGatewayClassStatusConditionsPatchArrayOutput() GatewayClassStatusConditionsPatchArrayOutput {
	return i.ToGatewayClassStatusConditionsPatchArrayOutputWithContext(context.Background())
}

func (i GatewayClassStatusConditionsPatchArray) ToGatewayClassStatusConditionsPatchArrayOutputWithContext(ctx context.Context) GatewayClassStatusConditionsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayClassStatusConditionsPatchArrayOutput)
}

// Condition contains details for one aspect of the current state of this API Resource.
// ---
// This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{
//	    // Represents the observations of a foo's current state.
//	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
//	    // +patchMergeKey=type
//	    // +patchStrategy=merge
//	    // +listType=map
//	    // +listMapKey=type
//	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//
//
//	    // other fields
//	}
type GatewayClassStatusConditionsPatchOutput struct{ *pulumi.OutputState }

func (GatewayClassStatusConditionsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayClassStatusConditionsPatch)(nil)).Elem()
}

func (o GatewayClassStatusConditionsPatchOutput) ToGatewayClassStatusConditionsPatchOutput() GatewayClassStatusConditionsPatchOutput {
	return o
}

func (o GatewayClassStatusConditionsPatchOutput) ToGatewayClassStatusConditionsPatchOutputWithContext(ctx context.Context) GatewayClassStatusConditionsPatchOutput {
	return o
}

// lastTransitionTime is the last time the condition transitioned from one status to another.
// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
func (o GatewayClassStatusConditionsPatchOutput) LastTransitionTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayClassStatusConditionsPatch) *string { return v.LastTransitionTime }).(pulumi.StringPtrOutput)
}

// message is a human readable message indicating details about the transition.
// This may be an empty string.
func (o GatewayClassStatusConditionsPatchOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayClassStatusConditionsPatch) *string { return v.Message }).(pulumi.StringPtrOutput)
}

// observedGeneration represents the .metadata.generation that the condition was set based upon.
// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
// with respect to the current state of the instance.
func (o GatewayClassStatusConditionsPatchOutput) ObservedGeneration() pulumi.IntPtrOutput {
	return o.ApplyT(func(v GatewayClassStatusConditionsPatch) *int { return v.ObservedGeneration }).(pulumi.IntPtrOutput)
}

// reason contains a programmatic identifier indicating the reason for the condition's last transition.
// Producers of specific condition types may define expected values and meanings for this field,
// and whether the values are considered a guaranteed API.
// The value should be a CamelCase string.
// This field may not be empty.
func (o GatewayClassStatusConditionsPatchOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayClassStatusConditionsPatch) *string { return v.Reason }).(pulumi.StringPtrOutput)
}

// status of the condition, one of True, False, Unknown.
func (o GatewayClassStatusConditionsPatchOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayClassStatusConditionsPatch) *string { return v.Status }).(pulumi.StringPtrOutput)
}

// type of condition in CamelCase or in foo.example.com/CamelCase.
// ---
// Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
// useful (see .node.status.conditions), the ability to deconflict is important.
// The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
func (o GatewayClassStatusConditionsPatchOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayClassStatusConditionsPatch) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type GatewayClassStatusConditionsPatchArrayOutput struct{ *pulumi.OutputState }

func (GatewayClassStatusConditionsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewayClassStatusConditionsPatch)(nil)).Elem()
}

func (o GatewayClassStatusConditionsPatchArrayOutput) ToGatewayClassStatusConditionsPatchArrayOutput() GatewayClassStatusConditionsPatchArrayOutput {
	return o
}

func (o GatewayClassStatusConditionsPatchArrayOutput) ToGatewayClassStatusConditionsPatchArrayOutputWithContext(ctx context.Context) GatewayClassStatusConditionsPatchArrayOutput {
	return o
}

func (o GatewayClassStatusConditionsPatchArrayOutput) Index(i pulumi.IntInput) GatewayClassStatusConditionsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GatewayClassStatusConditionsPatch {
		return vs[0].([]GatewayClassStatusConditionsPatch)[vs[1].(int)]
	}).(GatewayClassStatusConditionsPatchOutput)
}

// Status defines the current state of GatewayClass.
//
// Implementations MUST populate status on all GatewayClass resources which
// specify their controller name.
type GatewayClassStatusPatch struct {
	// Conditions is the current status from the controller for
	// this GatewayClass.
	//
	// Controllers should prefer to publish conditions using values
	// of GatewayClassConditionType for the type of each Condition.
	Conditions []GatewayClassStatusConditionsPatch `pulumi:"conditions"`
}

// GatewayClassStatusPatchInput is an input type that accepts GatewayClassStatusPatchArgs and GatewayClassStatusPatchOutput values.
// You can construct a concrete instance of `GatewayClassStatusPatchInput` via:
//
//	GatewayClassStatusPatchArgs{...}
type GatewayClassStatusPatchInput interface {
	pulumi.Input

	ToGatewayClassStatusPatchOutput() GatewayClassStatusPatchOutput
	ToGatewayClassStatusPatchOutputWithContext(context.Context) GatewayClassStatusPatchOutput
}

// Status defines the current state of GatewayClass.
//
// Implementations MUST populate status on all GatewayClass resources which
// specify their controller name.
type GatewayClassStatusPatchArgs struct {
	// Conditions is the current status from the controller for
	// this GatewayClass.
	//
	// Controllers should prefer to publish conditions using values
	// of GatewayClassConditionType for the type of each Condition.
	Conditions GatewayClassStatusConditionsPatchArrayInput `pulumi:"conditions"`
}

func (GatewayClassStatusPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayClassStatusPatch)(nil)).Elem()
}

func (i GatewayClassStatusPatchArgs) ToGatewayClassStatusPatchOutput() GatewayClassStatusPatchOutput {
	return i.ToGatewayClassStatusPatchOutputWithContext(context.Background())
}

func (i GatewayClassStatusPatchArgs) ToGatewayClassStatusPatchOutputWithContext(ctx context.Context) GatewayClassStatusPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayClassStatusPatchOutput)
}

func (i GatewayClassStatusPatchArgs) ToGatewayClassStatusPatchPtrOutput() GatewayClassStatusPatchPtrOutput {
	return i.ToGatewayClassStatusPatchPtrOutputWithContext(context.Background())
}

func (i GatewayClassStatusPatchArgs) ToGatewayClassStatusPatchPtrOutputWithContext(ctx context.Context) GatewayClassStatusPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayClassStatusPatchOutput).ToGatewayClassStatusPatchPtrOutputWithContext(ctx)
}

// GatewayClassStatusPatchPtrInput is an input type that accepts GatewayClassStatusPatchArgs, GatewayClassStatusPatchPtr and GatewayClassStatusPatchPtrOutput values.
// You can construct a concrete instance of `GatewayClassStatusPatchPtrInput` via:
//
//	        GatewayClassStatusPatchArgs{...}
//
//	or:
//
//	        nil
type GatewayClassStatusPatchPtrInput interface {
	pulumi.Input

	ToGatewayClassStatusPatchPtrOutput() GatewayClassStatusPatchPtrOutput
	ToGatewayClassStatusPatchPtrOutputWithContext(context.Context) GatewayClassStatusPatchPtrOutput
}

type gatewayClassStatusPatchPtrType GatewayClassStatusPatchArgs

func GatewayClassStatusPatchPtr(v *GatewayClassStatusPatchArgs) GatewayClassStatusPatchPtrInput {
	return (*gatewayClassStatusPatchPtrType)(v)
}

func (*gatewayClassStatusPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewayClassStatusPatch)(nil)).Elem()
}

func (i *gatewayClassStatusPatchPtrType) ToGatewayClassStatusPatchPtrOutput() GatewayClassStatusPatchPtrOutput {
	return i.ToGatewayClassStatusPatchPtrOutputWithContext(context.Background())
}

func (i *gatewayClassStatusPatchPtrType) ToGatewayClassStatusPatchPtrOutputWithContext(ctx context.Context) GatewayClassStatusPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayClassStatusPatchPtrOutput)
}

// Status defines the current state of GatewayClass.
//
// Implementations MUST populate status on all GatewayClass resources which
// specify their controller name.
type GatewayClassStatusPatchOutput struct{ *pulumi.OutputState }

func (GatewayClassStatusPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayClassStatusPatch)(nil)).Elem()
}

func (o GatewayClassStatusPatchOutput) ToGatewayClassStatusPatchOutput() GatewayClassStatusPatchOutput {
	return o
}

func (o GatewayClassStatusPatchOutput) ToGatewayClassStatusPatchOutputWithContext(ctx context.Context) GatewayClassStatusPatchOutput {
	return o
}

func (o GatewayClassStatusPatchOutput) ToGatewayClassStatusPatchPtrOutput() GatewayClassStatusPatchPtrOutput {
	return o.ToGatewayClassStatusPatchPtrOutputWithContext(context.Background())
}

func (o GatewayClassStatusPatchOutput) ToGatewayClassStatusPatchPtrOutputWithContext(ctx context.Context) GatewayClassStatusPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GatewayClassStatusPatch) *GatewayClassStatusPatch {
		return &v
	}).(GatewayClassStatusPatchPtrOutput)
}

// Conditions is the current status from the controller for
// this GatewayClass.
//
// Controllers should prefer to publish conditions using values
// of GatewayClassConditionType for the type of each Condition.
func (o GatewayClassStatusPatchOutput) Conditions() GatewayClassStatusConditionsPatchArrayOutput {
	return o.ApplyT(func(v GatewayClassStatusPatch) []GatewayClassStatusConditionsPatch { return v.Conditions }).(GatewayClassStatusConditionsPatchArrayOutput)
}

type GatewayClassStatusPatchPtrOutput struct{ *pulumi.OutputState }

func (GatewayClassStatusPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewayClassStatusPatch)(nil)).Elem()
}

func (o GatewayClassStatusPatchPtrOutput) ToGatewayClassStatusPatchPtrOutput() GatewayClassStatusPatchPtrOutput {
	return o
}

func (o GatewayClassStatusPatchPtrOutput) ToGatewayClassStatusPatchPtrOutputWithContext(ctx context.Context) GatewayClassStatusPatchPtrOutput {
	return o
}

func (o GatewayClassStatusPatchPtrOutput) Elem() GatewayClassStatusPatchOutput {
	return o.ApplyT(func(v *GatewayClassStatusPatch) GatewayClassStatusPatch {
		if v != nil {
			return *v
		}
		var ret GatewayClassStatusPatch
		return ret
	}).(GatewayClassStatusPatchOutput)
}

// Conditions is the current status from the controller for
// this GatewayClass.
//
// Controllers should prefer to publish conditions using values
// of GatewayClassConditionType for the type of each Condition.
func (o GatewayClassStatusPatchPtrOutput) Conditions() GatewayClassStatusConditionsPatchArrayOutput {
	return o.ApplyT(func(v *GatewayClassStatusPatch) []GatewayClassStatusConditionsPatch {
		if v == nil {
			return nil
		}
		return v.Conditions
	}).(GatewayClassStatusConditionsPatchArrayOutput)
}

// GatewayList is a list of Gateway
type GatewayListType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// List of gateways. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md
	Items []GatewayType `pulumi:"items"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Metadata *metav1.ListMeta `pulumi:"metadata"`
}

// GatewayListTypeInput is an input type that accepts GatewayListTypeArgs and GatewayListTypeOutput values.
// You can construct a concrete instance of `GatewayListTypeInput` via:
//
//	GatewayListTypeArgs{...}
type GatewayListTypeInput interface {
	pulumi.Input

	ToGatewayListTypeOutput() GatewayListTypeOutput
	ToGatewayListTypeOutputWithContext(context.Context) GatewayListTypeOutput
}

// GatewayList is a list of Gateway
type GatewayListTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// List of gateways. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md
	Items GatewayTypeArrayInput `pulumi:"items"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Metadata metav1.ListMetaPtrInput `pulumi:"metadata"`
}

func (GatewayListTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayListType)(nil)).Elem()
}

func (i GatewayListTypeArgs) ToGatewayListTypeOutput() GatewayListTypeOutput {
	return i.ToGatewayListTypeOutputWithContext(context.Background())
}

func (i GatewayListTypeArgs) ToGatewayListTypeOutputWithContext(ctx context.Context) GatewayListTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayListTypeOutput)
}

// GatewayList is a list of Gateway
type GatewayListTypeOutput struct{ *pulumi.OutputState }

func (GatewayListTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayListType)(nil)).Elem()
}

func (o GatewayListTypeOutput) ToGatewayListTypeOutput() GatewayListTypeOutput {
	return o
}

func (o GatewayListTypeOutput) ToGatewayListTypeOutputWithContext(ctx context.Context) GatewayListTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o GatewayListTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayListType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// List of gateways. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md
func (o GatewayListTypeOutput) Items() GatewayTypeArrayOutput {
	return o.ApplyT(func(v GatewayListType) []GatewayType { return v.Items }).(GatewayTypeArrayOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o GatewayListTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayListType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o GatewayListTypeOutput) Metadata() metav1.ListMetaPtrOutput {
	return o.ApplyT(func(v GatewayListType) *metav1.ListMeta { return v.Metadata }).(metav1.ListMetaPtrOutput)
}

// Gateway represents an instance of a service-traffic handling infrastructure
// by binding Listeners to a set of IP addresses.
type GatewayPatchType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata *metav1.ObjectMetaPatch `pulumi:"metadata"`
	Spec     *GatewaySpecPatch       `pulumi:"spec"`
	Status   *GatewayStatusPatch     `pulumi:"status"`
}

// GatewayPatchTypeInput is an input type that accepts GatewayPatchTypeArgs and GatewayPatchTypeOutput values.
// You can construct a concrete instance of `GatewayPatchTypeInput` via:
//
//	GatewayPatchTypeArgs{...}
type GatewayPatchTypeInput interface {
	pulumi.Input

	ToGatewayPatchTypeOutput() GatewayPatchTypeOutput
	ToGatewayPatchTypeOutputWithContext(context.Context) GatewayPatchTypeOutput
}

// Gateway represents an instance of a service-traffic handling infrastructure
// by binding Listeners to a set of IP addresses.
type GatewayPatchTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata metav1.ObjectMetaPatchPtrInput `pulumi:"metadata"`
	Spec     GatewaySpecPatchPtrInput       `pulumi:"spec"`
	Status   GatewayStatusPatchPtrInput     `pulumi:"status"`
}

func (GatewayPatchTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayPatchType)(nil)).Elem()
}

func (i GatewayPatchTypeArgs) ToGatewayPatchTypeOutput() GatewayPatchTypeOutput {
	return i.ToGatewayPatchTypeOutputWithContext(context.Background())
}

func (i GatewayPatchTypeArgs) ToGatewayPatchTypeOutputWithContext(ctx context.Context) GatewayPatchTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayPatchTypeOutput)
}

// Gateway represents an instance of a service-traffic handling infrastructure
// by binding Listeners to a set of IP addresses.
type GatewayPatchTypeOutput struct{ *pulumi.OutputState }

func (GatewayPatchTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayPatchType)(nil)).Elem()
}

func (o GatewayPatchTypeOutput) ToGatewayPatchTypeOutput() GatewayPatchTypeOutput {
	return o
}

func (o GatewayPatchTypeOutput) ToGatewayPatchTypeOutputWithContext(ctx context.Context) GatewayPatchTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o GatewayPatchTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayPatchType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o GatewayPatchTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayPatchType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
func (o GatewayPatchTypeOutput) Metadata() metav1.ObjectMetaPatchPtrOutput {
	return o.ApplyT(func(v GatewayPatchType) *metav1.ObjectMetaPatch { return v.Metadata }).(metav1.ObjectMetaPatchPtrOutput)
}

func (o GatewayPatchTypeOutput) Spec() GatewaySpecPatchPtrOutput {
	return o.ApplyT(func(v GatewayPatchType) *GatewaySpecPatch { return v.Spec }).(GatewaySpecPatchPtrOutput)
}

func (o GatewayPatchTypeOutput) Status() GatewayStatusPatchPtrOutput {
	return o.ApplyT(func(v GatewayPatchType) *GatewayStatusPatch { return v.Status }).(GatewayStatusPatchPtrOutput)
}

// Spec defines the desired state of Gateway.
type GatewaySpec struct {
	// Addresses requested for this Gateway. This is optional and behavior can
	// depend on the implementation. If a value is set in the spec and the
	// requested address is invalid or unavailable, the implementation MUST
	// indicate this in the associated entry in GatewayStatus.Addresses.
	//
	// The Addresses field represents a request for the address(es) on the
	// "outside of the Gateway", that traffic bound for this Gateway will use.
	// This could be the IP address or hostname of an external load balancer or
	// other networking infrastructure, or some other address that traffic will
	// be sent to.
	//
	// If no Addresses are specified, the implementation MAY schedule the
	// Gateway in an implementation-specific manner, assigning an appropriate
	// set of Addresses.
	//
	// The implementation MUST bind all Listeners to every GatewayAddress that
	// it assigns to the Gateway and add a corresponding entry in
	// GatewayStatus.Addresses.
	//
	// Support: Extended
	Addresses []GatewaySpecAddresses `pulumi:"addresses"`
	// GatewayClassName used for this Gateway. This is the name of a
	// GatewayClass resource.
	GatewayClassName *string `pulumi:"gatewayClassName"`
	// Listeners associated with this Gateway. Listeners define
	// logical endpoints that are bound on this Gateway's addresses.
	// At least one Listener MUST be specified.
	//
	// Each Listener in a set of Listeners (for example, in a single Gateway)
	// MUST be _distinct_, in that a traffic flow MUST be able to be assigned to
	// exactly one listener. (This section uses "set of Listeners" rather than
	// "Listeners in a single Gateway" because implementations MAY merge configuration
	// from multiple Gateways onto a single data plane, and these rules _also_
	// apply in that case).
	//
	// Practically, this means that each listener in a set MUST have a unique
	// combination of Port, Protocol, and, if supported by the protocol, Hostname.
	//
	// Some combinations of port, protocol, and TLS settings are considered
	// Core support and MUST be supported by implementations based on their
	// targeted conformance profile:
	//
	// HTTP Profile
	//
	// 1. HTTPRoute, Port: 80, Protocol: HTTP
	// 2. HTTPRoute, Port: 443, Protocol: HTTPS, TLS Mode: Terminate, TLS keypair provided
	//
	// TLS Profile
	//
	// 1. TLSRoute, Port: 443, Protocol: TLS, TLS Mode: Passthrough
	//
	// "Distinct" Listeners have the following property:
	//
	// The implementation can match inbound requests to a single distinct
	// Listener. When multiple Listeners share values for fields (for
	// example, two Listeners with the same Port value), the implementation
	// can match requests to only one of the Listeners using other
	// Listener fields.
	//
	// For example, the following Listener scenarios are distinct:
	//
	// 1. Multiple Listeners with the same Port that all use the "HTTP"
	//    Protocol that all have unique Hostname values.
	// 2. Multiple Listeners with the same Port that use either the "HTTPS" or
	//    "TLS" Protocol that all have unique Hostname values.
	// 3. A mixture of "TCP" and "UDP" Protocol Listeners, where no Listener
	//    with the same Protocol has the same Port value.
	//
	// Some fields in the Listener struct have possible values that affect
	// whether the Listener is distinct. Hostname is particularly relevant
	// for HTTP or HTTPS protocols.
	//
	// When using the Hostname value to select between same-Port, same-Protocol
	// Listeners, the Hostname value must be different on each Listener for the
	// Listener to be distinct.
	//
	// When the Listeners are distinct based on Hostname, inbound request
	// hostnames MUST match from the most specific to least specific Hostname
	// values to choose the correct Listener and its associated set of Routes.
	//
	// Exact matches must be processed before wildcard matches, and wildcard
	// matches must be processed before fallback (empty Hostname value)
	// matches. For example, `"foo.example.com"` takes precedence over
	// `"*.example.com"`, and `"*.example.com"` takes precedence over `""`.
	//
	// Additionally, if there are multiple wildcard entries, more specific
	// wildcard entries must be processed before less specific wildcard entries.
	// For example, `"*.foo.example.com"` takes precedence over `"*.example.com"`.
	// The precise definition here is that the higher the number of dots in the
	// hostname to the right of the wildcard character, the higher the precedence.
	//
	// The wildcard character will match any number of characters _and dots_ to
	// the left, however, so `"*.example.com"` will match both
	// `"foo.bar.example.com"` _and_ `"bar.example.com"`.
	//
	// If a set of Listeners contains Listeners that are not distinct, then those
	// Listeners are Conflicted, and the implementation MUST set the "Conflicted"
	// condition in the Listener Status to "True".
	//
	// Implementations MAY choose to accept a Gateway with some Conflicted
	// Listeners only if they only accept the partial Listener set that contains
	// no Conflicted Listeners. To put this another way, implementations may
	// accept a partial Listener set only if they throw out *all* the conflicting
	// Listeners. No picking one of the conflicting listeners as the winner.
	// This also means that the Gateway must have at least one non-conflicting
	// Listener in this case, otherwise it violates the requirement that at
	// least one Listener must be present.
	//
	// The implementation MUST set a "ListenersNotValid" condition on the
	// Gateway Status when the Gateway contains Conflicted Listeners whether or
	// not they accept the Gateway. That Condition SHOULD clearly
	// indicate in the Message which Listeners are conflicted, and which are
	// Accepted. Additionally, the Listener status for those listeners SHOULD
	// indicate which Listeners are conflicted and not Accepted.
	//
	// A Gateway's Listeners are considered "compatible" if:
	//
	// 1. They are distinct.
	// 2. The implementation can serve them in compliance with the Addresses
	//    requirement that all Listeners are available on all assigned
	//    addresses.
	//
	// Compatible combinations in Extended support are expected to vary across
	// implementations. A combination that is compatible for one implementation
	// may not be compatible for another.
	//
	// For example, an implementation that cannot serve both TCP and UDP listeners
	// on the same address, or cannot mix HTTPS and generic TLS listens on the same port
	// would not consider those cases compatible, even though they are distinct.
	//
	// Note that requests SHOULD match at most one Listener. For example, if
	// Listeners are defined for "foo.example.com" and "*.example.com", a
	// request to "foo.example.com" SHOULD only be routed using routes attached
	// to the "foo.example.com" Listener (and not the "*.example.com" Listener).
	// This concept is known as "Listener Isolation". Implementations that do
	// not support Listener Isolation MUST clearly document this.
	//
	// Implementations MAY merge separate Gateways onto a single set of
	// Addresses if all Listeners across all Gateways are compatible.
	//
	// Support: Core
	Listeners []GatewaySpecListeners `pulumi:"listeners"`
}

// GatewaySpecInput is an input type that accepts GatewaySpecArgs and GatewaySpecOutput values.
// You can construct a concrete instance of `GatewaySpecInput` via:
//
//	GatewaySpecArgs{...}
type GatewaySpecInput interface {
	pulumi.Input

	ToGatewaySpecOutput() GatewaySpecOutput
	ToGatewaySpecOutputWithContext(context.Context) GatewaySpecOutput
}

// Spec defines the desired state of Gateway.
type GatewaySpecArgs struct {
	// Addresses requested for this Gateway. This is optional and behavior can
	// depend on the implementation. If a value is set in the spec and the
	// requested address is invalid or unavailable, the implementation MUST
	// indicate this in the associated entry in GatewayStatus.Addresses.
	//
	// The Addresses field represents a request for the address(es) on the
	// "outside of the Gateway", that traffic bound for this Gateway will use.
	// This could be the IP address or hostname of an external load balancer or
	// other networking infrastructure, or some other address that traffic will
	// be sent to.
	//
	// If no Addresses are specified, the implementation MAY schedule the
	// Gateway in an implementation-specific manner, assigning an appropriate
	// set of Addresses.
	//
	// The implementation MUST bind all Listeners to every GatewayAddress that
	// it assigns to the Gateway and add a corresponding entry in
	// GatewayStatus.Addresses.
	//
	// Support: Extended
	Addresses GatewaySpecAddressesArrayInput `pulumi:"addresses"`
	// GatewayClassName used for this Gateway. This is the name of a
	// GatewayClass resource.
	GatewayClassName pulumi.StringPtrInput `pulumi:"gatewayClassName"`
	// Listeners associated with this Gateway. Listeners define
	// logical endpoints that are bound on this Gateway's addresses.
	// At least one Listener MUST be specified.
	//
	// Each Listener in a set of Listeners (for example, in a single Gateway)
	// MUST be _distinct_, in that a traffic flow MUST be able to be assigned to
	// exactly one listener. (This section uses "set of Listeners" rather than
	// "Listeners in a single Gateway" because implementations MAY merge configuration
	// from multiple Gateways onto a single data plane, and these rules _also_
	// apply in that case).
	//
	// Practically, this means that each listener in a set MUST have a unique
	// combination of Port, Protocol, and, if supported by the protocol, Hostname.
	//
	// Some combinations of port, protocol, and TLS settings are considered
	// Core support and MUST be supported by implementations based on their
	// targeted conformance profile:
	//
	// HTTP Profile
	//
	// 1. HTTPRoute, Port: 80, Protocol: HTTP
	// 2. HTTPRoute, Port: 443, Protocol: HTTPS, TLS Mode: Terminate, TLS keypair provided
	//
	// TLS Profile
	//
	// 1. TLSRoute, Port: 443, Protocol: TLS, TLS Mode: Passthrough
	//
	// "Distinct" Listeners have the following property:
	//
	// The implementation can match inbound requests to a single distinct
	// Listener. When multiple Listeners share values for fields (for
	// example, two Listeners with the same Port value), the implementation
	// can match requests to only one of the Listeners using other
	// Listener fields.
	//
	// For example, the following Listener scenarios are distinct:
	//
	// 1. Multiple Listeners with the same Port that all use the "HTTP"
	//    Protocol that all have unique Hostname values.
	// 2. Multiple Listeners with the same Port that use either the "HTTPS" or
	//    "TLS" Protocol that all have unique Hostname values.
	// 3. A mixture of "TCP" and "UDP" Protocol Listeners, where no Listener
	//    with the same Protocol has the same Port value.
	//
	// Some fields in the Listener struct have possible values that affect
	// whether the Listener is distinct. Hostname is particularly relevant
	// for HTTP or HTTPS protocols.
	//
	// When using the Hostname value to select between same-Port, same-Protocol
	// Listeners, the Hostname value must be different on each Listener for the
	// Listener to be distinct.
	//
	// When the Listeners are distinct based on Hostname, inbound request
	// hostnames MUST match from the most specific to least specific Hostname
	// values to choose the correct Listener and its associated set of Routes.
	//
	// Exact matches must be processed before wildcard matches, and wildcard
	// matches must be processed before fallback (empty Hostname value)
	// matches. For example, `"foo.example.com"` takes precedence over
	// `"*.example.com"`, and `"*.example.com"` takes precedence over `""`.
	//
	// Additionally, if there are multiple wildcard entries, more specific
	// wildcard entries must be processed before less specific wildcard entries.
	// For example, `"*.foo.example.com"` takes precedence over `"*.example.com"`.
	// The precise definition here is that the higher the number of dots in the
	// hostname to the right of the wildcard character, the higher the precedence.
	//
	// The wildcard character will match any number of characters _and dots_ to
	// the left, however, so `"*.example.com"` will match both
	// `"foo.bar.example.com"` _and_ `"bar.example.com"`.
	//
	// If a set of Listeners contains Listeners that are not distinct, then those
	// Listeners are Conflicted, and the implementation MUST set the "Conflicted"
	// condition in the Listener Status to "True".
	//
	// Implementations MAY choose to accept a Gateway with some Conflicted
	// Listeners only if they only accept the partial Listener set that contains
	// no Conflicted Listeners. To put this another way, implementations may
	// accept a partial Listener set only if they throw out *all* the conflicting
	// Listeners. No picking one of the conflicting listeners as the winner.
	// This also means that the Gateway must have at least one non-conflicting
	// Listener in this case, otherwise it violates the requirement that at
	// least one Listener must be present.
	//
	// The implementation MUST set a "ListenersNotValid" condition on the
	// Gateway Status when the Gateway contains Conflicted Listeners whether or
	// not they accept the Gateway. That Condition SHOULD clearly
	// indicate in the Message which Listeners are conflicted, and which are
	// Accepted. Additionally, the Listener status for those listeners SHOULD
	// indicate which Listeners are conflicted and not Accepted.
	//
	// A Gateway's Listeners are considered "compatible" if:
	//
	// 1. They are distinct.
	// 2. The implementation can serve them in compliance with the Addresses
	//    requirement that all Listeners are available on all assigned
	//    addresses.
	//
	// Compatible combinations in Extended support are expected to vary across
	// implementations. A combination that is compatible for one implementation
	// may not be compatible for another.
	//
	// For example, an implementation that cannot serve both TCP and UDP listeners
	// on the same address, or cannot mix HTTPS and generic TLS listens on the same port
	// would not consider those cases compatible, even though they are distinct.
	//
	// Note that requests SHOULD match at most one Listener. For example, if
	// Listeners are defined for "foo.example.com" and "*.example.com", a
	// request to "foo.example.com" SHOULD only be routed using routes attached
	// to the "foo.example.com" Listener (and not the "*.example.com" Listener).
	// This concept is known as "Listener Isolation". Implementations that do
	// not support Listener Isolation MUST clearly document this.
	//
	// Implementations MAY merge separate Gateways onto a single set of
	// Addresses if all Listeners across all Gateways are compatible.
	//
	// Support: Core
	Listeners GatewaySpecListenersArrayInput `pulumi:"listeners"`
}

func (GatewaySpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpec)(nil)).Elem()
}

func (i GatewaySpecArgs) ToGatewaySpecOutput() GatewaySpecOutput {
	return i.ToGatewaySpecOutputWithContext(context.Background())
}

func (i GatewaySpecArgs) ToGatewaySpecOutputWithContext(ctx context.Context) GatewaySpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecOutput)
}

func (i GatewaySpecArgs) ToGatewaySpecPtrOutput() GatewaySpecPtrOutput {
	return i.ToGatewaySpecPtrOutputWithContext(context.Background())
}

func (i GatewaySpecArgs) ToGatewaySpecPtrOutputWithContext(ctx context.Context) GatewaySpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecOutput).ToGatewaySpecPtrOutputWithContext(ctx)
}

// GatewaySpecPtrInput is an input type that accepts GatewaySpecArgs, GatewaySpecPtr and GatewaySpecPtrOutput values.
// You can construct a concrete instance of `GatewaySpecPtrInput` via:
//
//	        GatewaySpecArgs{...}
//
//	or:
//
//	        nil
type GatewaySpecPtrInput interface {
	pulumi.Input

	ToGatewaySpecPtrOutput() GatewaySpecPtrOutput
	ToGatewaySpecPtrOutputWithContext(context.Context) GatewaySpecPtrOutput
}

type gatewaySpecPtrType GatewaySpecArgs

func GatewaySpecPtr(v *GatewaySpecArgs) GatewaySpecPtrInput {
	return (*gatewaySpecPtrType)(v)
}

func (*gatewaySpecPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewaySpec)(nil)).Elem()
}

func (i *gatewaySpecPtrType) ToGatewaySpecPtrOutput() GatewaySpecPtrOutput {
	return i.ToGatewaySpecPtrOutputWithContext(context.Background())
}

func (i *gatewaySpecPtrType) ToGatewaySpecPtrOutputWithContext(ctx context.Context) GatewaySpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecPtrOutput)
}

// Spec defines the desired state of Gateway.
type GatewaySpecOutput struct{ *pulumi.OutputState }

func (GatewaySpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpec)(nil)).Elem()
}

func (o GatewaySpecOutput) ToGatewaySpecOutput() GatewaySpecOutput {
	return o
}

func (o GatewaySpecOutput) ToGatewaySpecOutputWithContext(ctx context.Context) GatewaySpecOutput {
	return o
}

func (o GatewaySpecOutput) ToGatewaySpecPtrOutput() GatewaySpecPtrOutput {
	return o.ToGatewaySpecPtrOutputWithContext(context.Background())
}

func (o GatewaySpecOutput) ToGatewaySpecPtrOutputWithContext(ctx context.Context) GatewaySpecPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GatewaySpec) *GatewaySpec {
		return &v
	}).(GatewaySpecPtrOutput)
}

// Addresses requested for this Gateway. This is optional and behavior can
// depend on the implementation. If a value is set in the spec and the
// requested address is invalid or unavailable, the implementation MUST
// indicate this in the associated entry in GatewayStatus.Addresses.
//
// The Addresses field represents a request for the address(es) on the
// "outside of the Gateway", that traffic bound for this Gateway will use.
// This could be the IP address or hostname of an external load balancer or
// other networking infrastructure, or some other address that traffic will
// be sent to.
//
// If no Addresses are specified, the implementation MAY schedule the
// Gateway in an implementation-specific manner, assigning an appropriate
// set of Addresses.
//
// The implementation MUST bind all Listeners to every GatewayAddress that
// it assigns to the Gateway and add a corresponding entry in
// GatewayStatus.Addresses.
//
// Support: Extended
func (o GatewaySpecOutput) Addresses() GatewaySpecAddressesArrayOutput {
	return o.ApplyT(func(v GatewaySpec) []GatewaySpecAddresses { return v.Addresses }).(GatewaySpecAddressesArrayOutput)
}

// GatewayClassName used for this Gateway. This is the name of a
// GatewayClass resource.
func (o GatewaySpecOutput) GatewayClassName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewaySpec) *string { return v.GatewayClassName }).(pulumi.StringPtrOutput)
}

// Listeners associated with this Gateway. Listeners define
// logical endpoints that are bound on this Gateway's addresses.
// At least one Listener MUST be specified.
//
// Each Listener in a set of Listeners (for example, in a single Gateway)
// MUST be _distinct_, in that a traffic flow MUST be able to be assigned to
// exactly one listener. (This section uses "set of Listeners" rather than
// "Listeners in a single Gateway" because implementations MAY merge configuration
// from multiple Gateways onto a single data plane, and these rules _also_
// apply in that case).
//
// Practically, this means that each listener in a set MUST have a unique
// combination of Port, Protocol, and, if supported by the protocol, Hostname.
//
// Some combinations of port, protocol, and TLS settings are considered
// Core support and MUST be supported by implementations based on their
// targeted conformance profile:
//
// # HTTP Profile
//
// 1. HTTPRoute, Port: 80, Protocol: HTTP
// 2. HTTPRoute, Port: 443, Protocol: HTTPS, TLS Mode: Terminate, TLS keypair provided
//
// # TLS Profile
//
// 1. TLSRoute, Port: 443, Protocol: TLS, TLS Mode: Passthrough
//
// "Distinct" Listeners have the following property:
//
// The implementation can match inbound requests to a single distinct
// Listener. When multiple Listeners share values for fields (for
// example, two Listeners with the same Port value), the implementation
// can match requests to only one of the Listeners using other
// Listener fields.
//
// For example, the following Listener scenarios are distinct:
//
//  1. Multiple Listeners with the same Port that all use the "HTTP"
//     Protocol that all have unique Hostname values.
//  2. Multiple Listeners with the same Port that use either the "HTTPS" or
//     "TLS" Protocol that all have unique Hostname values.
//  3. A mixture of "TCP" and "UDP" Protocol Listeners, where no Listener
//     with the same Protocol has the same Port value.
//
// Some fields in the Listener struct have possible values that affect
// whether the Listener is distinct. Hostname is particularly relevant
// for HTTP or HTTPS protocols.
//
// When using the Hostname value to select between same-Port, same-Protocol
// Listeners, the Hostname value must be different on each Listener for the
// Listener to be distinct.
//
// When the Listeners are distinct based on Hostname, inbound request
// hostnames MUST match from the most specific to least specific Hostname
// values to choose the correct Listener and its associated set of Routes.
//
// Exact matches must be processed before wildcard matches, and wildcard
// matches must be processed before fallback (empty Hostname value)
// matches. For example, `"foo.example.com"` takes precedence over
// `"*.example.com"`, and `"*.example.com"` takes precedence over `""`.
//
// Additionally, if there are multiple wildcard entries, more specific
// wildcard entries must be processed before less specific wildcard entries.
// For example, `"*.foo.example.com"` takes precedence over `"*.example.com"`.
// The precise definition here is that the higher the number of dots in the
// hostname to the right of the wildcard character, the higher the precedence.
//
// The wildcard character will match any number of characters _and dots_ to
// the left, however, so `"*.example.com"` will match both
// `"foo.bar.example.com"` _and_ `"bar.example.com"`.
//
// If a set of Listeners contains Listeners that are not distinct, then those
// Listeners are Conflicted, and the implementation MUST set the "Conflicted"
// condition in the Listener Status to "True".
//
// Implementations MAY choose to accept a Gateway with some Conflicted
// Listeners only if they only accept the partial Listener set that contains
// no Conflicted Listeners. To put this another way, implementations may
// accept a partial Listener set only if they throw out *all* the conflicting
// Listeners. No picking one of the conflicting listeners as the winner.
// This also means that the Gateway must have at least one non-conflicting
// Listener in this case, otherwise it violates the requirement that at
// least one Listener must be present.
//
// The implementation MUST set a "ListenersNotValid" condition on the
// Gateway Status when the Gateway contains Conflicted Listeners whether or
// not they accept the Gateway. That Condition SHOULD clearly
// indicate in the Message which Listeners are conflicted, and which are
// Accepted. Additionally, the Listener status for those listeners SHOULD
// indicate which Listeners are conflicted and not Accepted.
//
// A Gateway's Listeners are considered "compatible" if:
//
//  1. They are distinct.
//  2. The implementation can serve them in compliance with the Addresses
//     requirement that all Listeners are available on all assigned
//     addresses.
//
// Compatible combinations in Extended support are expected to vary across
// implementations. A combination that is compatible for one implementation
// may not be compatible for another.
//
// For example, an implementation that cannot serve both TCP and UDP listeners
// on the same address, or cannot mix HTTPS and generic TLS listens on the same port
// would not consider those cases compatible, even though they are distinct.
//
// Note that requests SHOULD match at most one Listener. For example, if
// Listeners are defined for "foo.example.com" and "*.example.com", a
// request to "foo.example.com" SHOULD only be routed using routes attached
// to the "foo.example.com" Listener (and not the "*.example.com" Listener).
// This concept is known as "Listener Isolation". Implementations that do
// not support Listener Isolation MUST clearly document this.
//
// Implementations MAY merge separate Gateways onto a single set of
// Addresses if all Listeners across all Gateways are compatible.
//
// Support: Core
func (o GatewaySpecOutput) Listeners() GatewaySpecListenersArrayOutput {
	return o.ApplyT(func(v GatewaySpec) []GatewaySpecListeners { return v.Listeners }).(GatewaySpecListenersArrayOutput)
}

type GatewaySpecPtrOutput struct{ *pulumi.OutputState }

func (GatewaySpecPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewaySpec)(nil)).Elem()
}

func (o GatewaySpecPtrOutput) ToGatewaySpecPtrOutput() GatewaySpecPtrOutput {
	return o
}

func (o GatewaySpecPtrOutput) ToGatewaySpecPtrOutputWithContext(ctx context.Context) GatewaySpecPtrOutput {
	return o
}

func (o GatewaySpecPtrOutput) Elem() GatewaySpecOutput {
	return o.ApplyT(func(v *GatewaySpec) GatewaySpec {
		if v != nil {
			return *v
		}
		var ret GatewaySpec
		return ret
	}).(GatewaySpecOutput)
}

// Addresses requested for this Gateway. This is optional and behavior can
// depend on the implementation. If a value is set in the spec and the
// requested address is invalid or unavailable, the implementation MUST
// indicate this in the associated entry in GatewayStatus.Addresses.
//
// The Addresses field represents a request for the address(es) on the
// "outside of the Gateway", that traffic bound for this Gateway will use.
// This could be the IP address or hostname of an external load balancer or
// other networking infrastructure, or some other address that traffic will
// be sent to.
//
// If no Addresses are specified, the implementation MAY schedule the
// Gateway in an implementation-specific manner, assigning an appropriate
// set of Addresses.
//
// The implementation MUST bind all Listeners to every GatewayAddress that
// it assigns to the Gateway and add a corresponding entry in
// GatewayStatus.Addresses.
//
// Support: Extended
func (o GatewaySpecPtrOutput) Addresses() GatewaySpecAddressesArrayOutput {
	return o.ApplyT(func(v *GatewaySpec) []GatewaySpecAddresses {
		if v == nil {
			return nil
		}
		return v.Addresses
	}).(GatewaySpecAddressesArrayOutput)
}

// GatewayClassName used for this Gateway. This is the name of a
// GatewayClass resource.
func (o GatewaySpecPtrOutput) GatewayClassName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GatewaySpec) *string {
		if v == nil {
			return nil
		}
		return v.GatewayClassName
	}).(pulumi.StringPtrOutput)
}

// Listeners associated with this Gateway. Listeners define
// logical endpoints that are bound on this Gateway's addresses.
// At least one Listener MUST be specified.
//
// Each Listener in a set of Listeners (for example, in a single Gateway)
// MUST be _distinct_, in that a traffic flow MUST be able to be assigned to
// exactly one listener. (This section uses "set of Listeners" rather than
// "Listeners in a single Gateway" because implementations MAY merge configuration
// from multiple Gateways onto a single data plane, and these rules _also_
// apply in that case).
//
// Practically, this means that each listener in a set MUST have a unique
// combination of Port, Protocol, and, if supported by the protocol, Hostname.
//
// Some combinations of port, protocol, and TLS settings are considered
// Core support and MUST be supported by implementations based on their
// targeted conformance profile:
//
// # HTTP Profile
//
// 1. HTTPRoute, Port: 80, Protocol: HTTP
// 2. HTTPRoute, Port: 443, Protocol: HTTPS, TLS Mode: Terminate, TLS keypair provided
//
// # TLS Profile
//
// 1. TLSRoute, Port: 443, Protocol: TLS, TLS Mode: Passthrough
//
// "Distinct" Listeners have the following property:
//
// The implementation can match inbound requests to a single distinct
// Listener. When multiple Listeners share values for fields (for
// example, two Listeners with the same Port value), the implementation
// can match requests to only one of the Listeners using other
// Listener fields.
//
// For example, the following Listener scenarios are distinct:
//
//  1. Multiple Listeners with the same Port that all use the "HTTP"
//     Protocol that all have unique Hostname values.
//  2. Multiple Listeners with the same Port that use either the "HTTPS" or
//     "TLS" Protocol that all have unique Hostname values.
//  3. A mixture of "TCP" and "UDP" Protocol Listeners, where no Listener
//     with the same Protocol has the same Port value.
//
// Some fields in the Listener struct have possible values that affect
// whether the Listener is distinct. Hostname is particularly relevant
// for HTTP or HTTPS protocols.
//
// When using the Hostname value to select between same-Port, same-Protocol
// Listeners, the Hostname value must be different on each Listener for the
// Listener to be distinct.
//
// When the Listeners are distinct based on Hostname, inbound request
// hostnames MUST match from the most specific to least specific Hostname
// values to choose the correct Listener and its associated set of Routes.
//
// Exact matches must be processed before wildcard matches, and wildcard
// matches must be processed before fallback (empty Hostname value)
// matches. For example, `"foo.example.com"` takes precedence over
// `"*.example.com"`, and `"*.example.com"` takes precedence over `""`.
//
// Additionally, if there are multiple wildcard entries, more specific
// wildcard entries must be processed before less specific wildcard entries.
// For example, `"*.foo.example.com"` takes precedence over `"*.example.com"`.
// The precise definition here is that the higher the number of dots in the
// hostname to the right of the wildcard character, the higher the precedence.
//
// The wildcard character will match any number of characters _and dots_ to
// the left, however, so `"*.example.com"` will match both
// `"foo.bar.example.com"` _and_ `"bar.example.com"`.
//
// If a set of Listeners contains Listeners that are not distinct, then those
// Listeners are Conflicted, and the implementation MUST set the "Conflicted"
// condition in the Listener Status to "True".
//
// Implementations MAY choose to accept a Gateway with some Conflicted
// Listeners only if they only accept the partial Listener set that contains
// no Conflicted Listeners. To put this another way, implementations may
// accept a partial Listener set only if they throw out *all* the conflicting
// Listeners. No picking one of the conflicting listeners as the winner.
// This also means that the Gateway must have at least one non-conflicting
// Listener in this case, otherwise it violates the requirement that at
// least one Listener must be present.
//
// The implementation MUST set a "ListenersNotValid" condition on the
// Gateway Status when the Gateway contains Conflicted Listeners whether or
// not they accept the Gateway. That Condition SHOULD clearly
// indicate in the Message which Listeners are conflicted, and which are
// Accepted. Additionally, the Listener status for those listeners SHOULD
// indicate which Listeners are conflicted and not Accepted.
//
// A Gateway's Listeners are considered "compatible" if:
//
//  1. They are distinct.
//  2. The implementation can serve them in compliance with the Addresses
//     requirement that all Listeners are available on all assigned
//     addresses.
//
// Compatible combinations in Extended support are expected to vary across
// implementations. A combination that is compatible for one implementation
// may not be compatible for another.
//
// For example, an implementation that cannot serve both TCP and UDP listeners
// on the same address, or cannot mix HTTPS and generic TLS listens on the same port
// would not consider those cases compatible, even though they are distinct.
//
// Note that requests SHOULD match at most one Listener. For example, if
// Listeners are defined for "foo.example.com" and "*.example.com", a
// request to "foo.example.com" SHOULD only be routed using routes attached
// to the "foo.example.com" Listener (and not the "*.example.com" Listener).
// This concept is known as "Listener Isolation". Implementations that do
// not support Listener Isolation MUST clearly document this.
//
// Implementations MAY merge separate Gateways onto a single set of
// Addresses if all Listeners across all Gateways are compatible.
//
// Support: Core
func (o GatewaySpecPtrOutput) Listeners() GatewaySpecListenersArrayOutput {
	return o.ApplyT(func(v *GatewaySpec) []GatewaySpecListeners {
		if v == nil {
			return nil
		}
		return v.Listeners
	}).(GatewaySpecListenersArrayOutput)
}

// GatewayAddress describes an address that can be bound to a Gateway.
type GatewaySpecAddresses struct {
	// Type of the address.
	Type *string `pulumi:"type"`
	// Value of the address. The validity of the values will depend
	// on the type and support by the controller.
	//
	// Examples: `1.2.3.4`, `128::1`, `my-ip-address`.
	Value *string `pulumi:"value"`
}

// GatewaySpecAddressesInput is an input type that accepts GatewaySpecAddressesArgs and GatewaySpecAddressesOutput values.
// You can construct a concrete instance of `GatewaySpecAddressesInput` via:
//
//	GatewaySpecAddressesArgs{...}
type GatewaySpecAddressesInput interface {
	pulumi.Input

	ToGatewaySpecAddressesOutput() GatewaySpecAddressesOutput
	ToGatewaySpecAddressesOutputWithContext(context.Context) GatewaySpecAddressesOutput
}

// GatewayAddress describes an address that can be bound to a Gateway.
type GatewaySpecAddressesArgs struct {
	// Type of the address.
	Type pulumi.StringPtrInput `pulumi:"type"`
	// Value of the address. The validity of the values will depend
	// on the type and support by the controller.
	//
	// Examples: `1.2.3.4`, `128::1`, `my-ip-address`.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (GatewaySpecAddressesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecAddresses)(nil)).Elem()
}

func (i GatewaySpecAddressesArgs) ToGatewaySpecAddressesOutput() GatewaySpecAddressesOutput {
	return i.ToGatewaySpecAddressesOutputWithContext(context.Background())
}

func (i GatewaySpecAddressesArgs) ToGatewaySpecAddressesOutputWithContext(ctx context.Context) GatewaySpecAddressesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecAddressesOutput)
}

// GatewaySpecAddressesArrayInput is an input type that accepts GatewaySpecAddressesArray and GatewaySpecAddressesArrayOutput values.
// You can construct a concrete instance of `GatewaySpecAddressesArrayInput` via:
//
//	GatewaySpecAddressesArray{ GatewaySpecAddressesArgs{...} }
type GatewaySpecAddressesArrayInput interface {
	pulumi.Input

	ToGatewaySpecAddressesArrayOutput() GatewaySpecAddressesArrayOutput
	ToGatewaySpecAddressesArrayOutputWithContext(context.Context) GatewaySpecAddressesArrayOutput
}

type GatewaySpecAddressesArray []GatewaySpecAddressesInput

func (GatewaySpecAddressesArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewaySpecAddresses)(nil)).Elem()
}

func (i GatewaySpecAddressesArray) ToGatewaySpecAddressesArrayOutput() GatewaySpecAddressesArrayOutput {
	return i.ToGatewaySpecAddressesArrayOutputWithContext(context.Background())
}

func (i GatewaySpecAddressesArray) ToGatewaySpecAddressesArrayOutputWithContext(ctx context.Context) GatewaySpecAddressesArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecAddressesArrayOutput)
}

// GatewayAddress describes an address that can be bound to a Gateway.
type GatewaySpecAddressesOutput struct{ *pulumi.OutputState }

func (GatewaySpecAddressesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecAddresses)(nil)).Elem()
}

func (o GatewaySpecAddressesOutput) ToGatewaySpecAddressesOutput() GatewaySpecAddressesOutput {
	return o
}

func (o GatewaySpecAddressesOutput) ToGatewaySpecAddressesOutputWithContext(ctx context.Context) GatewaySpecAddressesOutput {
	return o
}

// Type of the address.
func (o GatewaySpecAddressesOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewaySpecAddresses) *string { return v.Type }).(pulumi.StringPtrOutput)
}

// Value of the address. The validity of the values will depend
// on the type and support by the controller.
//
// Examples: `1.2.3.4`, `128::1`, `my-ip-address`.
func (o GatewaySpecAddressesOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewaySpecAddresses) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type GatewaySpecAddressesArrayOutput struct{ *pulumi.OutputState }

func (GatewaySpecAddressesArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewaySpecAddresses)(nil)).Elem()
}

func (o GatewaySpecAddressesArrayOutput) ToGatewaySpecAddressesArrayOutput() GatewaySpecAddressesArrayOutput {
	return o
}

func (o GatewaySpecAddressesArrayOutput) ToGatewaySpecAddressesArrayOutputWithContext(ctx context.Context) GatewaySpecAddressesArrayOutput {
	return o
}

func (o GatewaySpecAddressesArrayOutput) Index(i pulumi.IntInput) GatewaySpecAddressesOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GatewaySpecAddresses {
		return vs[0].([]GatewaySpecAddresses)[vs[1].(int)]
	}).(GatewaySpecAddressesOutput)
}

// GatewayAddress describes an address that can be bound to a Gateway.
type GatewaySpecAddressesPatch struct {
	// Type of the address.
	Type *string `pulumi:"type"`
	// Value of the address. The validity of the values will depend
	// on the type and support by the controller.
	//
	// Examples: `1.2.3.4`, `128::1`, `my-ip-address`.
	Value *string `pulumi:"value"`
}

// GatewaySpecAddressesPatchInput is an input type that accepts GatewaySpecAddressesPatchArgs and GatewaySpecAddressesPatchOutput values.
// You can construct a concrete instance of `GatewaySpecAddressesPatchInput` via:
//
//	GatewaySpecAddressesPatchArgs{...}
type GatewaySpecAddressesPatchInput interface {
	pulumi.Input

	ToGatewaySpecAddressesPatchOutput() GatewaySpecAddressesPatchOutput
	ToGatewaySpecAddressesPatchOutputWithContext(context.Context) GatewaySpecAddressesPatchOutput
}

// GatewayAddress describes an address that can be bound to a Gateway.
type GatewaySpecAddressesPatchArgs struct {
	// Type of the address.
	Type pulumi.StringPtrInput `pulumi:"type"`
	// Value of the address. The validity of the values will depend
	// on the type and support by the controller.
	//
	// Examples: `1.2.3.4`, `128::1`, `my-ip-address`.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (GatewaySpecAddressesPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecAddressesPatch)(nil)).Elem()
}

func (i GatewaySpecAddressesPatchArgs) ToGatewaySpecAddressesPatchOutput() GatewaySpecAddressesPatchOutput {
	return i.ToGatewaySpecAddressesPatchOutputWithContext(context.Background())
}

func (i GatewaySpecAddressesPatchArgs) ToGatewaySpecAddressesPatchOutputWithContext(ctx context.Context) GatewaySpecAddressesPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecAddressesPatchOutput)
}

// GatewaySpecAddressesPatchArrayInput is an input type that accepts GatewaySpecAddressesPatchArray and GatewaySpecAddressesPatchArrayOutput values.
// You can construct a concrete instance of `GatewaySpecAddressesPatchArrayInput` via:
//
//	GatewaySpecAddressesPatchArray{ GatewaySpecAddressesPatchArgs{...} }
type GatewaySpecAddressesPatchArrayInput interface {
	pulumi.Input

	ToGatewaySpecAddressesPatchArrayOutput() GatewaySpecAddressesPatchArrayOutput
	ToGatewaySpecAddressesPatchArrayOutputWithContext(context.Context) GatewaySpecAddressesPatchArrayOutput
}

type GatewaySpecAddressesPatchArray []GatewaySpecAddressesPatchInput

func (GatewaySpecAddressesPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewaySpecAddressesPatch)(nil)).Elem()
}

func (i GatewaySpecAddressesPatchArray) ToGatewaySpecAddressesPatchArrayOutput() GatewaySpecAddressesPatchArrayOutput {
	return i.ToGatewaySpecAddressesPatchArrayOutputWithContext(context.Background())
}

func (i GatewaySpecAddressesPatchArray) ToGatewaySpecAddressesPatchArrayOutputWithContext(ctx context.Context) GatewaySpecAddressesPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecAddressesPatchArrayOutput)
}

// GatewayAddress describes an address that can be bound to a Gateway.
type GatewaySpecAddressesPatchOutput struct{ *pulumi.OutputState }

func (GatewaySpecAddressesPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecAddressesPatch)(nil)).Elem()
}

func (o GatewaySpecAddressesPatchOutput) ToGatewaySpecAddressesPatchOutput() GatewaySpecAddressesPatchOutput {
	return o
}

func (o GatewaySpecAddressesPatchOutput) ToGatewaySpecAddressesPatchOutputWithContext(ctx context.Context) GatewaySpecAddressesPatchOutput {
	return o
}

// Type of the address.
func (o GatewaySpecAddressesPatchOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewaySpecAddressesPatch) *string { return v.Type }).(pulumi.StringPtrOutput)
}

// Value of the address. The validity of the values will depend
// on the type and support by the controller.
//
// Examples: `1.2.3.4`, `128::1`, `my-ip-address`.
func (o GatewaySpecAddressesPatchOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewaySpecAddressesPatch) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type GatewaySpecAddressesPatchArrayOutput struct{ *pulumi.OutputState }

func (GatewaySpecAddressesPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewaySpecAddressesPatch)(nil)).Elem()
}

func (o GatewaySpecAddressesPatchArrayOutput) ToGatewaySpecAddressesPatchArrayOutput() GatewaySpecAddressesPatchArrayOutput {
	return o
}

func (o GatewaySpecAddressesPatchArrayOutput) ToGatewaySpecAddressesPatchArrayOutputWithContext(ctx context.Context) GatewaySpecAddressesPatchArrayOutput {
	return o
}

func (o GatewaySpecAddressesPatchArrayOutput) Index(i pulumi.IntInput) GatewaySpecAddressesPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GatewaySpecAddressesPatch {
		return vs[0].([]GatewaySpecAddressesPatch)[vs[1].(int)]
	}).(GatewaySpecAddressesPatchOutput)
}

// Listener embodies the concept of a logical endpoint where a Gateway accepts
// network connections.
type GatewaySpecListeners struct {
	AllowedRoutes *GatewaySpecListenersAllowedRoutes `pulumi:"allowedRoutes"`
	// Hostname specifies the virtual hostname to match for protocol types that
	// define this concept. When unspecified, all hostnames are matched. This
	// field is ignored for protocols that don't require hostname based
	// matching.
	//
	// Implementations MUST apply Hostname matching appropriately for each of
	// the following protocols:
	//
	// * TLS: The Listener Hostname MUST match the SNI.
	// * HTTP: The Listener Hostname MUST match the Host header of the request.
	// * HTTPS: The Listener Hostname SHOULD match at both the TLS and HTTP
	//   protocol layers as described above. If an implementation does not
	//   ensure that both the SNI and Host header match the Listener hostname,
	//   it MUST clearly document that.
	//
	// For HTTPRoute and TLSRoute resources, there is an interaction with the
	// `spec.hostnames` array. When both listener and route specify hostnames,
	// there MUST be an intersection between the values for a Route to be
	// accepted. For more information, refer to the Route specific Hostnames
	// documentation.
	//
	// Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
	// as a suffix match. That means that a match for `*.example.com` would match
	// both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
	//
	// Support: Core
	Hostname *string `pulumi:"hostname"`
	// Name is the name of the Listener. This name MUST be unique within a
	// Gateway.
	//
	// Support: Core
	Name *string `pulumi:"name"`
	// Port is the network port. Multiple listeners may use the
	// same port, subject to the Listener compatibility rules.
	//
	// Support: Core
	Port *int `pulumi:"port"`
	// Protocol specifies the network protocol this listener expects to receive.
	//
	// Support: Core
	Protocol *string                  `pulumi:"protocol"`
	Tls      *GatewaySpecListenersTls `pulumi:"tls"`
}

// GatewaySpecListenersInput is an input type that accepts GatewaySpecListenersArgs and GatewaySpecListenersOutput values.
// You can construct a concrete instance of `GatewaySpecListenersInput` via:
//
//	GatewaySpecListenersArgs{...}
type GatewaySpecListenersInput interface {
	pulumi.Input

	ToGatewaySpecListenersOutput() GatewaySpecListenersOutput
	ToGatewaySpecListenersOutputWithContext(context.Context) GatewaySpecListenersOutput
}

// Listener embodies the concept of a logical endpoint where a Gateway accepts
// network connections.
type GatewaySpecListenersArgs struct {
	AllowedRoutes GatewaySpecListenersAllowedRoutesPtrInput `pulumi:"allowedRoutes"`
	// Hostname specifies the virtual hostname to match for protocol types that
	// define this concept. When unspecified, all hostnames are matched. This
	// field is ignored for protocols that don't require hostname based
	// matching.
	//
	// Implementations MUST apply Hostname matching appropriately for each of
	// the following protocols:
	//
	// * TLS: The Listener Hostname MUST match the SNI.
	// * HTTP: The Listener Hostname MUST match the Host header of the request.
	// * HTTPS: The Listener Hostname SHOULD match at both the TLS and HTTP
	//   protocol layers as described above. If an implementation does not
	//   ensure that both the SNI and Host header match the Listener hostname,
	//   it MUST clearly document that.
	//
	// For HTTPRoute and TLSRoute resources, there is an interaction with the
	// `spec.hostnames` array. When both listener and route specify hostnames,
	// there MUST be an intersection between the values for a Route to be
	// accepted. For more information, refer to the Route specific Hostnames
	// documentation.
	//
	// Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
	// as a suffix match. That means that a match for `*.example.com` would match
	// both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
	//
	// Support: Core
	Hostname pulumi.StringPtrInput `pulumi:"hostname"`
	// Name is the name of the Listener. This name MUST be unique within a
	// Gateway.
	//
	// Support: Core
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Port is the network port. Multiple listeners may use the
	// same port, subject to the Listener compatibility rules.
	//
	// Support: Core
	Port pulumi.IntPtrInput `pulumi:"port"`
	// Protocol specifies the network protocol this listener expects to receive.
	//
	// Support: Core
	Protocol pulumi.StringPtrInput           `pulumi:"protocol"`
	Tls      GatewaySpecListenersTlsPtrInput `pulumi:"tls"`
}

func (GatewaySpecListenersArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecListeners)(nil)).Elem()
}

func (i GatewaySpecListenersArgs) ToGatewaySpecListenersOutput() GatewaySpecListenersOutput {
	return i.ToGatewaySpecListenersOutputWithContext(context.Background())
}

func (i GatewaySpecListenersArgs) ToGatewaySpecListenersOutputWithContext(ctx context.Context) GatewaySpecListenersOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersOutput)
}

// GatewaySpecListenersArrayInput is an input type that accepts GatewaySpecListenersArray and GatewaySpecListenersArrayOutput values.
// You can construct a concrete instance of `GatewaySpecListenersArrayInput` via:
//
//	GatewaySpecListenersArray{ GatewaySpecListenersArgs{...} }
type GatewaySpecListenersArrayInput interface {
	pulumi.Input

	ToGatewaySpecListenersArrayOutput() GatewaySpecListenersArrayOutput
	ToGatewaySpecListenersArrayOutputWithContext(context.Context) GatewaySpecListenersArrayOutput
}

type GatewaySpecListenersArray []GatewaySpecListenersInput

func (GatewaySpecListenersArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewaySpecListeners)(nil)).Elem()
}

func (i GatewaySpecListenersArray) ToGatewaySpecListenersArrayOutput() GatewaySpecListenersArrayOutput {
	return i.ToGatewaySpecListenersArrayOutputWithContext(context.Background())
}

func (i GatewaySpecListenersArray) ToGatewaySpecListenersArrayOutputWithContext(ctx context.Context) GatewaySpecListenersArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersArrayOutput)
}

// Listener embodies the concept of a logical endpoint where a Gateway accepts
// network connections.
type GatewaySpecListenersOutput struct{ *pulumi.OutputState }

func (GatewaySpecListenersOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecListeners)(nil)).Elem()
}

func (o GatewaySpecListenersOutput) ToGatewaySpecListenersOutput() GatewaySpecListenersOutput {
	return o
}

func (o GatewaySpecListenersOutput) ToGatewaySpecListenersOutputWithContext(ctx context.Context) GatewaySpecListenersOutput {
	return o
}

func (o GatewaySpecListenersOutput) AllowedRoutes() GatewaySpecListenersAllowedRoutesPtrOutput {
	return o.ApplyT(func(v GatewaySpecListeners) *GatewaySpecListenersAllowedRoutes { return v.AllowedRoutes }).(GatewaySpecListenersAllowedRoutesPtrOutput)
}

// Hostname specifies the virtual hostname to match for protocol types that
// define this concept. When unspecified, all hostnames are matched. This
// field is ignored for protocols that don't require hostname based
// matching.
//
// Implementations MUST apply Hostname matching appropriately for each of
// the following protocols:
//
//   - TLS: The Listener Hostname MUST match the SNI.
//   - HTTP: The Listener Hostname MUST match the Host header of the request.
//   - HTTPS: The Listener Hostname SHOULD match at both the TLS and HTTP
//     protocol layers as described above. If an implementation does not
//     ensure that both the SNI and Host header match the Listener hostname,
//     it MUST clearly document that.
//
// For HTTPRoute and TLSRoute resources, there is an interaction with the
// `spec.hostnames` array. When both listener and route specify hostnames,
// there MUST be an intersection between the values for a Route to be
// accepted. For more information, refer to the Route specific Hostnames
// documentation.
//
// Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
// as a suffix match. That means that a match for `*.example.com` would match
// both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
//
// Support: Core
func (o GatewaySpecListenersOutput) Hostname() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewaySpecListeners) *string { return v.Hostname }).(pulumi.StringPtrOutput)
}

// Name is the name of the Listener. This name MUST be unique within a
// Gateway.
//
// Support: Core
func (o GatewaySpecListenersOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewaySpecListeners) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Port is the network port. Multiple listeners may use the
// same port, subject to the Listener compatibility rules.
//
// Support: Core
func (o GatewaySpecListenersOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v GatewaySpecListeners) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// Protocol specifies the network protocol this listener expects to receive.
//
// Support: Core
func (o GatewaySpecListenersOutput) Protocol() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewaySpecListeners) *string { return v.Protocol }).(pulumi.StringPtrOutput)
}

func (o GatewaySpecListenersOutput) Tls() GatewaySpecListenersTlsPtrOutput {
	return o.ApplyT(func(v GatewaySpecListeners) *GatewaySpecListenersTls { return v.Tls }).(GatewaySpecListenersTlsPtrOutput)
}

type GatewaySpecListenersArrayOutput struct{ *pulumi.OutputState }

func (GatewaySpecListenersArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewaySpecListeners)(nil)).Elem()
}

func (o GatewaySpecListenersArrayOutput) ToGatewaySpecListenersArrayOutput() GatewaySpecListenersArrayOutput {
	return o
}

func (o GatewaySpecListenersArrayOutput) ToGatewaySpecListenersArrayOutputWithContext(ctx context.Context) GatewaySpecListenersArrayOutput {
	return o
}

func (o GatewaySpecListenersArrayOutput) Index(i pulumi.IntInput) GatewaySpecListenersOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GatewaySpecListeners {
		return vs[0].([]GatewaySpecListeners)[vs[1].(int)]
	}).(GatewaySpecListenersOutput)
}

// AllowedRoutes defines the types of routes that MAY be attached to a
// Listener and the trusted namespaces where those Route resources MAY be
// present.
//
// Although a client request may match multiple route rules, only one rule
// may ultimately receive the request. Matching precedence MUST be
// determined in order of the following criteria:
//
//   - The most specific match as defined by the Route type.
//   - The oldest Route based on creation timestamp. For example, a Route with
//     a creation timestamp of "2020-09-08 01:02:03" is given precedence over
//     a Route with a creation timestamp of "2020-09-08 01:02:04".
//   - If everything else is equivalent, the Route appearing first in
//     alphabetical order (namespace/name) should be given precedence. For
//     example, foo/bar is given precedence over foo/baz.
//
// All valid rules within a Route attached to this Listener should be
// implemented. Invalid Route rules can be ignored (sometimes that will mean
// the full Route). If a Route rule transitions from valid to invalid,
// support for that Route rule should be dropped to ensure consistency. For
// example, even if a filter specified by a Route rule is invalid, the rest
// of the rules within that Route should still be supported.
//
// Support: Core
type GatewaySpecListenersAllowedRoutes struct {
	// Kinds specifies the groups and kinds of Routes that are allowed to bind
	// to this Gateway Listener. When unspecified or empty, the kinds of Routes
	// selected are determined using the Listener protocol.
	//
	// A RouteGroupKind MUST correspond to kinds of Routes that are compatible
	// with the application protocol specified in the Listener's Protocol field.
	// If an implementation does not support or recognize this resource type, it
	// MUST set the "ResolvedRefs" condition to False for this Listener with the
	// "InvalidRouteKinds" reason.
	//
	// Support: Core
	Kinds      []GatewaySpecListenersAllowedRoutesKinds     `pulumi:"kinds"`
	Namespaces *GatewaySpecListenersAllowedRoutesNamespaces `pulumi:"namespaces"`
}

// GatewaySpecListenersAllowedRoutesInput is an input type that accepts GatewaySpecListenersAllowedRoutesArgs and GatewaySpecListenersAllowedRoutesOutput values.
// You can construct a concrete instance of `GatewaySpecListenersAllowedRoutesInput` via:
//
//	GatewaySpecListenersAllowedRoutesArgs{...}
type GatewaySpecListenersAllowedRoutesInput interface {
	pulumi.Input

	ToGatewaySpecListenersAllowedRoutesOutput() GatewaySpecListenersAllowedRoutesOutput
	ToGatewaySpecListenersAllowedRoutesOutputWithContext(context.Context) GatewaySpecListenersAllowedRoutesOutput
}

// AllowedRoutes defines the types of routes that MAY be attached to a
// Listener and the trusted namespaces where those Route resources MAY be
// present.
//
// Although a client request may match multiple route rules, only one rule
// may ultimately receive the request. Matching precedence MUST be
// determined in order of the following criteria:
//
//   - The most specific match as defined by the Route type.
//   - The oldest Route based on creation timestamp. For example, a Route with
//     a creation timestamp of "2020-09-08 01:02:03" is given precedence over
//     a Route with a creation timestamp of "2020-09-08 01:02:04".
//   - If everything else is equivalent, the Route appearing first in
//     alphabetical order (namespace/name) should be given precedence. For
//     example, foo/bar is given precedence over foo/baz.
//
// All valid rules within a Route attached to this Listener should be
// implemented. Invalid Route rules can be ignored (sometimes that will mean
// the full Route). If a Route rule transitions from valid to invalid,
// support for that Route rule should be dropped to ensure consistency. For
// example, even if a filter specified by a Route rule is invalid, the rest
// of the rules within that Route should still be supported.
//
// Support: Core
type GatewaySpecListenersAllowedRoutesArgs struct {
	// Kinds specifies the groups and kinds of Routes that are allowed to bind
	// to this Gateway Listener. When unspecified or empty, the kinds of Routes
	// selected are determined using the Listener protocol.
	//
	// A RouteGroupKind MUST correspond to kinds of Routes that are compatible
	// with the application protocol specified in the Listener's Protocol field.
	// If an implementation does not support or recognize this resource type, it
	// MUST set the "ResolvedRefs" condition to False for this Listener with the
	// "InvalidRouteKinds" reason.
	//
	// Support: Core
	Kinds      GatewaySpecListenersAllowedRoutesKindsArrayInput    `pulumi:"kinds"`
	Namespaces GatewaySpecListenersAllowedRoutesNamespacesPtrInput `pulumi:"namespaces"`
}

func (GatewaySpecListenersAllowedRoutesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecListenersAllowedRoutes)(nil)).Elem()
}

func (i GatewaySpecListenersAllowedRoutesArgs) ToGatewaySpecListenersAllowedRoutesOutput() GatewaySpecListenersAllowedRoutesOutput {
	return i.ToGatewaySpecListenersAllowedRoutesOutputWithContext(context.Background())
}

func (i GatewaySpecListenersAllowedRoutesArgs) ToGatewaySpecListenersAllowedRoutesOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersAllowedRoutesOutput)
}

func (i GatewaySpecListenersAllowedRoutesArgs) ToGatewaySpecListenersAllowedRoutesPtrOutput() GatewaySpecListenersAllowedRoutesPtrOutput {
	return i.ToGatewaySpecListenersAllowedRoutesPtrOutputWithContext(context.Background())
}

func (i GatewaySpecListenersAllowedRoutesArgs) ToGatewaySpecListenersAllowedRoutesPtrOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersAllowedRoutesOutput).ToGatewaySpecListenersAllowedRoutesPtrOutputWithContext(ctx)
}

// GatewaySpecListenersAllowedRoutesPtrInput is an input type that accepts GatewaySpecListenersAllowedRoutesArgs, GatewaySpecListenersAllowedRoutesPtr and GatewaySpecListenersAllowedRoutesPtrOutput values.
// You can construct a concrete instance of `GatewaySpecListenersAllowedRoutesPtrInput` via:
//
//	        GatewaySpecListenersAllowedRoutesArgs{...}
//
//	or:
//
//	        nil
type GatewaySpecListenersAllowedRoutesPtrInput interface {
	pulumi.Input

	ToGatewaySpecListenersAllowedRoutesPtrOutput() GatewaySpecListenersAllowedRoutesPtrOutput
	ToGatewaySpecListenersAllowedRoutesPtrOutputWithContext(context.Context) GatewaySpecListenersAllowedRoutesPtrOutput
}

type gatewaySpecListenersAllowedRoutesPtrType GatewaySpecListenersAllowedRoutesArgs

func GatewaySpecListenersAllowedRoutesPtr(v *GatewaySpecListenersAllowedRoutesArgs) GatewaySpecListenersAllowedRoutesPtrInput {
	return (*gatewaySpecListenersAllowedRoutesPtrType)(v)
}

func (*gatewaySpecListenersAllowedRoutesPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewaySpecListenersAllowedRoutes)(nil)).Elem()
}

func (i *gatewaySpecListenersAllowedRoutesPtrType) ToGatewaySpecListenersAllowedRoutesPtrOutput() GatewaySpecListenersAllowedRoutesPtrOutput {
	return i.ToGatewaySpecListenersAllowedRoutesPtrOutputWithContext(context.Background())
}

func (i *gatewaySpecListenersAllowedRoutesPtrType) ToGatewaySpecListenersAllowedRoutesPtrOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersAllowedRoutesPtrOutput)
}

// AllowedRoutes defines the types of routes that MAY be attached to a
// Listener and the trusted namespaces where those Route resources MAY be
// present.
//
// Although a client request may match multiple route rules, only one rule
// may ultimately receive the request. Matching precedence MUST be
// determined in order of the following criteria:
//
//   - The most specific match as defined by the Route type.
//   - The oldest Route based on creation timestamp. For example, a Route with
//     a creation timestamp of "2020-09-08 01:02:03" is given precedence over
//     a Route with a creation timestamp of "2020-09-08 01:02:04".
//   - If everything else is equivalent, the Route appearing first in
//     alphabetical order (namespace/name) should be given precedence. For
//     example, foo/bar is given precedence over foo/baz.
//
// All valid rules within a Route attached to this Listener should be
// implemented. Invalid Route rules can be ignored (sometimes that will mean
// the full Route). If a Route rule transitions from valid to invalid,
// support for that Route rule should be dropped to ensure consistency. For
// example, even if a filter specified by a Route rule is invalid, the rest
// of the rules within that Route should still be supported.
//
// Support: Core
type GatewaySpecListenersAllowedRoutesOutput struct{ *pulumi.OutputState }

func (GatewaySpecListenersAllowedRoutesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecListenersAllowedRoutes)(nil)).Elem()
}

func (o GatewaySpecListenersAllowedRoutesOutput) ToGatewaySpecListenersAllowedRoutesOutput() GatewaySpecListenersAllowedRoutesOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesOutput) ToGatewaySpecListenersAllowedRoutesOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesOutput) ToGatewaySpecListenersAllowedRoutesPtrOutput() GatewaySpecListenersAllowedRoutesPtrOutput {
	return o.ToGatewaySpecListenersAllowedRoutesPtrOutputWithContext(context.Background())
}

func (o GatewaySpecListenersAllowedRoutesOutput) ToGatewaySpecListenersAllowedRoutesPtrOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GatewaySpecListenersAllowedRoutes) *GatewaySpecListenersAllowedRoutes {
		return &v
	}).(GatewaySpecListenersAllowedRoutesPtrOutput)
}

// Kinds specifies the groups and kinds of Routes that are allowed to bind
// to this Gateway Listener. When unspecified or empty, the kinds of Routes
// selected are determined using the Listener protocol.
//
// A RouteGroupKind MUST correspond to kinds of Routes that are compatible
// with the application protocol specified in the Listener's Protocol field.
// If an implementation does not support or recognize this resource type, it
// MUST set the "ResolvedRefs" condition to False for this Listener with the
// "InvalidRouteKinds" reason.
//
// Support: Core
func (o GatewaySpecListenersAllowedRoutesOutput) Kinds() GatewaySpecListenersAllowedRoutesKindsArrayOutput {
	return o.ApplyT(func(v GatewaySpecListenersAllowedRoutes) []GatewaySpecListenersAllowedRoutesKinds { return v.Kinds }).(GatewaySpecListenersAllowedRoutesKindsArrayOutput)
}

func (o GatewaySpecListenersAllowedRoutesOutput) Namespaces() GatewaySpecListenersAllowedRoutesNamespacesPtrOutput {
	return o.ApplyT(func(v GatewaySpecListenersAllowedRoutes) *GatewaySpecListenersAllowedRoutesNamespaces {
		return v.Namespaces
	}).(GatewaySpecListenersAllowedRoutesNamespacesPtrOutput)
}

type GatewaySpecListenersAllowedRoutesPtrOutput struct{ *pulumi.OutputState }

func (GatewaySpecListenersAllowedRoutesPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewaySpecListenersAllowedRoutes)(nil)).Elem()
}

func (o GatewaySpecListenersAllowedRoutesPtrOutput) ToGatewaySpecListenersAllowedRoutesPtrOutput() GatewaySpecListenersAllowedRoutesPtrOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesPtrOutput) ToGatewaySpecListenersAllowedRoutesPtrOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesPtrOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesPtrOutput) Elem() GatewaySpecListenersAllowedRoutesOutput {
	return o.ApplyT(func(v *GatewaySpecListenersAllowedRoutes) GatewaySpecListenersAllowedRoutes {
		if v != nil {
			return *v
		}
		var ret GatewaySpecListenersAllowedRoutes
		return ret
	}).(GatewaySpecListenersAllowedRoutesOutput)
}

// Kinds specifies the groups and kinds of Routes that are allowed to bind
// to this Gateway Listener. When unspecified or empty, the kinds of Routes
// selected are determined using the Listener protocol.
//
// A RouteGroupKind MUST correspond to kinds of Routes that are compatible
// with the application protocol specified in the Listener's Protocol field.
// If an implementation does not support or recognize this resource type, it
// MUST set the "ResolvedRefs" condition to False for this Listener with the
// "InvalidRouteKinds" reason.
//
// Support: Core
func (o GatewaySpecListenersAllowedRoutesPtrOutput) Kinds() GatewaySpecListenersAllowedRoutesKindsArrayOutput {
	return o.ApplyT(func(v *GatewaySpecListenersAllowedRoutes) []GatewaySpecListenersAllowedRoutesKinds {
		if v == nil {
			return nil
		}
		return v.Kinds
	}).(GatewaySpecListenersAllowedRoutesKindsArrayOutput)
}

func (o GatewaySpecListenersAllowedRoutesPtrOutput) Namespaces() GatewaySpecListenersAllowedRoutesNamespacesPtrOutput {
	return o.ApplyT(func(v *GatewaySpecListenersAllowedRoutes) *GatewaySpecListenersAllowedRoutesNamespaces {
		if v == nil {
			return nil
		}
		return v.Namespaces
	}).(GatewaySpecListenersAllowedRoutesNamespacesPtrOutput)
}

// RouteGroupKind indicates the group and kind of a Route resource.
type GatewaySpecListenersAllowedRoutesKinds struct {
	// Group is the group of the Route.
	Group *string `pulumi:"group"`
	// Kind is the kind of the Route.
	Kind *string `pulumi:"kind"`
}

// GatewaySpecListenersAllowedRoutesKindsInput is an input type that accepts GatewaySpecListenersAllowedRoutesKindsArgs and GatewaySpecListenersAllowedRoutesKindsOutput values.
// You can construct a concrete instance of `GatewaySpecListenersAllowedRoutesKindsInput` via:
//
//	GatewaySpecListenersAllowedRoutesKindsArgs{...}
type GatewaySpecListenersAllowedRoutesKindsInput interface {
	pulumi.Input

	ToGatewaySpecListenersAllowedRoutesKindsOutput() GatewaySpecListenersAllowedRoutesKindsOutput
	ToGatewaySpecListenersAllowedRoutesKindsOutputWithContext(context.Context) GatewaySpecListenersAllowedRoutesKindsOutput
}

// RouteGroupKind indicates the group and kind of a Route resource.
type GatewaySpecListenersAllowedRoutesKindsArgs struct {
	// Group is the group of the Route.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is the kind of the Route.
	Kind pulumi.StringPtrInput `pulumi:"kind"`
}

func (GatewaySpecListenersAllowedRoutesKindsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecListenersAllowedRoutesKinds)(nil)).Elem()
}

func (i GatewaySpecListenersAllowedRoutesKindsArgs) ToGatewaySpecListenersAllowedRoutesKindsOutput() GatewaySpecListenersAllowedRoutesKindsOutput {
	return i.ToGatewaySpecListenersAllowedRoutesKindsOutputWithContext(context.Background())
}

func (i GatewaySpecListenersAllowedRoutesKindsArgs) ToGatewaySpecListenersAllowedRoutesKindsOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesKindsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersAllowedRoutesKindsOutput)
}

// GatewaySpecListenersAllowedRoutesKindsArrayInput is an input type that accepts GatewaySpecListenersAllowedRoutesKindsArray and GatewaySpecListenersAllowedRoutesKindsArrayOutput values.
// You can construct a concrete instance of `GatewaySpecListenersAllowedRoutesKindsArrayInput` via:
//
//	GatewaySpecListenersAllowedRoutesKindsArray{ GatewaySpecListenersAllowedRoutesKindsArgs{...} }
type GatewaySpecListenersAllowedRoutesKindsArrayInput interface {
	pulumi.Input

	ToGatewaySpecListenersAllowedRoutesKindsArrayOutput() GatewaySpecListenersAllowedRoutesKindsArrayOutput
	ToGatewaySpecListenersAllowedRoutesKindsArrayOutputWithContext(context.Context) GatewaySpecListenersAllowedRoutesKindsArrayOutput
}

type GatewaySpecListenersAllowedRoutesKindsArray []GatewaySpecListenersAllowedRoutesKindsInput

func (GatewaySpecListenersAllowedRoutesKindsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewaySpecListenersAllowedRoutesKinds)(nil)).Elem()
}

func (i GatewaySpecListenersAllowedRoutesKindsArray) ToGatewaySpecListenersAllowedRoutesKindsArrayOutput() GatewaySpecListenersAllowedRoutesKindsArrayOutput {
	return i.ToGatewaySpecListenersAllowedRoutesKindsArrayOutputWithContext(context.Background())
}

func (i GatewaySpecListenersAllowedRoutesKindsArray) ToGatewaySpecListenersAllowedRoutesKindsArrayOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesKindsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersAllowedRoutesKindsArrayOutput)
}

// RouteGroupKind indicates the group and kind of a Route resource.
type GatewaySpecListenersAllowedRoutesKindsOutput struct{ *pulumi.OutputState }

func (GatewaySpecListenersAllowedRoutesKindsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecListenersAllowedRoutesKinds)(nil)).Elem()
}

func (o GatewaySpecListenersAllowedRoutesKindsOutput) ToGatewaySpecListenersAllowedRoutesKindsOutput() GatewaySpecListenersAllowedRoutesKindsOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesKindsOutput) ToGatewaySpecListenersAllowedRoutesKindsOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesKindsOutput {
	return o
}

// Group is the group of the Route.
func (o GatewaySpecListenersAllowedRoutesKindsOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewaySpecListenersAllowedRoutesKinds) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is the kind of the Route.
func (o GatewaySpecListenersAllowedRoutesKindsOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewaySpecListenersAllowedRoutesKinds) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

type GatewaySpecListenersAllowedRoutesKindsArrayOutput struct{ *pulumi.OutputState }

func (GatewaySpecListenersAllowedRoutesKindsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewaySpecListenersAllowedRoutesKinds)(nil)).Elem()
}

func (o GatewaySpecListenersAllowedRoutesKindsArrayOutput) ToGatewaySpecListenersAllowedRoutesKindsArrayOutput() GatewaySpecListenersAllowedRoutesKindsArrayOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesKindsArrayOutput) ToGatewaySpecListenersAllowedRoutesKindsArrayOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesKindsArrayOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesKindsArrayOutput) Index(i pulumi.IntInput) GatewaySpecListenersAllowedRoutesKindsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GatewaySpecListenersAllowedRoutesKinds {
		return vs[0].([]GatewaySpecListenersAllowedRoutesKinds)[vs[1].(int)]
	}).(GatewaySpecListenersAllowedRoutesKindsOutput)
}

// RouteGroupKind indicates the group and kind of a Route resource.
type GatewaySpecListenersAllowedRoutesKindsPatch struct {
	// Group is the group of the Route.
	Group *string `pulumi:"group"`
	// Kind is the kind of the Route.
	Kind *string `pulumi:"kind"`
}

// GatewaySpecListenersAllowedRoutesKindsPatchInput is an input type that accepts GatewaySpecListenersAllowedRoutesKindsPatchArgs and GatewaySpecListenersAllowedRoutesKindsPatchOutput values.
// You can construct a concrete instance of `GatewaySpecListenersAllowedRoutesKindsPatchInput` via:
//
//	GatewaySpecListenersAllowedRoutesKindsPatchArgs{...}
type GatewaySpecListenersAllowedRoutesKindsPatchInput interface {
	pulumi.Input

	ToGatewaySpecListenersAllowedRoutesKindsPatchOutput() GatewaySpecListenersAllowedRoutesKindsPatchOutput
	ToGatewaySpecListenersAllowedRoutesKindsPatchOutputWithContext(context.Context) GatewaySpecListenersAllowedRoutesKindsPatchOutput
}

// RouteGroupKind indicates the group and kind of a Route resource.
type GatewaySpecListenersAllowedRoutesKindsPatchArgs struct {
	// Group is the group of the Route.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is the kind of the Route.
	Kind pulumi.StringPtrInput `pulumi:"kind"`
}

func (GatewaySpecListenersAllowedRoutesKindsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecListenersAllowedRoutesKindsPatch)(nil)).Elem()
}

func (i GatewaySpecListenersAllowedRoutesKindsPatchArgs) ToGatewaySpecListenersAllowedRoutesKindsPatchOutput() GatewaySpecListenersAllowedRoutesKindsPatchOutput {
	return i.ToGatewaySpecListenersAllowedRoutesKindsPatchOutputWithContext(context.Background())
}

func (i GatewaySpecListenersAllowedRoutesKindsPatchArgs) ToGatewaySpecListenersAllowedRoutesKindsPatchOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesKindsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersAllowedRoutesKindsPatchOutput)
}

// GatewaySpecListenersAllowedRoutesKindsPatchArrayInput is an input type that accepts GatewaySpecListenersAllowedRoutesKindsPatchArray and GatewaySpecListenersAllowedRoutesKindsPatchArrayOutput values.
// You can construct a concrete instance of `GatewaySpecListenersAllowedRoutesKindsPatchArrayInput` via:
//
//	GatewaySpecListenersAllowedRoutesKindsPatchArray{ GatewaySpecListenersAllowedRoutesKindsPatchArgs{...} }
type GatewaySpecListenersAllowedRoutesKindsPatchArrayInput interface {
	pulumi.Input

	ToGatewaySpecListenersAllowedRoutesKindsPatchArrayOutput() GatewaySpecListenersAllowedRoutesKindsPatchArrayOutput
	ToGatewaySpecListenersAllowedRoutesKindsPatchArrayOutputWithContext(context.Context) GatewaySpecListenersAllowedRoutesKindsPatchArrayOutput
}

type GatewaySpecListenersAllowedRoutesKindsPatchArray []GatewaySpecListenersAllowedRoutesKindsPatchInput

func (GatewaySpecListenersAllowedRoutesKindsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewaySpecListenersAllowedRoutesKindsPatch)(nil)).Elem()
}

func (i GatewaySpecListenersAllowedRoutesKindsPatchArray) ToGatewaySpecListenersAllowedRoutesKindsPatchArrayOutput() GatewaySpecListenersAllowedRoutesKindsPatchArrayOutput {
	return i.ToGatewaySpecListenersAllowedRoutesKindsPatchArrayOutputWithContext(context.Background())
}

func (i GatewaySpecListenersAllowedRoutesKindsPatchArray) ToGatewaySpecListenersAllowedRoutesKindsPatchArrayOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesKindsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersAllowedRoutesKindsPatchArrayOutput)
}

// RouteGroupKind indicates the group and kind of a Route resource.
type GatewaySpecListenersAllowedRoutesKindsPatchOutput struct{ *pulumi.OutputState }

func (GatewaySpecListenersAllowedRoutesKindsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecListenersAllowedRoutesKindsPatch)(nil)).Elem()
}

func (o GatewaySpecListenersAllowedRoutesKindsPatchOutput) ToGatewaySpecListenersAllowedRoutesKindsPatchOutput() GatewaySpecListenersAllowedRoutesKindsPatchOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesKindsPatchOutput) ToGatewaySpecListenersAllowedRoutesKindsPatchOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesKindsPatchOutput {
	return o
}

// Group is the group of the Route.
func (o GatewaySpecListenersAllowedRoutesKindsPatchOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewaySpecListenersAllowedRoutesKindsPatch) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is the kind of the Route.
func (o GatewaySpecListenersAllowedRoutesKindsPatchOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewaySpecListenersAllowedRoutesKindsPatch) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

type GatewaySpecListenersAllowedRoutesKindsPatchArrayOutput struct{ *pulumi.OutputState }

func (GatewaySpecListenersAllowedRoutesKindsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewaySpecListenersAllowedRoutesKindsPatch)(nil)).Elem()
}

func (o GatewaySpecListenersAllowedRoutesKindsPatchArrayOutput) ToGatewaySpecListenersAllowedRoutesKindsPatchArrayOutput() GatewaySpecListenersAllowedRoutesKindsPatchArrayOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesKindsPatchArrayOutput) ToGatewaySpecListenersAllowedRoutesKindsPatchArrayOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesKindsPatchArrayOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesKindsPatchArrayOutput) Index(i pulumi.IntInput) GatewaySpecListenersAllowedRoutesKindsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GatewaySpecListenersAllowedRoutesKindsPatch {
		return vs[0].([]GatewaySpecListenersAllowedRoutesKindsPatch)[vs[1].(int)]
	}).(GatewaySpecListenersAllowedRoutesKindsPatchOutput)
}

// Namespaces indicates namespaces from which Routes may be attached to this
// Listener. This is restricted to the namespace of this Gateway by default.
//
// Support: Core
type GatewaySpecListenersAllowedRoutesNamespaces struct {
	// From indicates where Routes will be selected for this Gateway. Possible
	// values are:
	//
	// * All: Routes in all namespaces may be used by this Gateway.
	// * Selector: Routes in namespaces selected by the selector may be used by
	//   this Gateway.
	// * Same: Only Routes in the same namespace may be used by this Gateway.
	//
	// Support: Core
	From     *string                                              `pulumi:"from"`
	Selector *GatewaySpecListenersAllowedRoutesNamespacesSelector `pulumi:"selector"`
}

// GatewaySpecListenersAllowedRoutesNamespacesInput is an input type that accepts GatewaySpecListenersAllowedRoutesNamespacesArgs and GatewaySpecListenersAllowedRoutesNamespacesOutput values.
// You can construct a concrete instance of `GatewaySpecListenersAllowedRoutesNamespacesInput` via:
//
//	GatewaySpecListenersAllowedRoutesNamespacesArgs{...}
type GatewaySpecListenersAllowedRoutesNamespacesInput interface {
	pulumi.Input

	ToGatewaySpecListenersAllowedRoutesNamespacesOutput() GatewaySpecListenersAllowedRoutesNamespacesOutput
	ToGatewaySpecListenersAllowedRoutesNamespacesOutputWithContext(context.Context) GatewaySpecListenersAllowedRoutesNamespacesOutput
}

// Namespaces indicates namespaces from which Routes may be attached to this
// Listener. This is restricted to the namespace of this Gateway by default.
//
// Support: Core
type GatewaySpecListenersAllowedRoutesNamespacesArgs struct {
	// From indicates where Routes will be selected for this Gateway. Possible
	// values are:
	//
	// * All: Routes in all namespaces may be used by this Gateway.
	// * Selector: Routes in namespaces selected by the selector may be used by
	//   this Gateway.
	// * Same: Only Routes in the same namespace may be used by this Gateway.
	//
	// Support: Core
	From     pulumi.StringPtrInput                                       `pulumi:"from"`
	Selector GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrInput `pulumi:"selector"`
}

func (GatewaySpecListenersAllowedRoutesNamespacesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecListenersAllowedRoutesNamespaces)(nil)).Elem()
}

func (i GatewaySpecListenersAllowedRoutesNamespacesArgs) ToGatewaySpecListenersAllowedRoutesNamespacesOutput() GatewaySpecListenersAllowedRoutesNamespacesOutput {
	return i.ToGatewaySpecListenersAllowedRoutesNamespacesOutputWithContext(context.Background())
}

func (i GatewaySpecListenersAllowedRoutesNamespacesArgs) ToGatewaySpecListenersAllowedRoutesNamespacesOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesNamespacesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersAllowedRoutesNamespacesOutput)
}

func (i GatewaySpecListenersAllowedRoutesNamespacesArgs) ToGatewaySpecListenersAllowedRoutesNamespacesPtrOutput() GatewaySpecListenersAllowedRoutesNamespacesPtrOutput {
	return i.ToGatewaySpecListenersAllowedRoutesNamespacesPtrOutputWithContext(context.Background())
}

func (i GatewaySpecListenersAllowedRoutesNamespacesArgs) ToGatewaySpecListenersAllowedRoutesNamespacesPtrOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesNamespacesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersAllowedRoutesNamespacesOutput).ToGatewaySpecListenersAllowedRoutesNamespacesPtrOutputWithContext(ctx)
}

// GatewaySpecListenersAllowedRoutesNamespacesPtrInput is an input type that accepts GatewaySpecListenersAllowedRoutesNamespacesArgs, GatewaySpecListenersAllowedRoutesNamespacesPtr and GatewaySpecListenersAllowedRoutesNamespacesPtrOutput values.
// You can construct a concrete instance of `GatewaySpecListenersAllowedRoutesNamespacesPtrInput` via:
//
//	        GatewaySpecListenersAllowedRoutesNamespacesArgs{...}
//
//	or:
//
//	        nil
type GatewaySpecListenersAllowedRoutesNamespacesPtrInput interface {
	pulumi.Input

	ToGatewaySpecListenersAllowedRoutesNamespacesPtrOutput() GatewaySpecListenersAllowedRoutesNamespacesPtrOutput
	ToGatewaySpecListenersAllowedRoutesNamespacesPtrOutputWithContext(context.Context) GatewaySpecListenersAllowedRoutesNamespacesPtrOutput
}

type gatewaySpecListenersAllowedRoutesNamespacesPtrType GatewaySpecListenersAllowedRoutesNamespacesArgs

func GatewaySpecListenersAllowedRoutesNamespacesPtr(v *GatewaySpecListenersAllowedRoutesNamespacesArgs) GatewaySpecListenersAllowedRoutesNamespacesPtrInput {
	return (*gatewaySpecListenersAllowedRoutesNamespacesPtrType)(v)
}

func (*gatewaySpecListenersAllowedRoutesNamespacesPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewaySpecListenersAllowedRoutesNamespaces)(nil)).Elem()
}

func (i *gatewaySpecListenersAllowedRoutesNamespacesPtrType) ToGatewaySpecListenersAllowedRoutesNamespacesPtrOutput() GatewaySpecListenersAllowedRoutesNamespacesPtrOutput {
	return i.ToGatewaySpecListenersAllowedRoutesNamespacesPtrOutputWithContext(context.Background())
}

func (i *gatewaySpecListenersAllowedRoutesNamespacesPtrType) ToGatewaySpecListenersAllowedRoutesNamespacesPtrOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesNamespacesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersAllowedRoutesNamespacesPtrOutput)
}

// Namespaces indicates namespaces from which Routes may be attached to this
// Listener. This is restricted to the namespace of this Gateway by default.
//
// Support: Core
type GatewaySpecListenersAllowedRoutesNamespacesOutput struct{ *pulumi.OutputState }

func (GatewaySpecListenersAllowedRoutesNamespacesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecListenersAllowedRoutesNamespaces)(nil)).Elem()
}

func (o GatewaySpecListenersAllowedRoutesNamespacesOutput) ToGatewaySpecListenersAllowedRoutesNamespacesOutput() GatewaySpecListenersAllowedRoutesNamespacesOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesNamespacesOutput) ToGatewaySpecListenersAllowedRoutesNamespacesOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesNamespacesOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesNamespacesOutput) ToGatewaySpecListenersAllowedRoutesNamespacesPtrOutput() GatewaySpecListenersAllowedRoutesNamespacesPtrOutput {
	return o.ToGatewaySpecListenersAllowedRoutesNamespacesPtrOutputWithContext(context.Background())
}

func (o GatewaySpecListenersAllowedRoutesNamespacesOutput) ToGatewaySpecListenersAllowedRoutesNamespacesPtrOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesNamespacesPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GatewaySpecListenersAllowedRoutesNamespaces) *GatewaySpecListenersAllowedRoutesNamespaces {
		return &v
	}).(GatewaySpecListenersAllowedRoutesNamespacesPtrOutput)
}

// From indicates where Routes will be selected for this Gateway. Possible
// values are:
//
//   - All: Routes in all namespaces may be used by this Gateway.
//   - Selector: Routes in namespaces selected by the selector may be used by
//     this Gateway.
//   - Same: Only Routes in the same namespace may be used by this Gateway.
//
// Support: Core
func (o GatewaySpecListenersAllowedRoutesNamespacesOutput) From() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewaySpecListenersAllowedRoutesNamespaces) *string { return v.From }).(pulumi.StringPtrOutput)
}

func (o GatewaySpecListenersAllowedRoutesNamespacesOutput) Selector() GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput {
	return o.ApplyT(func(v GatewaySpecListenersAllowedRoutesNamespaces) *GatewaySpecListenersAllowedRoutesNamespacesSelector {
		return v.Selector
	}).(GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput)
}

type GatewaySpecListenersAllowedRoutesNamespacesPtrOutput struct{ *pulumi.OutputState }

func (GatewaySpecListenersAllowedRoutesNamespacesPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewaySpecListenersAllowedRoutesNamespaces)(nil)).Elem()
}

func (o GatewaySpecListenersAllowedRoutesNamespacesPtrOutput) ToGatewaySpecListenersAllowedRoutesNamespacesPtrOutput() GatewaySpecListenersAllowedRoutesNamespacesPtrOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesNamespacesPtrOutput) ToGatewaySpecListenersAllowedRoutesNamespacesPtrOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesNamespacesPtrOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesNamespacesPtrOutput) Elem() GatewaySpecListenersAllowedRoutesNamespacesOutput {
	return o.ApplyT(func(v *GatewaySpecListenersAllowedRoutesNamespaces) GatewaySpecListenersAllowedRoutesNamespaces {
		if v != nil {
			return *v
		}
		var ret GatewaySpecListenersAllowedRoutesNamespaces
		return ret
	}).(GatewaySpecListenersAllowedRoutesNamespacesOutput)
}

// From indicates where Routes will be selected for this Gateway. Possible
// values are:
//
//   - All: Routes in all namespaces may be used by this Gateway.
//   - Selector: Routes in namespaces selected by the selector may be used by
//     this Gateway.
//   - Same: Only Routes in the same namespace may be used by this Gateway.
//
// Support: Core
func (o GatewaySpecListenersAllowedRoutesNamespacesPtrOutput) From() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GatewaySpecListenersAllowedRoutesNamespaces) *string {
		if v == nil {
			return nil
		}
		return v.From
	}).(pulumi.StringPtrOutput)
}

func (o GatewaySpecListenersAllowedRoutesNamespacesPtrOutput) Selector() GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput {
	return o.ApplyT(func(v *GatewaySpecListenersAllowedRoutesNamespaces) *GatewaySpecListenersAllowedRoutesNamespacesSelector {
		if v == nil {
			return nil
		}
		return v.Selector
	}).(GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput)
}

// Namespaces indicates namespaces from which Routes may be attached to this
// Listener. This is restricted to the namespace of this Gateway by default.
//
// Support: Core
type GatewaySpecListenersAllowedRoutesNamespacesPatch struct {
	// From indicates where Routes will be selected for this Gateway. Possible
	// values are:
	//
	// * All: Routes in all namespaces may be used by this Gateway.
	// * Selector: Routes in namespaces selected by the selector may be used by
	//   this Gateway.
	// * Same: Only Routes in the same namespace may be used by this Gateway.
	//
	// Support: Core
	From     *string                                                   `pulumi:"from"`
	Selector *GatewaySpecListenersAllowedRoutesNamespacesSelectorPatch `pulumi:"selector"`
}

// GatewaySpecListenersAllowedRoutesNamespacesPatchInput is an input type that accepts GatewaySpecListenersAllowedRoutesNamespacesPatchArgs and GatewaySpecListenersAllowedRoutesNamespacesPatchOutput values.
// You can construct a concrete instance of `GatewaySpecListenersAllowedRoutesNamespacesPatchInput` via:
//
//	GatewaySpecListenersAllowedRoutesNamespacesPatchArgs{...}
type GatewaySpecListenersAllowedRoutesNamespacesPatchInput interface {
	pulumi.Input

	ToGatewaySpecListenersAllowedRoutesNamespacesPatchOutput() GatewaySpecListenersAllowedRoutesNamespacesPatchOutput
	ToGatewaySpecListenersAllowedRoutesNamespacesPatchOutputWithContext(context.Context) GatewaySpecListenersAllowedRoutesNamespacesPatchOutput
}

// Namespaces indicates namespaces from which Routes may be attached to this
// Listener. This is restricted to the namespace of this Gateway by default.
//
// Support: Core
type GatewaySpecListenersAllowedRoutesNamespacesPatchArgs struct {
	// From indicates where Routes will be selected for this Gateway. Possible
	// values are:
	//
	// * All: Routes in all namespaces may be used by this Gateway.
	// * Selector: Routes in namespaces selected by the selector may be used by
	//   this Gateway.
	// * Same: Only Routes in the same namespace may be used by this Gateway.
	//
	// Support: Core
	From     pulumi.StringPtrInput                                            `pulumi:"from"`
	Selector GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrInput `pulumi:"selector"`
}

func (GatewaySpecListenersAllowedRoutesNamespacesPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecListenersAllowedRoutesNamespacesPatch)(nil)).Elem()
}

func (i GatewaySpecListenersAllowedRoutesNamespacesPatchArgs) ToGatewaySpecListenersAllowedRoutesNamespacesPatchOutput() GatewaySpecListenersAllowedRoutesNamespacesPatchOutput {
	return i.ToGatewaySpecListenersAllowedRoutesNamespacesPatchOutputWithContext(context.Background())
}

func (i GatewaySpecListenersAllowedRoutesNamespacesPatchArgs) ToGatewaySpecListenersAllowedRoutesNamespacesPatchOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesNamespacesPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersAllowedRoutesNamespacesPatchOutput)
}

func (i GatewaySpecListenersAllowedRoutesNamespacesPatchArgs) ToGatewaySpecListenersAllowedRoutesNamespacesPatchPtrOutput() GatewaySpecListenersAllowedRoutesNamespacesPatchPtrOutput {
	return i.ToGatewaySpecListenersAllowedRoutesNamespacesPatchPtrOutputWithContext(context.Background())
}

func (i GatewaySpecListenersAllowedRoutesNamespacesPatchArgs) ToGatewaySpecListenersAllowedRoutesNamespacesPatchPtrOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesNamespacesPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersAllowedRoutesNamespacesPatchOutput).ToGatewaySpecListenersAllowedRoutesNamespacesPatchPtrOutputWithContext(ctx)
}

// GatewaySpecListenersAllowedRoutesNamespacesPatchPtrInput is an input type that accepts GatewaySpecListenersAllowedRoutesNamespacesPatchArgs, GatewaySpecListenersAllowedRoutesNamespacesPatchPtr and GatewaySpecListenersAllowedRoutesNamespacesPatchPtrOutput values.
// You can construct a concrete instance of `GatewaySpecListenersAllowedRoutesNamespacesPatchPtrInput` via:
//
//	        GatewaySpecListenersAllowedRoutesNamespacesPatchArgs{...}
//
//	or:
//
//	        nil
type GatewaySpecListenersAllowedRoutesNamespacesPatchPtrInput interface {
	pulumi.Input

	ToGatewaySpecListenersAllowedRoutesNamespacesPatchPtrOutput() GatewaySpecListenersAllowedRoutesNamespacesPatchPtrOutput
	ToGatewaySpecListenersAllowedRoutesNamespacesPatchPtrOutputWithContext(context.Context) GatewaySpecListenersAllowedRoutesNamespacesPatchPtrOutput
}

type gatewaySpecListenersAllowedRoutesNamespacesPatchPtrType GatewaySpecListenersAllowedRoutesNamespacesPatchArgs

func GatewaySpecListenersAllowedRoutesNamespacesPatchPtr(v *GatewaySpecListenersAllowedRoutesNamespacesPatchArgs) GatewaySpecListenersAllowedRoutesNamespacesPatchPtrInput {
	return (*gatewaySpecListenersAllowedRoutesNamespacesPatchPtrType)(v)
}

func (*gatewaySpecListenersAllowedRoutesNamespacesPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewaySpecListenersAllowedRoutesNamespacesPatch)(nil)).Elem()
}

func (i *gatewaySpecListenersAllowedRoutesNamespacesPatchPtrType) ToGatewaySpecListenersAllowedRoutesNamespacesPatchPtrOutput() GatewaySpecListenersAllowedRoutesNamespacesPatchPtrOutput {
	return i.ToGatewaySpecListenersAllowedRoutesNamespacesPatchPtrOutputWithContext(context.Background())
}

func (i *gatewaySpecListenersAllowedRoutesNamespacesPatchPtrType) ToGatewaySpecListenersAllowedRoutesNamespacesPatchPtrOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesNamespacesPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersAllowedRoutesNamespacesPatchPtrOutput)
}

// Namespaces indicates namespaces from which Routes may be attached to this
// Listener. This is restricted to the namespace of this Gateway by default.
//
// Support: Core
type GatewaySpecListenersAllowedRoutesNamespacesPatchOutput struct{ *pulumi.OutputState }

func (GatewaySpecListenersAllowedRoutesNamespacesPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecListenersAllowedRoutesNamespacesPatch)(nil)).Elem()
}

func (o GatewaySpecListenersAllowedRoutesNamespacesPatchOutput) ToGatewaySpecListenersAllowedRoutesNamespacesPatchOutput() GatewaySpecListenersAllowedRoutesNamespacesPatchOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesNamespacesPatchOutput) ToGatewaySpecListenersAllowedRoutesNamespacesPatchOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesNamespacesPatchOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesNamespacesPatchOutput) ToGatewaySpecListenersAllowedRoutesNamespacesPatchPtrOutput() GatewaySpecListenersAllowedRoutesNamespacesPatchPtrOutput {
	return o.ToGatewaySpecListenersAllowedRoutesNamespacesPatchPtrOutputWithContext(context.Background())
}

func (o GatewaySpecListenersAllowedRoutesNamespacesPatchOutput) ToGatewaySpecListenersAllowedRoutesNamespacesPatchPtrOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesNamespacesPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GatewaySpecListenersAllowedRoutesNamespacesPatch) *GatewaySpecListenersAllowedRoutesNamespacesPatch {
		return &v
	}).(GatewaySpecListenersAllowedRoutesNamespacesPatchPtrOutput)
}

// From indicates where Routes will be selected for this Gateway. Possible
// values are:
//
//   - All: Routes in all namespaces may be used by this Gateway.
//   - Selector: Routes in namespaces selected by the selector may be used by
//     this Gateway.
//   - Same: Only Routes in the same namespace may be used by this Gateway.
//
// Support: Core
func (o GatewaySpecListenersAllowedRoutesNamespacesPatchOutput) From() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewaySpecListenersAllowedRoutesNamespacesPatch) *string { return v.From }).(pulumi.StringPtrOutput)
}

func (o GatewaySpecListenersAllowedRoutesNamespacesPatchOutput) Selector() GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput {
	return o.ApplyT(func(v GatewaySpecListenersAllowedRoutesNamespacesPatch) *GatewaySpecListenersAllowedRoutesNamespacesSelectorPatch {
		return v.Selector
	}).(GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput)
}

type GatewaySpecListenersAllowedRoutesNamespacesPatchPtrOutput struct{ *pulumi.OutputState }

func (GatewaySpecListenersAllowedRoutesNamespacesPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewaySpecListenersAllowedRoutesNamespacesPatch)(nil)).Elem()
}

func (o GatewaySpecListenersAllowedRoutesNamespacesPatchPtrOutput) ToGatewaySpecListenersAllowedRoutesNamespacesPatchPtrOutput() GatewaySpecListenersAllowedRoutesNamespacesPatchPtrOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesNamespacesPatchPtrOutput) ToGatewaySpecListenersAllowedRoutesNamespacesPatchPtrOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesNamespacesPatchPtrOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesNamespacesPatchPtrOutput) Elem() GatewaySpecListenersAllowedRoutesNamespacesPatchOutput {
	return o.ApplyT(func(v *GatewaySpecListenersAllowedRoutesNamespacesPatch) GatewaySpecListenersAllowedRoutesNamespacesPatch {
		if v != nil {
			return *v
		}
		var ret GatewaySpecListenersAllowedRoutesNamespacesPatch
		return ret
	}).(GatewaySpecListenersAllowedRoutesNamespacesPatchOutput)
}

// From indicates where Routes will be selected for this Gateway. Possible
// values are:
//
//   - All: Routes in all namespaces may be used by this Gateway.
//   - Selector: Routes in namespaces selected by the selector may be used by
//     this Gateway.
//   - Same: Only Routes in the same namespace may be used by this Gateway.
//
// Support: Core
func (o GatewaySpecListenersAllowedRoutesNamespacesPatchPtrOutput) From() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GatewaySpecListenersAllowedRoutesNamespacesPatch) *string {
		if v == nil {
			return nil
		}
		return v.From
	}).(pulumi.StringPtrOutput)
}

func (o GatewaySpecListenersAllowedRoutesNamespacesPatchPtrOutput) Selector() GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput {
	return o.ApplyT(func(v *GatewaySpecListenersAllowedRoutesNamespacesPatch) *GatewaySpecListenersAllowedRoutesNamespacesSelectorPatch {
		if v == nil {
			return nil
		}
		return v.Selector
	}).(GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput)
}

// Selector must be specified when From is set to "Selector". In that case,
// only Routes in Namespaces matching this Selector will be selected by this
// Gateway. This field is ignored for other values of "From".
//
// Support: Core
type GatewaySpecListenersAllowedRoutesNamespacesSelector struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions []GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressions `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]string `pulumi:"matchLabels"`
}

// GatewaySpecListenersAllowedRoutesNamespacesSelectorInput is an input type that accepts GatewaySpecListenersAllowedRoutesNamespacesSelectorArgs and GatewaySpecListenersAllowedRoutesNamespacesSelectorOutput values.
// You can construct a concrete instance of `GatewaySpecListenersAllowedRoutesNamespacesSelectorInput` via:
//
//	GatewaySpecListenersAllowedRoutesNamespacesSelectorArgs{...}
type GatewaySpecListenersAllowedRoutesNamespacesSelectorInput interface {
	pulumi.Input

	ToGatewaySpecListenersAllowedRoutesNamespacesSelectorOutput() GatewaySpecListenersAllowedRoutesNamespacesSelectorOutput
	ToGatewaySpecListenersAllowedRoutesNamespacesSelectorOutputWithContext(context.Context) GatewaySpecListenersAllowedRoutesNamespacesSelectorOutput
}

// Selector must be specified when From is set to "Selector". In that case,
// only Routes in Namespaces matching this Selector will be selected by this
// Gateway. This field is ignored for other values of "From".
//
// Support: Core
type GatewaySpecListenersAllowedRoutesNamespacesSelectorArgs struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayInput `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels pulumi.StringMapInput `pulumi:"matchLabels"`
}

func (GatewaySpecListenersAllowedRoutesNamespacesSelectorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecListenersAllowedRoutesNamespacesSelector)(nil)).Elem()
}

func (i GatewaySpecListenersAllowedRoutesNamespacesSelectorArgs) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorOutput() GatewaySpecListenersAllowedRoutesNamespacesSelectorOutput {
	return i.ToGatewaySpecListenersAllowedRoutesNamespacesSelectorOutputWithContext(context.Background())
}

func (i GatewaySpecListenersAllowedRoutesNamespacesSelectorArgs) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesNamespacesSelectorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersAllowedRoutesNamespacesSelectorOutput)
}

func (i GatewaySpecListenersAllowedRoutesNamespacesSelectorArgs) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput() GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput {
	return i.ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutputWithContext(context.Background())
}

func (i GatewaySpecListenersAllowedRoutesNamespacesSelectorArgs) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersAllowedRoutesNamespacesSelectorOutput).ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutputWithContext(ctx)
}

// GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrInput is an input type that accepts GatewaySpecListenersAllowedRoutesNamespacesSelectorArgs, GatewaySpecListenersAllowedRoutesNamespacesSelectorPtr and GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput values.
// You can construct a concrete instance of `GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrInput` via:
//
//	        GatewaySpecListenersAllowedRoutesNamespacesSelectorArgs{...}
//
//	or:
//
//	        nil
type GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrInput interface {
	pulumi.Input

	ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput() GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput
	ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutputWithContext(context.Context) GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput
}

type gatewaySpecListenersAllowedRoutesNamespacesSelectorPtrType GatewaySpecListenersAllowedRoutesNamespacesSelectorArgs

func GatewaySpecListenersAllowedRoutesNamespacesSelectorPtr(v *GatewaySpecListenersAllowedRoutesNamespacesSelectorArgs) GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrInput {
	return (*gatewaySpecListenersAllowedRoutesNamespacesSelectorPtrType)(v)
}

func (*gatewaySpecListenersAllowedRoutesNamespacesSelectorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewaySpecListenersAllowedRoutesNamespacesSelector)(nil)).Elem()
}

func (i *gatewaySpecListenersAllowedRoutesNamespacesSelectorPtrType) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput() GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput {
	return i.ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutputWithContext(context.Background())
}

func (i *gatewaySpecListenersAllowedRoutesNamespacesSelectorPtrType) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput)
}

// Selector must be specified when From is set to "Selector". In that case,
// only Routes in Namespaces matching this Selector will be selected by this
// Gateway. This field is ignored for other values of "From".
//
// Support: Core
type GatewaySpecListenersAllowedRoutesNamespacesSelectorOutput struct{ *pulumi.OutputState }

func (GatewaySpecListenersAllowedRoutesNamespacesSelectorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecListenersAllowedRoutesNamespacesSelector)(nil)).Elem()
}

func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorOutput) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorOutput() GatewaySpecListenersAllowedRoutesNamespacesSelectorOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorOutput) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesNamespacesSelectorOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorOutput) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput() GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput {
	return o.ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutputWithContext(context.Background())
}

func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorOutput) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GatewaySpecListenersAllowedRoutesNamespacesSelector) *GatewaySpecListenersAllowedRoutesNamespacesSelector {
		return &v
	}).(GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorOutput) MatchExpressions() GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v GatewaySpecListenersAllowedRoutesNamespacesSelector) []GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressions {
		return v.MatchExpressions
	}).(GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v GatewaySpecListenersAllowedRoutesNamespacesSelector) map[string]string { return v.MatchLabels }).(pulumi.StringMapOutput)
}

type GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput struct{ *pulumi.OutputState }

func (GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewaySpecListenersAllowedRoutesNamespacesSelector)(nil)).Elem()
}

func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput() GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput) Elem() GatewaySpecListenersAllowedRoutesNamespacesSelectorOutput {
	return o.ApplyT(func(v *GatewaySpecListenersAllowedRoutesNamespacesSelector) GatewaySpecListenersAllowedRoutesNamespacesSelector {
		if v != nil {
			return *v
		}
		var ret GatewaySpecListenersAllowedRoutesNamespacesSelector
		return ret
	}).(GatewaySpecListenersAllowedRoutesNamespacesSelectorOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput) MatchExpressions() GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v *GatewaySpecListenersAllowedRoutesNamespacesSelector) []GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressions {
		if v == nil {
			return nil
		}
		return v.MatchExpressions
	}).(GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *GatewaySpecListenersAllowedRoutesNamespacesSelector) map[string]string {
		if v == nil {
			return nil
		}
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressions struct {
	// key is the label key that the selector applies to.
	Key *string `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator *string `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values []string `pulumi:"values"`
}

// GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsInput is an input type that accepts GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArgs and GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput values.
// You can construct a concrete instance of `GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsInput` via:
//
//	GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArgs{...}
type GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsInput interface {
	pulumi.Input

	ToGatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput() GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput
	ToGatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutputWithContext(context.Context) GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArgs struct {
	// key is the label key that the selector applies to.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator pulumi.StringPtrInput `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressions)(nil)).Elem()
}

func (i GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArgs) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput() GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput {
	return i.ToGatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutputWithContext(context.Background())
}

func (i GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArgs) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput)
}

// GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayInput is an input type that accepts GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArray and GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput values.
// You can construct a concrete instance of `GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayInput` via:
//
//	GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArray{ GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArgs{...} }
type GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayInput interface {
	pulumi.Input

	ToGatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput() GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput
	ToGatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutputWithContext(context.Context) GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput
}

type GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArray []GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsInput

func (GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressions)(nil)).Elem()
}

func (i GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArray) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput() GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput {
	return i.ToGatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutputWithContext(context.Background())
}

func (i GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArray) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput struct{ *pulumi.OutputState }

func (GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressions)(nil)).Elem()
}

func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput() GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput {
	return o
}

// key is the label key that the selector applies to.
func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressions) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// operator represents a key's relationship to a set of values.
// Valid operators are In, NotIn, Exists and DoesNotExist.
func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput) Operator() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressions) *string { return v.Operator }).(pulumi.StringPtrOutput)
}

// values is an array of string values. If the operator is In or NotIn,
// the values array must be non-empty. If the operator is Exists or DoesNotExist,
// the values array must be empty. This array is replaced during a strategic
// merge patch.
func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressions) []string { return v.Values }).(pulumi.StringArrayOutput)
}

type GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput struct{ *pulumi.OutputState }

func (GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressions)(nil)).Elem()
}

func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput() GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput) Index(i pulumi.IntInput) GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressions {
		return vs[0].([]GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressions)[vs[1].(int)]
	}).(GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatch struct {
	// key is the label key that the selector applies to.
	Key *string `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator *string `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values []string `pulumi:"values"`
}

// GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchInput is an input type that accepts GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArgs and GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchOutput values.
// You can construct a concrete instance of `GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchInput` via:
//
//	GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArgs{...}
type GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchInput interface {
	pulumi.Input

	ToGatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchOutput() GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchOutput
	ToGatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchOutputWithContext(context.Context) GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchOutput
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArgs struct {
	// key is the label key that the selector applies to.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator pulumi.StringPtrInput `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatch)(nil)).Elem()
}

func (i GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArgs) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchOutput() GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchOutput {
	return i.ToGatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchOutputWithContext(context.Background())
}

func (i GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArgs) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchOutput)
}

// GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayInput is an input type that accepts GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArray and GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayOutput values.
// You can construct a concrete instance of `GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayInput` via:
//
//	GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArray{ GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArgs{...} }
type GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayInput interface {
	pulumi.Input

	ToGatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayOutput() GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayOutput
	ToGatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayOutputWithContext(context.Context) GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayOutput
}

type GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArray []GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchInput

func (GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatch)(nil)).Elem()
}

func (i GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArray) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayOutput() GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayOutput {
	return i.ToGatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayOutputWithContext(context.Background())
}

func (i GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArray) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchOutput struct{ *pulumi.OutputState }

func (GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatch)(nil)).Elem()
}

func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchOutput) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchOutput() GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchOutput) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchOutput {
	return o
}

// key is the label key that the selector applies to.
func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatch) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// operator represents a key's relationship to a set of values.
// Valid operators are In, NotIn, Exists and DoesNotExist.
func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchOutput) Operator() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatch) *string {
		return v.Operator
	}).(pulumi.StringPtrOutput)
}

// values is an array of string values. If the operator is In or NotIn,
// the values array must be non-empty. If the operator is Exists or DoesNotExist,
// the values array must be empty. This array is replaced during a strategic
// merge patch.
func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatch) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayOutput struct{ *pulumi.OutputState }

func (GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatch)(nil)).Elem()
}

func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayOutput) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayOutput() GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayOutput) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayOutput) Index(i pulumi.IntInput) GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatch {
		return vs[0].([]GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatch)[vs[1].(int)]
	}).(GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchOutput)
}

// Selector must be specified when From is set to "Selector". In that case,
// only Routes in Namespaces matching this Selector will be selected by this
// Gateway. This field is ignored for other values of "From".
//
// Support: Core
type GatewaySpecListenersAllowedRoutesNamespacesSelectorPatch struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions []GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatch `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]string `pulumi:"matchLabels"`
}

// GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchInput is an input type that accepts GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchArgs and GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchOutput values.
// You can construct a concrete instance of `GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchInput` via:
//
//	GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchArgs{...}
type GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchInput interface {
	pulumi.Input

	ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPatchOutput() GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchOutput
	ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPatchOutputWithContext(context.Context) GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchOutput
}

// Selector must be specified when From is set to "Selector". In that case,
// only Routes in Namespaces matching this Selector will be selected by this
// Gateway. This field is ignored for other values of "From".
//
// Support: Core
type GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchArgs struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayInput `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels pulumi.StringMapInput `pulumi:"matchLabels"`
}

func (GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecListenersAllowedRoutesNamespacesSelectorPatch)(nil)).Elem()
}

func (i GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchArgs) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPatchOutput() GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchOutput {
	return i.ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPatchOutputWithContext(context.Background())
}

func (i GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchArgs) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPatchOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchOutput)
}

func (i GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchArgs) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput() GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput {
	return i.ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutputWithContext(context.Background())
}

func (i GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchArgs) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchOutput).ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutputWithContext(ctx)
}

// GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrInput is an input type that accepts GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchArgs, GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtr and GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput values.
// You can construct a concrete instance of `GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrInput` via:
//
//	        GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchArgs{...}
//
//	or:
//
//	        nil
type GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrInput interface {
	pulumi.Input

	ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput() GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput
	ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutputWithContext(context.Context) GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput
}

type gatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrType GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchArgs

func GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtr(v *GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchArgs) GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrInput {
	return (*gatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrType)(v)
}

func (*gatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewaySpecListenersAllowedRoutesNamespacesSelectorPatch)(nil)).Elem()
}

func (i *gatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrType) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput() GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput {
	return i.ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutputWithContext(context.Background())
}

func (i *gatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrType) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput)
}

// Selector must be specified when From is set to "Selector". In that case,
// only Routes in Namespaces matching this Selector will be selected by this
// Gateway. This field is ignored for other values of "From".
//
// Support: Core
type GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchOutput struct{ *pulumi.OutputState }

func (GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecListenersAllowedRoutesNamespacesSelectorPatch)(nil)).Elem()
}

func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchOutput) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPatchOutput() GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchOutput) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPatchOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchOutput) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput() GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput {
	return o.ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutputWithContext(context.Background())
}

func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchOutput) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GatewaySpecListenersAllowedRoutesNamespacesSelectorPatch) *GatewaySpecListenersAllowedRoutesNamespacesSelectorPatch {
		return &v
	}).(GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchOutput) MatchExpressions() GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayOutput {
	return o.ApplyT(func(v GatewaySpecListenersAllowedRoutesNamespacesSelectorPatch) []GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatch {
		return v.MatchExpressions
	}).(GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v GatewaySpecListenersAllowedRoutesNamespacesSelectorPatch) map[string]string {
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

type GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput struct{ *pulumi.OutputState }

func (GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewaySpecListenersAllowedRoutesNamespacesSelectorPatch)(nil)).Elem()
}

func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput() GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput) ToGatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput) Elem() GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchOutput {
	return o.ApplyT(func(v *GatewaySpecListenersAllowedRoutesNamespacesSelectorPatch) GatewaySpecListenersAllowedRoutesNamespacesSelectorPatch {
		if v != nil {
			return *v
		}
		var ret GatewaySpecListenersAllowedRoutesNamespacesSelectorPatch
		return ret
	}).(GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput) MatchExpressions() GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayOutput {
	return o.ApplyT(func(v *GatewaySpecListenersAllowedRoutesNamespacesSelectorPatch) []GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatch {
		if v == nil {
			return nil
		}
		return v.MatchExpressions
	}).(GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *GatewaySpecListenersAllowedRoutesNamespacesSelectorPatch) map[string]string {
		if v == nil {
			return nil
		}
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

// AllowedRoutes defines the types of routes that MAY be attached to a
// Listener and the trusted namespaces where those Route resources MAY be
// present.
//
// Although a client request may match multiple route rules, only one rule
// may ultimately receive the request. Matching precedence MUST be
// determined in order of the following criteria:
//
//   - The most specific match as defined by the Route type.
//   - The oldest Route based on creation timestamp. For example, a Route with
//     a creation timestamp of "2020-09-08 01:02:03" is given precedence over
//     a Route with a creation timestamp of "2020-09-08 01:02:04".
//   - If everything else is equivalent, the Route appearing first in
//     alphabetical order (namespace/name) should be given precedence. For
//     example, foo/bar is given precedence over foo/baz.
//
// All valid rules within a Route attached to this Listener should be
// implemented. Invalid Route rules can be ignored (sometimes that will mean
// the full Route). If a Route rule transitions from valid to invalid,
// support for that Route rule should be dropped to ensure consistency. For
// example, even if a filter specified by a Route rule is invalid, the rest
// of the rules within that Route should still be supported.
//
// Support: Core
type GatewaySpecListenersAllowedRoutesPatch struct {
	// Kinds specifies the groups and kinds of Routes that are allowed to bind
	// to this Gateway Listener. When unspecified or empty, the kinds of Routes
	// selected are determined using the Listener protocol.
	//
	// A RouteGroupKind MUST correspond to kinds of Routes that are compatible
	// with the application protocol specified in the Listener's Protocol field.
	// If an implementation does not support or recognize this resource type, it
	// MUST set the "ResolvedRefs" condition to False for this Listener with the
	// "InvalidRouteKinds" reason.
	//
	// Support: Core
	Kinds      []GatewaySpecListenersAllowedRoutesKindsPatch     `pulumi:"kinds"`
	Namespaces *GatewaySpecListenersAllowedRoutesNamespacesPatch `pulumi:"namespaces"`
}

// GatewaySpecListenersAllowedRoutesPatchInput is an input type that accepts GatewaySpecListenersAllowedRoutesPatchArgs and GatewaySpecListenersAllowedRoutesPatchOutput values.
// You can construct a concrete instance of `GatewaySpecListenersAllowedRoutesPatchInput` via:
//
//	GatewaySpecListenersAllowedRoutesPatchArgs{...}
type GatewaySpecListenersAllowedRoutesPatchInput interface {
	pulumi.Input

	ToGatewaySpecListenersAllowedRoutesPatchOutput() GatewaySpecListenersAllowedRoutesPatchOutput
	ToGatewaySpecListenersAllowedRoutesPatchOutputWithContext(context.Context) GatewaySpecListenersAllowedRoutesPatchOutput
}

// AllowedRoutes defines the types of routes that MAY be attached to a
// Listener and the trusted namespaces where those Route resources MAY be
// present.
//
// Although a client request may match multiple route rules, only one rule
// may ultimately receive the request. Matching precedence MUST be
// determined in order of the following criteria:
//
//   - The most specific match as defined by the Route type.
//   - The oldest Route based on creation timestamp. For example, a Route with
//     a creation timestamp of "2020-09-08 01:02:03" is given precedence over
//     a Route with a creation timestamp of "2020-09-08 01:02:04".
//   - If everything else is equivalent, the Route appearing first in
//     alphabetical order (namespace/name) should be given precedence. For
//     example, foo/bar is given precedence over foo/baz.
//
// All valid rules within a Route attached to this Listener should be
// implemented. Invalid Route rules can be ignored (sometimes that will mean
// the full Route). If a Route rule transitions from valid to invalid,
// support for that Route rule should be dropped to ensure consistency. For
// example, even if a filter specified by a Route rule is invalid, the rest
// of the rules within that Route should still be supported.
//
// Support: Core
type GatewaySpecListenersAllowedRoutesPatchArgs struct {
	// Kinds specifies the groups and kinds of Routes that are allowed to bind
	// to this Gateway Listener. When unspecified or empty, the kinds of Routes
	// selected are determined using the Listener protocol.
	//
	// A RouteGroupKind MUST correspond to kinds of Routes that are compatible
	// with the application protocol specified in the Listener's Protocol field.
	// If an implementation does not support or recognize this resource type, it
	// MUST set the "ResolvedRefs" condition to False for this Listener with the
	// "InvalidRouteKinds" reason.
	//
	// Support: Core
	Kinds      GatewaySpecListenersAllowedRoutesKindsPatchArrayInput    `pulumi:"kinds"`
	Namespaces GatewaySpecListenersAllowedRoutesNamespacesPatchPtrInput `pulumi:"namespaces"`
}

func (GatewaySpecListenersAllowedRoutesPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecListenersAllowedRoutesPatch)(nil)).Elem()
}

func (i GatewaySpecListenersAllowedRoutesPatchArgs) ToGatewaySpecListenersAllowedRoutesPatchOutput() GatewaySpecListenersAllowedRoutesPatchOutput {
	return i.ToGatewaySpecListenersAllowedRoutesPatchOutputWithContext(context.Background())
}

func (i GatewaySpecListenersAllowedRoutesPatchArgs) ToGatewaySpecListenersAllowedRoutesPatchOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersAllowedRoutesPatchOutput)
}

func (i GatewaySpecListenersAllowedRoutesPatchArgs) ToGatewaySpecListenersAllowedRoutesPatchPtrOutput() GatewaySpecListenersAllowedRoutesPatchPtrOutput {
	return i.ToGatewaySpecListenersAllowedRoutesPatchPtrOutputWithContext(context.Background())
}

func (i GatewaySpecListenersAllowedRoutesPatchArgs) ToGatewaySpecListenersAllowedRoutesPatchPtrOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersAllowedRoutesPatchOutput).ToGatewaySpecListenersAllowedRoutesPatchPtrOutputWithContext(ctx)
}

// GatewaySpecListenersAllowedRoutesPatchPtrInput is an input type that accepts GatewaySpecListenersAllowedRoutesPatchArgs, GatewaySpecListenersAllowedRoutesPatchPtr and GatewaySpecListenersAllowedRoutesPatchPtrOutput values.
// You can construct a concrete instance of `GatewaySpecListenersAllowedRoutesPatchPtrInput` via:
//
//	        GatewaySpecListenersAllowedRoutesPatchArgs{...}
//
//	or:
//
//	        nil
type GatewaySpecListenersAllowedRoutesPatchPtrInput interface {
	pulumi.Input

	ToGatewaySpecListenersAllowedRoutesPatchPtrOutput() GatewaySpecListenersAllowedRoutesPatchPtrOutput
	ToGatewaySpecListenersAllowedRoutesPatchPtrOutputWithContext(context.Context) GatewaySpecListenersAllowedRoutesPatchPtrOutput
}

type gatewaySpecListenersAllowedRoutesPatchPtrType GatewaySpecListenersAllowedRoutesPatchArgs

func GatewaySpecListenersAllowedRoutesPatchPtr(v *GatewaySpecListenersAllowedRoutesPatchArgs) GatewaySpecListenersAllowedRoutesPatchPtrInput {
	return (*gatewaySpecListenersAllowedRoutesPatchPtrType)(v)
}

func (*gatewaySpecListenersAllowedRoutesPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewaySpecListenersAllowedRoutesPatch)(nil)).Elem()
}

func (i *gatewaySpecListenersAllowedRoutesPatchPtrType) ToGatewaySpecListenersAllowedRoutesPatchPtrOutput() GatewaySpecListenersAllowedRoutesPatchPtrOutput {
	return i.ToGatewaySpecListenersAllowedRoutesPatchPtrOutputWithContext(context.Background())
}

func (i *gatewaySpecListenersAllowedRoutesPatchPtrType) ToGatewaySpecListenersAllowedRoutesPatchPtrOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersAllowedRoutesPatchPtrOutput)
}

// AllowedRoutes defines the types of routes that MAY be attached to a
// Listener and the trusted namespaces where those Route resources MAY be
// present.
//
// Although a client request may match multiple route rules, only one rule
// may ultimately receive the request. Matching precedence MUST be
// determined in order of the following criteria:
//
//   - The most specific match as defined by the Route type.
//   - The oldest Route based on creation timestamp. For example, a Route with
//     a creation timestamp of "2020-09-08 01:02:03" is given precedence over
//     a Route with a creation timestamp of "2020-09-08 01:02:04".
//   - If everything else is equivalent, the Route appearing first in
//     alphabetical order (namespace/name) should be given precedence. For
//     example, foo/bar is given precedence over foo/baz.
//
// All valid rules within a Route attached to this Listener should be
// implemented. Invalid Route rules can be ignored (sometimes that will mean
// the full Route). If a Route rule transitions from valid to invalid,
// support for that Route rule should be dropped to ensure consistency. For
// example, even if a filter specified by a Route rule is invalid, the rest
// of the rules within that Route should still be supported.
//
// Support: Core
type GatewaySpecListenersAllowedRoutesPatchOutput struct{ *pulumi.OutputState }

func (GatewaySpecListenersAllowedRoutesPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecListenersAllowedRoutesPatch)(nil)).Elem()
}

func (o GatewaySpecListenersAllowedRoutesPatchOutput) ToGatewaySpecListenersAllowedRoutesPatchOutput() GatewaySpecListenersAllowedRoutesPatchOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesPatchOutput) ToGatewaySpecListenersAllowedRoutesPatchOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesPatchOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesPatchOutput) ToGatewaySpecListenersAllowedRoutesPatchPtrOutput() GatewaySpecListenersAllowedRoutesPatchPtrOutput {
	return o.ToGatewaySpecListenersAllowedRoutesPatchPtrOutputWithContext(context.Background())
}

func (o GatewaySpecListenersAllowedRoutesPatchOutput) ToGatewaySpecListenersAllowedRoutesPatchPtrOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GatewaySpecListenersAllowedRoutesPatch) *GatewaySpecListenersAllowedRoutesPatch {
		return &v
	}).(GatewaySpecListenersAllowedRoutesPatchPtrOutput)
}

// Kinds specifies the groups and kinds of Routes that are allowed to bind
// to this Gateway Listener. When unspecified or empty, the kinds of Routes
// selected are determined using the Listener protocol.
//
// A RouteGroupKind MUST correspond to kinds of Routes that are compatible
// with the application protocol specified in the Listener's Protocol field.
// If an implementation does not support or recognize this resource type, it
// MUST set the "ResolvedRefs" condition to False for this Listener with the
// "InvalidRouteKinds" reason.
//
// Support: Core
func (o GatewaySpecListenersAllowedRoutesPatchOutput) Kinds() GatewaySpecListenersAllowedRoutesKindsPatchArrayOutput {
	return o.ApplyT(func(v GatewaySpecListenersAllowedRoutesPatch) []GatewaySpecListenersAllowedRoutesKindsPatch {
		return v.Kinds
	}).(GatewaySpecListenersAllowedRoutesKindsPatchArrayOutput)
}

func (o GatewaySpecListenersAllowedRoutesPatchOutput) Namespaces() GatewaySpecListenersAllowedRoutesNamespacesPatchPtrOutput {
	return o.ApplyT(func(v GatewaySpecListenersAllowedRoutesPatch) *GatewaySpecListenersAllowedRoutesNamespacesPatch {
		return v.Namespaces
	}).(GatewaySpecListenersAllowedRoutesNamespacesPatchPtrOutput)
}

type GatewaySpecListenersAllowedRoutesPatchPtrOutput struct{ *pulumi.OutputState }

func (GatewaySpecListenersAllowedRoutesPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewaySpecListenersAllowedRoutesPatch)(nil)).Elem()
}

func (o GatewaySpecListenersAllowedRoutesPatchPtrOutput) ToGatewaySpecListenersAllowedRoutesPatchPtrOutput() GatewaySpecListenersAllowedRoutesPatchPtrOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesPatchPtrOutput) ToGatewaySpecListenersAllowedRoutesPatchPtrOutputWithContext(ctx context.Context) GatewaySpecListenersAllowedRoutesPatchPtrOutput {
	return o
}

func (o GatewaySpecListenersAllowedRoutesPatchPtrOutput) Elem() GatewaySpecListenersAllowedRoutesPatchOutput {
	return o.ApplyT(func(v *GatewaySpecListenersAllowedRoutesPatch) GatewaySpecListenersAllowedRoutesPatch {
		if v != nil {
			return *v
		}
		var ret GatewaySpecListenersAllowedRoutesPatch
		return ret
	}).(GatewaySpecListenersAllowedRoutesPatchOutput)
}

// Kinds specifies the groups and kinds of Routes that are allowed to bind
// to this Gateway Listener. When unspecified or empty, the kinds of Routes
// selected are determined using the Listener protocol.
//
// A RouteGroupKind MUST correspond to kinds of Routes that are compatible
// with the application protocol specified in the Listener's Protocol field.
// If an implementation does not support or recognize this resource type, it
// MUST set the "ResolvedRefs" condition to False for this Listener with the
// "InvalidRouteKinds" reason.
//
// Support: Core
func (o GatewaySpecListenersAllowedRoutesPatchPtrOutput) Kinds() GatewaySpecListenersAllowedRoutesKindsPatchArrayOutput {
	return o.ApplyT(func(v *GatewaySpecListenersAllowedRoutesPatch) []GatewaySpecListenersAllowedRoutesKindsPatch {
		if v == nil {
			return nil
		}
		return v.Kinds
	}).(GatewaySpecListenersAllowedRoutesKindsPatchArrayOutput)
}

func (o GatewaySpecListenersAllowedRoutesPatchPtrOutput) Namespaces() GatewaySpecListenersAllowedRoutesNamespacesPatchPtrOutput {
	return o.ApplyT(func(v *GatewaySpecListenersAllowedRoutesPatch) *GatewaySpecListenersAllowedRoutesNamespacesPatch {
		if v == nil {
			return nil
		}
		return v.Namespaces
	}).(GatewaySpecListenersAllowedRoutesNamespacesPatchPtrOutput)
}

// Listener embodies the concept of a logical endpoint where a Gateway accepts
// network connections.
type GatewaySpecListenersPatch struct {
	AllowedRoutes *GatewaySpecListenersAllowedRoutesPatch `pulumi:"allowedRoutes"`
	// Hostname specifies the virtual hostname to match for protocol types that
	// define this concept. When unspecified, all hostnames are matched. This
	// field is ignored for protocols that don't require hostname based
	// matching.
	//
	// Implementations MUST apply Hostname matching appropriately for each of
	// the following protocols:
	//
	// * TLS: The Listener Hostname MUST match the SNI.
	// * HTTP: The Listener Hostname MUST match the Host header of the request.
	// * HTTPS: The Listener Hostname SHOULD match at both the TLS and HTTP
	//   protocol layers as described above. If an implementation does not
	//   ensure that both the SNI and Host header match the Listener hostname,
	//   it MUST clearly document that.
	//
	// For HTTPRoute and TLSRoute resources, there is an interaction with the
	// `spec.hostnames` array. When both listener and route specify hostnames,
	// there MUST be an intersection between the values for a Route to be
	// accepted. For more information, refer to the Route specific Hostnames
	// documentation.
	//
	// Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
	// as a suffix match. That means that a match for `*.example.com` would match
	// both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
	//
	// Support: Core
	Hostname *string `pulumi:"hostname"`
	// Name is the name of the Listener. This name MUST be unique within a
	// Gateway.
	//
	// Support: Core
	Name *string `pulumi:"name"`
	// Port is the network port. Multiple listeners may use the
	// same port, subject to the Listener compatibility rules.
	//
	// Support: Core
	Port *int `pulumi:"port"`
	// Protocol specifies the network protocol this listener expects to receive.
	//
	// Support: Core
	Protocol *string                       `pulumi:"protocol"`
	Tls      *GatewaySpecListenersTlsPatch `pulumi:"tls"`
}

// GatewaySpecListenersPatchInput is an input type that accepts GatewaySpecListenersPatchArgs and GatewaySpecListenersPatchOutput values.
// You can construct a concrete instance of `GatewaySpecListenersPatchInput` via:
//
//	GatewaySpecListenersPatchArgs{...}
type GatewaySpecListenersPatchInput interface {
	pulumi.Input

	ToGatewaySpecListenersPatchOutput() GatewaySpecListenersPatchOutput
	ToGatewaySpecListenersPatchOutputWithContext(context.Context) GatewaySpecListenersPatchOutput
}

// Listener embodies the concept of a logical endpoint where a Gateway accepts
// network connections.
type GatewaySpecListenersPatchArgs struct {
	AllowedRoutes GatewaySpecListenersAllowedRoutesPatchPtrInput `pulumi:"allowedRoutes"`
	// Hostname specifies the virtual hostname to match for protocol types that
	// define this concept. When unspecified, all hostnames are matched. This
	// field is ignored for protocols that don't require hostname based
	// matching.
	//
	// Implementations MUST apply Hostname matching appropriately for each of
	// the following protocols:
	//
	// * TLS: The Listener Hostname MUST match the SNI.
	// * HTTP: The Listener Hostname MUST match the Host header of the request.
	// * HTTPS: The Listener Hostname SHOULD match at both the TLS and HTTP
	//   protocol layers as described above. If an implementation does not
	//   ensure that both the SNI and Host header match the Listener hostname,
	//   it MUST clearly document that.
	//
	// For HTTPRoute and TLSRoute resources, there is an interaction with the
	// `spec.hostnames` array. When both listener and route specify hostnames,
	// there MUST be an intersection between the values for a Route to be
	// accepted. For more information, refer to the Route specific Hostnames
	// documentation.
	//
	// Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
	// as a suffix match. That means that a match for `*.example.com` would match
	// both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
	//
	// Support: Core
	Hostname pulumi.StringPtrInput `pulumi:"hostname"`
	// Name is the name of the Listener. This name MUST be unique within a
	// Gateway.
	//
	// Support: Core
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Port is the network port. Multiple listeners may use the
	// same port, subject to the Listener compatibility rules.
	//
	// Support: Core
	Port pulumi.IntPtrInput `pulumi:"port"`
	// Protocol specifies the network protocol this listener expects to receive.
	//
	// Support: Core
	Protocol pulumi.StringPtrInput                `pulumi:"protocol"`
	Tls      GatewaySpecListenersTlsPatchPtrInput `pulumi:"tls"`
}

func (GatewaySpecListenersPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecListenersPatch)(nil)).Elem()
}

func (i GatewaySpecListenersPatchArgs) ToGatewaySpecListenersPatchOutput() GatewaySpecListenersPatchOutput {
	return i.ToGatewaySpecListenersPatchOutputWithContext(context.Background())
}

func (i GatewaySpecListenersPatchArgs) ToGatewaySpecListenersPatchOutputWithContext(ctx context.Context) GatewaySpecListenersPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersPatchOutput)
}

// GatewaySpecListenersPatchArrayInput is an input type that accepts GatewaySpecListenersPatchArray and GatewaySpecListenersPatchArrayOutput values.
// You can construct a concrete instance of `GatewaySpecListenersPatchArrayInput` via:
//
//	GatewaySpecListenersPatchArray{ GatewaySpecListenersPatchArgs{...} }
type GatewaySpecListenersPatchArrayInput interface {
	pulumi.Input

	ToGatewaySpecListenersPatchArrayOutput() GatewaySpecListenersPatchArrayOutput
	ToGatewaySpecListenersPatchArrayOutputWithContext(context.Context) GatewaySpecListenersPatchArrayOutput
}

type GatewaySpecListenersPatchArray []GatewaySpecListenersPatchInput

func (GatewaySpecListenersPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewaySpecListenersPatch)(nil)).Elem()
}

func (i GatewaySpecListenersPatchArray) ToGatewaySpecListenersPatchArrayOutput() GatewaySpecListenersPatchArrayOutput {
	return i.ToGatewaySpecListenersPatchArrayOutputWithContext(context.Background())
}

func (i GatewaySpecListenersPatchArray) ToGatewaySpecListenersPatchArrayOutputWithContext(ctx context.Context) GatewaySpecListenersPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersPatchArrayOutput)
}

// Listener embodies the concept of a logical endpoint where a Gateway accepts
// network connections.
type GatewaySpecListenersPatchOutput struct{ *pulumi.OutputState }

func (GatewaySpecListenersPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecListenersPatch)(nil)).Elem()
}

func (o GatewaySpecListenersPatchOutput) ToGatewaySpecListenersPatchOutput() GatewaySpecListenersPatchOutput {
	return o
}

func (o GatewaySpecListenersPatchOutput) ToGatewaySpecListenersPatchOutputWithContext(ctx context.Context) GatewaySpecListenersPatchOutput {
	return o
}

func (o GatewaySpecListenersPatchOutput) AllowedRoutes() GatewaySpecListenersAllowedRoutesPatchPtrOutput {
	return o.ApplyT(func(v GatewaySpecListenersPatch) *GatewaySpecListenersAllowedRoutesPatch { return v.AllowedRoutes }).(GatewaySpecListenersAllowedRoutesPatchPtrOutput)
}

// Hostname specifies the virtual hostname to match for protocol types that
// define this concept. When unspecified, all hostnames are matched. This
// field is ignored for protocols that don't require hostname based
// matching.
//
// Implementations MUST apply Hostname matching appropriately for each of
// the following protocols:
//
//   - TLS: The Listener Hostname MUST match the SNI.
//   - HTTP: The Listener Hostname MUST match the Host header of the request.
//   - HTTPS: The Listener Hostname SHOULD match at both the TLS and HTTP
//     protocol layers as described above. If an implementation does not
//     ensure that both the SNI and Host header match the Listener hostname,
//     it MUST clearly document that.
//
// For HTTPRoute and TLSRoute resources, there is an interaction with the
// `spec.hostnames` array. When both listener and route specify hostnames,
// there MUST be an intersection between the values for a Route to be
// accepted. For more information, refer to the Route specific Hostnames
// documentation.
//
// Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
// as a suffix match. That means that a match for `*.example.com` would match
// both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
//
// Support: Core
func (o GatewaySpecListenersPatchOutput) Hostname() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewaySpecListenersPatch) *string { return v.Hostname }).(pulumi.StringPtrOutput)
}

// Name is the name of the Listener. This name MUST be unique within a
// Gateway.
//
// Support: Core
func (o GatewaySpecListenersPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewaySpecListenersPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Port is the network port. Multiple listeners may use the
// same port, subject to the Listener compatibility rules.
//
// Support: Core
func (o GatewaySpecListenersPatchOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v GatewaySpecListenersPatch) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// Protocol specifies the network protocol this listener expects to receive.
//
// Support: Core
func (o GatewaySpecListenersPatchOutput) Protocol() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewaySpecListenersPatch) *string { return v.Protocol }).(pulumi.StringPtrOutput)
}

func (o GatewaySpecListenersPatchOutput) Tls() GatewaySpecListenersTlsPatchPtrOutput {
	return o.ApplyT(func(v GatewaySpecListenersPatch) *GatewaySpecListenersTlsPatch { return v.Tls }).(GatewaySpecListenersTlsPatchPtrOutput)
}

type GatewaySpecListenersPatchArrayOutput struct{ *pulumi.OutputState }

func (GatewaySpecListenersPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewaySpecListenersPatch)(nil)).Elem()
}

func (o GatewaySpecListenersPatchArrayOutput) ToGatewaySpecListenersPatchArrayOutput() GatewaySpecListenersPatchArrayOutput {
	return o
}

func (o GatewaySpecListenersPatchArrayOutput) ToGatewaySpecListenersPatchArrayOutputWithContext(ctx context.Context) GatewaySpecListenersPatchArrayOutput {
	return o
}

func (o GatewaySpecListenersPatchArrayOutput) Index(i pulumi.IntInput) GatewaySpecListenersPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GatewaySpecListenersPatch {
		return vs[0].([]GatewaySpecListenersPatch)[vs[1].(int)]
	}).(GatewaySpecListenersPatchOutput)
}

// TLS is the TLS configuration for the Listener. This field is required if
// the Protocol field is "HTTPS" or "TLS". It is invalid to set this field
// if the Protocol field is "HTTP", "TCP", or "UDP".
//
// The association of SNIs to Certificate defined in GatewayTLSConfig is
// defined based on the Hostname field for this listener.
//
// The GatewayClass MUST use the longest matching SNI out of all
// available certificates for any TLS handshake.
//
// Support: Core
type GatewaySpecListenersTls struct {
	// CertificateRefs contains a series of references to Kubernetes objects that
	// contains TLS certificates and private keys. These certificates are used to
	// establish a TLS handshake for requests that match the hostname of the
	// associated listener.
	//
	// A single CertificateRef to a Kubernetes Secret has "Core" support.
	// Implementations MAY choose to support attaching multiple certificates to
	// a Listener, but this behavior is implementation-specific.
	//
	// References to a resource in different namespace are invalid UNLESS there
	// is a ReferenceGrant in the target namespace that allows the certificate
	// to be attached. If a ReferenceGrant does not allow this reference, the
	// "ResolvedRefs" condition MUST be set to False for this listener with the
	// "RefNotPermitted" reason.
	//
	// This field is required to have at least one element when the mode is set
	// to "Terminate" (default) and is optional otherwise.
	//
	// CertificateRefs can reference to standard Kubernetes resources, i.e.
	// Secret, or implementation-specific custom resources.
	//
	// Support: Core - A single reference to a Kubernetes Secret of type kubernetes.io/tls
	//
	// Support: Implementation-specific (More than one reference or other resource types)
	CertificateRefs []GatewaySpecListenersTlsCertificateRefs `pulumi:"certificateRefs"`
	// Mode defines the TLS behavior for the TLS session initiated by the client.
	// There are two possible modes:
	//
	// - Terminate: The TLS session between the downstream client and the
	//   Gateway is terminated at the Gateway. This mode requires certificates
	//   to be specified in some way, such as populating the certificateRefs
	//   field.
	// - Passthrough: The TLS session is NOT terminated by the Gateway. This
	//   implies that the Gateway can't decipher the TLS stream except for
	//   the ClientHello message of the TLS protocol. The certificateRefs field
	//   is ignored in this mode.
	//
	// Support: Core
	Mode *string `pulumi:"mode"`
	// Options are a list of key/value pairs to enable extended TLS
	// configuration for each implementation. For example, configuring the
	// minimum TLS version or supported cipher suites.
	//
	// A set of common keys MAY be defined by the API in the future. To avoid
	// any ambiguity, implementation-specific definitions MUST use
	// domain-prefixed names, such as `example.com/my-custom-option`.
	// Un-prefixed names are reserved for key names defined by Gateway API.
	//
	// Support: Implementation-specific
	Options map[string]string `pulumi:"options"`
}

// GatewaySpecListenersTlsInput is an input type that accepts GatewaySpecListenersTlsArgs and GatewaySpecListenersTlsOutput values.
// You can construct a concrete instance of `GatewaySpecListenersTlsInput` via:
//
//	GatewaySpecListenersTlsArgs{...}
type GatewaySpecListenersTlsInput interface {
	pulumi.Input

	ToGatewaySpecListenersTlsOutput() GatewaySpecListenersTlsOutput
	ToGatewaySpecListenersTlsOutputWithContext(context.Context) GatewaySpecListenersTlsOutput
}

// TLS is the TLS configuration for the Listener. This field is required if
// the Protocol field is "HTTPS" or "TLS". It is invalid to set this field
// if the Protocol field is "HTTP", "TCP", or "UDP".
//
// The association of SNIs to Certificate defined in GatewayTLSConfig is
// defined based on the Hostname field for this listener.
//
// The GatewayClass MUST use the longest matching SNI out of all
// available certificates for any TLS handshake.
//
// Support: Core
type GatewaySpecListenersTlsArgs struct {
	// CertificateRefs contains a series of references to Kubernetes objects that
	// contains TLS certificates and private keys. These certificates are used to
	// establish a TLS handshake for requests that match the hostname of the
	// associated listener.
	//
	// A single CertificateRef to a Kubernetes Secret has "Core" support.
	// Implementations MAY choose to support attaching multiple certificates to
	// a Listener, but this behavior is implementation-specific.
	//
	// References to a resource in different namespace are invalid UNLESS there
	// is a ReferenceGrant in the target namespace that allows the certificate
	// to be attached. If a ReferenceGrant does not allow this reference, the
	// "ResolvedRefs" condition MUST be set to False for this listener with the
	// "RefNotPermitted" reason.
	//
	// This field is required to have at least one element when the mode is set
	// to "Terminate" (default) and is optional otherwise.
	//
	// CertificateRefs can reference to standard Kubernetes resources, i.e.
	// Secret, or implementation-specific custom resources.
	//
	// Support: Core - A single reference to a Kubernetes Secret of type kubernetes.io/tls
	//
	// Support: Implementation-specific (More than one reference or other resource types)
	CertificateRefs GatewaySpecListenersTlsCertificateRefsArrayInput `pulumi:"certificateRefs"`
	// Mode defines the TLS behavior for the TLS session initiated by the client.
	// There are two possible modes:
	//
	// - Terminate: The TLS session between the downstream client and the
	//   Gateway is terminated at the Gateway. This mode requires certificates
	//   to be specified in some way, such as populating the certificateRefs
	//   field.
	// - Passthrough: The TLS session is NOT terminated by the Gateway. This
	//   implies that the Gateway can't decipher the TLS stream except for
	//   the ClientHello message of the TLS protocol. The certificateRefs field
	//   is ignored in this mode.
	//
	// Support: Core
	Mode pulumi.StringPtrInput `pulumi:"mode"`
	// Options are a list of key/value pairs to enable extended TLS
	// configuration for each implementation. For example, configuring the
	// minimum TLS version or supported cipher suites.
	//
	// A set of common keys MAY be defined by the API in the future. To avoid
	// any ambiguity, implementation-specific definitions MUST use
	// domain-prefixed names, such as `example.com/my-custom-option`.
	// Un-prefixed names are reserved for key names defined by Gateway API.
	//
	// Support: Implementation-specific
	Options pulumi.StringMapInput `pulumi:"options"`
}

func (GatewaySpecListenersTlsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecListenersTls)(nil)).Elem()
}

func (i GatewaySpecListenersTlsArgs) ToGatewaySpecListenersTlsOutput() GatewaySpecListenersTlsOutput {
	return i.ToGatewaySpecListenersTlsOutputWithContext(context.Background())
}

func (i GatewaySpecListenersTlsArgs) ToGatewaySpecListenersTlsOutputWithContext(ctx context.Context) GatewaySpecListenersTlsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersTlsOutput)
}

func (i GatewaySpecListenersTlsArgs) ToGatewaySpecListenersTlsPtrOutput() GatewaySpecListenersTlsPtrOutput {
	return i.ToGatewaySpecListenersTlsPtrOutputWithContext(context.Background())
}

func (i GatewaySpecListenersTlsArgs) ToGatewaySpecListenersTlsPtrOutputWithContext(ctx context.Context) GatewaySpecListenersTlsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersTlsOutput).ToGatewaySpecListenersTlsPtrOutputWithContext(ctx)
}

// GatewaySpecListenersTlsPtrInput is an input type that accepts GatewaySpecListenersTlsArgs, GatewaySpecListenersTlsPtr and GatewaySpecListenersTlsPtrOutput values.
// You can construct a concrete instance of `GatewaySpecListenersTlsPtrInput` via:
//
//	        GatewaySpecListenersTlsArgs{...}
//
//	or:
//
//	        nil
type GatewaySpecListenersTlsPtrInput interface {
	pulumi.Input

	ToGatewaySpecListenersTlsPtrOutput() GatewaySpecListenersTlsPtrOutput
	ToGatewaySpecListenersTlsPtrOutputWithContext(context.Context) GatewaySpecListenersTlsPtrOutput
}

type gatewaySpecListenersTlsPtrType GatewaySpecListenersTlsArgs

func GatewaySpecListenersTlsPtr(v *GatewaySpecListenersTlsArgs) GatewaySpecListenersTlsPtrInput {
	return (*gatewaySpecListenersTlsPtrType)(v)
}

func (*gatewaySpecListenersTlsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewaySpecListenersTls)(nil)).Elem()
}

func (i *gatewaySpecListenersTlsPtrType) ToGatewaySpecListenersTlsPtrOutput() GatewaySpecListenersTlsPtrOutput {
	return i.ToGatewaySpecListenersTlsPtrOutputWithContext(context.Background())
}

func (i *gatewaySpecListenersTlsPtrType) ToGatewaySpecListenersTlsPtrOutputWithContext(ctx context.Context) GatewaySpecListenersTlsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersTlsPtrOutput)
}

// TLS is the TLS configuration for the Listener. This field is required if
// the Protocol field is "HTTPS" or "TLS". It is invalid to set this field
// if the Protocol field is "HTTP", "TCP", or "UDP".
//
// The association of SNIs to Certificate defined in GatewayTLSConfig is
// defined based on the Hostname field for this listener.
//
// The GatewayClass MUST use the longest matching SNI out of all
// available certificates for any TLS handshake.
//
// Support: Core
type GatewaySpecListenersTlsOutput struct{ *pulumi.OutputState }

func (GatewaySpecListenersTlsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecListenersTls)(nil)).Elem()
}

func (o GatewaySpecListenersTlsOutput) ToGatewaySpecListenersTlsOutput() GatewaySpecListenersTlsOutput {
	return o
}

func (o GatewaySpecListenersTlsOutput) ToGatewaySpecListenersTlsOutputWithContext(ctx context.Context) GatewaySpecListenersTlsOutput {
	return o
}

func (o GatewaySpecListenersTlsOutput) ToGatewaySpecListenersTlsPtrOutput() GatewaySpecListenersTlsPtrOutput {
	return o.ToGatewaySpecListenersTlsPtrOutputWithContext(context.Background())
}

func (o GatewaySpecListenersTlsOutput) ToGatewaySpecListenersTlsPtrOutputWithContext(ctx context.Context) GatewaySpecListenersTlsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GatewaySpecListenersTls) *GatewaySpecListenersTls {
		return &v
	}).(GatewaySpecListenersTlsPtrOutput)
}

// CertificateRefs contains a series of references to Kubernetes objects that
// contains TLS certificates and private keys. These certificates are used to
// establish a TLS handshake for requests that match the hostname of the
// associated listener.
//
// A single CertificateRef to a Kubernetes Secret has "Core" support.
// Implementations MAY choose to support attaching multiple certificates to
// a Listener, but this behavior is implementation-specific.
//
// References to a resource in different namespace are invalid UNLESS there
// is a ReferenceGrant in the target namespace that allows the certificate
// to be attached. If a ReferenceGrant does not allow this reference, the
// "ResolvedRefs" condition MUST be set to False for this listener with the
// "RefNotPermitted" reason.
//
// This field is required to have at least one element when the mode is set
// to "Terminate" (default) and is optional otherwise.
//
// CertificateRefs can reference to standard Kubernetes resources, i.e.
// Secret, or implementation-specific custom resources.
//
// Support: Core - A single reference to a Kubernetes Secret of type kubernetes.io/tls
//
// Support: Implementation-specific (More than one reference or other resource types)
func (o GatewaySpecListenersTlsOutput) CertificateRefs() GatewaySpecListenersTlsCertificateRefsArrayOutput {
	return o.ApplyT(func(v GatewaySpecListenersTls) []GatewaySpecListenersTlsCertificateRefs { return v.CertificateRefs }).(GatewaySpecListenersTlsCertificateRefsArrayOutput)
}

// Mode defines the TLS behavior for the TLS session initiated by the client.
// There are two possible modes:
//
//   - Terminate: The TLS session between the downstream client and the
//     Gateway is terminated at the Gateway. This mode requires certificates
//     to be specified in some way, such as populating the certificateRefs
//     field.
//   - Passthrough: The TLS session is NOT terminated by the Gateway. This
//     implies that the Gateway can't decipher the TLS stream except for
//     the ClientHello message of the TLS protocol. The certificateRefs field
//     is ignored in this mode.
//
// Support: Core
func (o GatewaySpecListenersTlsOutput) Mode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewaySpecListenersTls) *string { return v.Mode }).(pulumi.StringPtrOutput)
}

// Options are a list of key/value pairs to enable extended TLS
// configuration for each implementation. For example, configuring the
// minimum TLS version or supported cipher suites.
//
// A set of common keys MAY be defined by the API in the future. To avoid
// any ambiguity, implementation-specific definitions MUST use
// domain-prefixed names, such as `example.com/my-custom-option`.
// Un-prefixed names are reserved for key names defined by Gateway API.
//
// Support: Implementation-specific
func (o GatewaySpecListenersTlsOutput) Options() pulumi.StringMapOutput {
	return o.ApplyT(func(v GatewaySpecListenersTls) map[string]string { return v.Options }).(pulumi.StringMapOutput)
}

type GatewaySpecListenersTlsPtrOutput struct{ *pulumi.OutputState }

func (GatewaySpecListenersTlsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewaySpecListenersTls)(nil)).Elem()
}

func (o GatewaySpecListenersTlsPtrOutput) ToGatewaySpecListenersTlsPtrOutput() GatewaySpecListenersTlsPtrOutput {
	return o
}

func (o GatewaySpecListenersTlsPtrOutput) ToGatewaySpecListenersTlsPtrOutputWithContext(ctx context.Context) GatewaySpecListenersTlsPtrOutput {
	return o
}

func (o GatewaySpecListenersTlsPtrOutput) Elem() GatewaySpecListenersTlsOutput {
	return o.ApplyT(func(v *GatewaySpecListenersTls) GatewaySpecListenersTls {
		if v != nil {
			return *v
		}
		var ret GatewaySpecListenersTls
		return ret
	}).(GatewaySpecListenersTlsOutput)
}

// CertificateRefs contains a series of references to Kubernetes objects that
// contains TLS certificates and private keys. These certificates are used to
// establish a TLS handshake for requests that match the hostname of the
// associated listener.
//
// A single CertificateRef to a Kubernetes Secret has "Core" support.
// Implementations MAY choose to support attaching multiple certificates to
// a Listener, but this behavior is implementation-specific.
//
// References to a resource in different namespace are invalid UNLESS there
// is a ReferenceGrant in the target namespace that allows the certificate
// to be attached. If a ReferenceGrant does not allow this reference, the
// "ResolvedRefs" condition MUST be set to False for this listener with the
// "RefNotPermitted" reason.
//
// This field is required to have at least one element when the mode is set
// to "Terminate" (default) and is optional otherwise.
//
// CertificateRefs can reference to standard Kubernetes resources, i.e.
// Secret, or implementation-specific custom resources.
//
// Support: Core - A single reference to a Kubernetes Secret of type kubernetes.io/tls
//
// Support: Implementation-specific (More than one reference or other resource types)
func (o GatewaySpecListenersTlsPtrOutput) CertificateRefs() GatewaySpecListenersTlsCertificateRefsArrayOutput {
	return o.ApplyT(func(v *GatewaySpecListenersTls) []GatewaySpecListenersTlsCertificateRefs {
		if v == nil {
			return nil
		}
		return v.CertificateRefs
	}).(GatewaySpecListenersTlsCertificateRefsArrayOutput)
}

// Mode defines the TLS behavior for the TLS session initiated by the client.
// There are two possible modes:
//
//   - Terminate: The TLS session between the downstream client and the
//     Gateway is terminated at the Gateway. This mode requires certificates
//     to be specified in some way, such as populating the certificateRefs
//     field.
//   - Passthrough: The TLS session is NOT terminated by the Gateway. This
//     implies that the Gateway can't decipher the TLS stream except for
//     the ClientHello message of the TLS protocol. The certificateRefs field
//     is ignored in this mode.
//
// Support: Core
func (o GatewaySpecListenersTlsPtrOutput) Mode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GatewaySpecListenersTls) *string {
		if v == nil {
			return nil
		}
		return v.Mode
	}).(pulumi.StringPtrOutput)
}

// Options are a list of key/value pairs to enable extended TLS
// configuration for each implementation. For example, configuring the
// minimum TLS version or supported cipher suites.
//
// A set of common keys MAY be defined by the API in the future. To avoid
// any ambiguity, implementation-specific definitions MUST use
// domain-prefixed names, such as `example.com/my-custom-option`.
// Un-prefixed names are reserved for key names defined by Gateway API.
//
// Support: Implementation-specific
func (o GatewaySpecListenersTlsPtrOutput) Options() pulumi.StringMapOutput {
	return o.ApplyT(func(v *GatewaySpecListenersTls) map[string]string {
		if v == nil {
			return nil
		}
		return v.Options
	}).(pulumi.StringMapOutput)
}

// SecretObjectReference identifies an API object including its namespace,
// defaulting to Secret.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
//
// References to objects with invalid Group and Kind are not valid, and must
// be rejected by the implementation, with appropriate Conditions set
// on the containing object.
type GatewaySpecListenersTlsCertificateRefs struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group *string `pulumi:"group"`
	// Kind is kind of the referent. For example "Secret".
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	Name *string `pulumi:"name"`
	// Namespace is the namespace of the referenced object. When unspecified, the local
	// namespace is inferred.
	//
	// Note that when a namespace different than the local namespace is specified,
	// a ReferenceGrant object is required in the referent namespace to allow that
	// namespace's owner to accept the reference. See the ReferenceGrant
	// documentation for details.
	//
	// Support: Core
	Namespace *string `pulumi:"namespace"`
}

// GatewaySpecListenersTlsCertificateRefsInput is an input type that accepts GatewaySpecListenersTlsCertificateRefsArgs and GatewaySpecListenersTlsCertificateRefsOutput values.
// You can construct a concrete instance of `GatewaySpecListenersTlsCertificateRefsInput` via:
//
//	GatewaySpecListenersTlsCertificateRefsArgs{...}
type GatewaySpecListenersTlsCertificateRefsInput interface {
	pulumi.Input

	ToGatewaySpecListenersTlsCertificateRefsOutput() GatewaySpecListenersTlsCertificateRefsOutput
	ToGatewaySpecListenersTlsCertificateRefsOutputWithContext(context.Context) GatewaySpecListenersTlsCertificateRefsOutput
}

// SecretObjectReference identifies an API object including its namespace,
// defaulting to Secret.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
//
// References to objects with invalid Group and Kind are not valid, and must
// be rejected by the implementation, with appropriate Conditions set
// on the containing object.
type GatewaySpecListenersTlsCertificateRefsArgs struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is kind of the referent. For example "Secret".
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace is the namespace of the referenced object. When unspecified, the local
	// namespace is inferred.
	//
	// Note that when a namespace different than the local namespace is specified,
	// a ReferenceGrant object is required in the referent namespace to allow that
	// namespace's owner to accept the reference. See the ReferenceGrant
	// documentation for details.
	//
	// Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
}

func (GatewaySpecListenersTlsCertificateRefsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecListenersTlsCertificateRefs)(nil)).Elem()
}

func (i GatewaySpecListenersTlsCertificateRefsArgs) ToGatewaySpecListenersTlsCertificateRefsOutput() GatewaySpecListenersTlsCertificateRefsOutput {
	return i.ToGatewaySpecListenersTlsCertificateRefsOutputWithContext(context.Background())
}

func (i GatewaySpecListenersTlsCertificateRefsArgs) ToGatewaySpecListenersTlsCertificateRefsOutputWithContext(ctx context.Context) GatewaySpecListenersTlsCertificateRefsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersTlsCertificateRefsOutput)
}

// GatewaySpecListenersTlsCertificateRefsArrayInput is an input type that accepts GatewaySpecListenersTlsCertificateRefsArray and GatewaySpecListenersTlsCertificateRefsArrayOutput values.
// You can construct a concrete instance of `GatewaySpecListenersTlsCertificateRefsArrayInput` via:
//
//	GatewaySpecListenersTlsCertificateRefsArray{ GatewaySpecListenersTlsCertificateRefsArgs{...} }
type GatewaySpecListenersTlsCertificateRefsArrayInput interface {
	pulumi.Input

	ToGatewaySpecListenersTlsCertificateRefsArrayOutput() GatewaySpecListenersTlsCertificateRefsArrayOutput
	ToGatewaySpecListenersTlsCertificateRefsArrayOutputWithContext(context.Context) GatewaySpecListenersTlsCertificateRefsArrayOutput
}

type GatewaySpecListenersTlsCertificateRefsArray []GatewaySpecListenersTlsCertificateRefsInput

func (GatewaySpecListenersTlsCertificateRefsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewaySpecListenersTlsCertificateRefs)(nil)).Elem()
}

func (i GatewaySpecListenersTlsCertificateRefsArray) ToGatewaySpecListenersTlsCertificateRefsArrayOutput() GatewaySpecListenersTlsCertificateRefsArrayOutput {
	return i.ToGatewaySpecListenersTlsCertificateRefsArrayOutputWithContext(context.Background())
}

func (i GatewaySpecListenersTlsCertificateRefsArray) ToGatewaySpecListenersTlsCertificateRefsArrayOutputWithContext(ctx context.Context) GatewaySpecListenersTlsCertificateRefsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersTlsCertificateRefsArrayOutput)
}

// SecretObjectReference identifies an API object including its namespace,
// defaulting to Secret.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
//
// References to objects with invalid Group and Kind are not valid, and must
// be rejected by the implementation, with appropriate Conditions set
// on the containing object.
type GatewaySpecListenersTlsCertificateRefsOutput struct{ *pulumi.OutputState }

func (GatewaySpecListenersTlsCertificateRefsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecListenersTlsCertificateRefs)(nil)).Elem()
}

func (o GatewaySpecListenersTlsCertificateRefsOutput) ToGatewaySpecListenersTlsCertificateRefsOutput() GatewaySpecListenersTlsCertificateRefsOutput {
	return o
}

func (o GatewaySpecListenersTlsCertificateRefsOutput) ToGatewaySpecListenersTlsCertificateRefsOutputWithContext(ctx context.Context) GatewaySpecListenersTlsCertificateRefsOutput {
	return o
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o GatewaySpecListenersTlsCertificateRefsOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewaySpecListenersTlsCertificateRefs) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent. For example "Secret".
func (o GatewaySpecListenersTlsCertificateRefsOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewaySpecListenersTlsCertificateRefs) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o GatewaySpecListenersTlsCertificateRefsOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewaySpecListenersTlsCertificateRefs) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the referenced object. When unspecified, the local
// namespace is inferred.
//
// Note that when a namespace different than the local namespace is specified,
// a ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// Support: Core
func (o GatewaySpecListenersTlsCertificateRefsOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewaySpecListenersTlsCertificateRefs) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

type GatewaySpecListenersTlsCertificateRefsArrayOutput struct{ *pulumi.OutputState }

func (GatewaySpecListenersTlsCertificateRefsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewaySpecListenersTlsCertificateRefs)(nil)).Elem()
}

func (o GatewaySpecListenersTlsCertificateRefsArrayOutput) ToGatewaySpecListenersTlsCertificateRefsArrayOutput() GatewaySpecListenersTlsCertificateRefsArrayOutput {
	return o
}

func (o GatewaySpecListenersTlsCertificateRefsArrayOutput) ToGatewaySpecListenersTlsCertificateRefsArrayOutputWithContext(ctx context.Context) GatewaySpecListenersTlsCertificateRefsArrayOutput {
	return o
}

func (o GatewaySpecListenersTlsCertificateRefsArrayOutput) Index(i pulumi.IntInput) GatewaySpecListenersTlsCertificateRefsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GatewaySpecListenersTlsCertificateRefs {
		return vs[0].([]GatewaySpecListenersTlsCertificateRefs)[vs[1].(int)]
	}).(GatewaySpecListenersTlsCertificateRefsOutput)
}

// SecretObjectReference identifies an API object including its namespace,
// defaulting to Secret.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
//
// References to objects with invalid Group and Kind are not valid, and must
// be rejected by the implementation, with appropriate Conditions set
// on the containing object.
type GatewaySpecListenersTlsCertificateRefsPatch struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group *string `pulumi:"group"`
	// Kind is kind of the referent. For example "Secret".
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	Name *string `pulumi:"name"`
	// Namespace is the namespace of the referenced object. When unspecified, the local
	// namespace is inferred.
	//
	// Note that when a namespace different than the local namespace is specified,
	// a ReferenceGrant object is required in the referent namespace to allow that
	// namespace's owner to accept the reference. See the ReferenceGrant
	// documentation for details.
	//
	// Support: Core
	Namespace *string `pulumi:"namespace"`
}

// GatewaySpecListenersTlsCertificateRefsPatchInput is an input type that accepts GatewaySpecListenersTlsCertificateRefsPatchArgs and GatewaySpecListenersTlsCertificateRefsPatchOutput values.
// You can construct a concrete instance of `GatewaySpecListenersTlsCertificateRefsPatchInput` via:
//
//	GatewaySpecListenersTlsCertificateRefsPatchArgs{...}
type GatewaySpecListenersTlsCertificateRefsPatchInput interface {
	pulumi.Input

	ToGatewaySpecListenersTlsCertificateRefsPatchOutput() GatewaySpecListenersTlsCertificateRefsPatchOutput
	ToGatewaySpecListenersTlsCertificateRefsPatchOutputWithContext(context.Context) GatewaySpecListenersTlsCertificateRefsPatchOutput
}

// SecretObjectReference identifies an API object including its namespace,
// defaulting to Secret.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
//
// References to objects with invalid Group and Kind are not valid, and must
// be rejected by the implementation, with appropriate Conditions set
// on the containing object.
type GatewaySpecListenersTlsCertificateRefsPatchArgs struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is kind of the referent. For example "Secret".
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace is the namespace of the referenced object. When unspecified, the local
	// namespace is inferred.
	//
	// Note that when a namespace different than the local namespace is specified,
	// a ReferenceGrant object is required in the referent namespace to allow that
	// namespace's owner to accept the reference. See the ReferenceGrant
	// documentation for details.
	//
	// Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
}

func (GatewaySpecListenersTlsCertificateRefsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecListenersTlsCertificateRefsPatch)(nil)).Elem()
}

func (i GatewaySpecListenersTlsCertificateRefsPatchArgs) ToGatewaySpecListenersTlsCertificateRefsPatchOutput() GatewaySpecListenersTlsCertificateRefsPatchOutput {
	return i.ToGatewaySpecListenersTlsCertificateRefsPatchOutputWithContext(context.Background())
}

func (i GatewaySpecListenersTlsCertificateRefsPatchArgs) ToGatewaySpecListenersTlsCertificateRefsPatchOutputWithContext(ctx context.Context) GatewaySpecListenersTlsCertificateRefsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersTlsCertificateRefsPatchOutput)
}

// GatewaySpecListenersTlsCertificateRefsPatchArrayInput is an input type that accepts GatewaySpecListenersTlsCertificateRefsPatchArray and GatewaySpecListenersTlsCertificateRefsPatchArrayOutput values.
// You can construct a concrete instance of `GatewaySpecListenersTlsCertificateRefsPatchArrayInput` via:
//
//	GatewaySpecListenersTlsCertificateRefsPatchArray{ GatewaySpecListenersTlsCertificateRefsPatchArgs{...} }
type GatewaySpecListenersTlsCertificateRefsPatchArrayInput interface {
	pulumi.Input

	ToGatewaySpecListenersTlsCertificateRefsPatchArrayOutput() GatewaySpecListenersTlsCertificateRefsPatchArrayOutput
	ToGatewaySpecListenersTlsCertificateRefsPatchArrayOutputWithContext(context.Context) GatewaySpecListenersTlsCertificateRefsPatchArrayOutput
}

type GatewaySpecListenersTlsCertificateRefsPatchArray []GatewaySpecListenersTlsCertificateRefsPatchInput

func (GatewaySpecListenersTlsCertificateRefsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewaySpecListenersTlsCertificateRefsPatch)(nil)).Elem()
}

func (i GatewaySpecListenersTlsCertificateRefsPatchArray) ToGatewaySpecListenersTlsCertificateRefsPatchArrayOutput() GatewaySpecListenersTlsCertificateRefsPatchArrayOutput {
	return i.ToGatewaySpecListenersTlsCertificateRefsPatchArrayOutputWithContext(context.Background())
}

func (i GatewaySpecListenersTlsCertificateRefsPatchArray) ToGatewaySpecListenersTlsCertificateRefsPatchArrayOutputWithContext(ctx context.Context) GatewaySpecListenersTlsCertificateRefsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersTlsCertificateRefsPatchArrayOutput)
}

// SecretObjectReference identifies an API object including its namespace,
// defaulting to Secret.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
//
// References to objects with invalid Group and Kind are not valid, and must
// be rejected by the implementation, with appropriate Conditions set
// on the containing object.
type GatewaySpecListenersTlsCertificateRefsPatchOutput struct{ *pulumi.OutputState }

func (GatewaySpecListenersTlsCertificateRefsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecListenersTlsCertificateRefsPatch)(nil)).Elem()
}

func (o GatewaySpecListenersTlsCertificateRefsPatchOutput) ToGatewaySpecListenersTlsCertificateRefsPatchOutput() GatewaySpecListenersTlsCertificateRefsPatchOutput {
	return o
}

func (o GatewaySpecListenersTlsCertificateRefsPatchOutput) ToGatewaySpecListenersTlsCertificateRefsPatchOutputWithContext(ctx context.Context) GatewaySpecListenersTlsCertificateRefsPatchOutput {
	return o
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o GatewaySpecListenersTlsCertificateRefsPatchOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewaySpecListenersTlsCertificateRefsPatch) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent. For example "Secret".
func (o GatewaySpecListenersTlsCertificateRefsPatchOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewaySpecListenersTlsCertificateRefsPatch) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o GatewaySpecListenersTlsCertificateRefsPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewaySpecListenersTlsCertificateRefsPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the referenced object. When unspecified, the local
// namespace is inferred.
//
// Note that when a namespace different than the local namespace is specified,
// a ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// Support: Core
func (o GatewaySpecListenersTlsCertificateRefsPatchOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewaySpecListenersTlsCertificateRefsPatch) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

type GatewaySpecListenersTlsCertificateRefsPatchArrayOutput struct{ *pulumi.OutputState }

func (GatewaySpecListenersTlsCertificateRefsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewaySpecListenersTlsCertificateRefsPatch)(nil)).Elem()
}

func (o GatewaySpecListenersTlsCertificateRefsPatchArrayOutput) ToGatewaySpecListenersTlsCertificateRefsPatchArrayOutput() GatewaySpecListenersTlsCertificateRefsPatchArrayOutput {
	return o
}

func (o GatewaySpecListenersTlsCertificateRefsPatchArrayOutput) ToGatewaySpecListenersTlsCertificateRefsPatchArrayOutputWithContext(ctx context.Context) GatewaySpecListenersTlsCertificateRefsPatchArrayOutput {
	return o
}

func (o GatewaySpecListenersTlsCertificateRefsPatchArrayOutput) Index(i pulumi.IntInput) GatewaySpecListenersTlsCertificateRefsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GatewaySpecListenersTlsCertificateRefsPatch {
		return vs[0].([]GatewaySpecListenersTlsCertificateRefsPatch)[vs[1].(int)]
	}).(GatewaySpecListenersTlsCertificateRefsPatchOutput)
}

// TLS is the TLS configuration for the Listener. This field is required if
// the Protocol field is "HTTPS" or "TLS". It is invalid to set this field
// if the Protocol field is "HTTP", "TCP", or "UDP".
//
// The association of SNIs to Certificate defined in GatewayTLSConfig is
// defined based on the Hostname field for this listener.
//
// The GatewayClass MUST use the longest matching SNI out of all
// available certificates for any TLS handshake.
//
// Support: Core
type GatewaySpecListenersTlsPatch struct {
	// CertificateRefs contains a series of references to Kubernetes objects that
	// contains TLS certificates and private keys. These certificates are used to
	// establish a TLS handshake for requests that match the hostname of the
	// associated listener.
	//
	// A single CertificateRef to a Kubernetes Secret has "Core" support.
	// Implementations MAY choose to support attaching multiple certificates to
	// a Listener, but this behavior is implementation-specific.
	//
	// References to a resource in different namespace are invalid UNLESS there
	// is a ReferenceGrant in the target namespace that allows the certificate
	// to be attached. If a ReferenceGrant does not allow this reference, the
	// "ResolvedRefs" condition MUST be set to False for this listener with the
	// "RefNotPermitted" reason.
	//
	// This field is required to have at least one element when the mode is set
	// to "Terminate" (default) and is optional otherwise.
	//
	// CertificateRefs can reference to standard Kubernetes resources, i.e.
	// Secret, or implementation-specific custom resources.
	//
	// Support: Core - A single reference to a Kubernetes Secret of type kubernetes.io/tls
	//
	// Support: Implementation-specific (More than one reference or other resource types)
	CertificateRefs []GatewaySpecListenersTlsCertificateRefsPatch `pulumi:"certificateRefs"`
	// Mode defines the TLS behavior for the TLS session initiated by the client.
	// There are two possible modes:
	//
	// - Terminate: The TLS session between the downstream client and the
	//   Gateway is terminated at the Gateway. This mode requires certificates
	//   to be specified in some way, such as populating the certificateRefs
	//   field.
	// - Passthrough: The TLS session is NOT terminated by the Gateway. This
	//   implies that the Gateway can't decipher the TLS stream except for
	//   the ClientHello message of the TLS protocol. The certificateRefs field
	//   is ignored in this mode.
	//
	// Support: Core
	Mode *string `pulumi:"mode"`
	// Options are a list of key/value pairs to enable extended TLS
	// configuration for each implementation. For example, configuring the
	// minimum TLS version or supported cipher suites.
	//
	// A set of common keys MAY be defined by the API in the future. To avoid
	// any ambiguity, implementation-specific definitions MUST use
	// domain-prefixed names, such as `example.com/my-custom-option`.
	// Un-prefixed names are reserved for key names defined by Gateway API.
	//
	// Support: Implementation-specific
	Options map[string]string `pulumi:"options"`
}

// GatewaySpecListenersTlsPatchInput is an input type that accepts GatewaySpecListenersTlsPatchArgs and GatewaySpecListenersTlsPatchOutput values.
// You can construct a concrete instance of `GatewaySpecListenersTlsPatchInput` via:
//
//	GatewaySpecListenersTlsPatchArgs{...}
type GatewaySpecListenersTlsPatchInput interface {
	pulumi.Input

	ToGatewaySpecListenersTlsPatchOutput() GatewaySpecListenersTlsPatchOutput
	ToGatewaySpecListenersTlsPatchOutputWithContext(context.Context) GatewaySpecListenersTlsPatchOutput
}

// TLS is the TLS configuration for the Listener. This field is required if
// the Protocol field is "HTTPS" or "TLS". It is invalid to set this field
// if the Protocol field is "HTTP", "TCP", or "UDP".
//
// The association of SNIs to Certificate defined in GatewayTLSConfig is
// defined based on the Hostname field for this listener.
//
// The GatewayClass MUST use the longest matching SNI out of all
// available certificates for any TLS handshake.
//
// Support: Core
type GatewaySpecListenersTlsPatchArgs struct {
	// CertificateRefs contains a series of references to Kubernetes objects that
	// contains TLS certificates and private keys. These certificates are used to
	// establish a TLS handshake for requests that match the hostname of the
	// associated listener.
	//
	// A single CertificateRef to a Kubernetes Secret has "Core" support.
	// Implementations MAY choose to support attaching multiple certificates to
	// a Listener, but this behavior is implementation-specific.
	//
	// References to a resource in different namespace are invalid UNLESS there
	// is a ReferenceGrant in the target namespace that allows the certificate
	// to be attached. If a ReferenceGrant does not allow this reference, the
	// "ResolvedRefs" condition MUST be set to False for this listener with the
	// "RefNotPermitted" reason.
	//
	// This field is required to have at least one element when the mode is set
	// to "Terminate" (default) and is optional otherwise.
	//
	// CertificateRefs can reference to standard Kubernetes resources, i.e.
	// Secret, or implementation-specific custom resources.
	//
	// Support: Core - A single reference to a Kubernetes Secret of type kubernetes.io/tls
	//
	// Support: Implementation-specific (More than one reference or other resource types)
	CertificateRefs GatewaySpecListenersTlsCertificateRefsPatchArrayInput `pulumi:"certificateRefs"`
	// Mode defines the TLS behavior for the TLS session initiated by the client.
	// There are two possible modes:
	//
	// - Terminate: The TLS session between the downstream client and the
	//   Gateway is terminated at the Gateway. This mode requires certificates
	//   to be specified in some way, such as populating the certificateRefs
	//   field.
	// - Passthrough: The TLS session is NOT terminated by the Gateway. This
	//   implies that the Gateway can't decipher the TLS stream except for
	//   the ClientHello message of the TLS protocol. The certificateRefs field
	//   is ignored in this mode.
	//
	// Support: Core
	Mode pulumi.StringPtrInput `pulumi:"mode"`
	// Options are a list of key/value pairs to enable extended TLS
	// configuration for each implementation. For example, configuring the
	// minimum TLS version or supported cipher suites.
	//
	// A set of common keys MAY be defined by the API in the future. To avoid
	// any ambiguity, implementation-specific definitions MUST use
	// domain-prefixed names, such as `example.com/my-custom-option`.
	// Un-prefixed names are reserved for key names defined by Gateway API.
	//
	// Support: Implementation-specific
	Options pulumi.StringMapInput `pulumi:"options"`
}

func (GatewaySpecListenersTlsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecListenersTlsPatch)(nil)).Elem()
}

func (i GatewaySpecListenersTlsPatchArgs) ToGatewaySpecListenersTlsPatchOutput() GatewaySpecListenersTlsPatchOutput {
	return i.ToGatewaySpecListenersTlsPatchOutputWithContext(context.Background())
}

func (i GatewaySpecListenersTlsPatchArgs) ToGatewaySpecListenersTlsPatchOutputWithContext(ctx context.Context) GatewaySpecListenersTlsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersTlsPatchOutput)
}

func (i GatewaySpecListenersTlsPatchArgs) ToGatewaySpecListenersTlsPatchPtrOutput() GatewaySpecListenersTlsPatchPtrOutput {
	return i.ToGatewaySpecListenersTlsPatchPtrOutputWithContext(context.Background())
}

func (i GatewaySpecListenersTlsPatchArgs) ToGatewaySpecListenersTlsPatchPtrOutputWithContext(ctx context.Context) GatewaySpecListenersTlsPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersTlsPatchOutput).ToGatewaySpecListenersTlsPatchPtrOutputWithContext(ctx)
}

// GatewaySpecListenersTlsPatchPtrInput is an input type that accepts GatewaySpecListenersTlsPatchArgs, GatewaySpecListenersTlsPatchPtr and GatewaySpecListenersTlsPatchPtrOutput values.
// You can construct a concrete instance of `GatewaySpecListenersTlsPatchPtrInput` via:
//
//	        GatewaySpecListenersTlsPatchArgs{...}
//
//	or:
//
//	        nil
type GatewaySpecListenersTlsPatchPtrInput interface {
	pulumi.Input

	ToGatewaySpecListenersTlsPatchPtrOutput() GatewaySpecListenersTlsPatchPtrOutput
	ToGatewaySpecListenersTlsPatchPtrOutputWithContext(context.Context) GatewaySpecListenersTlsPatchPtrOutput
}

type gatewaySpecListenersTlsPatchPtrType GatewaySpecListenersTlsPatchArgs

func GatewaySpecListenersTlsPatchPtr(v *GatewaySpecListenersTlsPatchArgs) GatewaySpecListenersTlsPatchPtrInput {
	return (*gatewaySpecListenersTlsPatchPtrType)(v)
}

func (*gatewaySpecListenersTlsPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewaySpecListenersTlsPatch)(nil)).Elem()
}

func (i *gatewaySpecListenersTlsPatchPtrType) ToGatewaySpecListenersTlsPatchPtrOutput() GatewaySpecListenersTlsPatchPtrOutput {
	return i.ToGatewaySpecListenersTlsPatchPtrOutputWithContext(context.Background())
}

func (i *gatewaySpecListenersTlsPatchPtrType) ToGatewaySpecListenersTlsPatchPtrOutputWithContext(ctx context.Context) GatewaySpecListenersTlsPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecListenersTlsPatchPtrOutput)
}

// TLS is the TLS configuration for the Listener. This field is required if
// the Protocol field is "HTTPS" or "TLS". It is invalid to set this field
// if the Protocol field is "HTTP", "TCP", or "UDP".
//
// The association of SNIs to Certificate defined in GatewayTLSConfig is
// defined based on the Hostname field for this listener.
//
// The GatewayClass MUST use the longest matching SNI out of all
// available certificates for any TLS handshake.
//
// Support: Core
type GatewaySpecListenersTlsPatchOutput struct{ *pulumi.OutputState }

func (GatewaySpecListenersTlsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecListenersTlsPatch)(nil)).Elem()
}

func (o GatewaySpecListenersTlsPatchOutput) ToGatewaySpecListenersTlsPatchOutput() GatewaySpecListenersTlsPatchOutput {
	return o
}

func (o GatewaySpecListenersTlsPatchOutput) ToGatewaySpecListenersTlsPatchOutputWithContext(ctx context.Context) GatewaySpecListenersTlsPatchOutput {
	return o
}

func (o GatewaySpecListenersTlsPatchOutput) ToGatewaySpecListenersTlsPatchPtrOutput() GatewaySpecListenersTlsPatchPtrOutput {
	return o.ToGatewaySpecListenersTlsPatchPtrOutputWithContext(context.Background())
}

func (o GatewaySpecListenersTlsPatchOutput) ToGatewaySpecListenersTlsPatchPtrOutputWithContext(ctx context.Context) GatewaySpecListenersTlsPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GatewaySpecListenersTlsPatch) *GatewaySpecListenersTlsPatch {
		return &v
	}).(GatewaySpecListenersTlsPatchPtrOutput)
}

// CertificateRefs contains a series of references to Kubernetes objects that
// contains TLS certificates and private keys. These certificates are used to
// establish a TLS handshake for requests that match the hostname of the
// associated listener.
//
// A single CertificateRef to a Kubernetes Secret has "Core" support.
// Implementations MAY choose to support attaching multiple certificates to
// a Listener, but this behavior is implementation-specific.
//
// References to a resource in different namespace are invalid UNLESS there
// is a ReferenceGrant in the target namespace that allows the certificate
// to be attached. If a ReferenceGrant does not allow this reference, the
// "ResolvedRefs" condition MUST be set to False for this listener with the
// "RefNotPermitted" reason.
//
// This field is required to have at least one element when the mode is set
// to "Terminate" (default) and is optional otherwise.
//
// CertificateRefs can reference to standard Kubernetes resources, i.e.
// Secret, or implementation-specific custom resources.
//
// Support: Core - A single reference to a Kubernetes Secret of type kubernetes.io/tls
//
// Support: Implementation-specific (More than one reference or other resource types)
func (o GatewaySpecListenersTlsPatchOutput) CertificateRefs() GatewaySpecListenersTlsCertificateRefsPatchArrayOutput {
	return o.ApplyT(func(v GatewaySpecListenersTlsPatch) []GatewaySpecListenersTlsCertificateRefsPatch {
		return v.CertificateRefs
	}).(GatewaySpecListenersTlsCertificateRefsPatchArrayOutput)
}

// Mode defines the TLS behavior for the TLS session initiated by the client.
// There are two possible modes:
//
//   - Terminate: The TLS session between the downstream client and the
//     Gateway is terminated at the Gateway. This mode requires certificates
//     to be specified in some way, such as populating the certificateRefs
//     field.
//   - Passthrough: The TLS session is NOT terminated by the Gateway. This
//     implies that the Gateway can't decipher the TLS stream except for
//     the ClientHello message of the TLS protocol. The certificateRefs field
//     is ignored in this mode.
//
// Support: Core
func (o GatewaySpecListenersTlsPatchOutput) Mode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewaySpecListenersTlsPatch) *string { return v.Mode }).(pulumi.StringPtrOutput)
}

// Options are a list of key/value pairs to enable extended TLS
// configuration for each implementation. For example, configuring the
// minimum TLS version or supported cipher suites.
//
// A set of common keys MAY be defined by the API in the future. To avoid
// any ambiguity, implementation-specific definitions MUST use
// domain-prefixed names, such as `example.com/my-custom-option`.
// Un-prefixed names are reserved for key names defined by Gateway API.
//
// Support: Implementation-specific
func (o GatewaySpecListenersTlsPatchOutput) Options() pulumi.StringMapOutput {
	return o.ApplyT(func(v GatewaySpecListenersTlsPatch) map[string]string { return v.Options }).(pulumi.StringMapOutput)
}

type GatewaySpecListenersTlsPatchPtrOutput struct{ *pulumi.OutputState }

func (GatewaySpecListenersTlsPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewaySpecListenersTlsPatch)(nil)).Elem()
}

func (o GatewaySpecListenersTlsPatchPtrOutput) ToGatewaySpecListenersTlsPatchPtrOutput() GatewaySpecListenersTlsPatchPtrOutput {
	return o
}

func (o GatewaySpecListenersTlsPatchPtrOutput) ToGatewaySpecListenersTlsPatchPtrOutputWithContext(ctx context.Context) GatewaySpecListenersTlsPatchPtrOutput {
	return o
}

func (o GatewaySpecListenersTlsPatchPtrOutput) Elem() GatewaySpecListenersTlsPatchOutput {
	return o.ApplyT(func(v *GatewaySpecListenersTlsPatch) GatewaySpecListenersTlsPatch {
		if v != nil {
			return *v
		}
		var ret GatewaySpecListenersTlsPatch
		return ret
	}).(GatewaySpecListenersTlsPatchOutput)
}

// CertificateRefs contains a series of references to Kubernetes objects that
// contains TLS certificates and private keys. These certificates are used to
// establish a TLS handshake for requests that match the hostname of the
// associated listener.
//
// A single CertificateRef to a Kubernetes Secret has "Core" support.
// Implementations MAY choose to support attaching multiple certificates to
// a Listener, but this behavior is implementation-specific.
//
// References to a resource in different namespace are invalid UNLESS there
// is a ReferenceGrant in the target namespace that allows the certificate
// to be attached. If a ReferenceGrant does not allow this reference, the
// "ResolvedRefs" condition MUST be set to False for this listener with the
// "RefNotPermitted" reason.
//
// This field is required to have at least one element when the mode is set
// to "Terminate" (default) and is optional otherwise.
//
// CertificateRefs can reference to standard Kubernetes resources, i.e.
// Secret, or implementation-specific custom resources.
//
// Support: Core - A single reference to a Kubernetes Secret of type kubernetes.io/tls
//
// Support: Implementation-specific (More than one reference or other resource types)
func (o GatewaySpecListenersTlsPatchPtrOutput) CertificateRefs() GatewaySpecListenersTlsCertificateRefsPatchArrayOutput {
	return o.ApplyT(func(v *GatewaySpecListenersTlsPatch) []GatewaySpecListenersTlsCertificateRefsPatch {
		if v == nil {
			return nil
		}
		return v.CertificateRefs
	}).(GatewaySpecListenersTlsCertificateRefsPatchArrayOutput)
}

// Mode defines the TLS behavior for the TLS session initiated by the client.
// There are two possible modes:
//
//   - Terminate: The TLS session between the downstream client and the
//     Gateway is terminated at the Gateway. This mode requires certificates
//     to be specified in some way, such as populating the certificateRefs
//     field.
//   - Passthrough: The TLS session is NOT terminated by the Gateway. This
//     implies that the Gateway can't decipher the TLS stream except for
//     the ClientHello message of the TLS protocol. The certificateRefs field
//     is ignored in this mode.
//
// Support: Core
func (o GatewaySpecListenersTlsPatchPtrOutput) Mode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GatewaySpecListenersTlsPatch) *string {
		if v == nil {
			return nil
		}
		return v.Mode
	}).(pulumi.StringPtrOutput)
}

// Options are a list of key/value pairs to enable extended TLS
// configuration for each implementation. For example, configuring the
// minimum TLS version or supported cipher suites.
//
// A set of common keys MAY be defined by the API in the future. To avoid
// any ambiguity, implementation-specific definitions MUST use
// domain-prefixed names, such as `example.com/my-custom-option`.
// Un-prefixed names are reserved for key names defined by Gateway API.
//
// Support: Implementation-specific
func (o GatewaySpecListenersTlsPatchPtrOutput) Options() pulumi.StringMapOutput {
	return o.ApplyT(func(v *GatewaySpecListenersTlsPatch) map[string]string {
		if v == nil {
			return nil
		}
		return v.Options
	}).(pulumi.StringMapOutput)
}

// Spec defines the desired state of Gateway.
type GatewaySpecPatch struct {
	// Addresses requested for this Gateway. This is optional and behavior can
	// depend on the implementation. If a value is set in the spec and the
	// requested address is invalid or unavailable, the implementation MUST
	// indicate this in the associated entry in GatewayStatus.Addresses.
	//
	// The Addresses field represents a request for the address(es) on the
	// "outside of the Gateway", that traffic bound for this Gateway will use.
	// This could be the IP address or hostname of an external load balancer or
	// other networking infrastructure, or some other address that traffic will
	// be sent to.
	//
	// If no Addresses are specified, the implementation MAY schedule the
	// Gateway in an implementation-specific manner, assigning an appropriate
	// set of Addresses.
	//
	// The implementation MUST bind all Listeners to every GatewayAddress that
	// it assigns to the Gateway and add a corresponding entry in
	// GatewayStatus.Addresses.
	//
	// Support: Extended
	Addresses []GatewaySpecAddressesPatch `pulumi:"addresses"`
	// GatewayClassName used for this Gateway. This is the name of a
	// GatewayClass resource.
	GatewayClassName *string `pulumi:"gatewayClassName"`
	// Listeners associated with this Gateway. Listeners define
	// logical endpoints that are bound on this Gateway's addresses.
	// At least one Listener MUST be specified.
	//
	// Each Listener in a set of Listeners (for example, in a single Gateway)
	// MUST be _distinct_, in that a traffic flow MUST be able to be assigned to
	// exactly one listener. (This section uses "set of Listeners" rather than
	// "Listeners in a single Gateway" because implementations MAY merge configuration
	// from multiple Gateways onto a single data plane, and these rules _also_
	// apply in that case).
	//
	// Practically, this means that each listener in a set MUST have a unique
	// combination of Port, Protocol, and, if supported by the protocol, Hostname.
	//
	// Some combinations of port, protocol, and TLS settings are considered
	// Core support and MUST be supported by implementations based on their
	// targeted conformance profile:
	//
	// HTTP Profile
	//
	// 1. HTTPRoute, Port: 80, Protocol: HTTP
	// 2. HTTPRoute, Port: 443, Protocol: HTTPS, TLS Mode: Terminate, TLS keypair provided
	//
	// TLS Profile
	//
	// 1. TLSRoute, Port: 443, Protocol: TLS, TLS Mode: Passthrough
	//
	// "Distinct" Listeners have the following property:
	//
	// The implementation can match inbound requests to a single distinct
	// Listener. When multiple Listeners share values for fields (for
	// example, two Listeners with the same Port value), the implementation
	// can match requests to only one of the Listeners using other
	// Listener fields.
	//
	// For example, the following Listener scenarios are distinct:
	//
	// 1. Multiple Listeners with the same Port that all use the "HTTP"
	//    Protocol that all have unique Hostname values.
	// 2. Multiple Listeners with the same Port that use either the "HTTPS" or
	//    "TLS" Protocol that all have unique Hostname values.
	// 3. A mixture of "TCP" and "UDP" Protocol Listeners, where no Listener
	//    with the same Protocol has the same Port value.
	//
	// Some fields in the Listener struct have possible values that affect
	// whether the Listener is distinct. Hostname is particularly relevant
	// for HTTP or HTTPS protocols.
	//
	// When using the Hostname value to select between same-Port, same-Protocol
	// Listeners, the Hostname value must be different on each Listener for the
	// Listener to be distinct.
	//
	// When the Listeners are distinct based on Hostname, inbound request
	// hostnames MUST match from the most specific to least specific Hostname
	// values to choose the correct Listener and its associated set of Routes.
	//
	// Exact matches must be processed before wildcard matches, and wildcard
	// matches must be processed before fallback (empty Hostname value)
	// matches. For example, `"foo.example.com"` takes precedence over
	// `"*.example.com"`, and `"*.example.com"` takes precedence over `""`.
	//
	// Additionally, if there are multiple wildcard entries, more specific
	// wildcard entries must be processed before less specific wildcard entries.
	// For example, `"*.foo.example.com"` takes precedence over `"*.example.com"`.
	// The precise definition here is that the higher the number of dots in the
	// hostname to the right of the wildcard character, the higher the precedence.
	//
	// The wildcard character will match any number of characters _and dots_ to
	// the left, however, so `"*.example.com"` will match both
	// `"foo.bar.example.com"` _and_ `"bar.example.com"`.
	//
	// If a set of Listeners contains Listeners that are not distinct, then those
	// Listeners are Conflicted, and the implementation MUST set the "Conflicted"
	// condition in the Listener Status to "True".
	//
	// Implementations MAY choose to accept a Gateway with some Conflicted
	// Listeners only if they only accept the partial Listener set that contains
	// no Conflicted Listeners. To put this another way, implementations may
	// accept a partial Listener set only if they throw out *all* the conflicting
	// Listeners. No picking one of the conflicting listeners as the winner.
	// This also means that the Gateway must have at least one non-conflicting
	// Listener in this case, otherwise it violates the requirement that at
	// least one Listener must be present.
	//
	// The implementation MUST set a "ListenersNotValid" condition on the
	// Gateway Status when the Gateway contains Conflicted Listeners whether or
	// not they accept the Gateway. That Condition SHOULD clearly
	// indicate in the Message which Listeners are conflicted, and which are
	// Accepted. Additionally, the Listener status for those listeners SHOULD
	// indicate which Listeners are conflicted and not Accepted.
	//
	// A Gateway's Listeners are considered "compatible" if:
	//
	// 1. They are distinct.
	// 2. The implementation can serve them in compliance with the Addresses
	//    requirement that all Listeners are available on all assigned
	//    addresses.
	//
	// Compatible combinations in Extended support are expected to vary across
	// implementations. A combination that is compatible for one implementation
	// may not be compatible for another.
	//
	// For example, an implementation that cannot serve both TCP and UDP listeners
	// on the same address, or cannot mix HTTPS and generic TLS listens on the same port
	// would not consider those cases compatible, even though they are distinct.
	//
	// Note that requests SHOULD match at most one Listener. For example, if
	// Listeners are defined for "foo.example.com" and "*.example.com", a
	// request to "foo.example.com" SHOULD only be routed using routes attached
	// to the "foo.example.com" Listener (and not the "*.example.com" Listener).
	// This concept is known as "Listener Isolation". Implementations that do
	// not support Listener Isolation MUST clearly document this.
	//
	// Implementations MAY merge separate Gateways onto a single set of
	// Addresses if all Listeners across all Gateways are compatible.
	//
	// Support: Core
	Listeners []GatewaySpecListenersPatch `pulumi:"listeners"`
}

// GatewaySpecPatchInput is an input type that accepts GatewaySpecPatchArgs and GatewaySpecPatchOutput values.
// You can construct a concrete instance of `GatewaySpecPatchInput` via:
//
//	GatewaySpecPatchArgs{...}
type GatewaySpecPatchInput interface {
	pulumi.Input

	ToGatewaySpecPatchOutput() GatewaySpecPatchOutput
	ToGatewaySpecPatchOutputWithContext(context.Context) GatewaySpecPatchOutput
}

// Spec defines the desired state of Gateway.
type GatewaySpecPatchArgs struct {
	// Addresses requested for this Gateway. This is optional and behavior can
	// depend on the implementation. If a value is set in the spec and the
	// requested address is invalid or unavailable, the implementation MUST
	// indicate this in the associated entry in GatewayStatus.Addresses.
	//
	// The Addresses field represents a request for the address(es) on the
	// "outside of the Gateway", that traffic bound for this Gateway will use.
	// This could be the IP address or hostname of an external load balancer or
	// other networking infrastructure, or some other address that traffic will
	// be sent to.
	//
	// If no Addresses are specified, the implementation MAY schedule the
	// Gateway in an implementation-specific manner, assigning an appropriate
	// set of Addresses.
	//
	// The implementation MUST bind all Listeners to every GatewayAddress that
	// it assigns to the Gateway and add a corresponding entry in
	// GatewayStatus.Addresses.
	//
	// Support: Extended
	Addresses GatewaySpecAddressesPatchArrayInput `pulumi:"addresses"`
	// GatewayClassName used for this Gateway. This is the name of a
	// GatewayClass resource.
	GatewayClassName pulumi.StringPtrInput `pulumi:"gatewayClassName"`
	// Listeners associated with this Gateway. Listeners define
	// logical endpoints that are bound on this Gateway's addresses.
	// At least one Listener MUST be specified.
	//
	// Each Listener in a set of Listeners (for example, in a single Gateway)
	// MUST be _distinct_, in that a traffic flow MUST be able to be assigned to
	// exactly one listener. (This section uses "set of Listeners" rather than
	// "Listeners in a single Gateway" because implementations MAY merge configuration
	// from multiple Gateways onto a single data plane, and these rules _also_
	// apply in that case).
	//
	// Practically, this means that each listener in a set MUST have a unique
	// combination of Port, Protocol, and, if supported by the protocol, Hostname.
	//
	// Some combinations of port, protocol, and TLS settings are considered
	// Core support and MUST be supported by implementations based on their
	// targeted conformance profile:
	//
	// HTTP Profile
	//
	// 1. HTTPRoute, Port: 80, Protocol: HTTP
	// 2. HTTPRoute, Port: 443, Protocol: HTTPS, TLS Mode: Terminate, TLS keypair provided
	//
	// TLS Profile
	//
	// 1. TLSRoute, Port: 443, Protocol: TLS, TLS Mode: Passthrough
	//
	// "Distinct" Listeners have the following property:
	//
	// The implementation can match inbound requests to a single distinct
	// Listener. When multiple Listeners share values for fields (for
	// example, two Listeners with the same Port value), the implementation
	// can match requests to only one of the Listeners using other
	// Listener fields.
	//
	// For example, the following Listener scenarios are distinct:
	//
	// 1. Multiple Listeners with the same Port that all use the "HTTP"
	//    Protocol that all have unique Hostname values.
	// 2. Multiple Listeners with the same Port that use either the "HTTPS" or
	//    "TLS" Protocol that all have unique Hostname values.
	// 3. A mixture of "TCP" and "UDP" Protocol Listeners, where no Listener
	//    with the same Protocol has the same Port value.
	//
	// Some fields in the Listener struct have possible values that affect
	// whether the Listener is distinct. Hostname is particularly relevant
	// for HTTP or HTTPS protocols.
	//
	// When using the Hostname value to select between same-Port, same-Protocol
	// Listeners, the Hostname value must be different on each Listener for the
	// Listener to be distinct.
	//
	// When the Listeners are distinct based on Hostname, inbound request
	// hostnames MUST match from the most specific to least specific Hostname
	// values to choose the correct Listener and its associated set of Routes.
	//
	// Exact matches must be processed before wildcard matches, and wildcard
	// matches must be processed before fallback (empty Hostname value)
	// matches. For example, `"foo.example.com"` takes precedence over
	// `"*.example.com"`, and `"*.example.com"` takes precedence over `""`.
	//
	// Additionally, if there are multiple wildcard entries, more specific
	// wildcard entries must be processed before less specific wildcard entries.
	// For example, `"*.foo.example.com"` takes precedence over `"*.example.com"`.
	// The precise definition here is that the higher the number of dots in the
	// hostname to the right of the wildcard character, the higher the precedence.
	//
	// The wildcard character will match any number of characters _and dots_ to
	// the left, however, so `"*.example.com"` will match both
	// `"foo.bar.example.com"` _and_ `"bar.example.com"`.
	//
	// If a set of Listeners contains Listeners that are not distinct, then those
	// Listeners are Conflicted, and the implementation MUST set the "Conflicted"
	// condition in the Listener Status to "True".
	//
	// Implementations MAY choose to accept a Gateway with some Conflicted
	// Listeners only if they only accept the partial Listener set that contains
	// no Conflicted Listeners. To put this another way, implementations may
	// accept a partial Listener set only if they throw out *all* the conflicting
	// Listeners. No picking one of the conflicting listeners as the winner.
	// This also means that the Gateway must have at least one non-conflicting
	// Listener in this case, otherwise it violates the requirement that at
	// least one Listener must be present.
	//
	// The implementation MUST set a "ListenersNotValid" condition on the
	// Gateway Status when the Gateway contains Conflicted Listeners whether or
	// not they accept the Gateway. That Condition SHOULD clearly
	// indicate in the Message which Listeners are conflicted, and which are
	// Accepted. Additionally, the Listener status for those listeners SHOULD
	// indicate which Listeners are conflicted and not Accepted.
	//
	// A Gateway's Listeners are considered "compatible" if:
	//
	// 1. They are distinct.
	// 2. The implementation can serve them in compliance with the Addresses
	//    requirement that all Listeners are available on all assigned
	//    addresses.
	//
	// Compatible combinations in Extended support are expected to vary across
	// implementations. A combination that is compatible for one implementation
	// may not be compatible for another.
	//
	// For example, an implementation that cannot serve both TCP and UDP listeners
	// on the same address, or cannot mix HTTPS and generic TLS listens on the same port
	// would not consider those cases compatible, even though they are distinct.
	//
	// Note that requests SHOULD match at most one Listener. For example, if
	// Listeners are defined for "foo.example.com" and "*.example.com", a
	// request to "foo.example.com" SHOULD only be routed using routes attached
	// to the "foo.example.com" Listener (and not the "*.example.com" Listener).
	// This concept is known as "Listener Isolation". Implementations that do
	// not support Listener Isolation MUST clearly document this.
	//
	// Implementations MAY merge separate Gateways onto a single set of
	// Addresses if all Listeners across all Gateways are compatible.
	//
	// Support: Core
	Listeners GatewaySpecListenersPatchArrayInput `pulumi:"listeners"`
}

func (GatewaySpecPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecPatch)(nil)).Elem()
}

func (i GatewaySpecPatchArgs) ToGatewaySpecPatchOutput() GatewaySpecPatchOutput {
	return i.ToGatewaySpecPatchOutputWithContext(context.Background())
}

func (i GatewaySpecPatchArgs) ToGatewaySpecPatchOutputWithContext(ctx context.Context) GatewaySpecPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecPatchOutput)
}

func (i GatewaySpecPatchArgs) ToGatewaySpecPatchPtrOutput() GatewaySpecPatchPtrOutput {
	return i.ToGatewaySpecPatchPtrOutputWithContext(context.Background())
}

func (i GatewaySpecPatchArgs) ToGatewaySpecPatchPtrOutputWithContext(ctx context.Context) GatewaySpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecPatchOutput).ToGatewaySpecPatchPtrOutputWithContext(ctx)
}

// GatewaySpecPatchPtrInput is an input type that accepts GatewaySpecPatchArgs, GatewaySpecPatchPtr and GatewaySpecPatchPtrOutput values.
// You can construct a concrete instance of `GatewaySpecPatchPtrInput` via:
//
//	        GatewaySpecPatchArgs{...}
//
//	or:
//
//	        nil
type GatewaySpecPatchPtrInput interface {
	pulumi.Input

	ToGatewaySpecPatchPtrOutput() GatewaySpecPatchPtrOutput
	ToGatewaySpecPatchPtrOutputWithContext(context.Context) GatewaySpecPatchPtrOutput
}

type gatewaySpecPatchPtrType GatewaySpecPatchArgs

func GatewaySpecPatchPtr(v *GatewaySpecPatchArgs) GatewaySpecPatchPtrInput {
	return (*gatewaySpecPatchPtrType)(v)
}

func (*gatewaySpecPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewaySpecPatch)(nil)).Elem()
}

func (i *gatewaySpecPatchPtrType) ToGatewaySpecPatchPtrOutput() GatewaySpecPatchPtrOutput {
	return i.ToGatewaySpecPatchPtrOutputWithContext(context.Background())
}

func (i *gatewaySpecPatchPtrType) ToGatewaySpecPatchPtrOutputWithContext(ctx context.Context) GatewaySpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewaySpecPatchPtrOutput)
}

// Spec defines the desired state of Gateway.
type GatewaySpecPatchOutput struct{ *pulumi.OutputState }

func (GatewaySpecPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewaySpecPatch)(nil)).Elem()
}

func (o GatewaySpecPatchOutput) ToGatewaySpecPatchOutput() GatewaySpecPatchOutput {
	return o
}

func (o GatewaySpecPatchOutput) ToGatewaySpecPatchOutputWithContext(ctx context.Context) GatewaySpecPatchOutput {
	return o
}

func (o GatewaySpecPatchOutput) ToGatewaySpecPatchPtrOutput() GatewaySpecPatchPtrOutput {
	return o.ToGatewaySpecPatchPtrOutputWithContext(context.Background())
}

func (o GatewaySpecPatchOutput) ToGatewaySpecPatchPtrOutputWithContext(ctx context.Context) GatewaySpecPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GatewaySpecPatch) *GatewaySpecPatch {
		return &v
	}).(GatewaySpecPatchPtrOutput)
}

// Addresses requested for this Gateway. This is optional and behavior can
// depend on the implementation. If a value is set in the spec and the
// requested address is invalid or unavailable, the implementation MUST
// indicate this in the associated entry in GatewayStatus.Addresses.
//
// The Addresses field represents a request for the address(es) on the
// "outside of the Gateway", that traffic bound for this Gateway will use.
// This could be the IP address or hostname of an external load balancer or
// other networking infrastructure, or some other address that traffic will
// be sent to.
//
// If no Addresses are specified, the implementation MAY schedule the
// Gateway in an implementation-specific manner, assigning an appropriate
// set of Addresses.
//
// The implementation MUST bind all Listeners to every GatewayAddress that
// it assigns to the Gateway and add a corresponding entry in
// GatewayStatus.Addresses.
//
// Support: Extended
func (o GatewaySpecPatchOutput) Addresses() GatewaySpecAddressesPatchArrayOutput {
	return o.ApplyT(func(v GatewaySpecPatch) []GatewaySpecAddressesPatch { return v.Addresses }).(GatewaySpecAddressesPatchArrayOutput)
}

// GatewayClassName used for this Gateway. This is the name of a
// GatewayClass resource.
func (o GatewaySpecPatchOutput) GatewayClassName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewaySpecPatch) *string { return v.GatewayClassName }).(pulumi.StringPtrOutput)
}

// Listeners associated with this Gateway. Listeners define
// logical endpoints that are bound on this Gateway's addresses.
// At least one Listener MUST be specified.
//
// Each Listener in a set of Listeners (for example, in a single Gateway)
// MUST be _distinct_, in that a traffic flow MUST be able to be assigned to
// exactly one listener. (This section uses "set of Listeners" rather than
// "Listeners in a single Gateway" because implementations MAY merge configuration
// from multiple Gateways onto a single data plane, and these rules _also_
// apply in that case).
//
// Practically, this means that each listener in a set MUST have a unique
// combination of Port, Protocol, and, if supported by the protocol, Hostname.
//
// Some combinations of port, protocol, and TLS settings are considered
// Core support and MUST be supported by implementations based on their
// targeted conformance profile:
//
// # HTTP Profile
//
// 1. HTTPRoute, Port: 80, Protocol: HTTP
// 2. HTTPRoute, Port: 443, Protocol: HTTPS, TLS Mode: Terminate, TLS keypair provided
//
// # TLS Profile
//
// 1. TLSRoute, Port: 443, Protocol: TLS, TLS Mode: Passthrough
//
// "Distinct" Listeners have the following property:
//
// The implementation can match inbound requests to a single distinct
// Listener. When multiple Listeners share values for fields (for
// example, two Listeners with the same Port value), the implementation
// can match requests to only one of the Listeners using other
// Listener fields.
//
// For example, the following Listener scenarios are distinct:
//
//  1. Multiple Listeners with the same Port that all use the "HTTP"
//     Protocol that all have unique Hostname values.
//  2. Multiple Listeners with the same Port that use either the "HTTPS" or
//     "TLS" Protocol that all have unique Hostname values.
//  3. A mixture of "TCP" and "UDP" Protocol Listeners, where no Listener
//     with the same Protocol has the same Port value.
//
// Some fields in the Listener struct have possible values that affect
// whether the Listener is distinct. Hostname is particularly relevant
// for HTTP or HTTPS protocols.
//
// When using the Hostname value to select between same-Port, same-Protocol
// Listeners, the Hostname value must be different on each Listener for the
// Listener to be distinct.
//
// When the Listeners are distinct based on Hostname, inbound request
// hostnames MUST match from the most specific to least specific Hostname
// values to choose the correct Listener and its associated set of Routes.
//
// Exact matches must be processed before wildcard matches, and wildcard
// matches must be processed before fallback (empty Hostname value)
// matches. For example, `"foo.example.com"` takes precedence over
// `"*.example.com"`, and `"*.example.com"` takes precedence over `""`.
//
// Additionally, if there are multiple wildcard entries, more specific
// wildcard entries must be processed before less specific wildcard entries.
// For example, `"*.foo.example.com"` takes precedence over `"*.example.com"`.
// The precise definition here is that the higher the number of dots in the
// hostname to the right of the wildcard character, the higher the precedence.
//
// The wildcard character will match any number of characters _and dots_ to
// the left, however, so `"*.example.com"` will match both
// `"foo.bar.example.com"` _and_ `"bar.example.com"`.
//
// If a set of Listeners contains Listeners that are not distinct, then those
// Listeners are Conflicted, and the implementation MUST set the "Conflicted"
// condition in the Listener Status to "True".
//
// Implementations MAY choose to accept a Gateway with some Conflicted
// Listeners only if they only accept the partial Listener set that contains
// no Conflicted Listeners. To put this another way, implementations may
// accept a partial Listener set only if they throw out *all* the conflicting
// Listeners. No picking one of the conflicting listeners as the winner.
// This also means that the Gateway must have at least one non-conflicting
// Listener in this case, otherwise it violates the requirement that at
// least one Listener must be present.
//
// The implementation MUST set a "ListenersNotValid" condition on the
// Gateway Status when the Gateway contains Conflicted Listeners whether or
// not they accept the Gateway. That Condition SHOULD clearly
// indicate in the Message which Listeners are conflicted, and which are
// Accepted. Additionally, the Listener status for those listeners SHOULD
// indicate which Listeners are conflicted and not Accepted.
//
// A Gateway's Listeners are considered "compatible" if:
//
//  1. They are distinct.
//  2. The implementation can serve them in compliance with the Addresses
//     requirement that all Listeners are available on all assigned
//     addresses.
//
// Compatible combinations in Extended support are expected to vary across
// implementations. A combination that is compatible for one implementation
// may not be compatible for another.
//
// For example, an implementation that cannot serve both TCP and UDP listeners
// on the same address, or cannot mix HTTPS and generic TLS listens on the same port
// would not consider those cases compatible, even though they are distinct.
//
// Note that requests SHOULD match at most one Listener. For example, if
// Listeners are defined for "foo.example.com" and "*.example.com", a
// request to "foo.example.com" SHOULD only be routed using routes attached
// to the "foo.example.com" Listener (and not the "*.example.com" Listener).
// This concept is known as "Listener Isolation". Implementations that do
// not support Listener Isolation MUST clearly document this.
//
// Implementations MAY merge separate Gateways onto a single set of
// Addresses if all Listeners across all Gateways are compatible.
//
// Support: Core
func (o GatewaySpecPatchOutput) Listeners() GatewaySpecListenersPatchArrayOutput {
	return o.ApplyT(func(v GatewaySpecPatch) []GatewaySpecListenersPatch { return v.Listeners }).(GatewaySpecListenersPatchArrayOutput)
}

type GatewaySpecPatchPtrOutput struct{ *pulumi.OutputState }

func (GatewaySpecPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewaySpecPatch)(nil)).Elem()
}

func (o GatewaySpecPatchPtrOutput) ToGatewaySpecPatchPtrOutput() GatewaySpecPatchPtrOutput {
	return o
}

func (o GatewaySpecPatchPtrOutput) ToGatewaySpecPatchPtrOutputWithContext(ctx context.Context) GatewaySpecPatchPtrOutput {
	return o
}

func (o GatewaySpecPatchPtrOutput) Elem() GatewaySpecPatchOutput {
	return o.ApplyT(func(v *GatewaySpecPatch) GatewaySpecPatch {
		if v != nil {
			return *v
		}
		var ret GatewaySpecPatch
		return ret
	}).(GatewaySpecPatchOutput)
}

// Addresses requested for this Gateway. This is optional and behavior can
// depend on the implementation. If a value is set in the spec and the
// requested address is invalid or unavailable, the implementation MUST
// indicate this in the associated entry in GatewayStatus.Addresses.
//
// The Addresses field represents a request for the address(es) on the
// "outside of the Gateway", that traffic bound for this Gateway will use.
// This could be the IP address or hostname of an external load balancer or
// other networking infrastructure, or some other address that traffic will
// be sent to.
//
// If no Addresses are specified, the implementation MAY schedule the
// Gateway in an implementation-specific manner, assigning an appropriate
// set of Addresses.
//
// The implementation MUST bind all Listeners to every GatewayAddress that
// it assigns to the Gateway and add a corresponding entry in
// GatewayStatus.Addresses.
//
// Support: Extended
func (o GatewaySpecPatchPtrOutput) Addresses() GatewaySpecAddressesPatchArrayOutput {
	return o.ApplyT(func(v *GatewaySpecPatch) []GatewaySpecAddressesPatch {
		if v == nil {
			return nil
		}
		return v.Addresses
	}).(GatewaySpecAddressesPatchArrayOutput)
}

// GatewayClassName used for this Gateway. This is the name of a
// GatewayClass resource.
func (o GatewaySpecPatchPtrOutput) GatewayClassName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GatewaySpecPatch) *string {
		if v == nil {
			return nil
		}
		return v.GatewayClassName
	}).(pulumi.StringPtrOutput)
}

// Listeners associated with this Gateway. Listeners define
// logical endpoints that are bound on this Gateway's addresses.
// At least one Listener MUST be specified.
//
// Each Listener in a set of Listeners (for example, in a single Gateway)
// MUST be _distinct_, in that a traffic flow MUST be able to be assigned to
// exactly one listener. (This section uses "set of Listeners" rather than
// "Listeners in a single Gateway" because implementations MAY merge configuration
// from multiple Gateways onto a single data plane, and these rules _also_
// apply in that case).
//
// Practically, this means that each listener in a set MUST have a unique
// combination of Port, Protocol, and, if supported by the protocol, Hostname.
//
// Some combinations of port, protocol, and TLS settings are considered
// Core support and MUST be supported by implementations based on their
// targeted conformance profile:
//
// # HTTP Profile
//
// 1. HTTPRoute, Port: 80, Protocol: HTTP
// 2. HTTPRoute, Port: 443, Protocol: HTTPS, TLS Mode: Terminate, TLS keypair provided
//
// # TLS Profile
//
// 1. TLSRoute, Port: 443, Protocol: TLS, TLS Mode: Passthrough
//
// "Distinct" Listeners have the following property:
//
// The implementation can match inbound requests to a single distinct
// Listener. When multiple Listeners share values for fields (for
// example, two Listeners with the same Port value), the implementation
// can match requests to only one of the Listeners using other
// Listener fields.
//
// For example, the following Listener scenarios are distinct:
//
//  1. Multiple Listeners with the same Port that all use the "HTTP"
//     Protocol that all have unique Hostname values.
//  2. Multiple Listeners with the same Port that use either the "HTTPS" or
//     "TLS" Protocol that all have unique Hostname values.
//  3. A mixture of "TCP" and "UDP" Protocol Listeners, where no Listener
//     with the same Protocol has the same Port value.
//
// Some fields in the Listener struct have possible values that affect
// whether the Listener is distinct. Hostname is particularly relevant
// for HTTP or HTTPS protocols.
//
// When using the Hostname value to select between same-Port, same-Protocol
// Listeners, the Hostname value must be different on each Listener for the
// Listener to be distinct.
//
// When the Listeners are distinct based on Hostname, inbound request
// hostnames MUST match from the most specific to least specific Hostname
// values to choose the correct Listener and its associated set of Routes.
//
// Exact matches must be processed before wildcard matches, and wildcard
// matches must be processed before fallback (empty Hostname value)
// matches. For example, `"foo.example.com"` takes precedence over
// `"*.example.com"`, and `"*.example.com"` takes precedence over `""`.
//
// Additionally, if there are multiple wildcard entries, more specific
// wildcard entries must be processed before less specific wildcard entries.
// For example, `"*.foo.example.com"` takes precedence over `"*.example.com"`.
// The precise definition here is that the higher the number of dots in the
// hostname to the right of the wildcard character, the higher the precedence.
//
// The wildcard character will match any number of characters _and dots_ to
// the left, however, so `"*.example.com"` will match both
// `"foo.bar.example.com"` _and_ `"bar.example.com"`.
//
// If a set of Listeners contains Listeners that are not distinct, then those
// Listeners are Conflicted, and the implementation MUST set the "Conflicted"
// condition in the Listener Status to "True".
//
// Implementations MAY choose to accept a Gateway with some Conflicted
// Listeners only if they only accept the partial Listener set that contains
// no Conflicted Listeners. To put this another way, implementations may
// accept a partial Listener set only if they throw out *all* the conflicting
// Listeners. No picking one of the conflicting listeners as the winner.
// This also means that the Gateway must have at least one non-conflicting
// Listener in this case, otherwise it violates the requirement that at
// least one Listener must be present.
//
// The implementation MUST set a "ListenersNotValid" condition on the
// Gateway Status when the Gateway contains Conflicted Listeners whether or
// not they accept the Gateway. That Condition SHOULD clearly
// indicate in the Message which Listeners are conflicted, and which are
// Accepted. Additionally, the Listener status for those listeners SHOULD
// indicate which Listeners are conflicted and not Accepted.
//
// A Gateway's Listeners are considered "compatible" if:
//
//  1. They are distinct.
//  2. The implementation can serve them in compliance with the Addresses
//     requirement that all Listeners are available on all assigned
//     addresses.
//
// Compatible combinations in Extended support are expected to vary across
// implementations. A combination that is compatible for one implementation
// may not be compatible for another.
//
// For example, an implementation that cannot serve both TCP and UDP listeners
// on the same address, or cannot mix HTTPS and generic TLS listens on the same port
// would not consider those cases compatible, even though they are distinct.
//
// Note that requests SHOULD match at most one Listener. For example, if
// Listeners are defined for "foo.example.com" and "*.example.com", a
// request to "foo.example.com" SHOULD only be routed using routes attached
// to the "foo.example.com" Listener (and not the "*.example.com" Listener).
// This concept is known as "Listener Isolation". Implementations that do
// not support Listener Isolation MUST clearly document this.
//
// Implementations MAY merge separate Gateways onto a single set of
// Addresses if all Listeners across all Gateways are compatible.
//
// Support: Core
func (o GatewaySpecPatchPtrOutput) Listeners() GatewaySpecListenersPatchArrayOutput {
	return o.ApplyT(func(v *GatewaySpecPatch) []GatewaySpecListenersPatch {
		if v == nil {
			return nil
		}
		return v.Listeners
	}).(GatewaySpecListenersPatchArrayOutput)
}

// Status defines the current state of Gateway.
type GatewayStatus struct {
	// Addresses lists the network addresses that have been bound to the
	// Gateway.
	//
	// This list may differ from the addresses provided in the spec under some
	// conditions:
	//
	//   * no addresses are specified, all addresses are dynamically assigned
	//   * a combination of specified and dynamic addresses are assigned
	//   * a specified address was unusable (e.g. already in use)
	Addresses []GatewayStatusAddresses `pulumi:"addresses"`
	// Conditions describe the current conditions of the Gateway.
	//
	// Implementations should prefer to express Gateway conditions
	// using the `GatewayConditionType` and `GatewayConditionReason`
	// constants so that operators and tools can converge on a common
	// vocabulary to describe Gateway state.
	//
	// Known condition types are:
	//
	// * "Accepted"
	// * "Programmed"
	// * "Ready"
	Conditions []GatewayStatusConditions `pulumi:"conditions"`
	// Listeners provide status for each unique listener port defined in the Spec.
	Listeners []GatewayStatusListeners `pulumi:"listeners"`
}

// GatewayStatusInput is an input type that accepts GatewayStatusArgs and GatewayStatusOutput values.
// You can construct a concrete instance of `GatewayStatusInput` via:
//
//	GatewayStatusArgs{...}
type GatewayStatusInput interface {
	pulumi.Input

	ToGatewayStatusOutput() GatewayStatusOutput
	ToGatewayStatusOutputWithContext(context.Context) GatewayStatusOutput
}

// Status defines the current state of Gateway.
type GatewayStatusArgs struct {
	// Addresses lists the network addresses that have been bound to the
	// Gateway.
	//
	// This list may differ from the addresses provided in the spec under some
	// conditions:
	//
	//   * no addresses are specified, all addresses are dynamically assigned
	//   * a combination of specified and dynamic addresses are assigned
	//   * a specified address was unusable (e.g. already in use)
	Addresses GatewayStatusAddressesArrayInput `pulumi:"addresses"`
	// Conditions describe the current conditions of the Gateway.
	//
	// Implementations should prefer to express Gateway conditions
	// using the `GatewayConditionType` and `GatewayConditionReason`
	// constants so that operators and tools can converge on a common
	// vocabulary to describe Gateway state.
	//
	// Known condition types are:
	//
	// * "Accepted"
	// * "Programmed"
	// * "Ready"
	Conditions GatewayStatusConditionsArrayInput `pulumi:"conditions"`
	// Listeners provide status for each unique listener port defined in the Spec.
	Listeners GatewayStatusListenersArrayInput `pulumi:"listeners"`
}

func (GatewayStatusArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayStatus)(nil)).Elem()
}

func (i GatewayStatusArgs) ToGatewayStatusOutput() GatewayStatusOutput {
	return i.ToGatewayStatusOutputWithContext(context.Background())
}

func (i GatewayStatusArgs) ToGatewayStatusOutputWithContext(ctx context.Context) GatewayStatusOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayStatusOutput)
}

func (i GatewayStatusArgs) ToGatewayStatusPtrOutput() GatewayStatusPtrOutput {
	return i.ToGatewayStatusPtrOutputWithContext(context.Background())
}

func (i GatewayStatusArgs) ToGatewayStatusPtrOutputWithContext(ctx context.Context) GatewayStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayStatusOutput).ToGatewayStatusPtrOutputWithContext(ctx)
}

// GatewayStatusPtrInput is an input type that accepts GatewayStatusArgs, GatewayStatusPtr and GatewayStatusPtrOutput values.
// You can construct a concrete instance of `GatewayStatusPtrInput` via:
//
//	        GatewayStatusArgs{...}
//
//	or:
//
//	        nil
type GatewayStatusPtrInput interface {
	pulumi.Input

	ToGatewayStatusPtrOutput() GatewayStatusPtrOutput
	ToGatewayStatusPtrOutputWithContext(context.Context) GatewayStatusPtrOutput
}

type gatewayStatusPtrType GatewayStatusArgs

func GatewayStatusPtr(v *GatewayStatusArgs) GatewayStatusPtrInput {
	return (*gatewayStatusPtrType)(v)
}

func (*gatewayStatusPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewayStatus)(nil)).Elem()
}

func (i *gatewayStatusPtrType) ToGatewayStatusPtrOutput() GatewayStatusPtrOutput {
	return i.ToGatewayStatusPtrOutputWithContext(context.Background())
}

func (i *gatewayStatusPtrType) ToGatewayStatusPtrOutputWithContext(ctx context.Context) GatewayStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayStatusPtrOutput)
}

// Status defines the current state of Gateway.
type GatewayStatusOutput struct{ *pulumi.OutputState }

func (GatewayStatusOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayStatus)(nil)).Elem()
}

func (o GatewayStatusOutput) ToGatewayStatusOutput() GatewayStatusOutput {
	return o
}

func (o GatewayStatusOutput) ToGatewayStatusOutputWithContext(ctx context.Context) GatewayStatusOutput {
	return o
}

func (o GatewayStatusOutput) ToGatewayStatusPtrOutput() GatewayStatusPtrOutput {
	return o.ToGatewayStatusPtrOutputWithContext(context.Background())
}

func (o GatewayStatusOutput) ToGatewayStatusPtrOutputWithContext(ctx context.Context) GatewayStatusPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GatewayStatus) *GatewayStatus {
		return &v
	}).(GatewayStatusPtrOutput)
}

// Addresses lists the network addresses that have been bound to the
// Gateway.
//
// This list may differ from the addresses provided in the spec under some
// conditions:
//
//   - no addresses are specified, all addresses are dynamically assigned
//   - a combination of specified and dynamic addresses are assigned
//   - a specified address was unusable (e.g. already in use)
func (o GatewayStatusOutput) Addresses() GatewayStatusAddressesArrayOutput {
	return o.ApplyT(func(v GatewayStatus) []GatewayStatusAddresses { return v.Addresses }).(GatewayStatusAddressesArrayOutput)
}

// Conditions describe the current conditions of the Gateway.
//
// Implementations should prefer to express Gateway conditions
// using the `GatewayConditionType` and `GatewayConditionReason`
// constants so that operators and tools can converge on a common
// vocabulary to describe Gateway state.
//
// Known condition types are:
//
// * "Accepted"
// * "Programmed"
// * "Ready"
func (o GatewayStatusOutput) Conditions() GatewayStatusConditionsArrayOutput {
	return o.ApplyT(func(v GatewayStatus) []GatewayStatusConditions { return v.Conditions }).(GatewayStatusConditionsArrayOutput)
}

// Listeners provide status for each unique listener port defined in the Spec.
func (o GatewayStatusOutput) Listeners() GatewayStatusListenersArrayOutput {
	return o.ApplyT(func(v GatewayStatus) []GatewayStatusListeners { return v.Listeners }).(GatewayStatusListenersArrayOutput)
}

type GatewayStatusPtrOutput struct{ *pulumi.OutputState }

func (GatewayStatusPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewayStatus)(nil)).Elem()
}

func (o GatewayStatusPtrOutput) ToGatewayStatusPtrOutput() GatewayStatusPtrOutput {
	return o
}

func (o GatewayStatusPtrOutput) ToGatewayStatusPtrOutputWithContext(ctx context.Context) GatewayStatusPtrOutput {
	return o
}

func (o GatewayStatusPtrOutput) Elem() GatewayStatusOutput {
	return o.ApplyT(func(v *GatewayStatus) GatewayStatus {
		if v != nil {
			return *v
		}
		var ret GatewayStatus
		return ret
	}).(GatewayStatusOutput)
}

// Addresses lists the network addresses that have been bound to the
// Gateway.
//
// This list may differ from the addresses provided in the spec under some
// conditions:
//
//   - no addresses are specified, all addresses are dynamically assigned
//   - a combination of specified and dynamic addresses are assigned
//   - a specified address was unusable (e.g. already in use)
func (o GatewayStatusPtrOutput) Addresses() GatewayStatusAddressesArrayOutput {
	return o.ApplyT(func(v *GatewayStatus) []GatewayStatusAddresses {
		if v == nil {
			return nil
		}
		return v.Addresses
	}).(GatewayStatusAddressesArrayOutput)
}

// Conditions describe the current conditions of the Gateway.
//
// Implementations should prefer to express Gateway conditions
// using the `GatewayConditionType` and `GatewayConditionReason`
// constants so that operators and tools can converge on a common
// vocabulary to describe Gateway state.
//
// Known condition types are:
//
// * "Accepted"
// * "Programmed"
// * "Ready"
func (o GatewayStatusPtrOutput) Conditions() GatewayStatusConditionsArrayOutput {
	return o.ApplyT(func(v *GatewayStatus) []GatewayStatusConditions {
		if v == nil {
			return nil
		}
		return v.Conditions
	}).(GatewayStatusConditionsArrayOutput)
}

// Listeners provide status for each unique listener port defined in the Spec.
func (o GatewayStatusPtrOutput) Listeners() GatewayStatusListenersArrayOutput {
	return o.ApplyT(func(v *GatewayStatus) []GatewayStatusListeners {
		if v == nil {
			return nil
		}
		return v.Listeners
	}).(GatewayStatusListenersArrayOutput)
}

// GatewayStatusAddress describes a network address that is bound to a Gateway.
type GatewayStatusAddresses struct {
	// Type of the address.
	Type *string `pulumi:"type"`
	// Value of the address. The validity of the values will depend
	// on the type and support by the controller.
	//
	// Examples: `1.2.3.4`, `128::1`, `my-ip-address`.
	Value *string `pulumi:"value"`
}

// GatewayStatusAddressesInput is an input type that accepts GatewayStatusAddressesArgs and GatewayStatusAddressesOutput values.
// You can construct a concrete instance of `GatewayStatusAddressesInput` via:
//
//	GatewayStatusAddressesArgs{...}
type GatewayStatusAddressesInput interface {
	pulumi.Input

	ToGatewayStatusAddressesOutput() GatewayStatusAddressesOutput
	ToGatewayStatusAddressesOutputWithContext(context.Context) GatewayStatusAddressesOutput
}

// GatewayStatusAddress describes a network address that is bound to a Gateway.
type GatewayStatusAddressesArgs struct {
	// Type of the address.
	Type pulumi.StringPtrInput `pulumi:"type"`
	// Value of the address. The validity of the values will depend
	// on the type and support by the controller.
	//
	// Examples: `1.2.3.4`, `128::1`, `my-ip-address`.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (GatewayStatusAddressesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayStatusAddresses)(nil)).Elem()
}

func (i GatewayStatusAddressesArgs) ToGatewayStatusAddressesOutput() GatewayStatusAddressesOutput {
	return i.ToGatewayStatusAddressesOutputWithContext(context.Background())
}

func (i GatewayStatusAddressesArgs) ToGatewayStatusAddressesOutputWithContext(ctx context.Context) GatewayStatusAddressesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayStatusAddressesOutput)
}

// GatewayStatusAddressesArrayInput is an input type that accepts GatewayStatusAddressesArray and GatewayStatusAddressesArrayOutput values.
// You can construct a concrete instance of `GatewayStatusAddressesArrayInput` via:
//
//	GatewayStatusAddressesArray{ GatewayStatusAddressesArgs{...} }
type GatewayStatusAddressesArrayInput interface {
	pulumi.Input

	ToGatewayStatusAddressesArrayOutput() GatewayStatusAddressesArrayOutput
	ToGatewayStatusAddressesArrayOutputWithContext(context.Context) GatewayStatusAddressesArrayOutput
}

type GatewayStatusAddressesArray []GatewayStatusAddressesInput

func (GatewayStatusAddressesArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewayStatusAddresses)(nil)).Elem()
}

func (i GatewayStatusAddressesArray) ToGatewayStatusAddressesArrayOutput() GatewayStatusAddressesArrayOutput {
	return i.ToGatewayStatusAddressesArrayOutputWithContext(context.Background())
}

func (i GatewayStatusAddressesArray) ToGatewayStatusAddressesArrayOutputWithContext(ctx context.Context) GatewayStatusAddressesArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayStatusAddressesArrayOutput)
}

// GatewayStatusAddress describes a network address that is bound to a Gateway.
type GatewayStatusAddressesOutput struct{ *pulumi.OutputState }

func (GatewayStatusAddressesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayStatusAddresses)(nil)).Elem()
}

func (o GatewayStatusAddressesOutput) ToGatewayStatusAddressesOutput() GatewayStatusAddressesOutput {
	return o
}

func (o GatewayStatusAddressesOutput) ToGatewayStatusAddressesOutputWithContext(ctx context.Context) GatewayStatusAddressesOutput {
	return o
}

// Type of the address.
func (o GatewayStatusAddressesOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayStatusAddresses) *string { return v.Type }).(pulumi.StringPtrOutput)
}

// Value of the address. The validity of the values will depend
// on the type and support by the controller.
//
// Examples: `1.2.3.4`, `128::1`, `my-ip-address`.
func (o GatewayStatusAddressesOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayStatusAddresses) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type GatewayStatusAddressesArrayOutput struct{ *pulumi.OutputState }

func (GatewayStatusAddressesArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewayStatusAddresses)(nil)).Elem()
}

func (o GatewayStatusAddressesArrayOutput) ToGatewayStatusAddressesArrayOutput() GatewayStatusAddressesArrayOutput {
	return o
}

func (o GatewayStatusAddressesArrayOutput) ToGatewayStatusAddressesArrayOutputWithContext(ctx context.Context) GatewayStatusAddressesArrayOutput {
	return o
}

func (o GatewayStatusAddressesArrayOutput) Index(i pulumi.IntInput) GatewayStatusAddressesOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GatewayStatusAddresses {
		return vs[0].([]GatewayStatusAddresses)[vs[1].(int)]
	}).(GatewayStatusAddressesOutput)
}

// GatewayStatusAddress describes a network address that is bound to a Gateway.
type GatewayStatusAddressesPatch struct {
	// Type of the address.
	Type *string `pulumi:"type"`
	// Value of the address. The validity of the values will depend
	// on the type and support by the controller.
	//
	// Examples: `1.2.3.4`, `128::1`, `my-ip-address`.
	Value *string `pulumi:"value"`
}

// GatewayStatusAddressesPatchInput is an input type that accepts GatewayStatusAddressesPatchArgs and GatewayStatusAddressesPatchOutput values.
// You can construct a concrete instance of `GatewayStatusAddressesPatchInput` via:
//
//	GatewayStatusAddressesPatchArgs{...}
type GatewayStatusAddressesPatchInput interface {
	pulumi.Input

	ToGatewayStatusAddressesPatchOutput() GatewayStatusAddressesPatchOutput
	ToGatewayStatusAddressesPatchOutputWithContext(context.Context) GatewayStatusAddressesPatchOutput
}

// GatewayStatusAddress describes a network address that is bound to a Gateway.
type GatewayStatusAddressesPatchArgs struct {
	// Type of the address.
	Type pulumi.StringPtrInput `pulumi:"type"`
	// Value of the address. The validity of the values will depend
	// on the type and support by the controller.
	//
	// Examples: `1.2.3.4`, `128::1`, `my-ip-address`.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (GatewayStatusAddressesPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayStatusAddressesPatch)(nil)).Elem()
}

func (i GatewayStatusAddressesPatchArgs) ToGatewayStatusAddressesPatchOutput() GatewayStatusAddressesPatchOutput {
	return i.ToGatewayStatusAddressesPatchOutputWithContext(context.Background())
}

func (i GatewayStatusAddressesPatchArgs) ToGatewayStatusAddressesPatchOutputWithContext(ctx context.Context) GatewayStatusAddressesPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayStatusAddressesPatchOutput)
}

// GatewayStatusAddressesPatchArrayInput is an input type that accepts GatewayStatusAddressesPatchArray and GatewayStatusAddressesPatchArrayOutput values.
// You can construct a concrete instance of `GatewayStatusAddressesPatchArrayInput` via:
//
//	GatewayStatusAddressesPatchArray{ GatewayStatusAddressesPatchArgs{...} }
type GatewayStatusAddressesPatchArrayInput interface {
	pulumi.Input

	ToGatewayStatusAddressesPatchArrayOutput() GatewayStatusAddressesPatchArrayOutput
	ToGatewayStatusAddressesPatchArrayOutputWithContext(context.Context) GatewayStatusAddressesPatchArrayOutput
}

type GatewayStatusAddressesPatchArray []GatewayStatusAddressesPatchInput

func (GatewayStatusAddressesPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewayStatusAddressesPatch)(nil)).Elem()
}

func (i GatewayStatusAddressesPatchArray) ToGatewayStatusAddressesPatchArrayOutput() GatewayStatusAddressesPatchArrayOutput {
	return i.ToGatewayStatusAddressesPatchArrayOutputWithContext(context.Background())
}

func (i GatewayStatusAddressesPatchArray) ToGatewayStatusAddressesPatchArrayOutputWithContext(ctx context.Context) GatewayStatusAddressesPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayStatusAddressesPatchArrayOutput)
}

// GatewayStatusAddress describes a network address that is bound to a Gateway.
type GatewayStatusAddressesPatchOutput struct{ *pulumi.OutputState }

func (GatewayStatusAddressesPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayStatusAddressesPatch)(nil)).Elem()
}

func (o GatewayStatusAddressesPatchOutput) ToGatewayStatusAddressesPatchOutput() GatewayStatusAddressesPatchOutput {
	return o
}

func (o GatewayStatusAddressesPatchOutput) ToGatewayStatusAddressesPatchOutputWithContext(ctx context.Context) GatewayStatusAddressesPatchOutput {
	return o
}

// Type of the address.
func (o GatewayStatusAddressesPatchOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayStatusAddressesPatch) *string { return v.Type }).(pulumi.StringPtrOutput)
}

// Value of the address. The validity of the values will depend
// on the type and support by the controller.
//
// Examples: `1.2.3.4`, `128::1`, `my-ip-address`.
func (o GatewayStatusAddressesPatchOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayStatusAddressesPatch) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type GatewayStatusAddressesPatchArrayOutput struct{ *pulumi.OutputState }

func (GatewayStatusAddressesPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewayStatusAddressesPatch)(nil)).Elem()
}

func (o GatewayStatusAddressesPatchArrayOutput) ToGatewayStatusAddressesPatchArrayOutput() GatewayStatusAddressesPatchArrayOutput {
	return o
}

func (o GatewayStatusAddressesPatchArrayOutput) ToGatewayStatusAddressesPatchArrayOutputWithContext(ctx context.Context) GatewayStatusAddressesPatchArrayOutput {
	return o
}

func (o GatewayStatusAddressesPatchArrayOutput) Index(i pulumi.IntInput) GatewayStatusAddressesPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GatewayStatusAddressesPatch {
		return vs[0].([]GatewayStatusAddressesPatch)[vs[1].(int)]
	}).(GatewayStatusAddressesPatchOutput)
}

// Condition contains details for one aspect of the current state of this API Resource.
// ---
// This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{
//	    // Represents the observations of a foo's current state.
//	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
//	    // +patchMergeKey=type
//	    // +patchStrategy=merge
//	    // +listType=map
//	    // +listMapKey=type
//	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//
//
//	    // other fields
//	}
type GatewayStatusConditions struct {
	// lastTransitionTime is the last time the condition transitioned from one status to another.
	// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	LastTransitionTime *string `pulumi:"lastTransitionTime"`
	// message is a human readable message indicating details about the transition.
	// This may be an empty string.
	Message *string `pulumi:"message"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon.
	// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
	// with respect to the current state of the instance.
	ObservedGeneration *int `pulumi:"observedGeneration"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition.
	// Producers of specific condition types may define expected values and meanings for this field,
	// and whether the values are considered a guaranteed API.
	// The value should be a CamelCase string.
	// This field may not be empty.
	Reason *string `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status *string `pulumi:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase.
	// ---
	// Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
	// useful (see .node.status.conditions), the ability to deconflict is important.
	// The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
	Type *string `pulumi:"type"`
}

// GatewayStatusConditionsInput is an input type that accepts GatewayStatusConditionsArgs and GatewayStatusConditionsOutput values.
// You can construct a concrete instance of `GatewayStatusConditionsInput` via:
//
//	GatewayStatusConditionsArgs{...}
type GatewayStatusConditionsInput interface {
	pulumi.Input

	ToGatewayStatusConditionsOutput() GatewayStatusConditionsOutput
	ToGatewayStatusConditionsOutputWithContext(context.Context) GatewayStatusConditionsOutput
}

// Condition contains details for one aspect of the current state of this API Resource.
// ---
// This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{
//	    // Represents the observations of a foo's current state.
//	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
//	    // +patchMergeKey=type
//	    // +patchStrategy=merge
//	    // +listType=map
//	    // +listMapKey=type
//	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//
//
//	    // other fields
//	}
type GatewayStatusConditionsArgs struct {
	// lastTransitionTime is the last time the condition transitioned from one status to another.
	// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	LastTransitionTime pulumi.StringPtrInput `pulumi:"lastTransitionTime"`
	// message is a human readable message indicating details about the transition.
	// This may be an empty string.
	Message pulumi.StringPtrInput `pulumi:"message"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon.
	// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
	// with respect to the current state of the instance.
	ObservedGeneration pulumi.IntPtrInput `pulumi:"observedGeneration"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition.
	// Producers of specific condition types may define expected values and meanings for this field,
	// and whether the values are considered a guaranteed API.
	// The value should be a CamelCase string.
	// This field may not be empty.
	Reason pulumi.StringPtrInput `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status pulumi.StringPtrInput `pulumi:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase.
	// ---
	// Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
	// useful (see .node.status.conditions), the ability to deconflict is important.
	// The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (GatewayStatusConditionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayStatusConditions)(nil)).Elem()
}

func (i GatewayStatusConditionsArgs) ToGatewayStatusConditionsOutput() GatewayStatusConditionsOutput {
	return i.ToGatewayStatusConditionsOutputWithContext(context.Background())
}

func (i GatewayStatusConditionsArgs) ToGatewayStatusConditionsOutputWithContext(ctx context.Context) GatewayStatusConditionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayStatusConditionsOutput)
}

// GatewayStatusConditionsArrayInput is an input type that accepts GatewayStatusConditionsArray and GatewayStatusConditionsArrayOutput values.
// You can construct a concrete instance of `GatewayStatusConditionsArrayInput` via:
//
//	GatewayStatusConditionsArray{ GatewayStatusConditionsArgs{...} }
type GatewayStatusConditionsArrayInput interface {
	pulumi.Input

	ToGatewayStatusConditionsArrayOutput() GatewayStatusConditionsArrayOutput
	ToGatewayStatusConditionsArrayOutputWithContext(context.Context) GatewayStatusConditionsArrayOutput
}

type GatewayStatusConditionsArray []GatewayStatusConditionsInput

func (GatewayStatusConditionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewayStatusConditions)(nil)).Elem()
}

func (i GatewayStatusConditionsArray) ToGatewayStatusConditionsArrayOutput() GatewayStatusConditionsArrayOutput {
	return i.ToGatewayStatusConditionsArrayOutputWithContext(context.Background())
}

func (i GatewayStatusConditionsArray) ToGatewayStatusConditionsArrayOutputWithContext(ctx context.Context) GatewayStatusConditionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayStatusConditionsArrayOutput)
}

// Condition contains details for one aspect of the current state of this API Resource.
// ---
// This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{
//	    // Represents the observations of a foo's current state.
//	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
//	    // +patchMergeKey=type
//	    // +patchStrategy=merge
//	    // +listType=map
//	    // +listMapKey=type
//	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//
//
//	    // other fields
//	}
type GatewayStatusConditionsOutput struct{ *pulumi.OutputState }

func (GatewayStatusConditionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayStatusConditions)(nil)).Elem()
}

func (o GatewayStatusConditionsOutput) ToGatewayStatusConditionsOutput() GatewayStatusConditionsOutput {
	return o
}

func (o GatewayStatusConditionsOutput) ToGatewayStatusConditionsOutputWithContext(ctx context.Context) GatewayStatusConditionsOutput {
	return o
}

// lastTransitionTime is the last time the condition transitioned from one status to another.
// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
func (o GatewayStatusConditionsOutput) LastTransitionTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayStatusConditions) *string { return v.LastTransitionTime }).(pulumi.StringPtrOutput)
}

// message is a human readable message indicating details about the transition.
// This may be an empty string.
func (o GatewayStatusConditionsOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayStatusConditions) *string { return v.Message }).(pulumi.StringPtrOutput)
}

// observedGeneration represents the .metadata.generation that the condition was set based upon.
// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
// with respect to the current state of the instance.
func (o GatewayStatusConditionsOutput) ObservedGeneration() pulumi.IntPtrOutput {
	return o.ApplyT(func(v GatewayStatusConditions) *int { return v.ObservedGeneration }).(pulumi.IntPtrOutput)
}

// reason contains a programmatic identifier indicating the reason for the condition's last transition.
// Producers of specific condition types may define expected values and meanings for this field,
// and whether the values are considered a guaranteed API.
// The value should be a CamelCase string.
// This field may not be empty.
func (o GatewayStatusConditionsOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayStatusConditions) *string { return v.Reason }).(pulumi.StringPtrOutput)
}

// status of the condition, one of True, False, Unknown.
func (o GatewayStatusConditionsOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayStatusConditions) *string { return v.Status }).(pulumi.StringPtrOutput)
}

// type of condition in CamelCase or in foo.example.com/CamelCase.
// ---
// Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
// useful (see .node.status.conditions), the ability to deconflict is important.
// The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
func (o GatewayStatusConditionsOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayStatusConditions) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type GatewayStatusConditionsArrayOutput struct{ *pulumi.OutputState }

func (GatewayStatusConditionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewayStatusConditions)(nil)).Elem()
}

func (o GatewayStatusConditionsArrayOutput) ToGatewayStatusConditionsArrayOutput() GatewayStatusConditionsArrayOutput {
	return o
}

func (o GatewayStatusConditionsArrayOutput) ToGatewayStatusConditionsArrayOutputWithContext(ctx context.Context) GatewayStatusConditionsArrayOutput {
	return o
}

func (o GatewayStatusConditionsArrayOutput) Index(i pulumi.IntInput) GatewayStatusConditionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GatewayStatusConditions {
		return vs[0].([]GatewayStatusConditions)[vs[1].(int)]
	}).(GatewayStatusConditionsOutput)
}

// Condition contains details for one aspect of the current state of this API Resource.
// ---
// This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{
//	    // Represents the observations of a foo's current state.
//	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
//	    // +patchMergeKey=type
//	    // +patchStrategy=merge
//	    // +listType=map
//	    // +listMapKey=type
//	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//
//
//	    // other fields
//	}
type GatewayStatusConditionsPatch struct {
	// lastTransitionTime is the last time the condition transitioned from one status to another.
	// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	LastTransitionTime *string `pulumi:"lastTransitionTime"`
	// message is a human readable message indicating details about the transition.
	// This may be an empty string.
	Message *string `pulumi:"message"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon.
	// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
	// with respect to the current state of the instance.
	ObservedGeneration *int `pulumi:"observedGeneration"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition.
	// Producers of specific condition types may define expected values and meanings for this field,
	// and whether the values are considered a guaranteed API.
	// The value should be a CamelCase string.
	// This field may not be empty.
	Reason *string `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status *string `pulumi:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase.
	// ---
	// Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
	// useful (see .node.status.conditions), the ability to deconflict is important.
	// The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
	Type *string `pulumi:"type"`
}

// GatewayStatusConditionsPatchInput is an input type that accepts GatewayStatusConditionsPatchArgs and GatewayStatusConditionsPatchOutput values.
// You can construct a concrete instance of `GatewayStatusConditionsPatchInput` via:
//
//	GatewayStatusConditionsPatchArgs{...}
type GatewayStatusConditionsPatchInput interface {
	pulumi.Input

	ToGatewayStatusConditionsPatchOutput() GatewayStatusConditionsPatchOutput
	ToGatewayStatusConditionsPatchOutputWithContext(context.Context) GatewayStatusConditionsPatchOutput
}

// Condition contains details for one aspect of the current state of this API Resource.
// ---
// This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{
//	    // Represents the observations of a foo's current state.
//	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
//	    // +patchMergeKey=type
//	    // +patchStrategy=merge
//	    // +listType=map
//	    // +listMapKey=type
//	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//
//
//	    // other fields
//	}
type GatewayStatusConditionsPatchArgs struct {
	// lastTransitionTime is the last time the condition transitioned from one status to another.
	// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	LastTransitionTime pulumi.StringPtrInput `pulumi:"lastTransitionTime"`
	// message is a human readable message indicating details about the transition.
	// This may be an empty string.
	Message pulumi.StringPtrInput `pulumi:"message"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon.
	// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
	// with respect to the current state of the instance.
	ObservedGeneration pulumi.IntPtrInput `pulumi:"observedGeneration"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition.
	// Producers of specific condition types may define expected values and meanings for this field,
	// and whether the values are considered a guaranteed API.
	// The value should be a CamelCase string.
	// This field may not be empty.
	Reason pulumi.StringPtrInput `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status pulumi.StringPtrInput `pulumi:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase.
	// ---
	// Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
	// useful (see .node.status.conditions), the ability to deconflict is important.
	// The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (GatewayStatusConditionsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayStatusConditionsPatch)(nil)).Elem()
}

func (i GatewayStatusConditionsPatchArgs) ToGatewayStatusConditionsPatchOutput() GatewayStatusConditionsPatchOutput {
	return i.ToGatewayStatusConditionsPatchOutputWithContext(context.Background())
}

func (i GatewayStatusConditionsPatchArgs) ToGatewayStatusConditionsPatchOutputWithContext(ctx context.Context) GatewayStatusConditionsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayStatusConditionsPatchOutput)
}

// GatewayStatusConditionsPatchArrayInput is an input type that accepts GatewayStatusConditionsPatchArray and GatewayStatusConditionsPatchArrayOutput values.
// You can construct a concrete instance of `GatewayStatusConditionsPatchArrayInput` via:
//
//	GatewayStatusConditionsPatchArray{ GatewayStatusConditionsPatchArgs{...} }
type GatewayStatusConditionsPatchArrayInput interface {
	pulumi.Input

	ToGatewayStatusConditionsPatchArrayOutput() GatewayStatusConditionsPatchArrayOutput
	ToGatewayStatusConditionsPatchArrayOutputWithContext(context.Context) GatewayStatusConditionsPatchArrayOutput
}

type GatewayStatusConditionsPatchArray []GatewayStatusConditionsPatchInput

func (GatewayStatusConditionsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewayStatusConditionsPatch)(nil)).Elem()
}

func (i GatewayStatusConditionsPatchArray) ToGatewayStatusConditionsPatchArrayOutput() GatewayStatusConditionsPatchArrayOutput {
	return i.ToGatewayStatusConditionsPatchArrayOutputWithContext(context.Background())
}

func (i GatewayStatusConditionsPatchArray) ToGatewayStatusConditionsPatchArrayOutputWithContext(ctx context.Context) GatewayStatusConditionsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayStatusConditionsPatchArrayOutput)
}

// Condition contains details for one aspect of the current state of this API Resource.
// ---
// This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{
//	    // Represents the observations of a foo's current state.
//	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
//	    // +patchMergeKey=type
//	    // +patchStrategy=merge
//	    // +listType=map
//	    // +listMapKey=type
//	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//
//
//	    // other fields
//	}
type GatewayStatusConditionsPatchOutput struct{ *pulumi.OutputState }

func (GatewayStatusConditionsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayStatusConditionsPatch)(nil)).Elem()
}

func (o GatewayStatusConditionsPatchOutput) ToGatewayStatusConditionsPatchOutput() GatewayStatusConditionsPatchOutput {
	return o
}

func (o GatewayStatusConditionsPatchOutput) ToGatewayStatusConditionsPatchOutputWithContext(ctx context.Context) GatewayStatusConditionsPatchOutput {
	return o
}

// lastTransitionTime is the last time the condition transitioned from one status to another.
// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
func (o GatewayStatusConditionsPatchOutput) LastTransitionTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayStatusConditionsPatch) *string { return v.LastTransitionTime }).(pulumi.StringPtrOutput)
}

// message is a human readable message indicating details about the transition.
// This may be an empty string.
func (o GatewayStatusConditionsPatchOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayStatusConditionsPatch) *string { return v.Message }).(pulumi.StringPtrOutput)
}

// observedGeneration represents the .metadata.generation that the condition was set based upon.
// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
// with respect to the current state of the instance.
func (o GatewayStatusConditionsPatchOutput) ObservedGeneration() pulumi.IntPtrOutput {
	return o.ApplyT(func(v GatewayStatusConditionsPatch) *int { return v.ObservedGeneration }).(pulumi.IntPtrOutput)
}

// reason contains a programmatic identifier indicating the reason for the condition's last transition.
// Producers of specific condition types may define expected values and meanings for this field,
// and whether the values are considered a guaranteed API.
// The value should be a CamelCase string.
// This field may not be empty.
func (o GatewayStatusConditionsPatchOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayStatusConditionsPatch) *string { return v.Reason }).(pulumi.StringPtrOutput)
}

// status of the condition, one of True, False, Unknown.
func (o GatewayStatusConditionsPatchOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayStatusConditionsPatch) *string { return v.Status }).(pulumi.StringPtrOutput)
}

// type of condition in CamelCase or in foo.example.com/CamelCase.
// ---
// Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
// useful (see .node.status.conditions), the ability to deconflict is important.
// The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
func (o GatewayStatusConditionsPatchOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayStatusConditionsPatch) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type GatewayStatusConditionsPatchArrayOutput struct{ *pulumi.OutputState }

func (GatewayStatusConditionsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewayStatusConditionsPatch)(nil)).Elem()
}

func (o GatewayStatusConditionsPatchArrayOutput) ToGatewayStatusConditionsPatchArrayOutput() GatewayStatusConditionsPatchArrayOutput {
	return o
}

func (o GatewayStatusConditionsPatchArrayOutput) ToGatewayStatusConditionsPatchArrayOutputWithContext(ctx context.Context) GatewayStatusConditionsPatchArrayOutput {
	return o
}

func (o GatewayStatusConditionsPatchArrayOutput) Index(i pulumi.IntInput) GatewayStatusConditionsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GatewayStatusConditionsPatch {
		return vs[0].([]GatewayStatusConditionsPatch)[vs[1].(int)]
	}).(GatewayStatusConditionsPatchOutput)
}

// ListenerStatus is the status associated with a Listener.
type GatewayStatusListeners struct {
	// AttachedRoutes represents the total number of Routes that have been
	// successfully attached to this Listener.
	//
	// Successful attachment of a Route to a Listener is based solely on the
	// combination of the AllowedRoutes field on the corresponding Listener
	// and the Route's ParentRefs field. A Route is successfully attached to
	// a Listener when it is selected by the Listener's AllowedRoutes field
	// AND the Route has a valid ParentRef selecting the whole Gateway
	// resource or a specific Listener as a parent resource (more detail on
	// attachment semantics can be found in the documentation on the various
	// Route kinds ParentRefs fields). Listener or Route status does not impact
	// successful attachment, i.e. the AttachedRoutes field count MUST be set
	// for Listeners with condition Accepted: false and MUST count successfully
	// attached Routes that may themselves have Accepted: false conditions.
	//
	// Uses for this field include troubleshooting Route attachment and
	// measuring blast radius/impact of changes to a Listener.
	AttachedRoutes *int `pulumi:"attachedRoutes"`
	// Conditions describe the current condition of this listener.
	Conditions []GatewayStatusListenersConditions `pulumi:"conditions"`
	// Name is the name of the Listener that this status corresponds to.
	Name *string `pulumi:"name"`
	// SupportedKinds is the list indicating the Kinds supported by this
	// listener. This MUST represent the kinds an implementation supports for
	// that Listener configuration.
	//
	// If kinds are specified in Spec that are not supported, they MUST NOT
	// appear in this list and an implementation MUST set the "ResolvedRefs"
	// condition to "False" with the "InvalidRouteKinds" reason. If both valid
	// and invalid Route kinds are specified, the implementation MUST
	// reference the valid Route kinds that have been specified.
	SupportedKinds []GatewayStatusListenersSupportedKinds `pulumi:"supportedKinds"`
}

// GatewayStatusListenersInput is an input type that accepts GatewayStatusListenersArgs and GatewayStatusListenersOutput values.
// You can construct a concrete instance of `GatewayStatusListenersInput` via:
//
//	GatewayStatusListenersArgs{...}
type GatewayStatusListenersInput interface {
	pulumi.Input

	ToGatewayStatusListenersOutput() GatewayStatusListenersOutput
	ToGatewayStatusListenersOutputWithContext(context.Context) GatewayStatusListenersOutput
}

// ListenerStatus is the status associated with a Listener.
type GatewayStatusListenersArgs struct {
	// AttachedRoutes represents the total number of Routes that have been
	// successfully attached to this Listener.
	//
	// Successful attachment of a Route to a Listener is based solely on the
	// combination of the AllowedRoutes field on the corresponding Listener
	// and the Route's ParentRefs field. A Route is successfully attached to
	// a Listener when it is selected by the Listener's AllowedRoutes field
	// AND the Route has a valid ParentRef selecting the whole Gateway
	// resource or a specific Listener as a parent resource (more detail on
	// attachment semantics can be found in the documentation on the various
	// Route kinds ParentRefs fields). Listener or Route status does not impact
	// successful attachment, i.e. the AttachedRoutes field count MUST be set
	// for Listeners with condition Accepted: false and MUST count successfully
	// attached Routes that may themselves have Accepted: false conditions.
	//
	// Uses for this field include troubleshooting Route attachment and
	// measuring blast radius/impact of changes to a Listener.
	AttachedRoutes pulumi.IntPtrInput `pulumi:"attachedRoutes"`
	// Conditions describe the current condition of this listener.
	Conditions GatewayStatusListenersConditionsArrayInput `pulumi:"conditions"`
	// Name is the name of the Listener that this status corresponds to.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// SupportedKinds is the list indicating the Kinds supported by this
	// listener. This MUST represent the kinds an implementation supports for
	// that Listener configuration.
	//
	// If kinds are specified in Spec that are not supported, they MUST NOT
	// appear in this list and an implementation MUST set the "ResolvedRefs"
	// condition to "False" with the "InvalidRouteKinds" reason. If both valid
	// and invalid Route kinds are specified, the implementation MUST
	// reference the valid Route kinds that have been specified.
	SupportedKinds GatewayStatusListenersSupportedKindsArrayInput `pulumi:"supportedKinds"`
}

func (GatewayStatusListenersArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayStatusListeners)(nil)).Elem()
}

func (i GatewayStatusListenersArgs) ToGatewayStatusListenersOutput() GatewayStatusListenersOutput {
	return i.ToGatewayStatusListenersOutputWithContext(context.Background())
}

func (i GatewayStatusListenersArgs) ToGatewayStatusListenersOutputWithContext(ctx context.Context) GatewayStatusListenersOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayStatusListenersOutput)
}

// GatewayStatusListenersArrayInput is an input type that accepts GatewayStatusListenersArray and GatewayStatusListenersArrayOutput values.
// You can construct a concrete instance of `GatewayStatusListenersArrayInput` via:
//
//	GatewayStatusListenersArray{ GatewayStatusListenersArgs{...} }
type GatewayStatusListenersArrayInput interface {
	pulumi.Input

	ToGatewayStatusListenersArrayOutput() GatewayStatusListenersArrayOutput
	ToGatewayStatusListenersArrayOutputWithContext(context.Context) GatewayStatusListenersArrayOutput
}

type GatewayStatusListenersArray []GatewayStatusListenersInput

func (GatewayStatusListenersArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewayStatusListeners)(nil)).Elem()
}

func (i GatewayStatusListenersArray) ToGatewayStatusListenersArrayOutput() GatewayStatusListenersArrayOutput {
	return i.ToGatewayStatusListenersArrayOutputWithContext(context.Background())
}

func (i GatewayStatusListenersArray) ToGatewayStatusListenersArrayOutputWithContext(ctx context.Context) GatewayStatusListenersArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayStatusListenersArrayOutput)
}

// ListenerStatus is the status associated with a Listener.
type GatewayStatusListenersOutput struct{ *pulumi.OutputState }

func (GatewayStatusListenersOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayStatusListeners)(nil)).Elem()
}

func (o GatewayStatusListenersOutput) ToGatewayStatusListenersOutput() GatewayStatusListenersOutput {
	return o
}

func (o GatewayStatusListenersOutput) ToGatewayStatusListenersOutputWithContext(ctx context.Context) GatewayStatusListenersOutput {
	return o
}

// AttachedRoutes represents the total number of Routes that have been
// successfully attached to this Listener.
//
// Successful attachment of a Route to a Listener is based solely on the
// combination of the AllowedRoutes field on the corresponding Listener
// and the Route's ParentRefs field. A Route is successfully attached to
// a Listener when it is selected by the Listener's AllowedRoutes field
// AND the Route has a valid ParentRef selecting the whole Gateway
// resource or a specific Listener as a parent resource (more detail on
// attachment semantics can be found in the documentation on the various
// Route kinds ParentRefs fields). Listener or Route status does not impact
// successful attachment, i.e. the AttachedRoutes field count MUST be set
// for Listeners with condition Accepted: false and MUST count successfully
// attached Routes that may themselves have Accepted: false conditions.
//
// Uses for this field include troubleshooting Route attachment and
// measuring blast radius/impact of changes to a Listener.
func (o GatewayStatusListenersOutput) AttachedRoutes() pulumi.IntPtrOutput {
	return o.ApplyT(func(v GatewayStatusListeners) *int { return v.AttachedRoutes }).(pulumi.IntPtrOutput)
}

// Conditions describe the current condition of this listener.
func (o GatewayStatusListenersOutput) Conditions() GatewayStatusListenersConditionsArrayOutput {
	return o.ApplyT(func(v GatewayStatusListeners) []GatewayStatusListenersConditions { return v.Conditions }).(GatewayStatusListenersConditionsArrayOutput)
}

// Name is the name of the Listener that this status corresponds to.
func (o GatewayStatusListenersOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayStatusListeners) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// SupportedKinds is the list indicating the Kinds supported by this
// listener. This MUST represent the kinds an implementation supports for
// that Listener configuration.
//
// If kinds are specified in Spec that are not supported, they MUST NOT
// appear in this list and an implementation MUST set the "ResolvedRefs"
// condition to "False" with the "InvalidRouteKinds" reason. If both valid
// and invalid Route kinds are specified, the implementation MUST
// reference the valid Route kinds that have been specified.
func (o GatewayStatusListenersOutput) SupportedKinds() GatewayStatusListenersSupportedKindsArrayOutput {
	return o.ApplyT(func(v GatewayStatusListeners) []GatewayStatusListenersSupportedKinds { return v.SupportedKinds }).(GatewayStatusListenersSupportedKindsArrayOutput)
}

type GatewayStatusListenersArrayOutput struct{ *pulumi.OutputState }

func (GatewayStatusListenersArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewayStatusListeners)(nil)).Elem()
}

func (o GatewayStatusListenersArrayOutput) ToGatewayStatusListenersArrayOutput() GatewayStatusListenersArrayOutput {
	return o
}

func (o GatewayStatusListenersArrayOutput) ToGatewayStatusListenersArrayOutputWithContext(ctx context.Context) GatewayStatusListenersArrayOutput {
	return o
}

func (o GatewayStatusListenersArrayOutput) Index(i pulumi.IntInput) GatewayStatusListenersOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GatewayStatusListeners {
		return vs[0].([]GatewayStatusListeners)[vs[1].(int)]
	}).(GatewayStatusListenersOutput)
}

// Condition contains details for one aspect of the current state of this API Resource.
// ---
// This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{
//	    // Represents the observations of a foo's current state.
//	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
//	    // +patchMergeKey=type
//	    // +patchStrategy=merge
//	    // +listType=map
//	    // +listMapKey=type
//	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//
//
//	    // other fields
//	}
type GatewayStatusListenersConditions struct {
	// lastTransitionTime is the last time the condition transitioned from one status to another.
	// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	LastTransitionTime *string `pulumi:"lastTransitionTime"`
	// message is a human readable message indicating details about the transition.
	// This may be an empty string.
	Message *string `pulumi:"message"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon.
	// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
	// with respect to the current state of the instance.
	ObservedGeneration *int `pulumi:"observedGeneration"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition.
	// Producers of specific condition types may define expected values and meanings for this field,
	// and whether the values are considered a guaranteed API.
	// The value should be a CamelCase string.
	// This field may not be empty.
	Reason *string `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status *string `pulumi:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase.
	// ---
	// Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
	// useful (see .node.status.conditions), the ability to deconflict is important.
	// The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
	Type *string `pulumi:"type"`
}

// GatewayStatusListenersConditionsInput is an input type that accepts GatewayStatusListenersConditionsArgs and GatewayStatusListenersConditionsOutput values.
// You can construct a concrete instance of `GatewayStatusListenersConditionsInput` via:
//
//	GatewayStatusListenersConditionsArgs{...}
type GatewayStatusListenersConditionsInput interface {
	pulumi.Input

	ToGatewayStatusListenersConditionsOutput() GatewayStatusListenersConditionsOutput
	ToGatewayStatusListenersConditionsOutputWithContext(context.Context) GatewayStatusListenersConditionsOutput
}

// Condition contains details for one aspect of the current state of this API Resource.
// ---
// This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{
//	    // Represents the observations of a foo's current state.
//	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
//	    // +patchMergeKey=type
//	    // +patchStrategy=merge
//	    // +listType=map
//	    // +listMapKey=type
//	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//
//
//	    // other fields
//	}
type GatewayStatusListenersConditionsArgs struct {
	// lastTransitionTime is the last time the condition transitioned from one status to another.
	// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	LastTransitionTime pulumi.StringPtrInput `pulumi:"lastTransitionTime"`
	// message is a human readable message indicating details about the transition.
	// This may be an empty string.
	Message pulumi.StringPtrInput `pulumi:"message"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon.
	// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
	// with respect to the current state of the instance.
	ObservedGeneration pulumi.IntPtrInput `pulumi:"observedGeneration"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition.
	// Producers of specific condition types may define expected values and meanings for this field,
	// and whether the values are considered a guaranteed API.
	// The value should be a CamelCase string.
	// This field may not be empty.
	Reason pulumi.StringPtrInput `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status pulumi.StringPtrInput `pulumi:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase.
	// ---
	// Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
	// useful (see .node.status.conditions), the ability to deconflict is important.
	// The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (GatewayStatusListenersConditionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayStatusListenersConditions)(nil)).Elem()
}

func (i GatewayStatusListenersConditionsArgs) ToGatewayStatusListenersConditionsOutput() GatewayStatusListenersConditionsOutput {
	return i.ToGatewayStatusListenersConditionsOutputWithContext(context.Background())
}

func (i GatewayStatusListenersConditionsArgs) ToGatewayStatusListenersConditionsOutputWithContext(ctx context.Context) GatewayStatusListenersConditionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayStatusListenersConditionsOutput)
}

// GatewayStatusListenersConditionsArrayInput is an input type that accepts GatewayStatusListenersConditionsArray and GatewayStatusListenersConditionsArrayOutput values.
// You can construct a concrete instance of `GatewayStatusListenersConditionsArrayInput` via:
//
//	GatewayStatusListenersConditionsArray{ GatewayStatusListenersConditionsArgs{...} }
type GatewayStatusListenersConditionsArrayInput interface {
	pulumi.Input

	ToGatewayStatusListenersConditionsArrayOutput() GatewayStatusListenersConditionsArrayOutput
	ToGatewayStatusListenersConditionsArrayOutputWithContext(context.Context) GatewayStatusListenersConditionsArrayOutput
}

type GatewayStatusListenersConditionsArray []GatewayStatusListenersConditionsInput

func (GatewayStatusListenersConditionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewayStatusListenersConditions)(nil)).Elem()
}

func (i GatewayStatusListenersConditionsArray) ToGatewayStatusListenersConditionsArrayOutput() GatewayStatusListenersConditionsArrayOutput {
	return i.ToGatewayStatusListenersConditionsArrayOutputWithContext(context.Background())
}

func (i GatewayStatusListenersConditionsArray) ToGatewayStatusListenersConditionsArrayOutputWithContext(ctx context.Context) GatewayStatusListenersConditionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayStatusListenersConditionsArrayOutput)
}

// Condition contains details for one aspect of the current state of this API Resource.
// ---
// This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{
//	    // Represents the observations of a foo's current state.
//	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
//	    // +patchMergeKey=type
//	    // +patchStrategy=merge
//	    // +listType=map
//	    // +listMapKey=type
//	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//
//
//	    // other fields
//	}
type GatewayStatusListenersConditionsOutput struct{ *pulumi.OutputState }

func (GatewayStatusListenersConditionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayStatusListenersConditions)(nil)).Elem()
}

func (o GatewayStatusListenersConditionsOutput) ToGatewayStatusListenersConditionsOutput() GatewayStatusListenersConditionsOutput {
	return o
}

func (o GatewayStatusListenersConditionsOutput) ToGatewayStatusListenersConditionsOutputWithContext(ctx context.Context) GatewayStatusListenersConditionsOutput {
	return o
}

// lastTransitionTime is the last time the condition transitioned from one status to another.
// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
func (o GatewayStatusListenersConditionsOutput) LastTransitionTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayStatusListenersConditions) *string { return v.LastTransitionTime }).(pulumi.StringPtrOutput)
}

// message is a human readable message indicating details about the transition.
// This may be an empty string.
func (o GatewayStatusListenersConditionsOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayStatusListenersConditions) *string { return v.Message }).(pulumi.StringPtrOutput)
}

// observedGeneration represents the .metadata.generation that the condition was set based upon.
// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
// with respect to the current state of the instance.
func (o GatewayStatusListenersConditionsOutput) ObservedGeneration() pulumi.IntPtrOutput {
	return o.ApplyT(func(v GatewayStatusListenersConditions) *int { return v.ObservedGeneration }).(pulumi.IntPtrOutput)
}

// reason contains a programmatic identifier indicating the reason for the condition's last transition.
// Producers of specific condition types may define expected values and meanings for this field,
// and whether the values are considered a guaranteed API.
// The value should be a CamelCase string.
// This field may not be empty.
func (o GatewayStatusListenersConditionsOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayStatusListenersConditions) *string { return v.Reason }).(pulumi.StringPtrOutput)
}

// status of the condition, one of True, False, Unknown.
func (o GatewayStatusListenersConditionsOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayStatusListenersConditions) *string { return v.Status }).(pulumi.StringPtrOutput)
}

// type of condition in CamelCase or in foo.example.com/CamelCase.
// ---
// Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
// useful (see .node.status.conditions), the ability to deconflict is important.
// The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
func (o GatewayStatusListenersConditionsOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayStatusListenersConditions) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type GatewayStatusListenersConditionsArrayOutput struct{ *pulumi.OutputState }

func (GatewayStatusListenersConditionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewayStatusListenersConditions)(nil)).Elem()
}

func (o GatewayStatusListenersConditionsArrayOutput) ToGatewayStatusListenersConditionsArrayOutput() GatewayStatusListenersConditionsArrayOutput {
	return o
}

func (o GatewayStatusListenersConditionsArrayOutput) ToGatewayStatusListenersConditionsArrayOutputWithContext(ctx context.Context) GatewayStatusListenersConditionsArrayOutput {
	return o
}

func (o GatewayStatusListenersConditionsArrayOutput) Index(i pulumi.IntInput) GatewayStatusListenersConditionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GatewayStatusListenersConditions {
		return vs[0].([]GatewayStatusListenersConditions)[vs[1].(int)]
	}).(GatewayStatusListenersConditionsOutput)
}

// Condition contains details for one aspect of the current state of this API Resource.
// ---
// This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{
//	    // Represents the observations of a foo's current state.
//	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
//	    // +patchMergeKey=type
//	    // +patchStrategy=merge
//	    // +listType=map
//	    // +listMapKey=type
//	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//
//
//	    // other fields
//	}
type GatewayStatusListenersConditionsPatch struct {
	// lastTransitionTime is the last time the condition transitioned from one status to another.
	// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	LastTransitionTime *string `pulumi:"lastTransitionTime"`
	// message is a human readable message indicating details about the transition.
	// This may be an empty string.
	Message *string `pulumi:"message"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon.
	// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
	// with respect to the current state of the instance.
	ObservedGeneration *int `pulumi:"observedGeneration"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition.
	// Producers of specific condition types may define expected values and meanings for this field,
	// and whether the values are considered a guaranteed API.
	// The value should be a CamelCase string.
	// This field may not be empty.
	Reason *string `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status *string `pulumi:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase.
	// ---
	// Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
	// useful (see .node.status.conditions), the ability to deconflict is important.
	// The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
	Type *string `pulumi:"type"`
}

// GatewayStatusListenersConditionsPatchInput is an input type that accepts GatewayStatusListenersConditionsPatchArgs and GatewayStatusListenersConditionsPatchOutput values.
// You can construct a concrete instance of `GatewayStatusListenersConditionsPatchInput` via:
//
//	GatewayStatusListenersConditionsPatchArgs{...}
type GatewayStatusListenersConditionsPatchInput interface {
	pulumi.Input

	ToGatewayStatusListenersConditionsPatchOutput() GatewayStatusListenersConditionsPatchOutput
	ToGatewayStatusListenersConditionsPatchOutputWithContext(context.Context) GatewayStatusListenersConditionsPatchOutput
}

// Condition contains details for one aspect of the current state of this API Resource.
// ---
// This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{
//	    // Represents the observations of a foo's current state.
//	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
//	    // +patchMergeKey=type
//	    // +patchStrategy=merge
//	    // +listType=map
//	    // +listMapKey=type
//	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//
//
//	    // other fields
//	}
type GatewayStatusListenersConditionsPatchArgs struct {
	// lastTransitionTime is the last time the condition transitioned from one status to another.
	// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	LastTransitionTime pulumi.StringPtrInput `pulumi:"lastTransitionTime"`
	// message is a human readable message indicating details about the transition.
	// This may be an empty string.
	Message pulumi.StringPtrInput `pulumi:"message"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon.
	// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
	// with respect to the current state of the instance.
	ObservedGeneration pulumi.IntPtrInput `pulumi:"observedGeneration"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition.
	// Producers of specific condition types may define expected values and meanings for this field,
	// and whether the values are considered a guaranteed API.
	// The value should be a CamelCase string.
	// This field may not be empty.
	Reason pulumi.StringPtrInput `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status pulumi.StringPtrInput `pulumi:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase.
	// ---
	// Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
	// useful (see .node.status.conditions), the ability to deconflict is important.
	// The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (GatewayStatusListenersConditionsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayStatusListenersConditionsPatch)(nil)).Elem()
}

func (i GatewayStatusListenersConditionsPatchArgs) ToGatewayStatusListenersConditionsPatchOutput() GatewayStatusListenersConditionsPatchOutput {
	return i.ToGatewayStatusListenersConditionsPatchOutputWithContext(context.Background())
}

func (i GatewayStatusListenersConditionsPatchArgs) ToGatewayStatusListenersConditionsPatchOutputWithContext(ctx context.Context) GatewayStatusListenersConditionsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayStatusListenersConditionsPatchOutput)
}

// GatewayStatusListenersConditionsPatchArrayInput is an input type that accepts GatewayStatusListenersConditionsPatchArray and GatewayStatusListenersConditionsPatchArrayOutput values.
// You can construct a concrete instance of `GatewayStatusListenersConditionsPatchArrayInput` via:
//
//	GatewayStatusListenersConditionsPatchArray{ GatewayStatusListenersConditionsPatchArgs{...} }
type GatewayStatusListenersConditionsPatchArrayInput interface {
	pulumi.Input

	ToGatewayStatusListenersConditionsPatchArrayOutput() GatewayStatusListenersConditionsPatchArrayOutput
	ToGatewayStatusListenersConditionsPatchArrayOutputWithContext(context.Context) GatewayStatusListenersConditionsPatchArrayOutput
}

type GatewayStatusListenersConditionsPatchArray []GatewayStatusListenersConditionsPatchInput

func (GatewayStatusListenersConditionsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewayStatusListenersConditionsPatch)(nil)).Elem()
}

func (i GatewayStatusListenersConditionsPatchArray) ToGatewayStatusListenersConditionsPatchArrayOutput() GatewayStatusListenersConditionsPatchArrayOutput {
	return i.ToGatewayStatusListenersConditionsPatchArrayOutputWithContext(context.Background())
}

func (i GatewayStatusListenersConditionsPatchArray) ToGatewayStatusListenersConditionsPatchArrayOutputWithContext(ctx context.Context) GatewayStatusListenersConditionsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayStatusListenersConditionsPatchArrayOutput)
}

// Condition contains details for one aspect of the current state of this API Resource.
// ---
// This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{
//	    // Represents the observations of a foo's current state.
//	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
//	    // +patchMergeKey=type
//	    // +patchStrategy=merge
//	    // +listType=map
//	    // +listMapKey=type
//	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//
//
//	    // other fields
//	}
type GatewayStatusListenersConditionsPatchOutput struct{ *pulumi.OutputState }

func (GatewayStatusListenersConditionsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayStatusListenersConditionsPatch)(nil)).Elem()
}

func (o GatewayStatusListenersConditionsPatchOutput) ToGatewayStatusListenersConditionsPatchOutput() GatewayStatusListenersConditionsPatchOutput {
	return o
}

func (o GatewayStatusListenersConditionsPatchOutput) ToGatewayStatusListenersConditionsPatchOutputWithContext(ctx context.Context) GatewayStatusListenersConditionsPatchOutput {
	return o
}

// lastTransitionTime is the last time the condition transitioned from one status to another.
// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
func (o GatewayStatusListenersConditionsPatchOutput) LastTransitionTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayStatusListenersConditionsPatch) *string { return v.LastTransitionTime }).(pulumi.StringPtrOutput)
}

// message is a human readable message indicating details about the transition.
// This may be an empty string.
func (o GatewayStatusListenersConditionsPatchOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayStatusListenersConditionsPatch) *string { return v.Message }).(pulumi.StringPtrOutput)
}

// observedGeneration represents the .metadata.generation that the condition was set based upon.
// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
// with respect to the current state of the instance.
func (o GatewayStatusListenersConditionsPatchOutput) ObservedGeneration() pulumi.IntPtrOutput {
	return o.ApplyT(func(v GatewayStatusListenersConditionsPatch) *int { return v.ObservedGeneration }).(pulumi.IntPtrOutput)
}

// reason contains a programmatic identifier indicating the reason for the condition's last transition.
// Producers of specific condition types may define expected values and meanings for this field,
// and whether the values are considered a guaranteed API.
// The value should be a CamelCase string.
// This field may not be empty.
func (o GatewayStatusListenersConditionsPatchOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayStatusListenersConditionsPatch) *string { return v.Reason }).(pulumi.StringPtrOutput)
}

// status of the condition, one of True, False, Unknown.
func (o GatewayStatusListenersConditionsPatchOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayStatusListenersConditionsPatch) *string { return v.Status }).(pulumi.StringPtrOutput)
}

// type of condition in CamelCase or in foo.example.com/CamelCase.
// ---
// Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
// useful (see .node.status.conditions), the ability to deconflict is important.
// The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
func (o GatewayStatusListenersConditionsPatchOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayStatusListenersConditionsPatch) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type GatewayStatusListenersConditionsPatchArrayOutput struct{ *pulumi.OutputState }

func (GatewayStatusListenersConditionsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewayStatusListenersConditionsPatch)(nil)).Elem()
}

func (o GatewayStatusListenersConditionsPatchArrayOutput) ToGatewayStatusListenersConditionsPatchArrayOutput() GatewayStatusListenersConditionsPatchArrayOutput {
	return o
}

func (o GatewayStatusListenersConditionsPatchArrayOutput) ToGatewayStatusListenersConditionsPatchArrayOutputWithContext(ctx context.Context) GatewayStatusListenersConditionsPatchArrayOutput {
	return o
}

func (o GatewayStatusListenersConditionsPatchArrayOutput) Index(i pulumi.IntInput) GatewayStatusListenersConditionsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GatewayStatusListenersConditionsPatch {
		return vs[0].([]GatewayStatusListenersConditionsPatch)[vs[1].(int)]
	}).(GatewayStatusListenersConditionsPatchOutput)
}

// ListenerStatus is the status associated with a Listener.
type GatewayStatusListenersPatch struct {
	// AttachedRoutes represents the total number of Routes that have been
	// successfully attached to this Listener.
	//
	// Successful attachment of a Route to a Listener is based solely on the
	// combination of the AllowedRoutes field on the corresponding Listener
	// and the Route's ParentRefs field. A Route is successfully attached to
	// a Listener when it is selected by the Listener's AllowedRoutes field
	// AND the Route has a valid ParentRef selecting the whole Gateway
	// resource or a specific Listener as a parent resource (more detail on
	// attachment semantics can be found in the documentation on the various
	// Route kinds ParentRefs fields). Listener or Route status does not impact
	// successful attachment, i.e. the AttachedRoutes field count MUST be set
	// for Listeners with condition Accepted: false and MUST count successfully
	// attached Routes that may themselves have Accepted: false conditions.
	//
	// Uses for this field include troubleshooting Route attachment and
	// measuring blast radius/impact of changes to a Listener.
	AttachedRoutes *int `pulumi:"attachedRoutes"`
	// Conditions describe the current condition of this listener.
	Conditions []GatewayStatusListenersConditionsPatch `pulumi:"conditions"`
	// Name is the name of the Listener that this status corresponds to.
	Name *string `pulumi:"name"`
	// SupportedKinds is the list indicating the Kinds supported by this
	// listener. This MUST represent the kinds an implementation supports for
	// that Listener configuration.
	//
	// If kinds are specified in Spec that are not supported, they MUST NOT
	// appear in this list and an implementation MUST set the "ResolvedRefs"
	// condition to "False" with the "InvalidRouteKinds" reason. If both valid
	// and invalid Route kinds are specified, the implementation MUST
	// reference the valid Route kinds that have been specified.
	SupportedKinds []GatewayStatusListenersSupportedKindsPatch `pulumi:"supportedKinds"`
}

// GatewayStatusListenersPatchInput is an input type that accepts GatewayStatusListenersPatchArgs and GatewayStatusListenersPatchOutput values.
// You can construct a concrete instance of `GatewayStatusListenersPatchInput` via:
//
//	GatewayStatusListenersPatchArgs{...}
type GatewayStatusListenersPatchInput interface {
	pulumi.Input

	ToGatewayStatusListenersPatchOutput() GatewayStatusListenersPatchOutput
	ToGatewayStatusListenersPatchOutputWithContext(context.Context) GatewayStatusListenersPatchOutput
}

// ListenerStatus is the status associated with a Listener.
type GatewayStatusListenersPatchArgs struct {
	// AttachedRoutes represents the total number of Routes that have been
	// successfully attached to this Listener.
	//
	// Successful attachment of a Route to a Listener is based solely on the
	// combination of the AllowedRoutes field on the corresponding Listener
	// and the Route's ParentRefs field. A Route is successfully attached to
	// a Listener when it is selected by the Listener's AllowedRoutes field
	// AND the Route has a valid ParentRef selecting the whole Gateway
	// resource or a specific Listener as a parent resource (more detail on
	// attachment semantics can be found in the documentation on the various
	// Route kinds ParentRefs fields). Listener or Route status does not impact
	// successful attachment, i.e. the AttachedRoutes field count MUST be set
	// for Listeners with condition Accepted: false and MUST count successfully
	// attached Routes that may themselves have Accepted: false conditions.
	//
	// Uses for this field include troubleshooting Route attachment and
	// measuring blast radius/impact of changes to a Listener.
	AttachedRoutes pulumi.IntPtrInput `pulumi:"attachedRoutes"`
	// Conditions describe the current condition of this listener.
	Conditions GatewayStatusListenersConditionsPatchArrayInput `pulumi:"conditions"`
	// Name is the name of the Listener that this status corresponds to.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// SupportedKinds is the list indicating the Kinds supported by this
	// listener. This MUST represent the kinds an implementation supports for
	// that Listener configuration.
	//
	// If kinds are specified in Spec that are not supported, they MUST NOT
	// appear in this list and an implementation MUST set the "ResolvedRefs"
	// condition to "False" with the "InvalidRouteKinds" reason. If both valid
	// and invalid Route kinds are specified, the implementation MUST
	// reference the valid Route kinds that have been specified.
	SupportedKinds GatewayStatusListenersSupportedKindsPatchArrayInput `pulumi:"supportedKinds"`
}

func (GatewayStatusListenersPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayStatusListenersPatch)(nil)).Elem()
}

func (i GatewayStatusListenersPatchArgs) ToGatewayStatusListenersPatchOutput() GatewayStatusListenersPatchOutput {
	return i.ToGatewayStatusListenersPatchOutputWithContext(context.Background())
}

func (i GatewayStatusListenersPatchArgs) ToGatewayStatusListenersPatchOutputWithContext(ctx context.Context) GatewayStatusListenersPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayStatusListenersPatchOutput)
}

// GatewayStatusListenersPatchArrayInput is an input type that accepts GatewayStatusListenersPatchArray and GatewayStatusListenersPatchArrayOutput values.
// You can construct a concrete instance of `GatewayStatusListenersPatchArrayInput` via:
//
//	GatewayStatusListenersPatchArray{ GatewayStatusListenersPatchArgs{...} }
type GatewayStatusListenersPatchArrayInput interface {
	pulumi.Input

	ToGatewayStatusListenersPatchArrayOutput() GatewayStatusListenersPatchArrayOutput
	ToGatewayStatusListenersPatchArrayOutputWithContext(context.Context) GatewayStatusListenersPatchArrayOutput
}

type GatewayStatusListenersPatchArray []GatewayStatusListenersPatchInput

func (GatewayStatusListenersPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewayStatusListenersPatch)(nil)).Elem()
}

func (i GatewayStatusListenersPatchArray) ToGatewayStatusListenersPatchArrayOutput() GatewayStatusListenersPatchArrayOutput {
	return i.ToGatewayStatusListenersPatchArrayOutputWithContext(context.Background())
}

func (i GatewayStatusListenersPatchArray) ToGatewayStatusListenersPatchArrayOutputWithContext(ctx context.Context) GatewayStatusListenersPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayStatusListenersPatchArrayOutput)
}

// ListenerStatus is the status associated with a Listener.
type GatewayStatusListenersPatchOutput struct{ *pulumi.OutputState }

func (GatewayStatusListenersPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayStatusListenersPatch)(nil)).Elem()
}

func (o GatewayStatusListenersPatchOutput) ToGatewayStatusListenersPatchOutput() GatewayStatusListenersPatchOutput {
	return o
}

func (o GatewayStatusListenersPatchOutput) ToGatewayStatusListenersPatchOutputWithContext(ctx context.Context) GatewayStatusListenersPatchOutput {
	return o
}

// AttachedRoutes represents the total number of Routes that have been
// successfully attached to this Listener.
//
// Successful attachment of a Route to a Listener is based solely on the
// combination of the AllowedRoutes field on the corresponding Listener
// and the Route's ParentRefs field. A Route is successfully attached to
// a Listener when it is selected by the Listener's AllowedRoutes field
// AND the Route has a valid ParentRef selecting the whole Gateway
// resource or a specific Listener as a parent resource (more detail on
// attachment semantics can be found in the documentation on the various
// Route kinds ParentRefs fields). Listener or Route status does not impact
// successful attachment, i.e. the AttachedRoutes field count MUST be set
// for Listeners with condition Accepted: false and MUST count successfully
// attached Routes that may themselves have Accepted: false conditions.
//
// Uses for this field include troubleshooting Route attachment and
// measuring blast radius/impact of changes to a Listener.
func (o GatewayStatusListenersPatchOutput) AttachedRoutes() pulumi.IntPtrOutput {
	return o.ApplyT(func(v GatewayStatusListenersPatch) *int { return v.AttachedRoutes }).(pulumi.IntPtrOutput)
}

// Conditions describe the current condition of this listener.
func (o GatewayStatusListenersPatchOutput) Conditions() GatewayStatusListenersConditionsPatchArrayOutput {
	return o.ApplyT(func(v GatewayStatusListenersPatch) []GatewayStatusListenersConditionsPatch { return v.Conditions }).(GatewayStatusListenersConditionsPatchArrayOutput)
}

// Name is the name of the Listener that this status corresponds to.
func (o GatewayStatusListenersPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayStatusListenersPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// SupportedKinds is the list indicating the Kinds supported by this
// listener. This MUST represent the kinds an implementation supports for
// that Listener configuration.
//
// If kinds are specified in Spec that are not supported, they MUST NOT
// appear in this list and an implementation MUST set the "ResolvedRefs"
// condition to "False" with the "InvalidRouteKinds" reason. If both valid
// and invalid Route kinds are specified, the implementation MUST
// reference the valid Route kinds that have been specified.
func (o GatewayStatusListenersPatchOutput) SupportedKinds() GatewayStatusListenersSupportedKindsPatchArrayOutput {
	return o.ApplyT(func(v GatewayStatusListenersPatch) []GatewayStatusListenersSupportedKindsPatch {
		return v.SupportedKinds
	}).(GatewayStatusListenersSupportedKindsPatchArrayOutput)
}

type GatewayStatusListenersPatchArrayOutput struct{ *pulumi.OutputState }

func (GatewayStatusListenersPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewayStatusListenersPatch)(nil)).Elem()
}

func (o GatewayStatusListenersPatchArrayOutput) ToGatewayStatusListenersPatchArrayOutput() GatewayStatusListenersPatchArrayOutput {
	return o
}

func (o GatewayStatusListenersPatchArrayOutput) ToGatewayStatusListenersPatchArrayOutputWithContext(ctx context.Context) GatewayStatusListenersPatchArrayOutput {
	return o
}

func (o GatewayStatusListenersPatchArrayOutput) Index(i pulumi.IntInput) GatewayStatusListenersPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GatewayStatusListenersPatch {
		return vs[0].([]GatewayStatusListenersPatch)[vs[1].(int)]
	}).(GatewayStatusListenersPatchOutput)
}

// RouteGroupKind indicates the group and kind of a Route resource.
type GatewayStatusListenersSupportedKinds struct {
	// Group is the group of the Route.
	Group *string `pulumi:"group"`
	// Kind is the kind of the Route.
	Kind *string `pulumi:"kind"`
}

// GatewayStatusListenersSupportedKindsInput is an input type that accepts GatewayStatusListenersSupportedKindsArgs and GatewayStatusListenersSupportedKindsOutput values.
// You can construct a concrete instance of `GatewayStatusListenersSupportedKindsInput` via:
//
//	GatewayStatusListenersSupportedKindsArgs{...}
type GatewayStatusListenersSupportedKindsInput interface {
	pulumi.Input

	ToGatewayStatusListenersSupportedKindsOutput() GatewayStatusListenersSupportedKindsOutput
	ToGatewayStatusListenersSupportedKindsOutputWithContext(context.Context) GatewayStatusListenersSupportedKindsOutput
}

// RouteGroupKind indicates the group and kind of a Route resource.
type GatewayStatusListenersSupportedKindsArgs struct {
	// Group is the group of the Route.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is the kind of the Route.
	Kind pulumi.StringPtrInput `pulumi:"kind"`
}

func (GatewayStatusListenersSupportedKindsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayStatusListenersSupportedKinds)(nil)).Elem()
}

func (i GatewayStatusListenersSupportedKindsArgs) ToGatewayStatusListenersSupportedKindsOutput() GatewayStatusListenersSupportedKindsOutput {
	return i.ToGatewayStatusListenersSupportedKindsOutputWithContext(context.Background())
}

func (i GatewayStatusListenersSupportedKindsArgs) ToGatewayStatusListenersSupportedKindsOutputWithContext(ctx context.Context) GatewayStatusListenersSupportedKindsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayStatusListenersSupportedKindsOutput)
}

// GatewayStatusListenersSupportedKindsArrayInput is an input type that accepts GatewayStatusListenersSupportedKindsArray and GatewayStatusListenersSupportedKindsArrayOutput values.
// You can construct a concrete instance of `GatewayStatusListenersSupportedKindsArrayInput` via:
//
//	GatewayStatusListenersSupportedKindsArray{ GatewayStatusListenersSupportedKindsArgs{...} }
type GatewayStatusListenersSupportedKindsArrayInput interface {
	pulumi.Input

	ToGatewayStatusListenersSupportedKindsArrayOutput() GatewayStatusListenersSupportedKindsArrayOutput
	ToGatewayStatusListenersSupportedKindsArrayOutputWithContext(context.Context) GatewayStatusListenersSupportedKindsArrayOutput
}

type GatewayStatusListenersSupportedKindsArray []GatewayStatusListenersSupportedKindsInput

func (GatewayStatusListenersSupportedKindsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewayStatusListenersSupportedKinds)(nil)).Elem()
}

func (i GatewayStatusListenersSupportedKindsArray) ToGatewayStatusListenersSupportedKindsArrayOutput() GatewayStatusListenersSupportedKindsArrayOutput {
	return i.ToGatewayStatusListenersSupportedKindsArrayOutputWithContext(context.Background())
}

func (i GatewayStatusListenersSupportedKindsArray) ToGatewayStatusListenersSupportedKindsArrayOutputWithContext(ctx context.Context) GatewayStatusListenersSupportedKindsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayStatusListenersSupportedKindsArrayOutput)
}

// RouteGroupKind indicates the group and kind of a Route resource.
type GatewayStatusListenersSupportedKindsOutput struct{ *pulumi.OutputState }

func (GatewayStatusListenersSupportedKindsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayStatusListenersSupportedKinds)(nil)).Elem()
}

func (o GatewayStatusListenersSupportedKindsOutput) ToGatewayStatusListenersSupportedKindsOutput() GatewayStatusListenersSupportedKindsOutput {
	return o
}

func (o GatewayStatusListenersSupportedKindsOutput) ToGatewayStatusListenersSupportedKindsOutputWithContext(ctx context.Context) GatewayStatusListenersSupportedKindsOutput {
	return o
}

// Group is the group of the Route.
func (o GatewayStatusListenersSupportedKindsOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayStatusListenersSupportedKinds) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is the kind of the Route.
func (o GatewayStatusListenersSupportedKindsOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayStatusListenersSupportedKinds) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

type GatewayStatusListenersSupportedKindsArrayOutput struct{ *pulumi.OutputState }

func (GatewayStatusListenersSupportedKindsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewayStatusListenersSupportedKinds)(nil)).Elem()
}

func (o GatewayStatusListenersSupportedKindsArrayOutput) ToGatewayStatusListenersSupportedKindsArrayOutput() GatewayStatusListenersSupportedKindsArrayOutput {
	return o
}

func (o GatewayStatusListenersSupportedKindsArrayOutput) ToGatewayStatusListenersSupportedKindsArrayOutputWithContext(ctx context.Context) GatewayStatusListenersSupportedKindsArrayOutput {
	return o
}

func (o GatewayStatusListenersSupportedKindsArrayOutput) Index(i pulumi.IntInput) GatewayStatusListenersSupportedKindsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GatewayStatusListenersSupportedKinds {
		return vs[0].([]GatewayStatusListenersSupportedKinds)[vs[1].(int)]
	}).(GatewayStatusListenersSupportedKindsOutput)
}

// RouteGroupKind indicates the group and kind of a Route resource.
type GatewayStatusListenersSupportedKindsPatch struct {
	// Group is the group of the Route.
	Group *string `pulumi:"group"`
	// Kind is the kind of the Route.
	Kind *string `pulumi:"kind"`
}

// GatewayStatusListenersSupportedKindsPatchInput is an input type that accepts GatewayStatusListenersSupportedKindsPatchArgs and GatewayStatusListenersSupportedKindsPatchOutput values.
// You can construct a concrete instance of `GatewayStatusListenersSupportedKindsPatchInput` via:
//
//	GatewayStatusListenersSupportedKindsPatchArgs{...}
type GatewayStatusListenersSupportedKindsPatchInput interface {
	pulumi.Input

	ToGatewayStatusListenersSupportedKindsPatchOutput() GatewayStatusListenersSupportedKindsPatchOutput
	ToGatewayStatusListenersSupportedKindsPatchOutputWithContext(context.Context) GatewayStatusListenersSupportedKindsPatchOutput
}

// RouteGroupKind indicates the group and kind of a Route resource.
type GatewayStatusListenersSupportedKindsPatchArgs struct {
	// Group is the group of the Route.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is the kind of the Route.
	Kind pulumi.StringPtrInput `pulumi:"kind"`
}

func (GatewayStatusListenersSupportedKindsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayStatusListenersSupportedKindsPatch)(nil)).Elem()
}

func (i GatewayStatusListenersSupportedKindsPatchArgs) ToGatewayStatusListenersSupportedKindsPatchOutput() GatewayStatusListenersSupportedKindsPatchOutput {
	return i.ToGatewayStatusListenersSupportedKindsPatchOutputWithContext(context.Background())
}

func (i GatewayStatusListenersSupportedKindsPatchArgs) ToGatewayStatusListenersSupportedKindsPatchOutputWithContext(ctx context.Context) GatewayStatusListenersSupportedKindsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayStatusListenersSupportedKindsPatchOutput)
}

// GatewayStatusListenersSupportedKindsPatchArrayInput is an input type that accepts GatewayStatusListenersSupportedKindsPatchArray and GatewayStatusListenersSupportedKindsPatchArrayOutput values.
// You can construct a concrete instance of `GatewayStatusListenersSupportedKindsPatchArrayInput` via:
//
//	GatewayStatusListenersSupportedKindsPatchArray{ GatewayStatusListenersSupportedKindsPatchArgs{...} }
type GatewayStatusListenersSupportedKindsPatchArrayInput interface {
	pulumi.Input

	ToGatewayStatusListenersSupportedKindsPatchArrayOutput() GatewayStatusListenersSupportedKindsPatchArrayOutput
	ToGatewayStatusListenersSupportedKindsPatchArrayOutputWithContext(context.Context) GatewayStatusListenersSupportedKindsPatchArrayOutput
}

type GatewayStatusListenersSupportedKindsPatchArray []GatewayStatusListenersSupportedKindsPatchInput

func (GatewayStatusListenersSupportedKindsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewayStatusListenersSupportedKindsPatch)(nil)).Elem()
}

func (i GatewayStatusListenersSupportedKindsPatchArray) ToGatewayStatusListenersSupportedKindsPatchArrayOutput() GatewayStatusListenersSupportedKindsPatchArrayOutput {
	return i.ToGatewayStatusListenersSupportedKindsPatchArrayOutputWithContext(context.Background())
}

func (i GatewayStatusListenersSupportedKindsPatchArray) ToGatewayStatusListenersSupportedKindsPatchArrayOutputWithContext(ctx context.Context) GatewayStatusListenersSupportedKindsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayStatusListenersSupportedKindsPatchArrayOutput)
}

// RouteGroupKind indicates the group and kind of a Route resource.
type GatewayStatusListenersSupportedKindsPatchOutput struct{ *pulumi.OutputState }

func (GatewayStatusListenersSupportedKindsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayStatusListenersSupportedKindsPatch)(nil)).Elem()
}

func (o GatewayStatusListenersSupportedKindsPatchOutput) ToGatewayStatusListenersSupportedKindsPatchOutput() GatewayStatusListenersSupportedKindsPatchOutput {
	return o
}

func (o GatewayStatusListenersSupportedKindsPatchOutput) ToGatewayStatusListenersSupportedKindsPatchOutputWithContext(ctx context.Context) GatewayStatusListenersSupportedKindsPatchOutput {
	return o
}

// Group is the group of the Route.
func (o GatewayStatusListenersSupportedKindsPatchOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayStatusListenersSupportedKindsPatch) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is the kind of the Route.
func (o GatewayStatusListenersSupportedKindsPatchOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GatewayStatusListenersSupportedKindsPatch) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

type GatewayStatusListenersSupportedKindsPatchArrayOutput struct{ *pulumi.OutputState }

func (GatewayStatusListenersSupportedKindsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GatewayStatusListenersSupportedKindsPatch)(nil)).Elem()
}

func (o GatewayStatusListenersSupportedKindsPatchArrayOutput) ToGatewayStatusListenersSupportedKindsPatchArrayOutput() GatewayStatusListenersSupportedKindsPatchArrayOutput {
	return o
}

func (o GatewayStatusListenersSupportedKindsPatchArrayOutput) ToGatewayStatusListenersSupportedKindsPatchArrayOutputWithContext(ctx context.Context) GatewayStatusListenersSupportedKindsPatchArrayOutput {
	return o
}

func (o GatewayStatusListenersSupportedKindsPatchArrayOutput) Index(i pulumi.IntInput) GatewayStatusListenersSupportedKindsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GatewayStatusListenersSupportedKindsPatch {
		return vs[0].([]GatewayStatusListenersSupportedKindsPatch)[vs[1].(int)]
	}).(GatewayStatusListenersSupportedKindsPatchOutput)
}

// Status defines the current state of Gateway.
type GatewayStatusPatch struct {
	// Addresses lists the network addresses that have been bound to the
	// Gateway.
	//
	// This list may differ from the addresses provided in the spec under some
	// conditions:
	//
	//   * no addresses are specified, all addresses are dynamically assigned
	//   * a combination of specified and dynamic addresses are assigned
	//   * a specified address was unusable (e.g. already in use)
	Addresses []GatewayStatusAddressesPatch `pulumi:"addresses"`
	// Conditions describe the current conditions of the Gateway.
	//
	// Implementations should prefer to express Gateway conditions
	// using the `GatewayConditionType` and `GatewayConditionReason`
	// constants so that operators and tools can converge on a common
	// vocabulary to describe Gateway state.
	//
	// Known condition types are:
	//
	// * "Accepted"
	// * "Programmed"
	// * "Ready"
	Conditions []GatewayStatusConditionsPatch `pulumi:"conditions"`
	// Listeners provide status for each unique listener port defined in the Spec.
	Listeners []GatewayStatusListenersPatch `pulumi:"listeners"`
}

// GatewayStatusPatchInput is an input type that accepts GatewayStatusPatchArgs and GatewayStatusPatchOutput values.
// You can construct a concrete instance of `GatewayStatusPatchInput` via:
//
//	GatewayStatusPatchArgs{...}
type GatewayStatusPatchInput interface {
	pulumi.Input

	ToGatewayStatusPatchOutput() GatewayStatusPatchOutput
	ToGatewayStatusPatchOutputWithContext(context.Context) GatewayStatusPatchOutput
}

// Status defines the current state of Gateway.
type GatewayStatusPatchArgs struct {
	// Addresses lists the network addresses that have been bound to the
	// Gateway.
	//
	// This list may differ from the addresses provided in the spec under some
	// conditions:
	//
	//   * no addresses are specified, all addresses are dynamically assigned
	//   * a combination of specified and dynamic addresses are assigned
	//   * a specified address was unusable (e.g. already in use)
	Addresses GatewayStatusAddressesPatchArrayInput `pulumi:"addresses"`
	// Conditions describe the current conditions of the Gateway.
	//
	// Implementations should prefer to express Gateway conditions
	// using the `GatewayConditionType` and `GatewayConditionReason`
	// constants so that operators and tools can converge on a common
	// vocabulary to describe Gateway state.
	//
	// Known condition types are:
	//
	// * "Accepted"
	// * "Programmed"
	// * "Ready"
	Conditions GatewayStatusConditionsPatchArrayInput `pulumi:"conditions"`
	// Listeners provide status for each unique listener port defined in the Spec.
	Listeners GatewayStatusListenersPatchArrayInput `pulumi:"listeners"`
}

func (GatewayStatusPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayStatusPatch)(nil)).Elem()
}

func (i GatewayStatusPatchArgs) ToGatewayStatusPatchOutput() GatewayStatusPatchOutput {
	return i.ToGatewayStatusPatchOutputWithContext(context.Background())
}

func (i GatewayStatusPatchArgs) ToGatewayStatusPatchOutputWithContext(ctx context.Context) GatewayStatusPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayStatusPatchOutput)
}

func (i GatewayStatusPatchArgs) ToGatewayStatusPatchPtrOutput() GatewayStatusPatchPtrOutput {
	return i.ToGatewayStatusPatchPtrOutputWithContext(context.Background())
}

func (i GatewayStatusPatchArgs) ToGatewayStatusPatchPtrOutputWithContext(ctx context.Context) GatewayStatusPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayStatusPatchOutput).ToGatewayStatusPatchPtrOutputWithContext(ctx)
}

// GatewayStatusPatchPtrInput is an input type that accepts GatewayStatusPatchArgs, GatewayStatusPatchPtr and GatewayStatusPatchPtrOutput values.
// You can construct a concrete instance of `GatewayStatusPatchPtrInput` via:
//
//	        GatewayStatusPatchArgs{...}
//
//	or:
//
//	        nil
type GatewayStatusPatchPtrInput interface {
	pulumi.Input

	ToGatewayStatusPatchPtrOutput() GatewayStatusPatchPtrOutput
	ToGatewayStatusPatchPtrOutputWithContext(context.Context) GatewayStatusPatchPtrOutput
}

type gatewayStatusPatchPtrType GatewayStatusPatchArgs

func GatewayStatusPatchPtr(v *GatewayStatusPatchArgs) GatewayStatusPatchPtrInput {
	return (*gatewayStatusPatchPtrType)(v)
}

func (*gatewayStatusPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewayStatusPatch)(nil)).Elem()
}

func (i *gatewayStatusPatchPtrType) ToGatewayStatusPatchPtrOutput() GatewayStatusPatchPtrOutput {
	return i.ToGatewayStatusPatchPtrOutputWithContext(context.Background())
}

func (i *gatewayStatusPatchPtrType) ToGatewayStatusPatchPtrOutputWithContext(ctx context.Context) GatewayStatusPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GatewayStatusPatchPtrOutput)
}

// Status defines the current state of Gateway.
type GatewayStatusPatchOutput struct{ *pulumi.OutputState }

func (GatewayStatusPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GatewayStatusPatch)(nil)).Elem()
}

func (o GatewayStatusPatchOutput) ToGatewayStatusPatchOutput() GatewayStatusPatchOutput {
	return o
}

func (o GatewayStatusPatchOutput) ToGatewayStatusPatchOutputWithContext(ctx context.Context) GatewayStatusPatchOutput {
	return o
}

func (o GatewayStatusPatchOutput) ToGatewayStatusPatchPtrOutput() GatewayStatusPatchPtrOutput {
	return o.ToGatewayStatusPatchPtrOutputWithContext(context.Background())
}

func (o GatewayStatusPatchOutput) ToGatewayStatusPatchPtrOutputWithContext(ctx context.Context) GatewayStatusPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GatewayStatusPatch) *GatewayStatusPatch {
		return &v
	}).(GatewayStatusPatchPtrOutput)
}

// Addresses lists the network addresses that have been bound to the
// Gateway.
//
// This list may differ from the addresses provided in the spec under some
// conditions:
//
//   - no addresses are specified, all addresses are dynamically assigned
//   - a combination of specified and dynamic addresses are assigned
//   - a specified address was unusable (e.g. already in use)
func (o GatewayStatusPatchOutput) Addresses() GatewayStatusAddressesPatchArrayOutput {
	return o.ApplyT(func(v GatewayStatusPatch) []GatewayStatusAddressesPatch { return v.Addresses }).(GatewayStatusAddressesPatchArrayOutput)
}

// Conditions describe the current conditions of the Gateway.
//
// Implementations should prefer to express Gateway conditions
// using the `GatewayConditionType` and `GatewayConditionReason`
// constants so that operators and tools can converge on a common
// vocabulary to describe Gateway state.
//
// Known condition types are:
//
// * "Accepted"
// * "Programmed"
// * "Ready"
func (o GatewayStatusPatchOutput) Conditions() GatewayStatusConditionsPatchArrayOutput {
	return o.ApplyT(func(v GatewayStatusPatch) []GatewayStatusConditionsPatch { return v.Conditions }).(GatewayStatusConditionsPatchArrayOutput)
}

// Listeners provide status for each unique listener port defined in the Spec.
func (o GatewayStatusPatchOutput) Listeners() GatewayStatusListenersPatchArrayOutput {
	return o.ApplyT(func(v GatewayStatusPatch) []GatewayStatusListenersPatch { return v.Listeners }).(GatewayStatusListenersPatchArrayOutput)
}

type GatewayStatusPatchPtrOutput struct{ *pulumi.OutputState }

func (GatewayStatusPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GatewayStatusPatch)(nil)).Elem()
}

func (o GatewayStatusPatchPtrOutput) ToGatewayStatusPatchPtrOutput() GatewayStatusPatchPtrOutput {
	return o
}

func (o GatewayStatusPatchPtrOutput) ToGatewayStatusPatchPtrOutputWithContext(ctx context.Context) GatewayStatusPatchPtrOutput {
	return o
}

func (o GatewayStatusPatchPtrOutput) Elem() GatewayStatusPatchOutput {
	return o.ApplyT(func(v *GatewayStatusPatch) GatewayStatusPatch {
		if v != nil {
			return *v
		}
		var ret GatewayStatusPatch
		return ret
	}).(GatewayStatusPatchOutput)
}

// Addresses lists the network addresses that have been bound to the
// Gateway.
//
// This list may differ from the addresses provided in the spec under some
// conditions:
//
//   - no addresses are specified, all addresses are dynamically assigned
//   - a combination of specified and dynamic addresses are assigned
//   - a specified address was unusable (e.g. already in use)
func (o GatewayStatusPatchPtrOutput) Addresses() GatewayStatusAddressesPatchArrayOutput {
	return o.ApplyT(func(v *GatewayStatusPatch) []GatewayStatusAddressesPatch {
		if v == nil {
			return nil
		}
		return v.Addresses
	}).(GatewayStatusAddressesPatchArrayOutput)
}

// Conditions describe the current conditions of the Gateway.
//
// Implementations should prefer to express Gateway conditions
// using the `GatewayConditionType` and `GatewayConditionReason`
// constants so that operators and tools can converge on a common
// vocabulary to describe Gateway state.
//
// Known condition types are:
//
// * "Accepted"
// * "Programmed"
// * "Ready"
func (o GatewayStatusPatchPtrOutput) Conditions() GatewayStatusConditionsPatchArrayOutput {
	return o.ApplyT(func(v *GatewayStatusPatch) []GatewayStatusConditionsPatch {
		if v == nil {
			return nil
		}
		return v.Conditions
	}).(GatewayStatusConditionsPatchArrayOutput)
}

// Listeners provide status for each unique listener port defined in the Spec.
func (o GatewayStatusPatchPtrOutput) Listeners() GatewayStatusListenersPatchArrayOutput {
	return o.ApplyT(func(v *GatewayStatusPatch) []GatewayStatusListenersPatch {
		if v == nil {
			return nil
		}
		return v.Listeners
	}).(GatewayStatusListenersPatchArrayOutput)
}

// HTTPRoute provides a way to route HTTP requests. This includes the capability
// to match requests by hostname, path, header, or query param. Filters can be
// used to specify additional processing steps. Backends specify where matching
// requests should be routed.
type HTTPRouteType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata *metav1.ObjectMeta `pulumi:"metadata"`
	Spec     *HTTPRouteSpec     `pulumi:"spec"`
	Status   *HTTPRouteStatus   `pulumi:"status"`
}

// HTTPRouteTypeInput is an input type that accepts HTTPRouteTypeArgs and HTTPRouteTypeOutput values.
// You can construct a concrete instance of `HTTPRouteTypeInput` via:
//
//	HTTPRouteTypeArgs{...}
type HTTPRouteTypeInput interface {
	pulumi.Input

	ToHTTPRouteTypeOutput() HTTPRouteTypeOutput
	ToHTTPRouteTypeOutputWithContext(context.Context) HTTPRouteTypeOutput
}

// HTTPRoute provides a way to route HTTP requests. This includes the capability
// to match requests by hostname, path, header, or query param. Filters can be
// used to specify additional processing steps. Backends specify where matching
// requests should be routed.
type HTTPRouteTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata metav1.ObjectMetaPtrInput `pulumi:"metadata"`
	Spec     HTTPRouteSpecPtrInput     `pulumi:"spec"`
	Status   HTTPRouteStatusPtrInput   `pulumi:"status"`
}

func (HTTPRouteTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteType)(nil)).Elem()
}

func (i HTTPRouteTypeArgs) ToHTTPRouteTypeOutput() HTTPRouteTypeOutput {
	return i.ToHTTPRouteTypeOutputWithContext(context.Background())
}

func (i HTTPRouteTypeArgs) ToHTTPRouteTypeOutputWithContext(ctx context.Context) HTTPRouteTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteTypeOutput)
}

// HTTPRouteTypeArrayInput is an input type that accepts HTTPRouteTypeArray and HTTPRouteTypeArrayOutput values.
// You can construct a concrete instance of `HTTPRouteTypeArrayInput` via:
//
//	HTTPRouteTypeArray{ HTTPRouteTypeArgs{...} }
type HTTPRouteTypeArrayInput interface {
	pulumi.Input

	ToHTTPRouteTypeArrayOutput() HTTPRouteTypeArrayOutput
	ToHTTPRouteTypeArrayOutputWithContext(context.Context) HTTPRouteTypeArrayOutput
}

type HTTPRouteTypeArray []HTTPRouteTypeInput

func (HTTPRouteTypeArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteType)(nil)).Elem()
}

func (i HTTPRouteTypeArray) ToHTTPRouteTypeArrayOutput() HTTPRouteTypeArrayOutput {
	return i.ToHTTPRouteTypeArrayOutputWithContext(context.Background())
}

func (i HTTPRouteTypeArray) ToHTTPRouteTypeArrayOutputWithContext(ctx context.Context) HTTPRouteTypeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteTypeArrayOutput)
}

// HTTPRoute provides a way to route HTTP requests. This includes the capability
// to match requests by hostname, path, header, or query param. Filters can be
// used to specify additional processing steps. Backends specify where matching
// requests should be routed.
type HTTPRouteTypeOutput struct{ *pulumi.OutputState }

func (HTTPRouteTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteType)(nil)).Elem()
}

func (o HTTPRouteTypeOutput) ToHTTPRouteTypeOutput() HTTPRouteTypeOutput {
	return o
}

func (o HTTPRouteTypeOutput) ToHTTPRouteTypeOutputWithContext(ctx context.Context) HTTPRouteTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o HTTPRouteTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o HTTPRouteTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
func (o HTTPRouteTypeOutput) Metadata() metav1.ObjectMetaPtrOutput {
	return o.ApplyT(func(v HTTPRouteType) *metav1.ObjectMeta { return v.Metadata }).(metav1.ObjectMetaPtrOutput)
}

func (o HTTPRouteTypeOutput) Spec() HTTPRouteSpecPtrOutput {
	return o.ApplyT(func(v HTTPRouteType) *HTTPRouteSpec { return v.Spec }).(HTTPRouteSpecPtrOutput)
}

func (o HTTPRouteTypeOutput) Status() HTTPRouteStatusPtrOutput {
	return o.ApplyT(func(v HTTPRouteType) *HTTPRouteStatus { return v.Status }).(HTTPRouteStatusPtrOutput)
}

type HTTPRouteTypeArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteTypeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteType)(nil)).Elem()
}

func (o HTTPRouteTypeArrayOutput) ToHTTPRouteTypeArrayOutput() HTTPRouteTypeArrayOutput {
	return o
}

func (o HTTPRouteTypeArrayOutput) ToHTTPRouteTypeArrayOutputWithContext(ctx context.Context) HTTPRouteTypeArrayOutput {
	return o
}

func (o HTTPRouteTypeArrayOutput) Index(i pulumi.IntInput) HTTPRouteTypeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteType {
		return vs[0].([]HTTPRouteType)[vs[1].(int)]
	}).(HTTPRouteTypeOutput)
}

// HTTPRouteList is a list of HTTPRoute
type HTTPRouteListType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// List of httproutes. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md
	Items []HTTPRouteType `pulumi:"items"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Metadata *metav1.ListMeta `pulumi:"metadata"`
}

// HTTPRouteListTypeInput is an input type that accepts HTTPRouteListTypeArgs and HTTPRouteListTypeOutput values.
// You can construct a concrete instance of `HTTPRouteListTypeInput` via:
//
//	HTTPRouteListTypeArgs{...}
type HTTPRouteListTypeInput interface {
	pulumi.Input

	ToHTTPRouteListTypeOutput() HTTPRouteListTypeOutput
	ToHTTPRouteListTypeOutputWithContext(context.Context) HTTPRouteListTypeOutput
}

// HTTPRouteList is a list of HTTPRoute
type HTTPRouteListTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// List of httproutes. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md
	Items HTTPRouteTypeArrayInput `pulumi:"items"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Metadata metav1.ListMetaPtrInput `pulumi:"metadata"`
}

func (HTTPRouteListTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteListType)(nil)).Elem()
}

func (i HTTPRouteListTypeArgs) ToHTTPRouteListTypeOutput() HTTPRouteListTypeOutput {
	return i.ToHTTPRouteListTypeOutputWithContext(context.Background())
}

func (i HTTPRouteListTypeArgs) ToHTTPRouteListTypeOutputWithContext(ctx context.Context) HTTPRouteListTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteListTypeOutput)
}

// HTTPRouteList is a list of HTTPRoute
type HTTPRouteListTypeOutput struct{ *pulumi.OutputState }

func (HTTPRouteListTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteListType)(nil)).Elem()
}

func (o HTTPRouteListTypeOutput) ToHTTPRouteListTypeOutput() HTTPRouteListTypeOutput {
	return o
}

func (o HTTPRouteListTypeOutput) ToHTTPRouteListTypeOutputWithContext(ctx context.Context) HTTPRouteListTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o HTTPRouteListTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteListType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// List of httproutes. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md
func (o HTTPRouteListTypeOutput) Items() HTTPRouteTypeArrayOutput {
	return o.ApplyT(func(v HTTPRouteListType) []HTTPRouteType { return v.Items }).(HTTPRouteTypeArrayOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o HTTPRouteListTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteListType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o HTTPRouteListTypeOutput) Metadata() metav1.ListMetaPtrOutput {
	return o.ApplyT(func(v HTTPRouteListType) *metav1.ListMeta { return v.Metadata }).(metav1.ListMetaPtrOutput)
}

// HTTPRoute provides a way to route HTTP requests. This includes the capability
// to match requests by hostname, path, header, or query param. Filters can be
// used to specify additional processing steps. Backends specify where matching
// requests should be routed.
type HTTPRoutePatchType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata *metav1.ObjectMetaPatch `pulumi:"metadata"`
	Spec     *HTTPRouteSpecPatch     `pulumi:"spec"`
	Status   *HTTPRouteStatusPatch   `pulumi:"status"`
}

// HTTPRoutePatchTypeInput is an input type that accepts HTTPRoutePatchTypeArgs and HTTPRoutePatchTypeOutput values.
// You can construct a concrete instance of `HTTPRoutePatchTypeInput` via:
//
//	HTTPRoutePatchTypeArgs{...}
type HTTPRoutePatchTypeInput interface {
	pulumi.Input

	ToHTTPRoutePatchTypeOutput() HTTPRoutePatchTypeOutput
	ToHTTPRoutePatchTypeOutputWithContext(context.Context) HTTPRoutePatchTypeOutput
}

// HTTPRoute provides a way to route HTTP requests. This includes the capability
// to match requests by hostname, path, header, or query param. Filters can be
// used to specify additional processing steps. Backends specify where matching
// requests should be routed.
type HTTPRoutePatchTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata metav1.ObjectMetaPatchPtrInput `pulumi:"metadata"`
	Spec     HTTPRouteSpecPatchPtrInput     `pulumi:"spec"`
	Status   HTTPRouteStatusPatchPtrInput   `pulumi:"status"`
}

func (HTTPRoutePatchTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRoutePatchType)(nil)).Elem()
}

func (i HTTPRoutePatchTypeArgs) ToHTTPRoutePatchTypeOutput() HTTPRoutePatchTypeOutput {
	return i.ToHTTPRoutePatchTypeOutputWithContext(context.Background())
}

func (i HTTPRoutePatchTypeArgs) ToHTTPRoutePatchTypeOutputWithContext(ctx context.Context) HTTPRoutePatchTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRoutePatchTypeOutput)
}

// HTTPRoute provides a way to route HTTP requests. This includes the capability
// to match requests by hostname, path, header, or query param. Filters can be
// used to specify additional processing steps. Backends specify where matching
// requests should be routed.
type HTTPRoutePatchTypeOutput struct{ *pulumi.OutputState }

func (HTTPRoutePatchTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRoutePatchType)(nil)).Elem()
}

func (o HTTPRoutePatchTypeOutput) ToHTTPRoutePatchTypeOutput() HTTPRoutePatchTypeOutput {
	return o
}

func (o HTTPRoutePatchTypeOutput) ToHTTPRoutePatchTypeOutputWithContext(ctx context.Context) HTTPRoutePatchTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o HTTPRoutePatchTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRoutePatchType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o HTTPRoutePatchTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRoutePatchType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
func (o HTTPRoutePatchTypeOutput) Metadata() metav1.ObjectMetaPatchPtrOutput {
	return o.ApplyT(func(v HTTPRoutePatchType) *metav1.ObjectMetaPatch { return v.Metadata }).(metav1.ObjectMetaPatchPtrOutput)
}

func (o HTTPRoutePatchTypeOutput) Spec() HTTPRouteSpecPatchPtrOutput {
	return o.ApplyT(func(v HTTPRoutePatchType) *HTTPRouteSpecPatch { return v.Spec }).(HTTPRouteSpecPatchPtrOutput)
}

func (o HTTPRoutePatchTypeOutput) Status() HTTPRouteStatusPatchPtrOutput {
	return o.ApplyT(func(v HTTPRoutePatchType) *HTTPRouteStatusPatch { return v.Status }).(HTTPRouteStatusPatchPtrOutput)
}

// Spec defines the desired state of HTTPRoute.
type HTTPRouteSpec struct {
	// Hostnames defines a set of hostnames that should match against the HTTP Host
	// header to select a HTTPRoute used to process the request. Implementations
	// MUST ignore any port value specified in the HTTP Host header while
	// performing a match and (absent of any applicable header modification
	// configuration) MUST forward this header unmodified to the backend.
	//
	// Valid values for Hostnames are determined by RFC 1123 definition of a
	// hostname with 2 notable exceptions:
	//
	// 1. IPs are not allowed.
	// 2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard
	//    label must appear by itself as the first label.
	//
	// If a hostname is specified by both the Listener and HTTPRoute, there
	// must be at least one intersecting hostname for the HTTPRoute to be
	// attached to the Listener. For example:
	//
	// * A Listener with `test.example.com` as the hostname matches HTTPRoutes
	//   that have either not specified any hostnames, or have specified at
	//   least one of `test.example.com` or `*.example.com`.
	// * A Listener with `*.example.com` as the hostname matches HTTPRoutes
	//   that have either not specified any hostnames or have specified at least
	//   one hostname that matches the Listener hostname. For example,
	//   `*.example.com`, `test.example.com`, and `foo.test.example.com` would
	//   all match. On the other hand, `example.com` and `test.example.net` would
	//   not match.
	//
	// Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
	// as a suffix match. That means that a match for `*.example.com` would match
	// both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
	//
	// If both the Listener and HTTPRoute have specified hostnames, any
	// HTTPRoute hostnames that do not match the Listener hostname MUST be
	// ignored. For example, if a Listener specified `*.example.com`, and the
	// HTTPRoute specified `test.example.com` and `test.example.net`,
	// `test.example.net` must not be considered for a match.
	//
	// If both the Listener and HTTPRoute have specified hostnames, and none
	// match with the criteria above, then the HTTPRoute is not accepted. The
	// implementation must raise an 'Accepted' Condition with a status of
	// `False` in the corresponding RouteParentStatus.
	//
	// In the event that multiple HTTPRoutes specify intersecting hostnames (e.g.
	// overlapping wildcard matching and exact matching hostnames), precedence must
	// be given to rules from the HTTPRoute with the largest number of:
	//
	// * Characters in a matching non-wildcard hostname.
	// * Characters in a matching hostname.
	//
	// If ties exist across multiple Routes, the matching precedence rules for
	// HTTPRouteMatches takes over.
	//
	// Support: Core
	Hostnames []string `pulumi:"hostnames"`
	// ParentRefs references the resources (usually Gateways) that a Route wants
	// to be attached to. Note that the referenced parent resource needs to
	// allow this for the attachment to be complete. For Gateways, that means
	// the Gateway needs to allow attachment from Routes of this kind and
	// namespace. For Services, that means the Service must either be in the same
	// namespace for a "producer" route, or the mesh implementation must support
	// and allow "consumer" routes for the referenced Service. ReferenceGrant is
	// not applicable for governing ParentRefs to Services - it is not possible to
	// create a "producer" route for a Service in a different namespace from the
	// Route.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// This API may be extended in the future to support additional kinds of parent
	// resources.
	//
	// ParentRefs must be _distinct_. This means either that:
	//
	// * They select different objects.  If this is the case, then parentRef
	//   entries are distinct. In terms of fields, this means that the
	//   multi-part key defined by `group`, `kind`, `namespace`, and `name` must
	//   be unique across all parentRef entries in the Route.
	// * They do not select different objects, but for each optional field used,
	//   each ParentRef that selects the same object must set the same set of
	//   optional fields to different values. If one ParentRef sets a
	//   combination of optional fields, all must set the same combination.
	//
	// Some examples:
	//
	// * If one ParentRef sets `sectionName`, all ParentRefs referencing the
	//   same object must also set `sectionName`.
	// * If one ParentRef sets `port`, all ParentRefs referencing the same
	//   object must also set `port`.
	// * If one ParentRef sets `sectionName` and `port`, all ParentRefs
	//   referencing the same object must also set `sectionName` and `port`.
	//
	// It is possible to separately reference multiple distinct objects that may
	// be collapsed by an implementation. For example, some implementations may
	// choose to merge compatible Gateway Listeners together. If that is the
	// case, the list of routes attached to those resources should also be
	// merged.
	//
	// Note that for ParentRefs that cross namespace boundaries, there are specific
	// rules. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example,
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable other kinds of cross-namespace reference.
	ParentRefs []HTTPRouteSpecParentRefs `pulumi:"parentRefs"`
	// Rules are a list of HTTP matchers, filters and actions.
	Rules []HTTPRouteSpecRules `pulumi:"rules"`
}

// HTTPRouteSpecInput is an input type that accepts HTTPRouteSpecArgs and HTTPRouteSpecOutput values.
// You can construct a concrete instance of `HTTPRouteSpecInput` via:
//
//	HTTPRouteSpecArgs{...}
type HTTPRouteSpecInput interface {
	pulumi.Input

	ToHTTPRouteSpecOutput() HTTPRouteSpecOutput
	ToHTTPRouteSpecOutputWithContext(context.Context) HTTPRouteSpecOutput
}

// Spec defines the desired state of HTTPRoute.
type HTTPRouteSpecArgs struct {
	// Hostnames defines a set of hostnames that should match against the HTTP Host
	// header to select a HTTPRoute used to process the request. Implementations
	// MUST ignore any port value specified in the HTTP Host header while
	// performing a match and (absent of any applicable header modification
	// configuration) MUST forward this header unmodified to the backend.
	//
	// Valid values for Hostnames are determined by RFC 1123 definition of a
	// hostname with 2 notable exceptions:
	//
	// 1. IPs are not allowed.
	// 2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard
	//    label must appear by itself as the first label.
	//
	// If a hostname is specified by both the Listener and HTTPRoute, there
	// must be at least one intersecting hostname for the HTTPRoute to be
	// attached to the Listener. For example:
	//
	// * A Listener with `test.example.com` as the hostname matches HTTPRoutes
	//   that have either not specified any hostnames, or have specified at
	//   least one of `test.example.com` or `*.example.com`.
	// * A Listener with `*.example.com` as the hostname matches HTTPRoutes
	//   that have either not specified any hostnames or have specified at least
	//   one hostname that matches the Listener hostname. For example,
	//   `*.example.com`, `test.example.com`, and `foo.test.example.com` would
	//   all match. On the other hand, `example.com` and `test.example.net` would
	//   not match.
	//
	// Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
	// as a suffix match. That means that a match for `*.example.com` would match
	// both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
	//
	// If both the Listener and HTTPRoute have specified hostnames, any
	// HTTPRoute hostnames that do not match the Listener hostname MUST be
	// ignored. For example, if a Listener specified `*.example.com`, and the
	// HTTPRoute specified `test.example.com` and `test.example.net`,
	// `test.example.net` must not be considered for a match.
	//
	// If both the Listener and HTTPRoute have specified hostnames, and none
	// match with the criteria above, then the HTTPRoute is not accepted. The
	// implementation must raise an 'Accepted' Condition with a status of
	// `False` in the corresponding RouteParentStatus.
	//
	// In the event that multiple HTTPRoutes specify intersecting hostnames (e.g.
	// overlapping wildcard matching and exact matching hostnames), precedence must
	// be given to rules from the HTTPRoute with the largest number of:
	//
	// * Characters in a matching non-wildcard hostname.
	// * Characters in a matching hostname.
	//
	// If ties exist across multiple Routes, the matching precedence rules for
	// HTTPRouteMatches takes over.
	//
	// Support: Core
	Hostnames pulumi.StringArrayInput `pulumi:"hostnames"`
	// ParentRefs references the resources (usually Gateways) that a Route wants
	// to be attached to. Note that the referenced parent resource needs to
	// allow this for the attachment to be complete. For Gateways, that means
	// the Gateway needs to allow attachment from Routes of this kind and
	// namespace. For Services, that means the Service must either be in the same
	// namespace for a "producer" route, or the mesh implementation must support
	// and allow "consumer" routes for the referenced Service. ReferenceGrant is
	// not applicable for governing ParentRefs to Services - it is not possible to
	// create a "producer" route for a Service in a different namespace from the
	// Route.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// This API may be extended in the future to support additional kinds of parent
	// resources.
	//
	// ParentRefs must be _distinct_. This means either that:
	//
	// * They select different objects.  If this is the case, then parentRef
	//   entries are distinct. In terms of fields, this means that the
	//   multi-part key defined by `group`, `kind`, `namespace`, and `name` must
	//   be unique across all parentRef entries in the Route.
	// * They do not select different objects, but for each optional field used,
	//   each ParentRef that selects the same object must set the same set of
	//   optional fields to different values. If one ParentRef sets a
	//   combination of optional fields, all must set the same combination.
	//
	// Some examples:
	//
	// * If one ParentRef sets `sectionName`, all ParentRefs referencing the
	//   same object must also set `sectionName`.
	// * If one ParentRef sets `port`, all ParentRefs referencing the same
	//   object must also set `port`.
	// * If one ParentRef sets `sectionName` and `port`, all ParentRefs
	//   referencing the same object must also set `sectionName` and `port`.
	//
	// It is possible to separately reference multiple distinct objects that may
	// be collapsed by an implementation. For example, some implementations may
	// choose to merge compatible Gateway Listeners together. If that is the
	// case, the list of routes attached to those resources should also be
	// merged.
	//
	// Note that for ParentRefs that cross namespace boundaries, there are specific
	// rules. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example,
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable other kinds of cross-namespace reference.
	ParentRefs HTTPRouteSpecParentRefsArrayInput `pulumi:"parentRefs"`
	// Rules are a list of HTTP matchers, filters and actions.
	Rules HTTPRouteSpecRulesArrayInput `pulumi:"rules"`
}

func (HTTPRouteSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpec)(nil)).Elem()
}

func (i HTTPRouteSpecArgs) ToHTTPRouteSpecOutput() HTTPRouteSpecOutput {
	return i.ToHTTPRouteSpecOutputWithContext(context.Background())
}

func (i HTTPRouteSpecArgs) ToHTTPRouteSpecOutputWithContext(ctx context.Context) HTTPRouteSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecOutput)
}

func (i HTTPRouteSpecArgs) ToHTTPRouteSpecPtrOutput() HTTPRouteSpecPtrOutput {
	return i.ToHTTPRouteSpecPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecArgs) ToHTTPRouteSpecPtrOutputWithContext(ctx context.Context) HTTPRouteSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecOutput).ToHTTPRouteSpecPtrOutputWithContext(ctx)
}

// HTTPRouteSpecPtrInput is an input type that accepts HTTPRouteSpecArgs, HTTPRouteSpecPtr and HTTPRouteSpecPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecPtrInput` via:
//
//	        HTTPRouteSpecArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecPtrOutput() HTTPRouteSpecPtrOutput
	ToHTTPRouteSpecPtrOutputWithContext(context.Context) HTTPRouteSpecPtrOutput
}

type httprouteSpecPtrType HTTPRouteSpecArgs

func HTTPRouteSpecPtr(v *HTTPRouteSpecArgs) HTTPRouteSpecPtrInput {
	return (*httprouteSpecPtrType)(v)
}

func (*httprouteSpecPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpec)(nil)).Elem()
}

func (i *httprouteSpecPtrType) ToHTTPRouteSpecPtrOutput() HTTPRouteSpecPtrOutput {
	return i.ToHTTPRouteSpecPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecPtrType) ToHTTPRouteSpecPtrOutputWithContext(ctx context.Context) HTTPRouteSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecPtrOutput)
}

// Spec defines the desired state of HTTPRoute.
type HTTPRouteSpecOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpec)(nil)).Elem()
}

func (o HTTPRouteSpecOutput) ToHTTPRouteSpecOutput() HTTPRouteSpecOutput {
	return o
}

func (o HTTPRouteSpecOutput) ToHTTPRouteSpecOutputWithContext(ctx context.Context) HTTPRouteSpecOutput {
	return o
}

func (o HTTPRouteSpecOutput) ToHTTPRouteSpecPtrOutput() HTTPRouteSpecPtrOutput {
	return o.ToHTTPRouteSpecPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecOutput) ToHTTPRouteSpecPtrOutputWithContext(ctx context.Context) HTTPRouteSpecPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpec) *HTTPRouteSpec {
		return &v
	}).(HTTPRouteSpecPtrOutput)
}

// Hostnames defines a set of hostnames that should match against the HTTP Host
// header to select a HTTPRoute used to process the request. Implementations
// MUST ignore any port value specified in the HTTP Host header while
// performing a match and (absent of any applicable header modification
// configuration) MUST forward this header unmodified to the backend.
//
// Valid values for Hostnames are determined by RFC 1123 definition of a
// hostname with 2 notable exceptions:
//
//  1. IPs are not allowed.
//  2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard
//     label must appear by itself as the first label.
//
// If a hostname is specified by both the Listener and HTTPRoute, there
// must be at least one intersecting hostname for the HTTPRoute to be
// attached to the Listener. For example:
//
//   - A Listener with `test.example.com` as the hostname matches HTTPRoutes
//     that have either not specified any hostnames, or have specified at
//     least one of `test.example.com` or `*.example.com`.
//   - A Listener with `*.example.com` as the hostname matches HTTPRoutes
//     that have either not specified any hostnames or have specified at least
//     one hostname that matches the Listener hostname. For example,
//     `*.example.com`, `test.example.com`, and `foo.test.example.com` would
//     all match. On the other hand, `example.com` and `test.example.net` would
//     not match.
//
// Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
// as a suffix match. That means that a match for `*.example.com` would match
// both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
//
// If both the Listener and HTTPRoute have specified hostnames, any
// HTTPRoute hostnames that do not match the Listener hostname MUST be
// ignored. For example, if a Listener specified `*.example.com`, and the
// HTTPRoute specified `test.example.com` and `test.example.net`,
// `test.example.net` must not be considered for a match.
//
// If both the Listener and HTTPRoute have specified hostnames, and none
// match with the criteria above, then the HTTPRoute is not accepted. The
// implementation must raise an 'Accepted' Condition with a status of
// `False` in the corresponding RouteParentStatus.
//
// In the event that multiple HTTPRoutes specify intersecting hostnames (e.g.
// overlapping wildcard matching and exact matching hostnames), precedence must
// be given to rules from the HTTPRoute with the largest number of:
//
// * Characters in a matching non-wildcard hostname.
// * Characters in a matching hostname.
//
// If ties exist across multiple Routes, the matching precedence rules for
// HTTPRouteMatches takes over.
//
// Support: Core
func (o HTTPRouteSpecOutput) Hostnames() pulumi.StringArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpec) []string { return v.Hostnames }).(pulumi.StringArrayOutput)
}

// ParentRefs references the resources (usually Gateways) that a Route wants
// to be attached to. Note that the referenced parent resource needs to
// allow this for the attachment to be complete. For Gateways, that means
// the Gateway needs to allow attachment from Routes of this kind and
// namespace. For Services, that means the Service must either be in the same
// namespace for a "producer" route, or the mesh implementation must support
// and allow "consumer" routes for the referenced Service. ReferenceGrant is
// not applicable for governing ParentRefs to Services - it is not possible to
// create a "producer" route for a Service in a different namespace from the
// Route.
//
// There are two kinds of parent resources with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// ParentRefs must be _distinct_. This means either that:
//
//   - They select different objects.  If this is the case, then parentRef
//     entries are distinct. In terms of fields, this means that the
//     multi-part key defined by `group`, `kind`, `namespace`, and `name` must
//     be unique across all parentRef entries in the Route.
//   - They do not select different objects, but for each optional field used,
//     each ParentRef that selects the same object must set the same set of
//     optional fields to different values. If one ParentRef sets a
//     combination of optional fields, all must set the same combination.
//
// Some examples:
//
//   - If one ParentRef sets `sectionName`, all ParentRefs referencing the
//     same object must also set `sectionName`.
//   - If one ParentRef sets `port`, all ParentRefs referencing the same
//     object must also set `port`.
//   - If one ParentRef sets `sectionName` and `port`, all ParentRefs
//     referencing the same object must also set `sectionName` and `port`.
//
// It is possible to separately reference multiple distinct objects that may
// be collapsed by an implementation. For example, some implementations may
// choose to merge compatible Gateway Listeners together. If that is the
// case, the list of routes attached to those resources should also be
// merged.
//
// Note that for ParentRefs that cross namespace boundaries, there are specific
// rules. Cross-namespace references are only valid if they are explicitly
// allowed by something in the namespace they are referring to. For example,
// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
// generic way to enable other kinds of cross-namespace reference.
func (o HTTPRouteSpecOutput) ParentRefs() HTTPRouteSpecParentRefsArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpec) []HTTPRouteSpecParentRefs { return v.ParentRefs }).(HTTPRouteSpecParentRefsArrayOutput)
}

// Rules are a list of HTTP matchers, filters and actions.
func (o HTTPRouteSpecOutput) Rules() HTTPRouteSpecRulesArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpec) []HTTPRouteSpecRules { return v.Rules }).(HTTPRouteSpecRulesArrayOutput)
}

type HTTPRouteSpecPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpec)(nil)).Elem()
}

func (o HTTPRouteSpecPtrOutput) ToHTTPRouteSpecPtrOutput() HTTPRouteSpecPtrOutput {
	return o
}

func (o HTTPRouteSpecPtrOutput) ToHTTPRouteSpecPtrOutputWithContext(ctx context.Context) HTTPRouteSpecPtrOutput {
	return o
}

func (o HTTPRouteSpecPtrOutput) Elem() HTTPRouteSpecOutput {
	return o.ApplyT(func(v *HTTPRouteSpec) HTTPRouteSpec {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpec
		return ret
	}).(HTTPRouteSpecOutput)
}

// Hostnames defines a set of hostnames that should match against the HTTP Host
// header to select a HTTPRoute used to process the request. Implementations
// MUST ignore any port value specified in the HTTP Host header while
// performing a match and (absent of any applicable header modification
// configuration) MUST forward this header unmodified to the backend.
//
// Valid values for Hostnames are determined by RFC 1123 definition of a
// hostname with 2 notable exceptions:
//
//  1. IPs are not allowed.
//  2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard
//     label must appear by itself as the first label.
//
// If a hostname is specified by both the Listener and HTTPRoute, there
// must be at least one intersecting hostname for the HTTPRoute to be
// attached to the Listener. For example:
//
//   - A Listener with `test.example.com` as the hostname matches HTTPRoutes
//     that have either not specified any hostnames, or have specified at
//     least one of `test.example.com` or `*.example.com`.
//   - A Listener with `*.example.com` as the hostname matches HTTPRoutes
//     that have either not specified any hostnames or have specified at least
//     one hostname that matches the Listener hostname. For example,
//     `*.example.com`, `test.example.com`, and `foo.test.example.com` would
//     all match. On the other hand, `example.com` and `test.example.net` would
//     not match.
//
// Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
// as a suffix match. That means that a match for `*.example.com` would match
// both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
//
// If both the Listener and HTTPRoute have specified hostnames, any
// HTTPRoute hostnames that do not match the Listener hostname MUST be
// ignored. For example, if a Listener specified `*.example.com`, and the
// HTTPRoute specified `test.example.com` and `test.example.net`,
// `test.example.net` must not be considered for a match.
//
// If both the Listener and HTTPRoute have specified hostnames, and none
// match with the criteria above, then the HTTPRoute is not accepted. The
// implementation must raise an 'Accepted' Condition with a status of
// `False` in the corresponding RouteParentStatus.
//
// In the event that multiple HTTPRoutes specify intersecting hostnames (e.g.
// overlapping wildcard matching and exact matching hostnames), precedence must
// be given to rules from the HTTPRoute with the largest number of:
//
// * Characters in a matching non-wildcard hostname.
// * Characters in a matching hostname.
//
// If ties exist across multiple Routes, the matching precedence rules for
// HTTPRouteMatches takes over.
//
// Support: Core
func (o HTTPRouteSpecPtrOutput) Hostnames() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *HTTPRouteSpec) []string {
		if v == nil {
			return nil
		}
		return v.Hostnames
	}).(pulumi.StringArrayOutput)
}

// ParentRefs references the resources (usually Gateways) that a Route wants
// to be attached to. Note that the referenced parent resource needs to
// allow this for the attachment to be complete. For Gateways, that means
// the Gateway needs to allow attachment from Routes of this kind and
// namespace. For Services, that means the Service must either be in the same
// namespace for a "producer" route, or the mesh implementation must support
// and allow "consumer" routes for the referenced Service. ReferenceGrant is
// not applicable for governing ParentRefs to Services - it is not possible to
// create a "producer" route for a Service in a different namespace from the
// Route.
//
// There are two kinds of parent resources with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// ParentRefs must be _distinct_. This means either that:
//
//   - They select different objects.  If this is the case, then parentRef
//     entries are distinct. In terms of fields, this means that the
//     multi-part key defined by `group`, `kind`, `namespace`, and `name` must
//     be unique across all parentRef entries in the Route.
//   - They do not select different objects, but for each optional field used,
//     each ParentRef that selects the same object must set the same set of
//     optional fields to different values. If one ParentRef sets a
//     combination of optional fields, all must set the same combination.
//
// Some examples:
//
//   - If one ParentRef sets `sectionName`, all ParentRefs referencing the
//     same object must also set `sectionName`.
//   - If one ParentRef sets `port`, all ParentRefs referencing the same
//     object must also set `port`.
//   - If one ParentRef sets `sectionName` and `port`, all ParentRefs
//     referencing the same object must also set `sectionName` and `port`.
//
// It is possible to separately reference multiple distinct objects that may
// be collapsed by an implementation. For example, some implementations may
// choose to merge compatible Gateway Listeners together. If that is the
// case, the list of routes attached to those resources should also be
// merged.
//
// Note that for ParentRefs that cross namespace boundaries, there are specific
// rules. Cross-namespace references are only valid if they are explicitly
// allowed by something in the namespace they are referring to. For example,
// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
// generic way to enable other kinds of cross-namespace reference.
func (o HTTPRouteSpecPtrOutput) ParentRefs() HTTPRouteSpecParentRefsArrayOutput {
	return o.ApplyT(func(v *HTTPRouteSpec) []HTTPRouteSpecParentRefs {
		if v == nil {
			return nil
		}
		return v.ParentRefs
	}).(HTTPRouteSpecParentRefsArrayOutput)
}

// Rules are a list of HTTP matchers, filters and actions.
func (o HTTPRouteSpecPtrOutput) Rules() HTTPRouteSpecRulesArrayOutput {
	return o.ApplyT(func(v *HTTPRouteSpec) []HTTPRouteSpecRules {
		if v == nil {
			return nil
		}
		return v.Rules
	}).(HTTPRouteSpecRulesArrayOutput)
}

// ParentReference identifies an API object (usually a Gateway) that can be considered
// a parent of this resource (usually a route). There are two kinds of parent resources
// with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
type HTTPRouteSpecParentRefs struct {
	// Group is the group of the referent.
	// When unspecified, "gateway.networking.k8s.io" is inferred.
	// To set the core API group (such as for a "Service" kind referent),
	// Group must be explicitly set to "" (empty string).
	//
	// Support: Core
	Group *string `pulumi:"group"`
	// Kind is kind of the referent.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// Support for other resources is Implementation-Specific.
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	//
	// Support: Core
	Name *string `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers
	// to the local namespace of the Route.
	//
	// Note that there are specific rules for ParentRefs which cross namespace
	// boundaries. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example:
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable any other kind of cross-namespace reference.
	//
	// Support: Core
	Namespace *string `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted
	// differently based on the type of parent resource.
	//
	// When the parent resource is a Gateway, this targets all listeners
	// listening on the specified port that also support this kind of Route(and
	// select this Route). It's not recommended to set `Port` unless the
	// networking behaviors specified in a Route must apply to a specific port
	// as opposed to a listener(s) whose port(s) may be changed. When both Port
	// and SectionName are specified, the name and port of the selected listener
	// must match both specified values.
	//
	// Implementations MAY choose to support other parent resources.
	// Implementations supporting other types of parent resources MUST clearly
	// document how/if Port is interpreted.
	//
	// For the purpose of status, an attachment is considered successful as
	// long as the parent resource accepts it partially. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
	// from the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route,
	// the Route MUST be considered detached from the Gateway.
	//
	// Support: Extended
	Port *int `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the
	// following resources, SectionName is interpreted as the following:
	//
	// * Gateway: Listener name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	// * Service: Port name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	//
	// Implementations MAY choose to support attaching Routes to other resources.
	// If that is the case, they MUST clearly document how SectionName is
	// interpreted.
	//
	// When unspecified (empty string), this will reference the entire resource.
	// For the purpose of status, an attachment is considered successful if at
	// least one section in the parent resource accepts it. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
	// the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route, the
	// Route MUST be considered detached from the Gateway.
	//
	// Support: Core
	SectionName *string `pulumi:"sectionName"`
}

// HTTPRouteSpecParentRefsInput is an input type that accepts HTTPRouteSpecParentRefsArgs and HTTPRouteSpecParentRefsOutput values.
// You can construct a concrete instance of `HTTPRouteSpecParentRefsInput` via:
//
//	HTTPRouteSpecParentRefsArgs{...}
type HTTPRouteSpecParentRefsInput interface {
	pulumi.Input

	ToHTTPRouteSpecParentRefsOutput() HTTPRouteSpecParentRefsOutput
	ToHTTPRouteSpecParentRefsOutputWithContext(context.Context) HTTPRouteSpecParentRefsOutput
}

// ParentReference identifies an API object (usually a Gateway) that can be considered
// a parent of this resource (usually a route). There are two kinds of parent resources
// with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
type HTTPRouteSpecParentRefsArgs struct {
	// Group is the group of the referent.
	// When unspecified, "gateway.networking.k8s.io" is inferred.
	// To set the core API group (such as for a "Service" kind referent),
	// Group must be explicitly set to "" (empty string).
	//
	// Support: Core
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is kind of the referent.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// Support for other resources is Implementation-Specific.
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	//
	// Support: Core
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers
	// to the local namespace of the Route.
	//
	// Note that there are specific rules for ParentRefs which cross namespace
	// boundaries. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example:
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable any other kind of cross-namespace reference.
	//
	// Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted
	// differently based on the type of parent resource.
	//
	// When the parent resource is a Gateway, this targets all listeners
	// listening on the specified port that also support this kind of Route(and
	// select this Route). It's not recommended to set `Port` unless the
	// networking behaviors specified in a Route must apply to a specific port
	// as opposed to a listener(s) whose port(s) may be changed. When both Port
	// and SectionName are specified, the name and port of the selected listener
	// must match both specified values.
	//
	// Implementations MAY choose to support other parent resources.
	// Implementations supporting other types of parent resources MUST clearly
	// document how/if Port is interpreted.
	//
	// For the purpose of status, an attachment is considered successful as
	// long as the parent resource accepts it partially. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
	// from the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route,
	// the Route MUST be considered detached from the Gateway.
	//
	// Support: Extended
	Port pulumi.IntPtrInput `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the
	// following resources, SectionName is interpreted as the following:
	//
	// * Gateway: Listener name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	// * Service: Port name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	//
	// Implementations MAY choose to support attaching Routes to other resources.
	// If that is the case, they MUST clearly document how SectionName is
	// interpreted.
	//
	// When unspecified (empty string), this will reference the entire resource.
	// For the purpose of status, an attachment is considered successful if at
	// least one section in the parent resource accepts it. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
	// the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route, the
	// Route MUST be considered detached from the Gateway.
	//
	// Support: Core
	SectionName pulumi.StringPtrInput `pulumi:"sectionName"`
}

func (HTTPRouteSpecParentRefsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecParentRefs)(nil)).Elem()
}

func (i HTTPRouteSpecParentRefsArgs) ToHTTPRouteSpecParentRefsOutput() HTTPRouteSpecParentRefsOutput {
	return i.ToHTTPRouteSpecParentRefsOutputWithContext(context.Background())
}

func (i HTTPRouteSpecParentRefsArgs) ToHTTPRouteSpecParentRefsOutputWithContext(ctx context.Context) HTTPRouteSpecParentRefsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecParentRefsOutput)
}

// HTTPRouteSpecParentRefsArrayInput is an input type that accepts HTTPRouteSpecParentRefsArray and HTTPRouteSpecParentRefsArrayOutput values.
// You can construct a concrete instance of `HTTPRouteSpecParentRefsArrayInput` via:
//
//	HTTPRouteSpecParentRefsArray{ HTTPRouteSpecParentRefsArgs{...} }
type HTTPRouteSpecParentRefsArrayInput interface {
	pulumi.Input

	ToHTTPRouteSpecParentRefsArrayOutput() HTTPRouteSpecParentRefsArrayOutput
	ToHTTPRouteSpecParentRefsArrayOutputWithContext(context.Context) HTTPRouteSpecParentRefsArrayOutput
}

type HTTPRouteSpecParentRefsArray []HTTPRouteSpecParentRefsInput

func (HTTPRouteSpecParentRefsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecParentRefs)(nil)).Elem()
}

func (i HTTPRouteSpecParentRefsArray) ToHTTPRouteSpecParentRefsArrayOutput() HTTPRouteSpecParentRefsArrayOutput {
	return i.ToHTTPRouteSpecParentRefsArrayOutputWithContext(context.Background())
}

func (i HTTPRouteSpecParentRefsArray) ToHTTPRouteSpecParentRefsArrayOutputWithContext(ctx context.Context) HTTPRouteSpecParentRefsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecParentRefsArrayOutput)
}

// ParentReference identifies an API object (usually a Gateway) that can be considered
// a parent of this resource (usually a route). There are two kinds of parent resources
// with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
type HTTPRouteSpecParentRefsOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecParentRefsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecParentRefs)(nil)).Elem()
}

func (o HTTPRouteSpecParentRefsOutput) ToHTTPRouteSpecParentRefsOutput() HTTPRouteSpecParentRefsOutput {
	return o
}

func (o HTTPRouteSpecParentRefsOutput) ToHTTPRouteSpecParentRefsOutputWithContext(ctx context.Context) HTTPRouteSpecParentRefsOutput {
	return o
}

// Group is the group of the referent.
// When unspecified, "gateway.networking.k8s.io" is inferred.
// To set the core API group (such as for a "Service" kind referent),
// Group must be explicitly set to "" (empty string).
//
// Support: Core
func (o HTTPRouteSpecParentRefsOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecParentRefs) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent.
//
// There are two kinds of parent resources with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// Support for other resources is Implementation-Specific.
func (o HTTPRouteSpecParentRefsOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecParentRefs) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
//
// Support: Core
func (o HTTPRouteSpecParentRefsOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecParentRefs) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the referent. When unspecified, this refers
// to the local namespace of the Route.
//
// Note that there are specific rules for ParentRefs which cross namespace
// boundaries. Cross-namespace references are only valid if they are explicitly
// allowed by something in the namespace they are referring to. For example:
// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
// generic way to enable any other kind of cross-namespace reference.
//
// Support: Core
func (o HTTPRouteSpecParentRefsOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecParentRefs) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Port is the network port this Route targets. It can be interpreted
// differently based on the type of parent resource.
//
// When the parent resource is a Gateway, this targets all listeners
// listening on the specified port that also support this kind of Route(and
// select this Route). It's not recommended to set `Port` unless the
// networking behaviors specified in a Route must apply to a specific port
// as opposed to a listener(s) whose port(s) may be changed. When both Port
// and SectionName are specified, the name and port of the selected listener
// must match both specified values.
//
// Implementations MAY choose to support other parent resources.
// Implementations supporting other types of parent resources MUST clearly
// document how/if Port is interpreted.
//
// For the purpose of status, an attachment is considered successful as
// long as the parent resource accepts it partially. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
// from the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route,
// the Route MUST be considered detached from the Gateway.
//
// Support: Extended
func (o HTTPRouteSpecParentRefsOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecParentRefs) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// SectionName is the name of a section within the target resource. In the
// following resources, SectionName is interpreted as the following:
//
//   - Gateway: Listener name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//   - Service: Port name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//
// Implementations MAY choose to support attaching Routes to other resources.
// If that is the case, they MUST clearly document how SectionName is
// interpreted.
//
// When unspecified (empty string), this will reference the entire resource.
// For the purpose of status, an attachment is considered successful if at
// least one section in the parent resource accepts it. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
// the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route, the
// Route MUST be considered detached from the Gateway.
//
// Support: Core
func (o HTTPRouteSpecParentRefsOutput) SectionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecParentRefs) *string { return v.SectionName }).(pulumi.StringPtrOutput)
}

type HTTPRouteSpecParentRefsArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecParentRefsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecParentRefs)(nil)).Elem()
}

func (o HTTPRouteSpecParentRefsArrayOutput) ToHTTPRouteSpecParentRefsArrayOutput() HTTPRouteSpecParentRefsArrayOutput {
	return o
}

func (o HTTPRouteSpecParentRefsArrayOutput) ToHTTPRouteSpecParentRefsArrayOutputWithContext(ctx context.Context) HTTPRouteSpecParentRefsArrayOutput {
	return o
}

func (o HTTPRouteSpecParentRefsArrayOutput) Index(i pulumi.IntInput) HTTPRouteSpecParentRefsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteSpecParentRefs {
		return vs[0].([]HTTPRouteSpecParentRefs)[vs[1].(int)]
	}).(HTTPRouteSpecParentRefsOutput)
}

// ParentReference identifies an API object (usually a Gateway) that can be considered
// a parent of this resource (usually a route). There are two kinds of parent resources
// with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
type HTTPRouteSpecParentRefsPatch struct {
	// Group is the group of the referent.
	// When unspecified, "gateway.networking.k8s.io" is inferred.
	// To set the core API group (such as for a "Service" kind referent),
	// Group must be explicitly set to "" (empty string).
	//
	// Support: Core
	Group *string `pulumi:"group"`
	// Kind is kind of the referent.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// Support for other resources is Implementation-Specific.
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	//
	// Support: Core
	Name *string `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers
	// to the local namespace of the Route.
	//
	// Note that there are specific rules for ParentRefs which cross namespace
	// boundaries. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example:
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable any other kind of cross-namespace reference.
	//
	// Support: Core
	Namespace *string `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted
	// differently based on the type of parent resource.
	//
	// When the parent resource is a Gateway, this targets all listeners
	// listening on the specified port that also support this kind of Route(and
	// select this Route). It's not recommended to set `Port` unless the
	// networking behaviors specified in a Route must apply to a specific port
	// as opposed to a listener(s) whose port(s) may be changed. When both Port
	// and SectionName are specified, the name and port of the selected listener
	// must match both specified values.
	//
	// Implementations MAY choose to support other parent resources.
	// Implementations supporting other types of parent resources MUST clearly
	// document how/if Port is interpreted.
	//
	// For the purpose of status, an attachment is considered successful as
	// long as the parent resource accepts it partially. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
	// from the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route,
	// the Route MUST be considered detached from the Gateway.
	//
	// Support: Extended
	Port *int `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the
	// following resources, SectionName is interpreted as the following:
	//
	// * Gateway: Listener name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	// * Service: Port name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	//
	// Implementations MAY choose to support attaching Routes to other resources.
	// If that is the case, they MUST clearly document how SectionName is
	// interpreted.
	//
	// When unspecified (empty string), this will reference the entire resource.
	// For the purpose of status, an attachment is considered successful if at
	// least one section in the parent resource accepts it. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
	// the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route, the
	// Route MUST be considered detached from the Gateway.
	//
	// Support: Core
	SectionName *string `pulumi:"sectionName"`
}

// HTTPRouteSpecParentRefsPatchInput is an input type that accepts HTTPRouteSpecParentRefsPatchArgs and HTTPRouteSpecParentRefsPatchOutput values.
// You can construct a concrete instance of `HTTPRouteSpecParentRefsPatchInput` via:
//
//	HTTPRouteSpecParentRefsPatchArgs{...}
type HTTPRouteSpecParentRefsPatchInput interface {
	pulumi.Input

	ToHTTPRouteSpecParentRefsPatchOutput() HTTPRouteSpecParentRefsPatchOutput
	ToHTTPRouteSpecParentRefsPatchOutputWithContext(context.Context) HTTPRouteSpecParentRefsPatchOutput
}

// ParentReference identifies an API object (usually a Gateway) that can be considered
// a parent of this resource (usually a route). There are two kinds of parent resources
// with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
type HTTPRouteSpecParentRefsPatchArgs struct {
	// Group is the group of the referent.
	// When unspecified, "gateway.networking.k8s.io" is inferred.
	// To set the core API group (such as for a "Service" kind referent),
	// Group must be explicitly set to "" (empty string).
	//
	// Support: Core
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is kind of the referent.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// Support for other resources is Implementation-Specific.
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	//
	// Support: Core
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers
	// to the local namespace of the Route.
	//
	// Note that there are specific rules for ParentRefs which cross namespace
	// boundaries. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example:
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable any other kind of cross-namespace reference.
	//
	// Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted
	// differently based on the type of parent resource.
	//
	// When the parent resource is a Gateway, this targets all listeners
	// listening on the specified port that also support this kind of Route(and
	// select this Route). It's not recommended to set `Port` unless the
	// networking behaviors specified in a Route must apply to a specific port
	// as opposed to a listener(s) whose port(s) may be changed. When both Port
	// and SectionName are specified, the name and port of the selected listener
	// must match both specified values.
	//
	// Implementations MAY choose to support other parent resources.
	// Implementations supporting other types of parent resources MUST clearly
	// document how/if Port is interpreted.
	//
	// For the purpose of status, an attachment is considered successful as
	// long as the parent resource accepts it partially. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
	// from the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route,
	// the Route MUST be considered detached from the Gateway.
	//
	// Support: Extended
	Port pulumi.IntPtrInput `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the
	// following resources, SectionName is interpreted as the following:
	//
	// * Gateway: Listener name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	// * Service: Port name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	//
	// Implementations MAY choose to support attaching Routes to other resources.
	// If that is the case, they MUST clearly document how SectionName is
	// interpreted.
	//
	// When unspecified (empty string), this will reference the entire resource.
	// For the purpose of status, an attachment is considered successful if at
	// least one section in the parent resource accepts it. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
	// the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route, the
	// Route MUST be considered detached from the Gateway.
	//
	// Support: Core
	SectionName pulumi.StringPtrInput `pulumi:"sectionName"`
}

func (HTTPRouteSpecParentRefsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecParentRefsPatch)(nil)).Elem()
}

func (i HTTPRouteSpecParentRefsPatchArgs) ToHTTPRouteSpecParentRefsPatchOutput() HTTPRouteSpecParentRefsPatchOutput {
	return i.ToHTTPRouteSpecParentRefsPatchOutputWithContext(context.Background())
}

func (i HTTPRouteSpecParentRefsPatchArgs) ToHTTPRouteSpecParentRefsPatchOutputWithContext(ctx context.Context) HTTPRouteSpecParentRefsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecParentRefsPatchOutput)
}

// HTTPRouteSpecParentRefsPatchArrayInput is an input type that accepts HTTPRouteSpecParentRefsPatchArray and HTTPRouteSpecParentRefsPatchArrayOutput values.
// You can construct a concrete instance of `HTTPRouteSpecParentRefsPatchArrayInput` via:
//
//	HTTPRouteSpecParentRefsPatchArray{ HTTPRouteSpecParentRefsPatchArgs{...} }
type HTTPRouteSpecParentRefsPatchArrayInput interface {
	pulumi.Input

	ToHTTPRouteSpecParentRefsPatchArrayOutput() HTTPRouteSpecParentRefsPatchArrayOutput
	ToHTTPRouteSpecParentRefsPatchArrayOutputWithContext(context.Context) HTTPRouteSpecParentRefsPatchArrayOutput
}

type HTTPRouteSpecParentRefsPatchArray []HTTPRouteSpecParentRefsPatchInput

func (HTTPRouteSpecParentRefsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecParentRefsPatch)(nil)).Elem()
}

func (i HTTPRouteSpecParentRefsPatchArray) ToHTTPRouteSpecParentRefsPatchArrayOutput() HTTPRouteSpecParentRefsPatchArrayOutput {
	return i.ToHTTPRouteSpecParentRefsPatchArrayOutputWithContext(context.Background())
}

func (i HTTPRouteSpecParentRefsPatchArray) ToHTTPRouteSpecParentRefsPatchArrayOutputWithContext(ctx context.Context) HTTPRouteSpecParentRefsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecParentRefsPatchArrayOutput)
}

// ParentReference identifies an API object (usually a Gateway) that can be considered
// a parent of this resource (usually a route). There are two kinds of parent resources
// with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
type HTTPRouteSpecParentRefsPatchOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecParentRefsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecParentRefsPatch)(nil)).Elem()
}

func (o HTTPRouteSpecParentRefsPatchOutput) ToHTTPRouteSpecParentRefsPatchOutput() HTTPRouteSpecParentRefsPatchOutput {
	return o
}

func (o HTTPRouteSpecParentRefsPatchOutput) ToHTTPRouteSpecParentRefsPatchOutputWithContext(ctx context.Context) HTTPRouteSpecParentRefsPatchOutput {
	return o
}

// Group is the group of the referent.
// When unspecified, "gateway.networking.k8s.io" is inferred.
// To set the core API group (such as for a "Service" kind referent),
// Group must be explicitly set to "" (empty string).
//
// Support: Core
func (o HTTPRouteSpecParentRefsPatchOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecParentRefsPatch) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent.
//
// There are two kinds of parent resources with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// Support for other resources is Implementation-Specific.
func (o HTTPRouteSpecParentRefsPatchOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecParentRefsPatch) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
//
// Support: Core
func (o HTTPRouteSpecParentRefsPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecParentRefsPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the referent. When unspecified, this refers
// to the local namespace of the Route.
//
// Note that there are specific rules for ParentRefs which cross namespace
// boundaries. Cross-namespace references are only valid if they are explicitly
// allowed by something in the namespace they are referring to. For example:
// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
// generic way to enable any other kind of cross-namespace reference.
//
// Support: Core
func (o HTTPRouteSpecParentRefsPatchOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecParentRefsPatch) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Port is the network port this Route targets. It can be interpreted
// differently based on the type of parent resource.
//
// When the parent resource is a Gateway, this targets all listeners
// listening on the specified port that also support this kind of Route(and
// select this Route). It's not recommended to set `Port` unless the
// networking behaviors specified in a Route must apply to a specific port
// as opposed to a listener(s) whose port(s) may be changed. When both Port
// and SectionName are specified, the name and port of the selected listener
// must match both specified values.
//
// Implementations MAY choose to support other parent resources.
// Implementations supporting other types of parent resources MUST clearly
// document how/if Port is interpreted.
//
// For the purpose of status, an attachment is considered successful as
// long as the parent resource accepts it partially. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
// from the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route,
// the Route MUST be considered detached from the Gateway.
//
// Support: Extended
func (o HTTPRouteSpecParentRefsPatchOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecParentRefsPatch) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// SectionName is the name of a section within the target resource. In the
// following resources, SectionName is interpreted as the following:
//
//   - Gateway: Listener name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//   - Service: Port name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//
// Implementations MAY choose to support attaching Routes to other resources.
// If that is the case, they MUST clearly document how SectionName is
// interpreted.
//
// When unspecified (empty string), this will reference the entire resource.
// For the purpose of status, an attachment is considered successful if at
// least one section in the parent resource accepts it. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
// the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route, the
// Route MUST be considered detached from the Gateway.
//
// Support: Core
func (o HTTPRouteSpecParentRefsPatchOutput) SectionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecParentRefsPatch) *string { return v.SectionName }).(pulumi.StringPtrOutput)
}

type HTTPRouteSpecParentRefsPatchArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecParentRefsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecParentRefsPatch)(nil)).Elem()
}

func (o HTTPRouteSpecParentRefsPatchArrayOutput) ToHTTPRouteSpecParentRefsPatchArrayOutput() HTTPRouteSpecParentRefsPatchArrayOutput {
	return o
}

func (o HTTPRouteSpecParentRefsPatchArrayOutput) ToHTTPRouteSpecParentRefsPatchArrayOutputWithContext(ctx context.Context) HTTPRouteSpecParentRefsPatchArrayOutput {
	return o
}

func (o HTTPRouteSpecParentRefsPatchArrayOutput) Index(i pulumi.IntInput) HTTPRouteSpecParentRefsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteSpecParentRefsPatch {
		return vs[0].([]HTTPRouteSpecParentRefsPatch)[vs[1].(int)]
	}).(HTTPRouteSpecParentRefsPatchOutput)
}

// Spec defines the desired state of HTTPRoute.
type HTTPRouteSpecPatch struct {
	// Hostnames defines a set of hostnames that should match against the HTTP Host
	// header to select a HTTPRoute used to process the request. Implementations
	// MUST ignore any port value specified in the HTTP Host header while
	// performing a match and (absent of any applicable header modification
	// configuration) MUST forward this header unmodified to the backend.
	//
	// Valid values for Hostnames are determined by RFC 1123 definition of a
	// hostname with 2 notable exceptions:
	//
	// 1. IPs are not allowed.
	// 2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard
	//    label must appear by itself as the first label.
	//
	// If a hostname is specified by both the Listener and HTTPRoute, there
	// must be at least one intersecting hostname for the HTTPRoute to be
	// attached to the Listener. For example:
	//
	// * A Listener with `test.example.com` as the hostname matches HTTPRoutes
	//   that have either not specified any hostnames, or have specified at
	//   least one of `test.example.com` or `*.example.com`.
	// * A Listener with `*.example.com` as the hostname matches HTTPRoutes
	//   that have either not specified any hostnames or have specified at least
	//   one hostname that matches the Listener hostname. For example,
	//   `*.example.com`, `test.example.com`, and `foo.test.example.com` would
	//   all match. On the other hand, `example.com` and `test.example.net` would
	//   not match.
	//
	// Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
	// as a suffix match. That means that a match for `*.example.com` would match
	// both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
	//
	// If both the Listener and HTTPRoute have specified hostnames, any
	// HTTPRoute hostnames that do not match the Listener hostname MUST be
	// ignored. For example, if a Listener specified `*.example.com`, and the
	// HTTPRoute specified `test.example.com` and `test.example.net`,
	// `test.example.net` must not be considered for a match.
	//
	// If both the Listener and HTTPRoute have specified hostnames, and none
	// match with the criteria above, then the HTTPRoute is not accepted. The
	// implementation must raise an 'Accepted' Condition with a status of
	// `False` in the corresponding RouteParentStatus.
	//
	// In the event that multiple HTTPRoutes specify intersecting hostnames (e.g.
	// overlapping wildcard matching and exact matching hostnames), precedence must
	// be given to rules from the HTTPRoute with the largest number of:
	//
	// * Characters in a matching non-wildcard hostname.
	// * Characters in a matching hostname.
	//
	// If ties exist across multiple Routes, the matching precedence rules for
	// HTTPRouteMatches takes over.
	//
	// Support: Core
	Hostnames []string `pulumi:"hostnames"`
	// ParentRefs references the resources (usually Gateways) that a Route wants
	// to be attached to. Note that the referenced parent resource needs to
	// allow this for the attachment to be complete. For Gateways, that means
	// the Gateway needs to allow attachment from Routes of this kind and
	// namespace. For Services, that means the Service must either be in the same
	// namespace for a "producer" route, or the mesh implementation must support
	// and allow "consumer" routes for the referenced Service. ReferenceGrant is
	// not applicable for governing ParentRefs to Services - it is not possible to
	// create a "producer" route for a Service in a different namespace from the
	// Route.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// This API may be extended in the future to support additional kinds of parent
	// resources.
	//
	// ParentRefs must be _distinct_. This means either that:
	//
	// * They select different objects.  If this is the case, then parentRef
	//   entries are distinct. In terms of fields, this means that the
	//   multi-part key defined by `group`, `kind`, `namespace`, and `name` must
	//   be unique across all parentRef entries in the Route.
	// * They do not select different objects, but for each optional field used,
	//   each ParentRef that selects the same object must set the same set of
	//   optional fields to different values. If one ParentRef sets a
	//   combination of optional fields, all must set the same combination.
	//
	// Some examples:
	//
	// * If one ParentRef sets `sectionName`, all ParentRefs referencing the
	//   same object must also set `sectionName`.
	// * If one ParentRef sets `port`, all ParentRefs referencing the same
	//   object must also set `port`.
	// * If one ParentRef sets `sectionName` and `port`, all ParentRefs
	//   referencing the same object must also set `sectionName` and `port`.
	//
	// It is possible to separately reference multiple distinct objects that may
	// be collapsed by an implementation. For example, some implementations may
	// choose to merge compatible Gateway Listeners together. If that is the
	// case, the list of routes attached to those resources should also be
	// merged.
	//
	// Note that for ParentRefs that cross namespace boundaries, there are specific
	// rules. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example,
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable other kinds of cross-namespace reference.
	ParentRefs []HTTPRouteSpecParentRefsPatch `pulumi:"parentRefs"`
	// Rules are a list of HTTP matchers, filters and actions.
	Rules []HTTPRouteSpecRulesPatch `pulumi:"rules"`
}

// HTTPRouteSpecPatchInput is an input type that accepts HTTPRouteSpecPatchArgs and HTTPRouteSpecPatchOutput values.
// You can construct a concrete instance of `HTTPRouteSpecPatchInput` via:
//
//	HTTPRouteSpecPatchArgs{...}
type HTTPRouteSpecPatchInput interface {
	pulumi.Input

	ToHTTPRouteSpecPatchOutput() HTTPRouteSpecPatchOutput
	ToHTTPRouteSpecPatchOutputWithContext(context.Context) HTTPRouteSpecPatchOutput
}

// Spec defines the desired state of HTTPRoute.
type HTTPRouteSpecPatchArgs struct {
	// Hostnames defines a set of hostnames that should match against the HTTP Host
	// header to select a HTTPRoute used to process the request. Implementations
	// MUST ignore any port value specified in the HTTP Host header while
	// performing a match and (absent of any applicable header modification
	// configuration) MUST forward this header unmodified to the backend.
	//
	// Valid values for Hostnames are determined by RFC 1123 definition of a
	// hostname with 2 notable exceptions:
	//
	// 1. IPs are not allowed.
	// 2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard
	//    label must appear by itself as the first label.
	//
	// If a hostname is specified by both the Listener and HTTPRoute, there
	// must be at least one intersecting hostname for the HTTPRoute to be
	// attached to the Listener. For example:
	//
	// * A Listener with `test.example.com` as the hostname matches HTTPRoutes
	//   that have either not specified any hostnames, or have specified at
	//   least one of `test.example.com` or `*.example.com`.
	// * A Listener with `*.example.com` as the hostname matches HTTPRoutes
	//   that have either not specified any hostnames or have specified at least
	//   one hostname that matches the Listener hostname. For example,
	//   `*.example.com`, `test.example.com`, and `foo.test.example.com` would
	//   all match. On the other hand, `example.com` and `test.example.net` would
	//   not match.
	//
	// Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
	// as a suffix match. That means that a match for `*.example.com` would match
	// both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
	//
	// If both the Listener and HTTPRoute have specified hostnames, any
	// HTTPRoute hostnames that do not match the Listener hostname MUST be
	// ignored. For example, if a Listener specified `*.example.com`, and the
	// HTTPRoute specified `test.example.com` and `test.example.net`,
	// `test.example.net` must not be considered for a match.
	//
	// If both the Listener and HTTPRoute have specified hostnames, and none
	// match with the criteria above, then the HTTPRoute is not accepted. The
	// implementation must raise an 'Accepted' Condition with a status of
	// `False` in the corresponding RouteParentStatus.
	//
	// In the event that multiple HTTPRoutes specify intersecting hostnames (e.g.
	// overlapping wildcard matching and exact matching hostnames), precedence must
	// be given to rules from the HTTPRoute with the largest number of:
	//
	// * Characters in a matching non-wildcard hostname.
	// * Characters in a matching hostname.
	//
	// If ties exist across multiple Routes, the matching precedence rules for
	// HTTPRouteMatches takes over.
	//
	// Support: Core
	Hostnames pulumi.StringArrayInput `pulumi:"hostnames"`
	// ParentRefs references the resources (usually Gateways) that a Route wants
	// to be attached to. Note that the referenced parent resource needs to
	// allow this for the attachment to be complete. For Gateways, that means
	// the Gateway needs to allow attachment from Routes of this kind and
	// namespace. For Services, that means the Service must either be in the same
	// namespace for a "producer" route, or the mesh implementation must support
	// and allow "consumer" routes for the referenced Service. ReferenceGrant is
	// not applicable for governing ParentRefs to Services - it is not possible to
	// create a "producer" route for a Service in a different namespace from the
	// Route.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// This API may be extended in the future to support additional kinds of parent
	// resources.
	//
	// ParentRefs must be _distinct_. This means either that:
	//
	// * They select different objects.  If this is the case, then parentRef
	//   entries are distinct. In terms of fields, this means that the
	//   multi-part key defined by `group`, `kind`, `namespace`, and `name` must
	//   be unique across all parentRef entries in the Route.
	// * They do not select different objects, but for each optional field used,
	//   each ParentRef that selects the same object must set the same set of
	//   optional fields to different values. If one ParentRef sets a
	//   combination of optional fields, all must set the same combination.
	//
	// Some examples:
	//
	// * If one ParentRef sets `sectionName`, all ParentRefs referencing the
	//   same object must also set `sectionName`.
	// * If one ParentRef sets `port`, all ParentRefs referencing the same
	//   object must also set `port`.
	// * If one ParentRef sets `sectionName` and `port`, all ParentRefs
	//   referencing the same object must also set `sectionName` and `port`.
	//
	// It is possible to separately reference multiple distinct objects that may
	// be collapsed by an implementation. For example, some implementations may
	// choose to merge compatible Gateway Listeners together. If that is the
	// case, the list of routes attached to those resources should also be
	// merged.
	//
	// Note that for ParentRefs that cross namespace boundaries, there are specific
	// rules. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example,
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable other kinds of cross-namespace reference.
	ParentRefs HTTPRouteSpecParentRefsPatchArrayInput `pulumi:"parentRefs"`
	// Rules are a list of HTTP matchers, filters and actions.
	Rules HTTPRouteSpecRulesPatchArrayInput `pulumi:"rules"`
}

func (HTTPRouteSpecPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecPatch)(nil)).Elem()
}

func (i HTTPRouteSpecPatchArgs) ToHTTPRouteSpecPatchOutput() HTTPRouteSpecPatchOutput {
	return i.ToHTTPRouteSpecPatchOutputWithContext(context.Background())
}

func (i HTTPRouteSpecPatchArgs) ToHTTPRouteSpecPatchOutputWithContext(ctx context.Context) HTTPRouteSpecPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecPatchOutput)
}

func (i HTTPRouteSpecPatchArgs) ToHTTPRouteSpecPatchPtrOutput() HTTPRouteSpecPatchPtrOutput {
	return i.ToHTTPRouteSpecPatchPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecPatchArgs) ToHTTPRouteSpecPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecPatchOutput).ToHTTPRouteSpecPatchPtrOutputWithContext(ctx)
}

// HTTPRouteSpecPatchPtrInput is an input type that accepts HTTPRouteSpecPatchArgs, HTTPRouteSpecPatchPtr and HTTPRouteSpecPatchPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecPatchPtrInput` via:
//
//	        HTTPRouteSpecPatchArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecPatchPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecPatchPtrOutput() HTTPRouteSpecPatchPtrOutput
	ToHTTPRouteSpecPatchPtrOutputWithContext(context.Context) HTTPRouteSpecPatchPtrOutput
}

type httprouteSpecPatchPtrType HTTPRouteSpecPatchArgs

func HTTPRouteSpecPatchPtr(v *HTTPRouteSpecPatchArgs) HTTPRouteSpecPatchPtrInput {
	return (*httprouteSpecPatchPtrType)(v)
}

func (*httprouteSpecPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecPatch)(nil)).Elem()
}

func (i *httprouteSpecPatchPtrType) ToHTTPRouteSpecPatchPtrOutput() HTTPRouteSpecPatchPtrOutput {
	return i.ToHTTPRouteSpecPatchPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecPatchPtrType) ToHTTPRouteSpecPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecPatchPtrOutput)
}

// Spec defines the desired state of HTTPRoute.
type HTTPRouteSpecPatchOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecPatch)(nil)).Elem()
}

func (o HTTPRouteSpecPatchOutput) ToHTTPRouteSpecPatchOutput() HTTPRouteSpecPatchOutput {
	return o
}

func (o HTTPRouteSpecPatchOutput) ToHTTPRouteSpecPatchOutputWithContext(ctx context.Context) HTTPRouteSpecPatchOutput {
	return o
}

func (o HTTPRouteSpecPatchOutput) ToHTTPRouteSpecPatchPtrOutput() HTTPRouteSpecPatchPtrOutput {
	return o.ToHTTPRouteSpecPatchPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecPatchOutput) ToHTTPRouteSpecPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecPatch) *HTTPRouteSpecPatch {
		return &v
	}).(HTTPRouteSpecPatchPtrOutput)
}

// Hostnames defines a set of hostnames that should match against the HTTP Host
// header to select a HTTPRoute used to process the request. Implementations
// MUST ignore any port value specified in the HTTP Host header while
// performing a match and (absent of any applicable header modification
// configuration) MUST forward this header unmodified to the backend.
//
// Valid values for Hostnames are determined by RFC 1123 definition of a
// hostname with 2 notable exceptions:
//
//  1. IPs are not allowed.
//  2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard
//     label must appear by itself as the first label.
//
// If a hostname is specified by both the Listener and HTTPRoute, there
// must be at least one intersecting hostname for the HTTPRoute to be
// attached to the Listener. For example:
//
//   - A Listener with `test.example.com` as the hostname matches HTTPRoutes
//     that have either not specified any hostnames, or have specified at
//     least one of `test.example.com` or `*.example.com`.
//   - A Listener with `*.example.com` as the hostname matches HTTPRoutes
//     that have either not specified any hostnames or have specified at least
//     one hostname that matches the Listener hostname. For example,
//     `*.example.com`, `test.example.com`, and `foo.test.example.com` would
//     all match. On the other hand, `example.com` and `test.example.net` would
//     not match.
//
// Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
// as a suffix match. That means that a match for `*.example.com` would match
// both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
//
// If both the Listener and HTTPRoute have specified hostnames, any
// HTTPRoute hostnames that do not match the Listener hostname MUST be
// ignored. For example, if a Listener specified `*.example.com`, and the
// HTTPRoute specified `test.example.com` and `test.example.net`,
// `test.example.net` must not be considered for a match.
//
// If both the Listener and HTTPRoute have specified hostnames, and none
// match with the criteria above, then the HTTPRoute is not accepted. The
// implementation must raise an 'Accepted' Condition with a status of
// `False` in the corresponding RouteParentStatus.
//
// In the event that multiple HTTPRoutes specify intersecting hostnames (e.g.
// overlapping wildcard matching and exact matching hostnames), precedence must
// be given to rules from the HTTPRoute with the largest number of:
//
// * Characters in a matching non-wildcard hostname.
// * Characters in a matching hostname.
//
// If ties exist across multiple Routes, the matching precedence rules for
// HTTPRouteMatches takes over.
//
// Support: Core
func (o HTTPRouteSpecPatchOutput) Hostnames() pulumi.StringArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecPatch) []string { return v.Hostnames }).(pulumi.StringArrayOutput)
}

// ParentRefs references the resources (usually Gateways) that a Route wants
// to be attached to. Note that the referenced parent resource needs to
// allow this for the attachment to be complete. For Gateways, that means
// the Gateway needs to allow attachment from Routes of this kind and
// namespace. For Services, that means the Service must either be in the same
// namespace for a "producer" route, or the mesh implementation must support
// and allow "consumer" routes for the referenced Service. ReferenceGrant is
// not applicable for governing ParentRefs to Services - it is not possible to
// create a "producer" route for a Service in a different namespace from the
// Route.
//
// There are two kinds of parent resources with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// ParentRefs must be _distinct_. This means either that:
//
//   - They select different objects.  If this is the case, then parentRef
//     entries are distinct. In terms of fields, this means that the
//     multi-part key defined by `group`, `kind`, `namespace`, and `name` must
//     be unique across all parentRef entries in the Route.
//   - They do not select different objects, but for each optional field used,
//     each ParentRef that selects the same object must set the same set of
//     optional fields to different values. If one ParentRef sets a
//     combination of optional fields, all must set the same combination.
//
// Some examples:
//
//   - If one ParentRef sets `sectionName`, all ParentRefs referencing the
//     same object must also set `sectionName`.
//   - If one ParentRef sets `port`, all ParentRefs referencing the same
//     object must also set `port`.
//   - If one ParentRef sets `sectionName` and `port`, all ParentRefs
//     referencing the same object must also set `sectionName` and `port`.
//
// It is possible to separately reference multiple distinct objects that may
// be collapsed by an implementation. For example, some implementations may
// choose to merge compatible Gateway Listeners together. If that is the
// case, the list of routes attached to those resources should also be
// merged.
//
// Note that for ParentRefs that cross namespace boundaries, there are specific
// rules. Cross-namespace references are only valid if they are explicitly
// allowed by something in the namespace they are referring to. For example,
// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
// generic way to enable other kinds of cross-namespace reference.
func (o HTTPRouteSpecPatchOutput) ParentRefs() HTTPRouteSpecParentRefsPatchArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecPatch) []HTTPRouteSpecParentRefsPatch { return v.ParentRefs }).(HTTPRouteSpecParentRefsPatchArrayOutput)
}

// Rules are a list of HTTP matchers, filters and actions.
func (o HTTPRouteSpecPatchOutput) Rules() HTTPRouteSpecRulesPatchArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecPatch) []HTTPRouteSpecRulesPatch { return v.Rules }).(HTTPRouteSpecRulesPatchArrayOutput)
}

type HTTPRouteSpecPatchPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecPatch)(nil)).Elem()
}

func (o HTTPRouteSpecPatchPtrOutput) ToHTTPRouteSpecPatchPtrOutput() HTTPRouteSpecPatchPtrOutput {
	return o
}

func (o HTTPRouteSpecPatchPtrOutput) ToHTTPRouteSpecPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecPatchPtrOutput {
	return o
}

func (o HTTPRouteSpecPatchPtrOutput) Elem() HTTPRouteSpecPatchOutput {
	return o.ApplyT(func(v *HTTPRouteSpecPatch) HTTPRouteSpecPatch {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecPatch
		return ret
	}).(HTTPRouteSpecPatchOutput)
}

// Hostnames defines a set of hostnames that should match against the HTTP Host
// header to select a HTTPRoute used to process the request. Implementations
// MUST ignore any port value specified in the HTTP Host header while
// performing a match and (absent of any applicable header modification
// configuration) MUST forward this header unmodified to the backend.
//
// Valid values for Hostnames are determined by RFC 1123 definition of a
// hostname with 2 notable exceptions:
//
//  1. IPs are not allowed.
//  2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard
//     label must appear by itself as the first label.
//
// If a hostname is specified by both the Listener and HTTPRoute, there
// must be at least one intersecting hostname for the HTTPRoute to be
// attached to the Listener. For example:
//
//   - A Listener with `test.example.com` as the hostname matches HTTPRoutes
//     that have either not specified any hostnames, or have specified at
//     least one of `test.example.com` or `*.example.com`.
//   - A Listener with `*.example.com` as the hostname matches HTTPRoutes
//     that have either not specified any hostnames or have specified at least
//     one hostname that matches the Listener hostname. For example,
//     `*.example.com`, `test.example.com`, and `foo.test.example.com` would
//     all match. On the other hand, `example.com` and `test.example.net` would
//     not match.
//
// Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
// as a suffix match. That means that a match for `*.example.com` would match
// both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
//
// If both the Listener and HTTPRoute have specified hostnames, any
// HTTPRoute hostnames that do not match the Listener hostname MUST be
// ignored. For example, if a Listener specified `*.example.com`, and the
// HTTPRoute specified `test.example.com` and `test.example.net`,
// `test.example.net` must not be considered for a match.
//
// If both the Listener and HTTPRoute have specified hostnames, and none
// match with the criteria above, then the HTTPRoute is not accepted. The
// implementation must raise an 'Accepted' Condition with a status of
// `False` in the corresponding RouteParentStatus.
//
// In the event that multiple HTTPRoutes specify intersecting hostnames (e.g.
// overlapping wildcard matching and exact matching hostnames), precedence must
// be given to rules from the HTTPRoute with the largest number of:
//
// * Characters in a matching non-wildcard hostname.
// * Characters in a matching hostname.
//
// If ties exist across multiple Routes, the matching precedence rules for
// HTTPRouteMatches takes over.
//
// Support: Core
func (o HTTPRouteSpecPatchPtrOutput) Hostnames() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *HTTPRouteSpecPatch) []string {
		if v == nil {
			return nil
		}
		return v.Hostnames
	}).(pulumi.StringArrayOutput)
}

// ParentRefs references the resources (usually Gateways) that a Route wants
// to be attached to. Note that the referenced parent resource needs to
// allow this for the attachment to be complete. For Gateways, that means
// the Gateway needs to allow attachment from Routes of this kind and
// namespace. For Services, that means the Service must either be in the same
// namespace for a "producer" route, or the mesh implementation must support
// and allow "consumer" routes for the referenced Service. ReferenceGrant is
// not applicable for governing ParentRefs to Services - it is not possible to
// create a "producer" route for a Service in a different namespace from the
// Route.
//
// There are two kinds of parent resources with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// ParentRefs must be _distinct_. This means either that:
//
//   - They select different objects.  If this is the case, then parentRef
//     entries are distinct. In terms of fields, this means that the
//     multi-part key defined by `group`, `kind`, `namespace`, and `name` must
//     be unique across all parentRef entries in the Route.
//   - They do not select different objects, but for each optional field used,
//     each ParentRef that selects the same object must set the same set of
//     optional fields to different values. If one ParentRef sets a
//     combination of optional fields, all must set the same combination.
//
// Some examples:
//
//   - If one ParentRef sets `sectionName`, all ParentRefs referencing the
//     same object must also set `sectionName`.
//   - If one ParentRef sets `port`, all ParentRefs referencing the same
//     object must also set `port`.
//   - If one ParentRef sets `sectionName` and `port`, all ParentRefs
//     referencing the same object must also set `sectionName` and `port`.
//
// It is possible to separately reference multiple distinct objects that may
// be collapsed by an implementation. For example, some implementations may
// choose to merge compatible Gateway Listeners together. If that is the
// case, the list of routes attached to those resources should also be
// merged.
//
// Note that for ParentRefs that cross namespace boundaries, there are specific
// rules. Cross-namespace references are only valid if they are explicitly
// allowed by something in the namespace they are referring to. For example,
// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
// generic way to enable other kinds of cross-namespace reference.
func (o HTTPRouteSpecPatchPtrOutput) ParentRefs() HTTPRouteSpecParentRefsPatchArrayOutput {
	return o.ApplyT(func(v *HTTPRouteSpecPatch) []HTTPRouteSpecParentRefsPatch {
		if v == nil {
			return nil
		}
		return v.ParentRefs
	}).(HTTPRouteSpecParentRefsPatchArrayOutput)
}

// Rules are a list of HTTP matchers, filters and actions.
func (o HTTPRouteSpecPatchPtrOutput) Rules() HTTPRouteSpecRulesPatchArrayOutput {
	return o.ApplyT(func(v *HTTPRouteSpecPatch) []HTTPRouteSpecRulesPatch {
		if v == nil {
			return nil
		}
		return v.Rules
	}).(HTTPRouteSpecRulesPatchArrayOutput)
}

// HTTPRouteRule defines semantics for matching an HTTP request based on
// conditions (matches), processing it (filters), and forwarding the request to
// an API object (backendRefs).
type HTTPRouteSpecRules struct {
	// BackendRefs defines the backend(s) where matching requests should be
	// sent.
	//
	// Failure behavior here depends on how many BackendRefs are specified and
	// how many are invalid.
	//
	// If *all* entries in BackendRefs are invalid, and there are also no filters
	// specified in this route rule, *all* traffic which matches this rule MUST
	// receive a 500 status code.
	//
	// See the HTTPBackendRef definition for the rules about what makes a single
	// HTTPBackendRef invalid.
	//
	// When a HTTPBackendRef is invalid, 500 status codes MUST be returned for
	// requests that would have otherwise been routed to an invalid backend. If
	// multiple backends are specified, and some are invalid, the proportion of
	// requests that would otherwise have been routed to an invalid backend
	// MUST receive a 500 status code.
	//
	// For example, if two backends are specified with equal weights, and one is
	// invalid, 50 percent of traffic must receive a 500. Implementations may
	// choose how that 50 percent is determined.
	//
	// Support: Core for Kubernetes Service
	//
	// Support: Extended for Kubernetes ServiceImport
	//
	// Support: Implementation-specific for any other resource
	//
	// Support for weight: Core
	BackendRefs []HTTPRouteSpecRulesBackendRefs `pulumi:"backendRefs"`
	// Filters define the filters that are applied to requests that match
	// this rule.
	//
	// Wherever possible, implementations SHOULD implement filters in the order
	// they are specified.
	//
	// Implementations MAY choose to implement this ordering strictly, rejecting
	// any combination or order of filters that can not be supported. If implementations
	// choose a strict interpretation of filter ordering, they MUST clearly document
	// that behavior.
	//
	// To reject an invalid combination or order of filters, implementations SHOULD
	// consider the Route Rules with this configuration invalid. If all Route Rules
	// in a Route are invalid, the entire Route would be considered invalid. If only
	// a portion of Route Rules are invalid, implementations MUST set the
	// "PartiallyInvalid" condition for the Route.
	//
	// Conformance-levels at this level are defined based on the type of filter:
	//
	// - ALL core filters MUST be supported by all implementations.
	// - Implementers are encouraged to support extended filters.
	// - Implementation-specific custom filters have no API guarantees across
	//   implementations.
	//
	// Specifying the same filter multiple times is not supported unless explicitly
	// indicated in the filter.
	//
	// All filters are expected to be compatible with each other except for the
	// URLRewrite and RequestRedirect filters, which may not be combined. If an
	// implementation can not support other combinations of filters, they must clearly
	// document that limitation. In cases where incompatible or unsupported
	// filters are specified and cause the `Accepted` condition to be set to status
	// `False`, implementations may use the `IncompatibleFilters` reason to specify
	// this configuration error.
	//
	// Support: Core
	Filters []HTTPRouteSpecRulesFilters `pulumi:"filters"`
	// Matches define conditions used for matching the rule against incoming
	// HTTP requests. Each match is independent, i.e. this rule will be matched
	// if **any** one of the matches is satisfied.
	//
	// For example, take the following matches configuration:
	//
	// For a request to match against this rule, a request must satisfy
	// EITHER of the two conditions:
	//
	// - path prefixed with `/foo` AND contains the header `version: v2`
	// - path prefix of `/v2/foo`
	//
	// See the documentation for HTTPRouteMatch on how to specify multiple
	// match conditions that should be ANDed together.
	//
	// If no matches are specified, the default is a prefix
	// path match on "/", which has the effect of matching every
	// HTTP request.
	//
	// Proxy or Load Balancer routing configuration generated from HTTPRoutes
	// MUST prioritize matches based on the following criteria, continuing on
	// ties. Across all rules specified on applicable Routes, precedence must be
	// given to the match having:
	//
	// * "Exact" path match.
	// * "Prefix" path match with largest number of characters.
	// * Method match.
	// * Largest number of header matches.
	// * Largest number of query param matches.
	//
	// Note: The precedence of RegularExpression path matches are implementation-specific.
	//
	// If ties still exist across multiple Routes, matching precedence MUST be
	// determined in order of the following criteria, continuing on ties:
	//
	// * The oldest Route based on creation timestamp.
	// * The Route appearing first in alphabetical order by
	//   "{namespace}/{name}".
	//
	// If ties still exist within an HTTPRoute, matching precedence MUST be granted
	// to the FIRST matching rule (in list order) with a match meeting the above
	// criteria.
	//
	// When no rules matching a request have been successfully attached to the
	// parent a request is coming from, a HTTP 404 status code MUST be returned.
	Matches []HTTPRouteSpecRulesMatches `pulumi:"matches"`
}

// HTTPRouteSpecRulesInput is an input type that accepts HTTPRouteSpecRulesArgs and HTTPRouteSpecRulesOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesInput` via:
//
//	HTTPRouteSpecRulesArgs{...}
type HTTPRouteSpecRulesInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesOutput() HTTPRouteSpecRulesOutput
	ToHTTPRouteSpecRulesOutputWithContext(context.Context) HTTPRouteSpecRulesOutput
}

// HTTPRouteRule defines semantics for matching an HTTP request based on
// conditions (matches), processing it (filters), and forwarding the request to
// an API object (backendRefs).
type HTTPRouteSpecRulesArgs struct {
	// BackendRefs defines the backend(s) where matching requests should be
	// sent.
	//
	// Failure behavior here depends on how many BackendRefs are specified and
	// how many are invalid.
	//
	// If *all* entries in BackendRefs are invalid, and there are also no filters
	// specified in this route rule, *all* traffic which matches this rule MUST
	// receive a 500 status code.
	//
	// See the HTTPBackendRef definition for the rules about what makes a single
	// HTTPBackendRef invalid.
	//
	// When a HTTPBackendRef is invalid, 500 status codes MUST be returned for
	// requests that would have otherwise been routed to an invalid backend. If
	// multiple backends are specified, and some are invalid, the proportion of
	// requests that would otherwise have been routed to an invalid backend
	// MUST receive a 500 status code.
	//
	// For example, if two backends are specified with equal weights, and one is
	// invalid, 50 percent of traffic must receive a 500. Implementations may
	// choose how that 50 percent is determined.
	//
	// Support: Core for Kubernetes Service
	//
	// Support: Extended for Kubernetes ServiceImport
	//
	// Support: Implementation-specific for any other resource
	//
	// Support for weight: Core
	BackendRefs HTTPRouteSpecRulesBackendRefsArrayInput `pulumi:"backendRefs"`
	// Filters define the filters that are applied to requests that match
	// this rule.
	//
	// Wherever possible, implementations SHOULD implement filters in the order
	// they are specified.
	//
	// Implementations MAY choose to implement this ordering strictly, rejecting
	// any combination or order of filters that can not be supported. If implementations
	// choose a strict interpretation of filter ordering, they MUST clearly document
	// that behavior.
	//
	// To reject an invalid combination or order of filters, implementations SHOULD
	// consider the Route Rules with this configuration invalid. If all Route Rules
	// in a Route are invalid, the entire Route would be considered invalid. If only
	// a portion of Route Rules are invalid, implementations MUST set the
	// "PartiallyInvalid" condition for the Route.
	//
	// Conformance-levels at this level are defined based on the type of filter:
	//
	// - ALL core filters MUST be supported by all implementations.
	// - Implementers are encouraged to support extended filters.
	// - Implementation-specific custom filters have no API guarantees across
	//   implementations.
	//
	// Specifying the same filter multiple times is not supported unless explicitly
	// indicated in the filter.
	//
	// All filters are expected to be compatible with each other except for the
	// URLRewrite and RequestRedirect filters, which may not be combined. If an
	// implementation can not support other combinations of filters, they must clearly
	// document that limitation. In cases where incompatible or unsupported
	// filters are specified and cause the `Accepted` condition to be set to status
	// `False`, implementations may use the `IncompatibleFilters` reason to specify
	// this configuration error.
	//
	// Support: Core
	Filters HTTPRouteSpecRulesFiltersArrayInput `pulumi:"filters"`
	// Matches define conditions used for matching the rule against incoming
	// HTTP requests. Each match is independent, i.e. this rule will be matched
	// if **any** one of the matches is satisfied.
	//
	// For example, take the following matches configuration:
	//
	// For a request to match against this rule, a request must satisfy
	// EITHER of the two conditions:
	//
	// - path prefixed with `/foo` AND contains the header `version: v2`
	// - path prefix of `/v2/foo`
	//
	// See the documentation for HTTPRouteMatch on how to specify multiple
	// match conditions that should be ANDed together.
	//
	// If no matches are specified, the default is a prefix
	// path match on "/", which has the effect of matching every
	// HTTP request.
	//
	// Proxy or Load Balancer routing configuration generated from HTTPRoutes
	// MUST prioritize matches based on the following criteria, continuing on
	// ties. Across all rules specified on applicable Routes, precedence must be
	// given to the match having:
	//
	// * "Exact" path match.
	// * "Prefix" path match with largest number of characters.
	// * Method match.
	// * Largest number of header matches.
	// * Largest number of query param matches.
	//
	// Note: The precedence of RegularExpression path matches are implementation-specific.
	//
	// If ties still exist across multiple Routes, matching precedence MUST be
	// determined in order of the following criteria, continuing on ties:
	//
	// * The oldest Route based on creation timestamp.
	// * The Route appearing first in alphabetical order by
	//   "{namespace}/{name}".
	//
	// If ties still exist within an HTTPRoute, matching precedence MUST be granted
	// to the FIRST matching rule (in list order) with a match meeting the above
	// criteria.
	//
	// When no rules matching a request have been successfully attached to the
	// parent a request is coming from, a HTTP 404 status code MUST be returned.
	Matches HTTPRouteSpecRulesMatchesArrayInput `pulumi:"matches"`
}

func (HTTPRouteSpecRulesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRules)(nil)).Elem()
}

func (i HTTPRouteSpecRulesArgs) ToHTTPRouteSpecRulesOutput() HTTPRouteSpecRulesOutput {
	return i.ToHTTPRouteSpecRulesOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesArgs) ToHTTPRouteSpecRulesOutputWithContext(ctx context.Context) HTTPRouteSpecRulesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesOutput)
}

// HTTPRouteSpecRulesArrayInput is an input type that accepts HTTPRouteSpecRulesArray and HTTPRouteSpecRulesArrayOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesArrayInput` via:
//
//	HTTPRouteSpecRulesArray{ HTTPRouteSpecRulesArgs{...} }
type HTTPRouteSpecRulesArrayInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesArrayOutput() HTTPRouteSpecRulesArrayOutput
	ToHTTPRouteSpecRulesArrayOutputWithContext(context.Context) HTTPRouteSpecRulesArrayOutput
}

type HTTPRouteSpecRulesArray []HTTPRouteSpecRulesInput

func (HTTPRouteSpecRulesArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRules)(nil)).Elem()
}

func (i HTTPRouteSpecRulesArray) ToHTTPRouteSpecRulesArrayOutput() HTTPRouteSpecRulesArrayOutput {
	return i.ToHTTPRouteSpecRulesArrayOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesArray) ToHTTPRouteSpecRulesArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesArrayOutput)
}

// HTTPRouteRule defines semantics for matching an HTTP request based on
// conditions (matches), processing it (filters), and forwarding the request to
// an API object (backendRefs).
type HTTPRouteSpecRulesOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRules)(nil)).Elem()
}

func (o HTTPRouteSpecRulesOutput) ToHTTPRouteSpecRulesOutput() HTTPRouteSpecRulesOutput {
	return o
}

func (o HTTPRouteSpecRulesOutput) ToHTTPRouteSpecRulesOutputWithContext(ctx context.Context) HTTPRouteSpecRulesOutput {
	return o
}

// BackendRefs defines the backend(s) where matching requests should be
// sent.
//
// Failure behavior here depends on how many BackendRefs are specified and
// how many are invalid.
//
// If *all* entries in BackendRefs are invalid, and there are also no filters
// specified in this route rule, *all* traffic which matches this rule MUST
// receive a 500 status code.
//
// See the HTTPBackendRef definition for the rules about what makes a single
// HTTPBackendRef invalid.
//
// When a HTTPBackendRef is invalid, 500 status codes MUST be returned for
// requests that would have otherwise been routed to an invalid backend. If
// multiple backends are specified, and some are invalid, the proportion of
// requests that would otherwise have been routed to an invalid backend
// MUST receive a 500 status code.
//
// For example, if two backends are specified with equal weights, and one is
// invalid, 50 percent of traffic must receive a 500. Implementations may
// choose how that 50 percent is determined.
//
// Support: Core for Kubernetes Service
//
// Support: Extended for Kubernetes ServiceImport
//
// Support: Implementation-specific for any other resource
//
// Support for weight: Core
func (o HTTPRouteSpecRulesOutput) BackendRefs() HTTPRouteSpecRulesBackendRefsArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRules) []HTTPRouteSpecRulesBackendRefs { return v.BackendRefs }).(HTTPRouteSpecRulesBackendRefsArrayOutput)
}

// Filters define the filters that are applied to requests that match
// this rule.
//
// Wherever possible, implementations SHOULD implement filters in the order
// they are specified.
//
// Implementations MAY choose to implement this ordering strictly, rejecting
// any combination or order of filters that can not be supported. If implementations
// choose a strict interpretation of filter ordering, they MUST clearly document
// that behavior.
//
// To reject an invalid combination or order of filters, implementations SHOULD
// consider the Route Rules with this configuration invalid. If all Route Rules
// in a Route are invalid, the entire Route would be considered invalid. If only
// a portion of Route Rules are invalid, implementations MUST set the
// "PartiallyInvalid" condition for the Route.
//
// Conformance-levels at this level are defined based on the type of filter:
//
//   - ALL core filters MUST be supported by all implementations.
//   - Implementers are encouraged to support extended filters.
//   - Implementation-specific custom filters have no API guarantees across
//     implementations.
//
// Specifying the same filter multiple times is not supported unless explicitly
// indicated in the filter.
//
// All filters are expected to be compatible with each other except for the
// URLRewrite and RequestRedirect filters, which may not be combined. If an
// implementation can not support other combinations of filters, they must clearly
// document that limitation. In cases where incompatible or unsupported
// filters are specified and cause the `Accepted` condition to be set to status
// `False`, implementations may use the `IncompatibleFilters` reason to specify
// this configuration error.
//
// Support: Core
func (o HTTPRouteSpecRulesOutput) Filters() HTTPRouteSpecRulesFiltersArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRules) []HTTPRouteSpecRulesFilters { return v.Filters }).(HTTPRouteSpecRulesFiltersArrayOutput)
}

// Matches define conditions used for matching the rule against incoming
// HTTP requests. Each match is independent, i.e. this rule will be matched
// if **any** one of the matches is satisfied.
//
// For example, take the following matches configuration:
//
// For a request to match against this rule, a request must satisfy
// EITHER of the two conditions:
//
// - path prefixed with `/foo` AND contains the header `version: v2`
// - path prefix of `/v2/foo`
//
// See the documentation for HTTPRouteMatch on how to specify multiple
// match conditions that should be ANDed together.
//
// If no matches are specified, the default is a prefix
// path match on "/", which has the effect of matching every
// HTTP request.
//
// Proxy or Load Balancer routing configuration generated from HTTPRoutes
// MUST prioritize matches based on the following criteria, continuing on
// ties. Across all rules specified on applicable Routes, precedence must be
// given to the match having:
//
// * "Exact" path match.
// * "Prefix" path match with largest number of characters.
// * Method match.
// * Largest number of header matches.
// * Largest number of query param matches.
//
// Note: The precedence of RegularExpression path matches are implementation-specific.
//
// If ties still exist across multiple Routes, matching precedence MUST be
// determined in order of the following criteria, continuing on ties:
//
//   - The oldest Route based on creation timestamp.
//   - The Route appearing first in alphabetical order by
//     "{namespace}/{name}".
//
// If ties still exist within an HTTPRoute, matching precedence MUST be granted
// to the FIRST matching rule (in list order) with a match meeting the above
// criteria.
//
// When no rules matching a request have been successfully attached to the
// parent a request is coming from, a HTTP 404 status code MUST be returned.
func (o HTTPRouteSpecRulesOutput) Matches() HTTPRouteSpecRulesMatchesArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRules) []HTTPRouteSpecRulesMatches { return v.Matches }).(HTTPRouteSpecRulesMatchesArrayOutput)
}

type HTTPRouteSpecRulesArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRules)(nil)).Elem()
}

func (o HTTPRouteSpecRulesArrayOutput) ToHTTPRouteSpecRulesArrayOutput() HTTPRouteSpecRulesArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesArrayOutput) ToHTTPRouteSpecRulesArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesArrayOutput) Index(i pulumi.IntInput) HTTPRouteSpecRulesOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteSpecRules {
		return vs[0].([]HTTPRouteSpecRules)[vs[1].(int)]
	}).(HTTPRouteSpecRulesOutput)
}

// HTTPBackendRef defines how a HTTPRoute forwards a HTTP request.
//
// Note that when a namespace different than the local namespace is specified, a
// ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// <gateway:experimental:description>
//
// When the BackendRef points to a Kubernetes Service, implementations SHOULD
// honor the appProtocol field if it is set for the target Service Port.
//
// Implementations supporting appProtocol SHOULD recognize the Kubernetes
// Standard Application Protocols defined in KEP-3726.
//
// If a Service appProtocol isn't specified, an implementation MAY infer the
// backend protocol through its own means. Implementations MAY infer the
// protocol from the Route type referring to the backend Service.
//
// If a Route is not able to send traffic to the backend using the specified
// protocol then the backend is considered invalid. Implementations MUST set the
// "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.
//
// </gateway:experimental:description>
type HTTPRouteSpecRulesBackendRefs struct {
	// Filters defined at this level should be executed if and only if the
	// request is being forwarded to the backend defined here.
	//
	// Support: Implementation-specific (For broader support of filters, use the
	// Filters field in HTTPRouteRule.)
	Filters []HTTPRouteSpecRulesBackendRefsFilters `pulumi:"filters"`
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group *string `pulumi:"group"`
	// Kind is the Kubernetes resource kind of the referent. For example
	// "Service".
	//
	// Defaults to "Service" when not specified.
	//
	// ExternalName services can refer to CNAME DNS records that may live
	// outside of the cluster and as such are difficult to reason about in
	// terms of conformance. They also may not be safe to forward to (see
	// CVE-2021-25740 for more information). Implementations SHOULD NOT
	// support ExternalName Services.
	//
	// Support: Core (Services with a type other than ExternalName)
	//
	// Support: Implementation-specific (Services with type ExternalName)
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	Name *string `pulumi:"name"`
	// Namespace is the namespace of the backend. When unspecified, the local
	// namespace is inferred.
	//
	// Note that when a namespace different than the local namespace is specified,
	// a ReferenceGrant object is required in the referent namespace to allow that
	// namespace's owner to accept the reference. See the ReferenceGrant
	// documentation for details.
	//
	// Support: Core
	Namespace *string `pulumi:"namespace"`
	// Port specifies the destination port number to use for this resource.
	// Port is required when the referent is a Kubernetes Service. In this
	// case, the port number is the service port number, not the target port.
	// For other resources, destination port might be derived from the referent
	// resource or this field.
	Port *int `pulumi:"port"`
	// Weight specifies the proportion of requests forwarded to the referenced
	// backend. This is computed as weight/(sum of all weights in this
	// BackendRefs list). For non-zero values, there may be some epsilon from
	// the exact proportion defined here depending on the precision an
	// implementation supports. Weight is not a percentage and the sum of
	// weights does not need to equal 100.
	//
	// If only one backend is specified and it has a weight greater than 0, 100%
	// of the traffic is forwarded to that backend. If weight is set to 0, no
	// traffic should be forwarded for this entry. If unspecified, weight
	// defaults to 1.
	//
	// Support for this field varies based on the context where used.
	Weight *int `pulumi:"weight"`
}

// HTTPRouteSpecRulesBackendRefsInput is an input type that accepts HTTPRouteSpecRulesBackendRefsArgs and HTTPRouteSpecRulesBackendRefsOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsInput` via:
//
//	HTTPRouteSpecRulesBackendRefsArgs{...}
type HTTPRouteSpecRulesBackendRefsInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsOutput() HTTPRouteSpecRulesBackendRefsOutput
	ToHTTPRouteSpecRulesBackendRefsOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsOutput
}

// HTTPBackendRef defines how a HTTPRoute forwards a HTTP request.
//
// Note that when a namespace different than the local namespace is specified, a
// ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// <gateway:experimental:description>
//
// When the BackendRef points to a Kubernetes Service, implementations SHOULD
// honor the appProtocol field if it is set for the target Service Port.
//
// Implementations supporting appProtocol SHOULD recognize the Kubernetes
// Standard Application Protocols defined in KEP-3726.
//
// If a Service appProtocol isn't specified, an implementation MAY infer the
// backend protocol through its own means. Implementations MAY infer the
// protocol from the Route type referring to the backend Service.
//
// If a Route is not able to send traffic to the backend using the specified
// protocol then the backend is considered invalid. Implementations MUST set the
// "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.
//
// </gateway:experimental:description>
type HTTPRouteSpecRulesBackendRefsArgs struct {
	// Filters defined at this level should be executed if and only if the
	// request is being forwarded to the backend defined here.
	//
	// Support: Implementation-specific (For broader support of filters, use the
	// Filters field in HTTPRouteRule.)
	Filters HTTPRouteSpecRulesBackendRefsFiltersArrayInput `pulumi:"filters"`
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is the Kubernetes resource kind of the referent. For example
	// "Service".
	//
	// Defaults to "Service" when not specified.
	//
	// ExternalName services can refer to CNAME DNS records that may live
	// outside of the cluster and as such are difficult to reason about in
	// terms of conformance. They also may not be safe to forward to (see
	// CVE-2021-25740 for more information). Implementations SHOULD NOT
	// support ExternalName Services.
	//
	// Support: Core (Services with a type other than ExternalName)
	//
	// Support: Implementation-specific (Services with type ExternalName)
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace is the namespace of the backend. When unspecified, the local
	// namespace is inferred.
	//
	// Note that when a namespace different than the local namespace is specified,
	// a ReferenceGrant object is required in the referent namespace to allow that
	// namespace's owner to accept the reference. See the ReferenceGrant
	// documentation for details.
	//
	// Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Port specifies the destination port number to use for this resource.
	// Port is required when the referent is a Kubernetes Service. In this
	// case, the port number is the service port number, not the target port.
	// For other resources, destination port might be derived from the referent
	// resource or this field.
	Port pulumi.IntPtrInput `pulumi:"port"`
	// Weight specifies the proportion of requests forwarded to the referenced
	// backend. This is computed as weight/(sum of all weights in this
	// BackendRefs list). For non-zero values, there may be some epsilon from
	// the exact proportion defined here depending on the precision an
	// implementation supports. Weight is not a percentage and the sum of
	// weights does not need to equal 100.
	//
	// If only one backend is specified and it has a weight greater than 0, 100%
	// of the traffic is forwarded to that backend. If weight is set to 0, no
	// traffic should be forwarded for this entry. If unspecified, weight
	// defaults to 1.
	//
	// Support for this field varies based on the context where used.
	Weight pulumi.IntPtrInput `pulumi:"weight"`
}

func (HTTPRouteSpecRulesBackendRefsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefs)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsArgs) ToHTTPRouteSpecRulesBackendRefsOutput() HTTPRouteSpecRulesBackendRefsOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsArgs) ToHTTPRouteSpecRulesBackendRefsOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsOutput)
}

// HTTPRouteSpecRulesBackendRefsArrayInput is an input type that accepts HTTPRouteSpecRulesBackendRefsArray and HTTPRouteSpecRulesBackendRefsArrayOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsArrayInput` via:
//
//	HTTPRouteSpecRulesBackendRefsArray{ HTTPRouteSpecRulesBackendRefsArgs{...} }
type HTTPRouteSpecRulesBackendRefsArrayInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsArrayOutput() HTTPRouteSpecRulesBackendRefsArrayOutput
	ToHTTPRouteSpecRulesBackendRefsArrayOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsArrayOutput
}

type HTTPRouteSpecRulesBackendRefsArray []HTTPRouteSpecRulesBackendRefsInput

func (HTTPRouteSpecRulesBackendRefsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesBackendRefs)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsArray) ToHTTPRouteSpecRulesBackendRefsArrayOutput() HTTPRouteSpecRulesBackendRefsArrayOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsArrayOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsArray) ToHTTPRouteSpecRulesBackendRefsArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsArrayOutput)
}

// HTTPBackendRef defines how a HTTPRoute forwards a HTTP request.
//
// Note that when a namespace different than the local namespace is specified, a
// ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// <gateway:experimental:description>
//
// When the BackendRef points to a Kubernetes Service, implementations SHOULD
// honor the appProtocol field if it is set for the target Service Port.
//
// Implementations supporting appProtocol SHOULD recognize the Kubernetes
// Standard Application Protocols defined in KEP-3726.
//
// If a Service appProtocol isn't specified, an implementation MAY infer the
// backend protocol through its own means. Implementations MAY infer the
// protocol from the Route type referring to the backend Service.
//
// If a Route is not able to send traffic to the backend using the specified
// protocol then the backend is considered invalid. Implementations MUST set the
// "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.
//
// </gateway:experimental:description>
type HTTPRouteSpecRulesBackendRefsOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefs)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsOutput) ToHTTPRouteSpecRulesBackendRefsOutput() HTTPRouteSpecRulesBackendRefsOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsOutput) ToHTTPRouteSpecRulesBackendRefsOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsOutput {
	return o
}

// Filters defined at this level should be executed if and only if the
// request is being forwarded to the backend defined here.
//
// Support: Implementation-specific (For broader support of filters, use the
// Filters field in HTTPRouteRule.)
func (o HTTPRouteSpecRulesBackendRefsOutput) Filters() HTTPRouteSpecRulesBackendRefsFiltersArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefs) []HTTPRouteSpecRulesBackendRefsFilters { return v.Filters }).(HTTPRouteSpecRulesBackendRefsFiltersArrayOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o HTTPRouteSpecRulesBackendRefsOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefs) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is the Kubernetes resource kind of the referent. For example
// "Service".
//
// Defaults to "Service" when not specified.
//
// ExternalName services can refer to CNAME DNS records that may live
// outside of the cluster and as such are difficult to reason about in
// terms of conformance. They also may not be safe to forward to (see
// CVE-2021-25740 for more information). Implementations SHOULD NOT
// support ExternalName Services.
//
// Support: Core (Services with a type other than ExternalName)
//
// Support: Implementation-specific (Services with type ExternalName)
func (o HTTPRouteSpecRulesBackendRefsOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefs) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o HTTPRouteSpecRulesBackendRefsOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefs) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the backend. When unspecified, the local
// namespace is inferred.
//
// Note that when a namespace different than the local namespace is specified,
// a ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// Support: Core
func (o HTTPRouteSpecRulesBackendRefsOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefs) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Port specifies the destination port number to use for this resource.
// Port is required when the referent is a Kubernetes Service. In this
// case, the port number is the service port number, not the target port.
// For other resources, destination port might be derived from the referent
// resource or this field.
func (o HTTPRouteSpecRulesBackendRefsOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefs) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// Weight specifies the proportion of requests forwarded to the referenced
// backend. This is computed as weight/(sum of all weights in this
// BackendRefs list). For non-zero values, there may be some epsilon from
// the exact proportion defined here depending on the precision an
// implementation supports. Weight is not a percentage and the sum of
// weights does not need to equal 100.
//
// If only one backend is specified and it has a weight greater than 0, 100%
// of the traffic is forwarded to that backend. If weight is set to 0, no
// traffic should be forwarded for this entry. If unspecified, weight
// defaults to 1.
//
// Support for this field varies based on the context where used.
func (o HTTPRouteSpecRulesBackendRefsOutput) Weight() pulumi.IntPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefs) *int { return v.Weight }).(pulumi.IntPtrOutput)
}

type HTTPRouteSpecRulesBackendRefsArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesBackendRefs)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsArrayOutput) ToHTTPRouteSpecRulesBackendRefsArrayOutput() HTTPRouteSpecRulesBackendRefsArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsArrayOutput) ToHTTPRouteSpecRulesBackendRefsArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsArrayOutput) Index(i pulumi.IntInput) HTTPRouteSpecRulesBackendRefsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteSpecRulesBackendRefs {
		return vs[0].([]HTTPRouteSpecRulesBackendRefs)[vs[1].(int)]
	}).(HTTPRouteSpecRulesBackendRefsOutput)
}

// HTTPRouteFilter defines processing steps that must be completed during the
// request or response lifecycle. HTTPRouteFilters are meant as an extension
// point to express processing that may be done in Gateway implementations. Some
// examples include request or response modification, implementing
// authentication strategies, rate-limiting, and traffic shaping. API
// guarantee/conformance is defined based on the type of the filter.
type HTTPRouteSpecRulesBackendRefsFilters struct {
	ExtensionRef           *HTTPRouteSpecRulesBackendRefsFiltersExtensionRef           `pulumi:"extensionRef"`
	RequestHeaderModifier  *HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifier  `pulumi:"requestHeaderModifier"`
	RequestMirror          *HTTPRouteSpecRulesBackendRefsFiltersRequestMirror          `pulumi:"requestMirror"`
	RequestRedirect        *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect        `pulumi:"requestRedirect"`
	ResponseHeaderModifier *HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifier `pulumi:"responseHeaderModifier"`
	// Type identifies the type of filter to apply. As with other API fields,
	// types are classified into three conformance levels:
	//
	// - Core: Filter types and their corresponding configuration defined by
	// "Support: Core" in this package, e.g. "RequestHeaderModifier". All
	// implementations must support core filters.
	//
	// - Extended: Filter types and their corresponding configuration defined by
	// "Support: Extended" in this package, e.g. "RequestMirror". Implementers
	// are encouraged to support extended filters.
	//
	// - Implementation-specific: Filters that are defined and supported by
	// specific vendors.
	// In the future, filters showing convergence in behavior across multiple
	// implementations will be considered for inclusion in extended or core
	// conformance levels. Filter-specific configuration for such filters
	// is specified using the ExtensionRef field. `Type` should be set to
	// "ExtensionRef" for custom filters.
	//
	// Implementers are encouraged to define custom implementation types to
	// extend the core API with implementation-specific behavior.
	//
	// If a reference to a custom filter type cannot be resolved, the filter
	// MUST NOT be skipped. Instead, requests that would have been processed by
	// that filter MUST receive a HTTP error response.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	Type       *string                                         `pulumi:"type"`
	UrlRewrite *HTTPRouteSpecRulesBackendRefsFiltersUrlRewrite `pulumi:"urlRewrite"`
}

// HTTPRouteSpecRulesBackendRefsFiltersInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersArgs and HTTPRouteSpecRulesBackendRefsFiltersOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersArgs{...}
type HTTPRouteSpecRulesBackendRefsFiltersInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersOutput() HTTPRouteSpecRulesBackendRefsFiltersOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersOutput
}

// HTTPRouteFilter defines processing steps that must be completed during the
// request or response lifecycle. HTTPRouteFilters are meant as an extension
// point to express processing that may be done in Gateway implementations. Some
// examples include request or response modification, implementing
// authentication strategies, rate-limiting, and traffic shaping. API
// guarantee/conformance is defined based on the type of the filter.
type HTTPRouteSpecRulesBackendRefsFiltersArgs struct {
	ExtensionRef           HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrInput           `pulumi:"extensionRef"`
	RequestHeaderModifier  HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrInput  `pulumi:"requestHeaderModifier"`
	RequestMirror          HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrInput          `pulumi:"requestMirror"`
	RequestRedirect        HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrInput        `pulumi:"requestRedirect"`
	ResponseHeaderModifier HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrInput `pulumi:"responseHeaderModifier"`
	// Type identifies the type of filter to apply. As with other API fields,
	// types are classified into three conformance levels:
	//
	// - Core: Filter types and their corresponding configuration defined by
	// "Support: Core" in this package, e.g. "RequestHeaderModifier". All
	// implementations must support core filters.
	//
	// - Extended: Filter types and their corresponding configuration defined by
	// "Support: Extended" in this package, e.g. "RequestMirror". Implementers
	// are encouraged to support extended filters.
	//
	// - Implementation-specific: Filters that are defined and supported by
	// specific vendors.
	// In the future, filters showing convergence in behavior across multiple
	// implementations will be considered for inclusion in extended or core
	// conformance levels. Filter-specific configuration for such filters
	// is specified using the ExtensionRef field. `Type` should be set to
	// "ExtensionRef" for custom filters.
	//
	// Implementers are encouraged to define custom implementation types to
	// extend the core API with implementation-specific behavior.
	//
	// If a reference to a custom filter type cannot be resolved, the filter
	// MUST NOT be skipped. Instead, requests that would have been processed by
	// that filter MUST receive a HTTP error response.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	Type       pulumi.StringPtrInput                                  `pulumi:"type"`
	UrlRewrite HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrInput `pulumi:"urlRewrite"`
}

func (HTTPRouteSpecRulesBackendRefsFiltersArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFilters)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersArgs) ToHTTPRouteSpecRulesBackendRefsFiltersOutput() HTTPRouteSpecRulesBackendRefsFiltersOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersArgs) ToHTTPRouteSpecRulesBackendRefsFiltersOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersOutput)
}

// HTTPRouteSpecRulesBackendRefsFiltersArrayInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersArray and HTTPRouteSpecRulesBackendRefsFiltersArrayOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersArrayInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersArray{ HTTPRouteSpecRulesBackendRefsFiltersArgs{...} }
type HTTPRouteSpecRulesBackendRefsFiltersArrayInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersArrayOutput() HTTPRouteSpecRulesBackendRefsFiltersArrayOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersArrayOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersArrayOutput
}

type HTTPRouteSpecRulesBackendRefsFiltersArray []HTTPRouteSpecRulesBackendRefsFiltersInput

func (HTTPRouteSpecRulesBackendRefsFiltersArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesBackendRefsFilters)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersArray) ToHTTPRouteSpecRulesBackendRefsFiltersArrayOutput() HTTPRouteSpecRulesBackendRefsFiltersArrayOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersArrayOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersArray) ToHTTPRouteSpecRulesBackendRefsFiltersArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersArrayOutput)
}

// HTTPRouteFilter defines processing steps that must be completed during the
// request or response lifecycle. HTTPRouteFilters are meant as an extension
// point to express processing that may be done in Gateway implementations. Some
// examples include request or response modification, implementing
// authentication strategies, rate-limiting, and traffic shaping. API
// guarantee/conformance is defined based on the type of the filter.
type HTTPRouteSpecRulesBackendRefsFiltersOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFilters)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersOutput) ToHTTPRouteSpecRulesBackendRefsFiltersOutput() HTTPRouteSpecRulesBackendRefsFiltersOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersOutput) ToHTTPRouteSpecRulesBackendRefsFiltersOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersOutput) ExtensionRef() HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFilters) *HTTPRouteSpecRulesBackendRefsFiltersExtensionRef {
		return v.ExtensionRef
	}).(HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput)
}

func (o HTTPRouteSpecRulesBackendRefsFiltersOutput) RequestHeaderModifier() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFilters) *HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifier {
		return v.RequestHeaderModifier
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput)
}

func (o HTTPRouteSpecRulesBackendRefsFiltersOutput) RequestMirror() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFilters) *HTTPRouteSpecRulesBackendRefsFiltersRequestMirror {
		return v.RequestMirror
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput)
}

func (o HTTPRouteSpecRulesBackendRefsFiltersOutput) RequestRedirect() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFilters) *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect {
		return v.RequestRedirect
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput)
}

func (o HTTPRouteSpecRulesBackendRefsFiltersOutput) ResponseHeaderModifier() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFilters) *HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifier {
		return v.ResponseHeaderModifier
	}).(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput)
}

// Type identifies the type of filter to apply. As with other API fields,
// types are classified into three conformance levels:
//
// - Core: Filter types and their corresponding configuration defined by
// "Support: Core" in this package, e.g. "RequestHeaderModifier". All
// implementations must support core filters.
//
// - Extended: Filter types and their corresponding configuration defined by
// "Support: Extended" in this package, e.g. "RequestMirror". Implementers
// are encouraged to support extended filters.
//
// - Implementation-specific: Filters that are defined and supported by
// specific vendors.
// In the future, filters showing convergence in behavior across multiple
// implementations will be considered for inclusion in extended or core
// conformance levels. Filter-specific configuration for such filters
// is specified using the ExtensionRef field. `Type` should be set to
// "ExtensionRef" for custom filters.
//
// Implementers are encouraged to define custom implementation types to
// extend the core API with implementation-specific behavior.
//
// If a reference to a custom filter type cannot be resolved, the filter
// MUST NOT be skipped. Instead, requests that would have been processed by
// that filter MUST receive a HTTP error response.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
func (o HTTPRouteSpecRulesBackendRefsFiltersOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFilters) *string { return v.Type }).(pulumi.StringPtrOutput)
}

func (o HTTPRouteSpecRulesBackendRefsFiltersOutput) UrlRewrite() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFilters) *HTTPRouteSpecRulesBackendRefsFiltersUrlRewrite {
		return v.UrlRewrite
	}).(HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput)
}

type HTTPRouteSpecRulesBackendRefsFiltersArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesBackendRefsFilters)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersArrayOutput) ToHTTPRouteSpecRulesBackendRefsFiltersArrayOutput() HTTPRouteSpecRulesBackendRefsFiltersArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersArrayOutput) ToHTTPRouteSpecRulesBackendRefsFiltersArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersArrayOutput) Index(i pulumi.IntInput) HTTPRouteSpecRulesBackendRefsFiltersOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteSpecRulesBackendRefsFilters {
		return vs[0].([]HTTPRouteSpecRulesBackendRefsFilters)[vs[1].(int)]
	}).(HTTPRouteSpecRulesBackendRefsFiltersOutput)
}

// ExtensionRef is an optional, implementation-specific extension to the
// "filter" behavior.  For example, resource "myroutefilter" in group
// "networking.example.net"). ExtensionRef MUST NOT be used for core and
// extended filters.
//
// This filter can be used multiple times within the same rule.
//
// Support: Implementation-specific
type HTTPRouteSpecRulesBackendRefsFiltersExtensionRef struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group *string `pulumi:"group"`
	// Kind is kind of the referent. For example "HTTPRoute" or "Service".
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	Name *string `pulumi:"name"`
}

// HTTPRouteSpecRulesBackendRefsFiltersExtensionRefInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersExtensionRefArgs and HTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersExtensionRefInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersExtensionRefArgs{...}
type HTTPRouteSpecRulesBackendRefsFiltersExtensionRefInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutput() HTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutput
}

// ExtensionRef is an optional, implementation-specific extension to the
// "filter" behavior.  For example, resource "myroutefilter" in group
// "networking.example.net"). ExtensionRef MUST NOT be used for core and
// extended filters.
//
// This filter can be used multiple times within the same rule.
//
// Support: Implementation-specific
type HTTPRouteSpecRulesBackendRefsFiltersExtensionRefArgs struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is kind of the referent. For example "HTTPRoute" or "Service".
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (HTTPRouteSpecRulesBackendRefsFiltersExtensionRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersExtensionRef)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersExtensionRefArgs) ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutput() HTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersExtensionRefArgs) ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutput)
}

func (i HTTPRouteSpecRulesBackendRefsFiltersExtensionRefArgs) ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersExtensionRefArgs) ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutput).ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersExtensionRefArgs, HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtr and HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrInput` via:
//
//	        HTTPRouteSpecRulesBackendRefsFiltersExtensionRefArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput
}

type httprouteSpecRulesBackendRefsFiltersExtensionRefPtrType HTTPRouteSpecRulesBackendRefsFiltersExtensionRefArgs

func HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtr(v *HTTPRouteSpecRulesBackendRefsFiltersExtensionRefArgs) HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrInput {
	return (*httprouteSpecRulesBackendRefsFiltersExtensionRefPtrType)(v)
}

func (*httprouteSpecRulesBackendRefsFiltersExtensionRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersExtensionRef)(nil)).Elem()
}

func (i *httprouteSpecRulesBackendRefsFiltersExtensionRefPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesBackendRefsFiltersExtensionRefPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput)
}

// ExtensionRef is an optional, implementation-specific extension to the
// "filter" behavior.  For example, resource "myroutefilter" in group
// "networking.example.net"). ExtensionRef MUST NOT be used for core and
// extended filters.
//
// This filter can be used multiple times within the same rule.
//
// Support: Implementation-specific
type HTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersExtensionRef)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutput) ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutput() HTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutput) ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutput) ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput {
	return o.ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutput) ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesBackendRefsFiltersExtensionRef) *HTTPRouteSpecRulesBackendRefsFiltersExtensionRef {
		return &v
	}).(HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o HTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersExtensionRef) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent. For example "HTTPRoute" or "Service".
func (o HTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersExtensionRef) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o HTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersExtensionRef) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersExtensionRef)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput) Elem() HTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersExtensionRef) HTTPRouteSpecRulesBackendRefsFiltersExtensionRef {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesBackendRefsFiltersExtensionRef
		return ret
	}).(HTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersExtensionRef) *string {
		if v == nil {
			return nil
		}
		return v.Group
	}).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent. For example "HTTPRoute" or "Service".
func (o HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersExtensionRef) *string {
		if v == nil {
			return nil
		}
		return v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersExtensionRef) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// ExtensionRef is an optional, implementation-specific extension to the
// "filter" behavior.  For example, resource "myroutefilter" in group
// "networking.example.net"). ExtensionRef MUST NOT be used for core and
// extended filters.
//
// This filter can be used multiple times within the same rule.
//
// Support: Implementation-specific
type HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatch struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group *string `pulumi:"group"`
	// Kind is kind of the referent. For example "HTTPRoute" or "Service".
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	Name *string `pulumi:"name"`
}

// HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchArgs and HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchArgs{...}
type HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutput() HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutput
}

// ExtensionRef is an optional, implementation-specific extension to the
// "filter" behavior.  For example, resource "myroutefilter" in group
// "networking.example.net"). ExtensionRef MUST NOT be used for core and
// extended filters.
//
// This filter can be used multiple times within the same rule.
//
// Support: Implementation-specific
type HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchArgs struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is kind of the referent. For example "HTTPRoute" or "Service".
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutput() HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutput)
}

func (i HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutput).ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchArgs, HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtr and HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrInput` via:
//
//	        HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput
}

type httprouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrType HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchArgs

func HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtr(v *HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchArgs) HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrInput {
	return (*httprouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrType)(v)
}

func (*httprouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatch)(nil)).Elem()
}

func (i *httprouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput)
}

// ExtensionRef is an optional, implementation-specific extension to the
// "filter" behavior.  For example, resource "myroutefilter" in group
// "networking.example.net"). ExtensionRef MUST NOT be used for core and
// extended filters.
//
// This filter can be used multiple times within the same rule.
//
// Support: Implementation-specific
type HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutput() HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput {
	return o.ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatch) *HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatch {
		return &v
	}).(HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatch) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent. For example "HTTPRoute" or "Service".
func (o HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatch) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput) Elem() HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatch) HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatch {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatch
		return ret
	}).(HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Group
	}).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent. For example "HTTPRoute" or "Service".
func (o HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// HTTPRouteFilter defines processing steps that must be completed during the
// request or response lifecycle. HTTPRouteFilters are meant as an extension
// point to express processing that may be done in Gateway implementations. Some
// examples include request or response modification, implementing
// authentication strategies, rate-limiting, and traffic shaping. API
// guarantee/conformance is defined based on the type of the filter.
type HTTPRouteSpecRulesBackendRefsFiltersPatch struct {
	ExtensionRef           *HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatch           `pulumi:"extensionRef"`
	RequestHeaderModifier  *HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatch  `pulumi:"requestHeaderModifier"`
	RequestMirror          *HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatch          `pulumi:"requestMirror"`
	RequestRedirect        *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatch        `pulumi:"requestRedirect"`
	ResponseHeaderModifier *HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatch `pulumi:"responseHeaderModifier"`
	// Type identifies the type of filter to apply. As with other API fields,
	// types are classified into three conformance levels:
	//
	// - Core: Filter types and their corresponding configuration defined by
	// "Support: Core" in this package, e.g. "RequestHeaderModifier". All
	// implementations must support core filters.
	//
	// - Extended: Filter types and their corresponding configuration defined by
	// "Support: Extended" in this package, e.g. "RequestMirror". Implementers
	// are encouraged to support extended filters.
	//
	// - Implementation-specific: Filters that are defined and supported by
	// specific vendors.
	// In the future, filters showing convergence in behavior across multiple
	// implementations will be considered for inclusion in extended or core
	// conformance levels. Filter-specific configuration for such filters
	// is specified using the ExtensionRef field. `Type` should be set to
	// "ExtensionRef" for custom filters.
	//
	// Implementers are encouraged to define custom implementation types to
	// extend the core API with implementation-specific behavior.
	//
	// If a reference to a custom filter type cannot be resolved, the filter
	// MUST NOT be skipped. Instead, requests that would have been processed by
	// that filter MUST receive a HTTP error response.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	Type       *string                                              `pulumi:"type"`
	UrlRewrite *HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatch `pulumi:"urlRewrite"`
}

// HTTPRouteSpecRulesBackendRefsFiltersPatchInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersPatchArgs and HTTPRouteSpecRulesBackendRefsFiltersPatchOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersPatchInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersPatchArgs{...}
type HTTPRouteSpecRulesBackendRefsFiltersPatchInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersPatchOutput() HTTPRouteSpecRulesBackendRefsFiltersPatchOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersPatchOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersPatchOutput
}

// HTTPRouteFilter defines processing steps that must be completed during the
// request or response lifecycle. HTTPRouteFilters are meant as an extension
// point to express processing that may be done in Gateway implementations. Some
// examples include request or response modification, implementing
// authentication strategies, rate-limiting, and traffic shaping. API
// guarantee/conformance is defined based on the type of the filter.
type HTTPRouteSpecRulesBackendRefsFiltersPatchArgs struct {
	ExtensionRef           HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrInput           `pulumi:"extensionRef"`
	RequestHeaderModifier  HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrInput  `pulumi:"requestHeaderModifier"`
	RequestMirror          HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrInput          `pulumi:"requestMirror"`
	RequestRedirect        HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrInput        `pulumi:"requestRedirect"`
	ResponseHeaderModifier HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrInput `pulumi:"responseHeaderModifier"`
	// Type identifies the type of filter to apply. As with other API fields,
	// types are classified into three conformance levels:
	//
	// - Core: Filter types and their corresponding configuration defined by
	// "Support: Core" in this package, e.g. "RequestHeaderModifier". All
	// implementations must support core filters.
	//
	// - Extended: Filter types and their corresponding configuration defined by
	// "Support: Extended" in this package, e.g. "RequestMirror". Implementers
	// are encouraged to support extended filters.
	//
	// - Implementation-specific: Filters that are defined and supported by
	// specific vendors.
	// In the future, filters showing convergence in behavior across multiple
	// implementations will be considered for inclusion in extended or core
	// conformance levels. Filter-specific configuration for such filters
	// is specified using the ExtensionRef field. `Type` should be set to
	// "ExtensionRef" for custom filters.
	//
	// Implementers are encouraged to define custom implementation types to
	// extend the core API with implementation-specific behavior.
	//
	// If a reference to a custom filter type cannot be resolved, the filter
	// MUST NOT be skipped. Instead, requests that would have been processed by
	// that filter MUST receive a HTTP error response.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	Type       pulumi.StringPtrInput                                       `pulumi:"type"`
	UrlRewrite HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrInput `pulumi:"urlRewrite"`
}

func (HTTPRouteSpecRulesBackendRefsFiltersPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersPatchOutput() HTTPRouteSpecRulesBackendRefsFiltersPatchOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersPatchOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersPatchOutput)
}

// HTTPRouteSpecRulesBackendRefsFiltersPatchArrayInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersPatchArray and HTTPRouteSpecRulesBackendRefsFiltersPatchArrayOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersPatchArrayInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersPatchArray{ HTTPRouteSpecRulesBackendRefsFiltersPatchArgs{...} }
type HTTPRouteSpecRulesBackendRefsFiltersPatchArrayInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersPatchArrayOutput() HTTPRouteSpecRulesBackendRefsFiltersPatchArrayOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersPatchArrayOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersPatchArrayOutput
}

type HTTPRouteSpecRulesBackendRefsFiltersPatchArray []HTTPRouteSpecRulesBackendRefsFiltersPatchInput

func (HTTPRouteSpecRulesBackendRefsFiltersPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesBackendRefsFiltersPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersPatchArray) ToHTTPRouteSpecRulesBackendRefsFiltersPatchArrayOutput() HTTPRouteSpecRulesBackendRefsFiltersPatchArrayOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersPatchArrayOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersPatchArray) ToHTTPRouteSpecRulesBackendRefsFiltersPatchArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersPatchArrayOutput)
}

// HTTPRouteFilter defines processing steps that must be completed during the
// request or response lifecycle. HTTPRouteFilters are meant as an extension
// point to express processing that may be done in Gateway implementations. Some
// examples include request or response modification, implementing
// authentication strategies, rate-limiting, and traffic shaping. API
// guarantee/conformance is defined based on the type of the filter.
type HTTPRouteSpecRulesBackendRefsFiltersPatchOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersPatchOutput() HTTPRouteSpecRulesBackendRefsFiltersPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersPatchOutput) ExtensionRef() HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersPatch) *HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatch {
		return v.ExtensionRef
	}).(HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput)
}

func (o HTTPRouteSpecRulesBackendRefsFiltersPatchOutput) RequestHeaderModifier() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersPatch) *HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatch {
		return v.RequestHeaderModifier
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput)
}

func (o HTTPRouteSpecRulesBackendRefsFiltersPatchOutput) RequestMirror() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersPatch) *HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatch {
		return v.RequestMirror
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput)
}

func (o HTTPRouteSpecRulesBackendRefsFiltersPatchOutput) RequestRedirect() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersPatch) *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatch {
		return v.RequestRedirect
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrOutput)
}

func (o HTTPRouteSpecRulesBackendRefsFiltersPatchOutput) ResponseHeaderModifier() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersPatch) *HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatch {
		return v.ResponseHeaderModifier
	}).(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput)
}

// Type identifies the type of filter to apply. As with other API fields,
// types are classified into three conformance levels:
//
// - Core: Filter types and their corresponding configuration defined by
// "Support: Core" in this package, e.g. "RequestHeaderModifier". All
// implementations must support core filters.
//
// - Extended: Filter types and their corresponding configuration defined by
// "Support: Extended" in this package, e.g. "RequestMirror". Implementers
// are encouraged to support extended filters.
//
// - Implementation-specific: Filters that are defined and supported by
// specific vendors.
// In the future, filters showing convergence in behavior across multiple
// implementations will be considered for inclusion in extended or core
// conformance levels. Filter-specific configuration for such filters
// is specified using the ExtensionRef field. `Type` should be set to
// "ExtensionRef" for custom filters.
//
// Implementers are encouraged to define custom implementation types to
// extend the core API with implementation-specific behavior.
//
// If a reference to a custom filter type cannot be resolved, the filter
// MUST NOT be skipped. Instead, requests that would have been processed by
// that filter MUST receive a HTTP error response.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
func (o HTTPRouteSpecRulesBackendRefsFiltersPatchOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersPatch) *string { return v.Type }).(pulumi.StringPtrOutput)
}

func (o HTTPRouteSpecRulesBackendRefsFiltersPatchOutput) UrlRewrite() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersPatch) *HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatch {
		return v.UrlRewrite
	}).(HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrOutput)
}

type HTTPRouteSpecRulesBackendRefsFiltersPatchArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesBackendRefsFiltersPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersPatchArrayOutput) ToHTTPRouteSpecRulesBackendRefsFiltersPatchArrayOutput() HTTPRouteSpecRulesBackendRefsFiltersPatchArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersPatchArrayOutput) ToHTTPRouteSpecRulesBackendRefsFiltersPatchArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersPatchArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersPatchArrayOutput) Index(i pulumi.IntInput) HTTPRouteSpecRulesBackendRefsFiltersPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteSpecRulesBackendRefsFiltersPatch {
		return vs[0].([]HTTPRouteSpecRulesBackendRefsFiltersPatch)[vs[1].(int)]
	}).(HTTPRouteSpecRulesBackendRefsFiltersPatchOutput)
}

// RequestHeaderModifier defines a schema for a filter that modifies request
// headers.
//
// Support: Core
type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifier struct {
	// Add adds the given header(s) (name, value) to the request
	// before the action. It appends to any existing values associated
	// with the header name.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   add:
	//   - name: "my-header"
	//     value: "bar,baz"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: foo,bar,baz
	Add []HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd `pulumi:"add"`
	// Remove the given header(s) from the HTTP request before the action. The
	// value of Remove is a list of HTTP header names. Note that the header
	// names are case-insensitive (see
	// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header1: foo
	//   my-header2: bar
	//   my-header3: baz
	//
	// Config:
	//   remove: ["my-header1", "my-header3"]
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header2: bar
	Remove []string `pulumi:"remove"`
	// Set overwrites the request with the given header (name, value)
	// before the action.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   set:
	//   - name: "my-header"
	//     value: "bar"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: bar
	Set []HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet `pulumi:"set"`
}

// HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs and HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs{...}
type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput
}

// RequestHeaderModifier defines a schema for a filter that modifies request
// headers.
//
// Support: Core
type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs struct {
	// Add adds the given header(s) (name, value) to the request
	// before the action. It appends to any existing values associated
	// with the header name.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   add:
	//   - name: "my-header"
	//     value: "bar,baz"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: foo,bar,baz
	Add HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayInput `pulumi:"add"`
	// Remove the given header(s) from the HTTP request before the action. The
	// value of Remove is a list of HTTP header names. Note that the header
	// names are case-insensitive (see
	// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header1: foo
	//   my-header2: bar
	//   my-header3: baz
	//
	// Config:
	//   remove: ["my-header1", "my-header3"]
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header2: bar
	Remove pulumi.StringArrayInput `pulumi:"remove"`
	// Set overwrites the request with the given header (name, value)
	// before the action.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   set:
	//   - name: "my-header"
	//     value: "bar"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: bar
	Set HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayInput `pulumi:"set"`
}

func (HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifier)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput)
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput).ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs, HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtr and HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrInput` via:
//
//	        HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput
}

type httprouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrType HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs

func HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtr(v *HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrInput {
	return (*httprouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrType)(v)
}

func (*httprouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifier)(nil)).Elem()
}

func (i *httprouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput)
}

// RequestHeaderModifier defines a schema for a filter that modifies request
// headers.
//
// Support: Core
type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifier)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput {
	return o.ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifier) *HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifier {
		return &v
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput)
}

// Add adds the given header(s) (name, value) to the request
// before the action. It appends to any existing values associated
// with the header name.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	add:
//	- name: "my-header"
//	  value: "bar,baz"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: foo,bar,baz
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput) Add() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifier) []HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd {
		return v.Add
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput)
}

// Remove the given header(s) from the HTTP request before the action. The
// value of Remove is a list of HTTP header names. Note that the header
// names are case-insensitive (see
// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header1: foo
//	my-header2: bar
//	my-header3: baz
//
// Config:
//
//	remove: ["my-header1", "my-header3"]
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header2: bar
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput) Remove() pulumi.StringArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifier) []string { return v.Remove }).(pulumi.StringArrayOutput)
}

// Set overwrites the request with the given header (name, value)
// before the action.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	set:
//	- name: "my-header"
//	  value: "bar"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: bar
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput) Set() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifier) []HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet {
		return v.Set
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput)
}

type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifier)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput) Elem() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifier) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifier {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifier
		return ret
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput)
}

// Add adds the given header(s) (name, value) to the request
// before the action. It appends to any existing values associated
// with the header name.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	add:
//	- name: "my-header"
//	  value: "bar,baz"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: foo,bar,baz
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput) Add() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifier) []HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd {
		if v == nil {
			return nil
		}
		return v.Add
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput)
}

// Remove the given header(s) from the HTTP request before the action. The
// value of Remove is a list of HTTP header names. Note that the header
// names are case-insensitive (see
// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header1: foo
//	my-header2: bar
//	my-header3: baz
//
// Config:
//
//	remove: ["my-header1", "my-header3"]
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header2: bar
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput) Remove() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifier) []string {
		if v == nil {
			return nil
		}
		return v.Remove
	}).(pulumi.StringArrayOutput)
}

// Set overwrites the request with the given header (name, value)
// before the action.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	set:
//	- name: "my-header"
//	  value: "bar"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: bar
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput) Set() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifier) []HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet {
		if v == nil {
			return nil
		}
		return v.Set
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name *string `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value *string `pulumi:"value"`
}

// HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArgs and HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArgs{...}
type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArgs struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput)
}

// HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArray and HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArray{ HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArgs{...} }
type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput
}

type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArray []HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddInput

func (HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArray) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArray) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput {
	return o
}

// Name is the name of the HTTP Header to be matched. Name matching MUST be
// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
//
// If multiple entries specify equivalent header names, the first entry with
// an equivalent name MUST be considered for a match. Subsequent entries
// with an equivalent header name MUST be ignored. Due to the
// case-insensitivity of header names, "foo" and "Foo" are considered
// equivalent.
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Value is the value of HTTP Header to be matched.
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput) Index(i pulumi.IntInput) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd {
		return vs[0].([]HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd)[vs[1].(int)]
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatch struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name *string `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value *string `pulumi:"value"`
}

// HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArgs and HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArgs{...}
type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchOutput
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArgs struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchOutput)
}

// HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArray and HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArray{ HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArgs{...} }
type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayOutput
}

type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArray []HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchInput

func (HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArray) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArray) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchOutput {
	return o
}

// Name is the name of the HTTP Header to be matched. Name matching MUST be
// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
//
// If multiple entries specify equivalent header names, the first entry with
// an equivalent name MUST be considered for a match. Subsequent entries
// with an equivalent header name MUST be ignored. Due to the
// case-insensitivity of header names, "foo" and "Foo" are considered
// equivalent.
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Value is the value of HTTP Header to be matched.
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatch) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayOutput) Index(i pulumi.IntInput) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatch {
		return vs[0].([]HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatch)[vs[1].(int)]
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchOutput)
}

// RequestHeaderModifier defines a schema for a filter that modifies request
// headers.
//
// Support: Core
type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatch struct {
	// Add adds the given header(s) (name, value) to the request
	// before the action. It appends to any existing values associated
	// with the header name.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   add:
	//   - name: "my-header"
	//     value: "bar,baz"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: foo,bar,baz
	Add []HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatch `pulumi:"add"`
	// Remove the given header(s) from the HTTP request before the action. The
	// value of Remove is a list of HTTP header names. Note that the header
	// names are case-insensitive (see
	// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header1: foo
	//   my-header2: bar
	//   my-header3: baz
	//
	// Config:
	//   remove: ["my-header1", "my-header3"]
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header2: bar
	Remove []string `pulumi:"remove"`
	// Set overwrites the request with the given header (name, value)
	// before the action.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   set:
	//   - name: "my-header"
	//     value: "bar"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: bar
	Set []HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatch `pulumi:"set"`
}

// HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchArgs and HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchArgs{...}
type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutput
}

// RequestHeaderModifier defines a schema for a filter that modifies request
// headers.
//
// Support: Core
type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchArgs struct {
	// Add adds the given header(s) (name, value) to the request
	// before the action. It appends to any existing values associated
	// with the header name.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   add:
	//   - name: "my-header"
	//     value: "bar,baz"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: foo,bar,baz
	Add HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayInput `pulumi:"add"`
	// Remove the given header(s) from the HTTP request before the action. The
	// value of Remove is a list of HTTP header names. Note that the header
	// names are case-insensitive (see
	// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header1: foo
	//   my-header2: bar
	//   my-header3: baz
	//
	// Config:
	//   remove: ["my-header1", "my-header3"]
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header2: bar
	Remove pulumi.StringArrayInput `pulumi:"remove"`
	// Set overwrites the request with the given header (name, value)
	// before the action.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   set:
	//   - name: "my-header"
	//     value: "bar"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: bar
	Set HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayInput `pulumi:"set"`
}

func (HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutput)
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutput).ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchArgs, HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtr and HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrInput` via:
//
//	        HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput
}

type httprouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrType HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchArgs

func HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtr(v *HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchArgs) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrInput {
	return (*httprouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrType)(v)
}

func (*httprouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatch)(nil)).Elem()
}

func (i *httprouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput)
}

// RequestHeaderModifier defines a schema for a filter that modifies request
// headers.
//
// Support: Core
type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput {
	return o.ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatch) *HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatch {
		return &v
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput)
}

// Add adds the given header(s) (name, value) to the request
// before the action. It appends to any existing values associated
// with the header name.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	add:
//	- name: "my-header"
//	  value: "bar,baz"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: foo,bar,baz
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutput) Add() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatch) []HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatch {
		return v.Add
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayOutput)
}

// Remove the given header(s) from the HTTP request before the action. The
// value of Remove is a list of HTTP header names. Note that the header
// names are case-insensitive (see
// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header1: foo
//	my-header2: bar
//	my-header3: baz
//
// Config:
//
//	remove: ["my-header1", "my-header3"]
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header2: bar
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutput) Remove() pulumi.StringArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatch) []string { return v.Remove }).(pulumi.StringArrayOutput)
}

// Set overwrites the request with the given header (name, value)
// before the action.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	set:
//	- name: "my-header"
//	  value: "bar"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: bar
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutput) Set() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatch) []HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatch {
		return v.Set
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayOutput)
}

type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput) Elem() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatch) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatch {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatch
		return ret
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutput)
}

// Add adds the given header(s) (name, value) to the request
// before the action. It appends to any existing values associated
// with the header name.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	add:
//	- name: "my-header"
//	  value: "bar,baz"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: foo,bar,baz
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput) Add() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatch) []HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatch {
		if v == nil {
			return nil
		}
		return v.Add
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayOutput)
}

// Remove the given header(s) from the HTTP request before the action. The
// value of Remove is a list of HTTP header names. Note that the header
// names are case-insensitive (see
// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header1: foo
//	my-header2: bar
//	my-header3: baz
//
// Config:
//
//	remove: ["my-header1", "my-header3"]
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header2: bar
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput) Remove() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatch) []string {
		if v == nil {
			return nil
		}
		return v.Remove
	}).(pulumi.StringArrayOutput)
}

// Set overwrites the request with the given header (name, value)
// before the action.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	set:
//	- name: "my-header"
//	  value: "bar"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: bar
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput) Set() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatch) []HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatch {
		if v == nil {
			return nil
		}
		return v.Set
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name *string `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value *string `pulumi:"value"`
}

// HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArgs and HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArgs{...}
type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArgs struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput)
}

// HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArray and HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArray{ HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArgs{...} }
type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput
}

type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArray []HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetInput

func (HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArray) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArray) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput {
	return o
}

// Name is the name of the HTTP Header to be matched. Name matching MUST be
// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
//
// If multiple entries specify equivalent header names, the first entry with
// an equivalent name MUST be considered for a match. Subsequent entries
// with an equivalent header name MUST be ignored. Due to the
// case-insensitivity of header names, "foo" and "Foo" are considered
// equivalent.
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Value is the value of HTTP Header to be matched.
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput) Index(i pulumi.IntInput) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet {
		return vs[0].([]HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet)[vs[1].(int)]
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatch struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name *string `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value *string `pulumi:"value"`
}

// HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArgs and HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArgs{...}
type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchOutput
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArgs struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchOutput)
}

// HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArray and HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArray{ HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArgs{...} }
type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayOutput
}

type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArray []HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchInput

func (HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArray) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArray) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchOutput {
	return o
}

// Name is the name of the HTTP Header to be matched. Name matching MUST be
// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
//
// If multiple entries specify equivalent header names, the first entry with
// an equivalent name MUST be considered for a match. Subsequent entries
// with an equivalent header name MUST be ignored. Due to the
// case-insensitivity of header names, "foo" and "Foo" are considered
// equivalent.
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Value is the value of HTTP Header to be matched.
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatch) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayOutput) Index(i pulumi.IntInput) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatch {
		return vs[0].([]HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatch)[vs[1].(int)]
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchOutput)
}

// RequestMirror defines a schema for a filter that mirrors requests.
// Requests are sent to the specified destination, but responses from
// that destination are ignored.
//
// This filter can be used multiple times within the same rule. Note that
// not all implementations will be able to support mirroring to multiple
// backends.
//
// Support: Extended
type HTTPRouteSpecRulesBackendRefsFiltersRequestMirror struct {
	BackendRef *HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef `pulumi:"backendRef"`
}

// HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorArgs and HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorArgs{...}
type HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorOutput
}

// RequestMirror defines a schema for a filter that mirrors requests.
// Requests are sent to the specified destination, but responses from
// that destination are ignored.
//
// This filter can be used multiple times within the same rule. Note that
// not all implementations will be able to support mirroring to multiple
// backends.
//
// Support: Extended
type HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorArgs struct {
	BackendRef HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrInput `pulumi:"backendRef"`
}

func (HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestMirror)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorOutput)
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorOutput).ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorArgs, HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtr and HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrInput` via:
//
//	        HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput
}

type httprouteSpecRulesBackendRefsFiltersRequestMirrorPtrType HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorArgs

func HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtr(v *HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorArgs) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrInput {
	return (*httprouteSpecRulesBackendRefsFiltersRequestMirrorPtrType)(v)
}

func (*httprouteSpecRulesBackendRefsFiltersRequestMirrorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersRequestMirror)(nil)).Elem()
}

func (i *httprouteSpecRulesBackendRefsFiltersRequestMirrorPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesBackendRefsFiltersRequestMirrorPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput)
}

// RequestMirror defines a schema for a filter that mirrors requests.
// Requests are sent to the specified destination, but responses from
// that destination are ignored.
//
// This filter can be used multiple times within the same rule. Note that
// not all implementations will be able to support mirroring to multiple
// backends.
//
// Support: Extended
type HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestMirror)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput {
	return o.ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesBackendRefsFiltersRequestMirror) *HTTPRouteSpecRulesBackendRefsFiltersRequestMirror {
		return &v
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput)
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorOutput) BackendRef() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestMirror) *HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef {
		return v.BackendRef
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput)
}

type HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersRequestMirror)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput) Elem() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestMirror) HTTPRouteSpecRulesBackendRefsFiltersRequestMirror {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesBackendRefsFiltersRequestMirror
		return ret
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorOutput)
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput) BackendRef() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestMirror) *HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef {
		if v == nil {
			return nil
		}
		return v.BackendRef
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput)
}

// BackendRef references a resource where mirrored requests are sent.
//
// Mirrored requests must be sent only to a single destination endpoint
// within this BackendRef, irrespective of how many endpoints are present
// within this BackendRef.
//
// If the referent cannot be found, this BackendRef is invalid and must be
// dropped from the Gateway. The controller must ensure the "ResolvedRefs"
// condition on the Route status is set to `status: False` and not configure
// this backend in the underlying implementation.
//
// If there is a cross-namespace reference to an *existing* object
// that is not allowed by a ReferenceGrant, the controller must ensure the
// "ResolvedRefs"  condition on the Route is set to `status: False`,
// with the "RefNotPermitted" reason and not configure this backend in the
// underlying implementation.
//
// In either error case, the Message of the `ResolvedRefs` Condition
// should be used to provide more detail about the problem.
//
// Support: Extended for Kubernetes Service
//
// Support: Implementation-specific for any other resource
type HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group *string `pulumi:"group"`
	// Kind is the Kubernetes resource kind of the referent. For example
	// "Service".
	//
	// Defaults to "Service" when not specified.
	//
	// ExternalName services can refer to CNAME DNS records that may live
	// outside of the cluster and as such are difficult to reason about in
	// terms of conformance. They also may not be safe to forward to (see
	// CVE-2021-25740 for more information). Implementations SHOULD NOT
	// support ExternalName Services.
	//
	// Support: Core (Services with a type other than ExternalName)
	//
	// Support: Implementation-specific (Services with type ExternalName)
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	Name *string `pulumi:"name"`
	// Namespace is the namespace of the backend. When unspecified, the local
	// namespace is inferred.
	//
	// Note that when a namespace different than the local namespace is specified,
	// a ReferenceGrant object is required in the referent namespace to allow that
	// namespace's owner to accept the reference. See the ReferenceGrant
	// documentation for details.
	//
	// Support: Core
	Namespace *string `pulumi:"namespace"`
	// Port specifies the destination port number to use for this resource.
	// Port is required when the referent is a Kubernetes Service. In this
	// case, the port number is the service port number, not the target port.
	// For other resources, destination port might be derived from the referent
	// resource or this field.
	Port *int `pulumi:"port"`
}

// HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs and HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs{...}
type HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput
}

// BackendRef references a resource where mirrored requests are sent.
//
// Mirrored requests must be sent only to a single destination endpoint
// within this BackendRef, irrespective of how many endpoints are present
// within this BackendRef.
//
// If the referent cannot be found, this BackendRef is invalid and must be
// dropped from the Gateway. The controller must ensure the "ResolvedRefs"
// condition on the Route status is set to `status: False` and not configure
// this backend in the underlying implementation.
//
// If there is a cross-namespace reference to an *existing* object
// that is not allowed by a ReferenceGrant, the controller must ensure the
// "ResolvedRefs"  condition on the Route is set to `status: False`,
// with the "RefNotPermitted" reason and not configure this backend in the
// underlying implementation.
//
// In either error case, the Message of the `ResolvedRefs` Condition
// should be used to provide more detail about the problem.
//
// Support: Extended for Kubernetes Service
//
// Support: Implementation-specific for any other resource
type HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is the Kubernetes resource kind of the referent. For example
	// "Service".
	//
	// Defaults to "Service" when not specified.
	//
	// ExternalName services can refer to CNAME DNS records that may live
	// outside of the cluster and as such are difficult to reason about in
	// terms of conformance. They also may not be safe to forward to (see
	// CVE-2021-25740 for more information). Implementations SHOULD NOT
	// support ExternalName Services.
	//
	// Support: Core (Services with a type other than ExternalName)
	//
	// Support: Implementation-specific (Services with type ExternalName)
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace is the namespace of the backend. When unspecified, the local
	// namespace is inferred.
	//
	// Note that when a namespace different than the local namespace is specified,
	// a ReferenceGrant object is required in the referent namespace to allow that
	// namespace's owner to accept the reference. See the ReferenceGrant
	// documentation for details.
	//
	// Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Port specifies the destination port number to use for this resource.
	// Port is required when the referent is a Kubernetes Service. In this
	// case, the port number is the service port number, not the target port.
	// For other resources, destination port might be derived from the referent
	// resource or this field.
	Port pulumi.IntPtrInput `pulumi:"port"`
}

func (HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput)
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput).ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs, HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtr and HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrInput` via:
//
//	        HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput
}

type httprouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrType HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs

func HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtr(v *HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrInput {
	return (*httprouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrType)(v)
}

func (*httprouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef)(nil)).Elem()
}

func (i *httprouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput)
}

// BackendRef references a resource where mirrored requests are sent.
//
// Mirrored requests must be sent only to a single destination endpoint
// within this BackendRef, irrespective of how many endpoints are present
// within this BackendRef.
//
// If the referent cannot be found, this BackendRef is invalid and must be
// dropped from the Gateway. The controller must ensure the "ResolvedRefs"
// condition on the Route status is set to `status: False` and not configure
// this backend in the underlying implementation.
//
// If there is a cross-namespace reference to an *existing* object
// that is not allowed by a ReferenceGrant, the controller must ensure the
// "ResolvedRefs"  condition on the Route is set to `status: False`,
// with the "RefNotPermitted" reason and not configure this backend in the
// underlying implementation.
//
// In either error case, the Message of the `ResolvedRefs` Condition
// should be used to provide more detail about the problem.
//
// Support: Extended for Kubernetes Service
//
// Support: Implementation-specific for any other resource
type HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput {
	return o.ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef) *HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef {
		return &v
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is the Kubernetes resource kind of the referent. For example
// "Service".
//
// Defaults to "Service" when not specified.
//
// ExternalName services can refer to CNAME DNS records that may live
// outside of the cluster and as such are difficult to reason about in
// terms of conformance. They also may not be safe to forward to (see
// CVE-2021-25740 for more information). Implementations SHOULD NOT
// support ExternalName Services.
//
// Support: Core (Services with a type other than ExternalName)
//
// Support: Implementation-specific (Services with type ExternalName)
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the backend. When unspecified, the local
// namespace is inferred.
//
// Note that when a namespace different than the local namespace is specified,
// a ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// Support: Core
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Port specifies the destination port number to use for this resource.
// Port is required when the referent is a Kubernetes Service. In this
// case, the port number is the service port number, not the target port.
// For other resources, destination port might be derived from the referent
// resource or this field.
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef) *int { return v.Port }).(pulumi.IntPtrOutput)
}

type HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput) Elem() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef
		return ret
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef) *string {
		if v == nil {
			return nil
		}
		return v.Group
	}).(pulumi.StringPtrOutput)
}

// Kind is the Kubernetes resource kind of the referent. For example
// "Service".
//
// Defaults to "Service" when not specified.
//
// ExternalName services can refer to CNAME DNS records that may live
// outside of the cluster and as such are difficult to reason about in
// terms of conformance. They also may not be safe to forward to (see
// CVE-2021-25740 for more information). Implementations SHOULD NOT
// support ExternalName Services.
//
// Support: Core (Services with a type other than ExternalName)
//
// Support: Implementation-specific (Services with type ExternalName)
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef) *string {
		if v == nil {
			return nil
		}
		return v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the backend. When unspecified, the local
// namespace is inferred.
//
// Note that when a namespace different than the local namespace is specified,
// a ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// Support: Core
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

// Port specifies the destination port number to use for this resource.
// Port is required when the referent is a Kubernetes Service. In this
// case, the port number is the service port number, not the target port.
// For other resources, destination port might be derived from the referent
// resource or this field.
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef) *int {
		if v == nil {
			return nil
		}
		return v.Port
	}).(pulumi.IntPtrOutput)
}

// BackendRef references a resource where mirrored requests are sent.
//
// Mirrored requests must be sent only to a single destination endpoint
// within this BackendRef, irrespective of how many endpoints are present
// within this BackendRef.
//
// If the referent cannot be found, this BackendRef is invalid and must be
// dropped from the Gateway. The controller must ensure the "ResolvedRefs"
// condition on the Route status is set to `status: False` and not configure
// this backend in the underlying implementation.
//
// If there is a cross-namespace reference to an *existing* object
// that is not allowed by a ReferenceGrant, the controller must ensure the
// "ResolvedRefs"  condition on the Route is set to `status: False`,
// with the "RefNotPermitted" reason and not configure this backend in the
// underlying implementation.
//
// In either error case, the Message of the `ResolvedRefs` Condition
// should be used to provide more detail about the problem.
//
// Support: Extended for Kubernetes Service
//
// Support: Implementation-specific for any other resource
type HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatch struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group *string `pulumi:"group"`
	// Kind is the Kubernetes resource kind of the referent. For example
	// "Service".
	//
	// Defaults to "Service" when not specified.
	//
	// ExternalName services can refer to CNAME DNS records that may live
	// outside of the cluster and as such are difficult to reason about in
	// terms of conformance. They also may not be safe to forward to (see
	// CVE-2021-25740 for more information). Implementations SHOULD NOT
	// support ExternalName Services.
	//
	// Support: Core (Services with a type other than ExternalName)
	//
	// Support: Implementation-specific (Services with type ExternalName)
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	Name *string `pulumi:"name"`
	// Namespace is the namespace of the backend. When unspecified, the local
	// namespace is inferred.
	//
	// Note that when a namespace different than the local namespace is specified,
	// a ReferenceGrant object is required in the referent namespace to allow that
	// namespace's owner to accept the reference. See the ReferenceGrant
	// documentation for details.
	//
	// Support: Core
	Namespace *string `pulumi:"namespace"`
	// Port specifies the destination port number to use for this resource.
	// Port is required when the referent is a Kubernetes Service. In this
	// case, the port number is the service port number, not the target port.
	// For other resources, destination port might be derived from the referent
	// resource or this field.
	Port *int `pulumi:"port"`
}

// HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchArgs and HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchArgs{...}
type HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutput
}

// BackendRef references a resource where mirrored requests are sent.
//
// Mirrored requests must be sent only to a single destination endpoint
// within this BackendRef, irrespective of how many endpoints are present
// within this BackendRef.
//
// If the referent cannot be found, this BackendRef is invalid and must be
// dropped from the Gateway. The controller must ensure the "ResolvedRefs"
// condition on the Route status is set to `status: False` and not configure
// this backend in the underlying implementation.
//
// If there is a cross-namespace reference to an *existing* object
// that is not allowed by a ReferenceGrant, the controller must ensure the
// "ResolvedRefs"  condition on the Route is set to `status: False`,
// with the "RefNotPermitted" reason and not configure this backend in the
// underlying implementation.
//
// In either error case, the Message of the `ResolvedRefs` Condition
// should be used to provide more detail about the problem.
//
// Support: Extended for Kubernetes Service
//
// Support: Implementation-specific for any other resource
type HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchArgs struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is the Kubernetes resource kind of the referent. For example
	// "Service".
	//
	// Defaults to "Service" when not specified.
	//
	// ExternalName services can refer to CNAME DNS records that may live
	// outside of the cluster and as such are difficult to reason about in
	// terms of conformance. They also may not be safe to forward to (see
	// CVE-2021-25740 for more information). Implementations SHOULD NOT
	// support ExternalName Services.
	//
	// Support: Core (Services with a type other than ExternalName)
	//
	// Support: Implementation-specific (Services with type ExternalName)
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace is the namespace of the backend. When unspecified, the local
	// namespace is inferred.
	//
	// Note that when a namespace different than the local namespace is specified,
	// a ReferenceGrant object is required in the referent namespace to allow that
	// namespace's owner to accept the reference. See the ReferenceGrant
	// documentation for details.
	//
	// Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Port specifies the destination port number to use for this resource.
	// Port is required when the referent is a Kubernetes Service. In this
	// case, the port number is the service port number, not the target port.
	// For other resources, destination port might be derived from the referent
	// resource or this field.
	Port pulumi.IntPtrInput `pulumi:"port"`
}

func (HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutput)
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutput).ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchArgs, HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtr and HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrInput` via:
//
//	        HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput
}

type httprouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrType HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchArgs

func HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtr(v *HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchArgs) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrInput {
	return (*httprouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrType)(v)
}

func (*httprouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatch)(nil)).Elem()
}

func (i *httprouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput)
}

// BackendRef references a resource where mirrored requests are sent.
//
// Mirrored requests must be sent only to a single destination endpoint
// within this BackendRef, irrespective of how many endpoints are present
// within this BackendRef.
//
// If the referent cannot be found, this BackendRef is invalid and must be
// dropped from the Gateway. The controller must ensure the "ResolvedRefs"
// condition on the Route status is set to `status: False` and not configure
// this backend in the underlying implementation.
//
// If there is a cross-namespace reference to an *existing* object
// that is not allowed by a ReferenceGrant, the controller must ensure the
// "ResolvedRefs"  condition on the Route is set to `status: False`,
// with the "RefNotPermitted" reason and not configure this backend in the
// underlying implementation.
//
// In either error case, the Message of the `ResolvedRefs` Condition
// should be used to provide more detail about the problem.
//
// Support: Extended for Kubernetes Service
//
// Support: Implementation-specific for any other resource
type HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput {
	return o.ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatch) *HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatch {
		return &v
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatch) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is the Kubernetes resource kind of the referent. For example
// "Service".
//
// Defaults to "Service" when not specified.
//
// ExternalName services can refer to CNAME DNS records that may live
// outside of the cluster and as such are difficult to reason about in
// terms of conformance. They also may not be safe to forward to (see
// CVE-2021-25740 for more information). Implementations SHOULD NOT
// support ExternalName Services.
//
// Support: Core (Services with a type other than ExternalName)
//
// Support: Implementation-specific (Services with type ExternalName)
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatch) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the backend. When unspecified, the local
// namespace is inferred.
//
// Note that when a namespace different than the local namespace is specified,
// a ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// Support: Core
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatch) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Port specifies the destination port number to use for this resource.
// Port is required when the referent is a Kubernetes Service. In this
// case, the port number is the service port number, not the target port.
// For other resources, destination port might be derived from the referent
// resource or this field.
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatch) *int { return v.Port }).(pulumi.IntPtrOutput)
}

type HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput) Elem() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatch) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatch {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatch
		return ret
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Group
	}).(pulumi.StringPtrOutput)
}

// Kind is the Kubernetes resource kind of the referent. For example
// "Service".
//
// Defaults to "Service" when not specified.
//
// ExternalName services can refer to CNAME DNS records that may live
// outside of the cluster and as such are difficult to reason about in
// terms of conformance. They also may not be safe to forward to (see
// CVE-2021-25740 for more information). Implementations SHOULD NOT
// support ExternalName Services.
//
// Support: Core (Services with a type other than ExternalName)
//
// Support: Implementation-specific (Services with type ExternalName)
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the backend. When unspecified, the local
// namespace is inferred.
//
// Note that when a namespace different than the local namespace is specified,
// a ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// Support: Core
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

// Port specifies the destination port number to use for this resource.
// Port is required when the referent is a Kubernetes Service. In this
// case, the port number is the service port number, not the target port.
// For other resources, destination port might be derived from the referent
// resource or this field.
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatch) *int {
		if v == nil {
			return nil
		}
		return v.Port
	}).(pulumi.IntPtrOutput)
}

// RequestMirror defines a schema for a filter that mirrors requests.
// Requests are sent to the specified destination, but responses from
// that destination are ignored.
//
// This filter can be used multiple times within the same rule. Note that
// not all implementations will be able to support mirroring to multiple
// backends.
//
// Support: Extended
type HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatch struct {
	BackendRef *HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatch `pulumi:"backendRef"`
}

// HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchArgs and HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchArgs{...}
type HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchOutput
}

// RequestMirror defines a schema for a filter that mirrors requests.
// Requests are sent to the specified destination, but responses from
// that destination are ignored.
//
// This filter can be used multiple times within the same rule. Note that
// not all implementations will be able to support mirroring to multiple
// backends.
//
// Support: Extended
type HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchArgs struct {
	BackendRef HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrInput `pulumi:"backendRef"`
}

func (HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchOutput)
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchOutput).ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchArgs, HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtr and HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrInput` via:
//
//	        HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput
}

type httprouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrType HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchArgs

func HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtr(v *HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchArgs) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrInput {
	return (*httprouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrType)(v)
}

func (*httprouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatch)(nil)).Elem()
}

func (i *httprouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput)
}

// RequestMirror defines a schema for a filter that mirrors requests.
// Requests are sent to the specified destination, but responses from
// that destination are ignored.
//
// This filter can be used multiple times within the same rule. Note that
// not all implementations will be able to support mirroring to multiple
// backends.
//
// Support: Extended
type HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput {
	return o.ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatch) *HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatch {
		return &v
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput)
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchOutput) BackendRef() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatch) *HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatch {
		return v.BackendRef
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput)
}

type HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput) Elem() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatch) HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatch {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatch
		return ret
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchOutput)
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput) BackendRef() HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatch) *HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatch {
		if v == nil {
			return nil
		}
		return v.BackendRef
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput)
}

// RequestRedirect defines a schema for a filter that responds to the
// request with an HTTP redirection.
//
// Support: Core
type HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect struct {
	// Hostname is the hostname to be used in the value of the `Location`
	// header in the response.
	// When empty, the hostname in the `Host` header of the request is used.
	//
	// Support: Core
	Hostname *string                                                  `pulumi:"hostname"`
	Path     *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPath `pulumi:"path"`
	// Port is the port to be used in the value of the `Location`
	// header in the response.
	//
	// If no port is specified, the redirect port MUST be derived using the
	// following rules:
	//
	// * If redirect scheme is not-empty, the redirect port MUST be the well-known
	//   port associated with the redirect scheme. Specifically "http" to port 80
	//   and "https" to port 443. If the redirect scheme does not have a
	//   well-known port, the listener port of the Gateway SHOULD be used.
	// * If redirect scheme is empty, the redirect port MUST be the Gateway
	//   Listener port.
	//
	// Implementations SHOULD NOT add the port number in the 'Location'
	// header in the following cases:
	//
	// * A Location header that will use HTTP (whether that is determined via
	//   the Listener protocol or the Scheme field) _and_ use port 80.
	// * A Location header that will use HTTPS (whether that is determined via
	//   the Listener protocol or the Scheme field) _and_ use port 443.
	//
	// Support: Extended
	Port *int `pulumi:"port"`
	// Scheme is the scheme to be used in the value of the `Location` header in
	// the response. When empty, the scheme of the request is used.
	//
	// Scheme redirects can affect the port of the redirect, for more information,
	// refer to the documentation for the port field of this filter.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	//
	// Support: Extended
	Scheme *string `pulumi:"scheme"`
	// StatusCode is the HTTP status code to be used in response.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	//
	// Support: Core
	StatusCode *int `pulumi:"statusCode"`
}

// HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectArgs and HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectArgs{...}
type HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutput
}

// RequestRedirect defines a schema for a filter that responds to the
// request with an HTTP redirection.
//
// Support: Core
type HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectArgs struct {
	// Hostname is the hostname to be used in the value of the `Location`
	// header in the response.
	// When empty, the hostname in the `Host` header of the request is used.
	//
	// Support: Core
	Hostname pulumi.StringPtrInput                                           `pulumi:"hostname"`
	Path     HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrInput `pulumi:"path"`
	// Port is the port to be used in the value of the `Location`
	// header in the response.
	//
	// If no port is specified, the redirect port MUST be derived using the
	// following rules:
	//
	// * If redirect scheme is not-empty, the redirect port MUST be the well-known
	//   port associated with the redirect scheme. Specifically "http" to port 80
	//   and "https" to port 443. If the redirect scheme does not have a
	//   well-known port, the listener port of the Gateway SHOULD be used.
	// * If redirect scheme is empty, the redirect port MUST be the Gateway
	//   Listener port.
	//
	// Implementations SHOULD NOT add the port number in the 'Location'
	// header in the following cases:
	//
	// * A Location header that will use HTTP (whether that is determined via
	//   the Listener protocol or the Scheme field) _and_ use port 80.
	// * A Location header that will use HTTPS (whether that is determined via
	//   the Listener protocol or the Scheme field) _and_ use port 443.
	//
	// Support: Extended
	Port pulumi.IntPtrInput `pulumi:"port"`
	// Scheme is the scheme to be used in the value of the `Location` header in
	// the response. When empty, the scheme of the request is used.
	//
	// Scheme redirects can affect the port of the redirect, for more information,
	// refer to the documentation for the port field of this filter.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	//
	// Support: Extended
	Scheme pulumi.StringPtrInput `pulumi:"scheme"`
	// StatusCode is the HTTP status code to be used in response.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	//
	// Support: Core
	StatusCode pulumi.IntPtrInput `pulumi:"statusCode"`
}

func (HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutput)
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutput).ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectArgs, HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtr and HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrInput` via:
//
//	        HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput
}

type httprouteSpecRulesBackendRefsFiltersRequestRedirectPtrType HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectArgs

func HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtr(v *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectArgs) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrInput {
	return (*httprouteSpecRulesBackendRefsFiltersRequestRedirectPtrType)(v)
}

func (*httprouteSpecRulesBackendRefsFiltersRequestRedirectPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect)(nil)).Elem()
}

func (i *httprouteSpecRulesBackendRefsFiltersRequestRedirectPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesBackendRefsFiltersRequestRedirectPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput)
}

// RequestRedirect defines a schema for a filter that responds to the
// request with an HTTP redirection.
//
// Support: Core
type HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput {
	return o.ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect) *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect {
		return &v
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput)
}

// Hostname is the hostname to be used in the value of the `Location`
// header in the response.
// When empty, the hostname in the `Host` header of the request is used.
//
// Support: Core
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutput) Hostname() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect) *string { return v.Hostname }).(pulumi.StringPtrOutput)
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutput) Path() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect) *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPath {
		return v.Path
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput)
}

// Port is the port to be used in the value of the `Location`
// header in the response.
//
// If no port is specified, the redirect port MUST be derived using the
// following rules:
//
//   - If redirect scheme is not-empty, the redirect port MUST be the well-known
//     port associated with the redirect scheme. Specifically "http" to port 80
//     and "https" to port 443. If the redirect scheme does not have a
//     well-known port, the listener port of the Gateway SHOULD be used.
//   - If redirect scheme is empty, the redirect port MUST be the Gateway
//     Listener port.
//
// Implementations SHOULD NOT add the port number in the 'Location'
// header in the following cases:
//
//   - A Location header that will use HTTP (whether that is determined via
//     the Listener protocol or the Scheme field) _and_ use port 80.
//   - A Location header that will use HTTPS (whether that is determined via
//     the Listener protocol or the Scheme field) _and_ use port 443.
//
// Support: Extended
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// Scheme is the scheme to be used in the value of the `Location` header in
// the response. When empty, the scheme of the request is used.
//
// Scheme redirects can affect the port of the redirect, for more information,
// refer to the documentation for the port field of this filter.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
//
// Support: Extended
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutput) Scheme() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect) *string { return v.Scheme }).(pulumi.StringPtrOutput)
}

// StatusCode is the HTTP status code to be used in response.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
//
// Support: Core
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutput) StatusCode() pulumi.IntPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect) *int { return v.StatusCode }).(pulumi.IntPtrOutput)
}

type HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput) Elem() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect
		return ret
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutput)
}

// Hostname is the hostname to be used in the value of the `Location`
// header in the response.
// When empty, the hostname in the `Host` header of the request is used.
//
// Support: Core
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput) Hostname() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect) *string {
		if v == nil {
			return nil
		}
		return v.Hostname
	}).(pulumi.StringPtrOutput)
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput) Path() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect) *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPath {
		if v == nil {
			return nil
		}
		return v.Path
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput)
}

// Port is the port to be used in the value of the `Location`
// header in the response.
//
// If no port is specified, the redirect port MUST be derived using the
// following rules:
//
//   - If redirect scheme is not-empty, the redirect port MUST be the well-known
//     port associated with the redirect scheme. Specifically "http" to port 80
//     and "https" to port 443. If the redirect scheme does not have a
//     well-known port, the listener port of the Gateway SHOULD be used.
//   - If redirect scheme is empty, the redirect port MUST be the Gateway
//     Listener port.
//
// Implementations SHOULD NOT add the port number in the 'Location'
// header in the following cases:
//
//   - A Location header that will use HTTP (whether that is determined via
//     the Listener protocol or the Scheme field) _and_ use port 80.
//   - A Location header that will use HTTPS (whether that is determined via
//     the Listener protocol or the Scheme field) _and_ use port 443.
//
// Support: Extended
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect) *int {
		if v == nil {
			return nil
		}
		return v.Port
	}).(pulumi.IntPtrOutput)
}

// Scheme is the scheme to be used in the value of the `Location` header in
// the response. When empty, the scheme of the request is used.
//
// Scheme redirects can affect the port of the redirect, for more information,
// refer to the documentation for the port field of this filter.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
//
// Support: Extended
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput) Scheme() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect) *string {
		if v == nil {
			return nil
		}
		return v.Scheme
	}).(pulumi.StringPtrOutput)
}

// StatusCode is the HTTP status code to be used in response.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
//
// Support: Core
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput) StatusCode() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect) *int {
		if v == nil {
			return nil
		}
		return v.StatusCode
	}).(pulumi.IntPtrOutput)
}

// RequestRedirect defines a schema for a filter that responds to the
// request with an HTTP redirection.
//
// Support: Core
type HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatch struct {
	// Hostname is the hostname to be used in the value of the `Location`
	// header in the response.
	// When empty, the hostname in the `Host` header of the request is used.
	//
	// Support: Core
	Hostname *string                                                       `pulumi:"hostname"`
	Path     *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatch `pulumi:"path"`
	// Port is the port to be used in the value of the `Location`
	// header in the response.
	//
	// If no port is specified, the redirect port MUST be derived using the
	// following rules:
	//
	// * If redirect scheme is not-empty, the redirect port MUST be the well-known
	//   port associated with the redirect scheme. Specifically "http" to port 80
	//   and "https" to port 443. If the redirect scheme does not have a
	//   well-known port, the listener port of the Gateway SHOULD be used.
	// * If redirect scheme is empty, the redirect port MUST be the Gateway
	//   Listener port.
	//
	// Implementations SHOULD NOT add the port number in the 'Location'
	// header in the following cases:
	//
	// * A Location header that will use HTTP (whether that is determined via
	//   the Listener protocol or the Scheme field) _and_ use port 80.
	// * A Location header that will use HTTPS (whether that is determined via
	//   the Listener protocol or the Scheme field) _and_ use port 443.
	//
	// Support: Extended
	Port *int `pulumi:"port"`
	// Scheme is the scheme to be used in the value of the `Location` header in
	// the response. When empty, the scheme of the request is used.
	//
	// Scheme redirects can affect the port of the redirect, for more information,
	// refer to the documentation for the port field of this filter.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	//
	// Support: Extended
	Scheme *string `pulumi:"scheme"`
	// StatusCode is the HTTP status code to be used in response.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	//
	// Support: Core
	StatusCode *int `pulumi:"statusCode"`
}

// HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchArgs and HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchArgs{...}
type HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchOutput
}

// RequestRedirect defines a schema for a filter that responds to the
// request with an HTTP redirection.
//
// Support: Core
type HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchArgs struct {
	// Hostname is the hostname to be used in the value of the `Location`
	// header in the response.
	// When empty, the hostname in the `Host` header of the request is used.
	//
	// Support: Core
	Hostname pulumi.StringPtrInput                                                `pulumi:"hostname"`
	Path     HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrInput `pulumi:"path"`
	// Port is the port to be used in the value of the `Location`
	// header in the response.
	//
	// If no port is specified, the redirect port MUST be derived using the
	// following rules:
	//
	// * If redirect scheme is not-empty, the redirect port MUST be the well-known
	//   port associated with the redirect scheme. Specifically "http" to port 80
	//   and "https" to port 443. If the redirect scheme does not have a
	//   well-known port, the listener port of the Gateway SHOULD be used.
	// * If redirect scheme is empty, the redirect port MUST be the Gateway
	//   Listener port.
	//
	// Implementations SHOULD NOT add the port number in the 'Location'
	// header in the following cases:
	//
	// * A Location header that will use HTTP (whether that is determined via
	//   the Listener protocol or the Scheme field) _and_ use port 80.
	// * A Location header that will use HTTPS (whether that is determined via
	//   the Listener protocol or the Scheme field) _and_ use port 443.
	//
	// Support: Extended
	Port pulumi.IntPtrInput `pulumi:"port"`
	// Scheme is the scheme to be used in the value of the `Location` header in
	// the response. When empty, the scheme of the request is used.
	//
	// Scheme redirects can affect the port of the redirect, for more information,
	// refer to the documentation for the port field of this filter.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	//
	// Support: Extended
	Scheme pulumi.StringPtrInput `pulumi:"scheme"`
	// StatusCode is the HTTP status code to be used in response.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	//
	// Support: Core
	StatusCode pulumi.IntPtrInput `pulumi:"statusCode"`
}

func (HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchOutput)
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchOutput).ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchArgs, HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtr and HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrInput` via:
//
//	        HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrOutput
}

type httprouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrType HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchArgs

func HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtr(v *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchArgs) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrInput {
	return (*httprouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrType)(v)
}

func (*httprouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatch)(nil)).Elem()
}

func (i *httprouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrOutput)
}

// RequestRedirect defines a schema for a filter that responds to the
// request with an HTTP redirection.
//
// Support: Core
type HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrOutput {
	return o.ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatch) *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatch {
		return &v
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrOutput)
}

// Hostname is the hostname to be used in the value of the `Location`
// header in the response.
// When empty, the hostname in the `Host` header of the request is used.
//
// Support: Core
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchOutput) Hostname() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatch) *string { return v.Hostname }).(pulumi.StringPtrOutput)
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchOutput) Path() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatch) *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatch {
		return v.Path
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrOutput)
}

// Port is the port to be used in the value of the `Location`
// header in the response.
//
// If no port is specified, the redirect port MUST be derived using the
// following rules:
//
//   - If redirect scheme is not-empty, the redirect port MUST be the well-known
//     port associated with the redirect scheme. Specifically "http" to port 80
//     and "https" to port 443. If the redirect scheme does not have a
//     well-known port, the listener port of the Gateway SHOULD be used.
//   - If redirect scheme is empty, the redirect port MUST be the Gateway
//     Listener port.
//
// Implementations SHOULD NOT add the port number in the 'Location'
// header in the following cases:
//
//   - A Location header that will use HTTP (whether that is determined via
//     the Listener protocol or the Scheme field) _and_ use port 80.
//   - A Location header that will use HTTPS (whether that is determined via
//     the Listener protocol or the Scheme field) _and_ use port 443.
//
// Support: Extended
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatch) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// Scheme is the scheme to be used in the value of the `Location` header in
// the response. When empty, the scheme of the request is used.
//
// Scheme redirects can affect the port of the redirect, for more information,
// refer to the documentation for the port field of this filter.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
//
// Support: Extended
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchOutput) Scheme() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatch) *string { return v.Scheme }).(pulumi.StringPtrOutput)
}

// StatusCode is the HTTP status code to be used in response.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
//
// Support: Core
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchOutput) StatusCode() pulumi.IntPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatch) *int { return v.StatusCode }).(pulumi.IntPtrOutput)
}

type HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrOutput) Elem() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatch) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatch {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatch
		return ret
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchOutput)
}

// Hostname is the hostname to be used in the value of the `Location`
// header in the response.
// When empty, the hostname in the `Host` header of the request is used.
//
// Support: Core
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrOutput) Hostname() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatch) *string {
		if v == nil {
			return nil
		}
		return v.Hostname
	}).(pulumi.StringPtrOutput)
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrOutput) Path() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatch) *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatch {
		if v == nil {
			return nil
		}
		return v.Path
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrOutput)
}

// Port is the port to be used in the value of the `Location`
// header in the response.
//
// If no port is specified, the redirect port MUST be derived using the
// following rules:
//
//   - If redirect scheme is not-empty, the redirect port MUST be the well-known
//     port associated with the redirect scheme. Specifically "http" to port 80
//     and "https" to port 443. If the redirect scheme does not have a
//     well-known port, the listener port of the Gateway SHOULD be used.
//   - If redirect scheme is empty, the redirect port MUST be the Gateway
//     Listener port.
//
// Implementations SHOULD NOT add the port number in the 'Location'
// header in the following cases:
//
//   - A Location header that will use HTTP (whether that is determined via
//     the Listener protocol or the Scheme field) _and_ use port 80.
//   - A Location header that will use HTTPS (whether that is determined via
//     the Listener protocol or the Scheme field) _and_ use port 443.
//
// Support: Extended
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatch) *int {
		if v == nil {
			return nil
		}
		return v.Port
	}).(pulumi.IntPtrOutput)
}

// Scheme is the scheme to be used in the value of the `Location` header in
// the response. When empty, the scheme of the request is used.
//
// Scheme redirects can affect the port of the redirect, for more information,
// refer to the documentation for the port field of this filter.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
//
// Support: Extended
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrOutput) Scheme() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatch) *string {
		if v == nil {
			return nil
		}
		return v.Scheme
	}).(pulumi.StringPtrOutput)
}

// StatusCode is the HTTP status code to be used in response.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
//
// Support: Core
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrOutput) StatusCode() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatch) *int {
		if v == nil {
			return nil
		}
		return v.StatusCode
	}).(pulumi.IntPtrOutput)
}

// Path defines parameters used to modify the path of the incoming request.
// The modified path is then used to construct the `Location` header. When
// empty, the request path is used as-is.
//
// Support: Extended
type HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPath struct {
	// ReplaceFullPath specifies the value with which to replace the full path
	// of a request during a rewrite or redirect.
	ReplaceFullPath *string `pulumi:"replaceFullPath"`
	// ReplacePrefixMatch specifies the value with which to replace the prefix
	// match of a request during a rewrite or redirect. For example, a request
	// to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
	// of "/xyz" would be modified to "/xyz/bar".
	//
	// Note that this matches the behavior of the PathPrefix match type. This
	// matches full path elements. A path element refers to the list of labels
	// in the path split by the `/` separator. When specified, a trailing `/` is
	// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
	// match the prefix `/abc`, but the path `/abcd` would not.
	//
	// ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
	// Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
	// the implementation setting the Accepted Condition for the Route to `status: False`.
	//
	// Request Path | Prefix Match | Replace Prefix | Modified Path
	// -------------|--------------|----------------|----------
	// /foo/bar     | /foo         | /xyz           | /xyz/bar
	// /foo/bar     | /foo         | /xyz/          | /xyz/bar
	// /foo/bar     | /foo/        | /xyz           | /xyz/bar
	// /foo/bar     | /foo/        | /xyz/          | /xyz/bar
	// /foo         | /foo         | /xyz           | /xyz
	// /foo/        | /foo         | /xyz           | /xyz/
	// /foo/bar     | /foo         | <empty string> | /bar
	// /foo/        | /foo         | <empty string> | /
	// /foo         | /foo         | <empty string> | /
	// /foo/        | /foo         | /              | /
	// /foo         | /foo         | /              | /
	ReplacePrefixMatch *string `pulumi:"replacePrefixMatch"`
	// Type defines the type of path modifier. Additional types may be
	// added in a future release of the API.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	Type *string `pulumi:"type"`
}

// HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathArgs and HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathArgs{...}
type HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutput
}

// Path defines parameters used to modify the path of the incoming request.
// The modified path is then used to construct the `Location` header. When
// empty, the request path is used as-is.
//
// Support: Extended
type HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathArgs struct {
	// ReplaceFullPath specifies the value with which to replace the full path
	// of a request during a rewrite or redirect.
	ReplaceFullPath pulumi.StringPtrInput `pulumi:"replaceFullPath"`
	// ReplacePrefixMatch specifies the value with which to replace the prefix
	// match of a request during a rewrite or redirect. For example, a request
	// to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
	// of "/xyz" would be modified to "/xyz/bar".
	//
	// Note that this matches the behavior of the PathPrefix match type. This
	// matches full path elements. A path element refers to the list of labels
	// in the path split by the `/` separator. When specified, a trailing `/` is
	// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
	// match the prefix `/abc`, but the path `/abcd` would not.
	//
	// ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
	// Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
	// the implementation setting the Accepted Condition for the Route to `status: False`.
	//
	// Request Path | Prefix Match | Replace Prefix | Modified Path
	// -------------|--------------|----------------|----------
	// /foo/bar     | /foo         | /xyz           | /xyz/bar
	// /foo/bar     | /foo         | /xyz/          | /xyz/bar
	// /foo/bar     | /foo/        | /xyz           | /xyz/bar
	// /foo/bar     | /foo/        | /xyz/          | /xyz/bar
	// /foo         | /foo         | /xyz           | /xyz
	// /foo/        | /foo         | /xyz           | /xyz/
	// /foo/bar     | /foo         | <empty string> | /bar
	// /foo/        | /foo         | <empty string> | /
	// /foo         | /foo         | <empty string> | /
	// /foo/        | /foo         | /              | /
	// /foo         | /foo         | /              | /
	ReplacePrefixMatch pulumi.StringPtrInput `pulumi:"replacePrefixMatch"`
	// Type defines the type of path modifier. Additional types may be
	// added in a future release of the API.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPath)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutput)
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutput).ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathArgs, HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtr and HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrInput` via:
//
//	        HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput
}

type httprouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrType HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathArgs

func HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtr(v *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathArgs) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrInput {
	return (*httprouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrType)(v)
}

func (*httprouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPath)(nil)).Elem()
}

func (i *httprouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput)
}

// Path defines parameters used to modify the path of the incoming request.
// The modified path is then used to construct the `Location` header. When
// empty, the request path is used as-is.
//
// Support: Extended
type HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPath)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput {
	return o.ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPath) *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPath {
		return &v
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput)
}

// ReplaceFullPath specifies the value with which to replace the full path
// of a request during a rewrite or redirect.
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutput) ReplaceFullPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPath) *string { return v.ReplaceFullPath }).(pulumi.StringPtrOutput)
}

// ReplacePrefixMatch specifies the value with which to replace the prefix
// match of a request during a rewrite or redirect. For example, a request
// to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
// of "/xyz" would be modified to "/xyz/bar".
//
// Note that this matches the behavior of the PathPrefix match type. This
// matches full path elements. A path element refers to the list of labels
// in the path split by the `/` separator. When specified, a trailing `/` is
// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
// match the prefix `/abc`, but the path `/abcd` would not.
//
// ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
// Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
// the implementation setting the Accepted Condition for the Route to `status: False`.
//
// Request Path | Prefix Match | Replace Prefix | Modified Path
// -------------|--------------|----------------|----------
// /foo/bar     | /foo         | /xyz           | /xyz/bar
// /foo/bar     | /foo         | /xyz/          | /xyz/bar
// /foo/bar     | /foo/        | /xyz           | /xyz/bar
// /foo/bar     | /foo/        | /xyz/          | /xyz/bar
// /foo         | /foo         | /xyz           | /xyz
// /foo/        | /foo         | /xyz           | /xyz/
// /foo/bar     | /foo         | <empty string> | /bar
// /foo/        | /foo         | <empty string> | /
// /foo         | /foo         | <empty string> | /
// /foo/        | /foo         | /              | /
// /foo         | /foo         | /              | /
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutput) ReplacePrefixMatch() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPath) *string { return v.ReplacePrefixMatch }).(pulumi.StringPtrOutput)
}

// Type defines the type of path modifier. Additional types may be
// added in a future release of the API.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPath) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPath)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput) Elem() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPath) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPath {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPath
		return ret
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutput)
}

// ReplaceFullPath specifies the value with which to replace the full path
// of a request during a rewrite or redirect.
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput) ReplaceFullPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPath) *string {
		if v == nil {
			return nil
		}
		return v.ReplaceFullPath
	}).(pulumi.StringPtrOutput)
}

// ReplacePrefixMatch specifies the value with which to replace the prefix
// match of a request during a rewrite or redirect. For example, a request
// to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
// of "/xyz" would be modified to "/xyz/bar".
//
// Note that this matches the behavior of the PathPrefix match type. This
// matches full path elements. A path element refers to the list of labels
// in the path split by the `/` separator. When specified, a trailing `/` is
// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
// match the prefix `/abc`, but the path `/abcd` would not.
//
// ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
// Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
// the implementation setting the Accepted Condition for the Route to `status: False`.
//
// Request Path | Prefix Match | Replace Prefix | Modified Path
// -------------|--------------|----------------|----------
// /foo/bar     | /foo         | /xyz           | /xyz/bar
// /foo/bar     | /foo         | /xyz/          | /xyz/bar
// /foo/bar     | /foo/        | /xyz           | /xyz/bar
// /foo/bar     | /foo/        | /xyz/          | /xyz/bar
// /foo         | /foo         | /xyz           | /xyz
// /foo/        | /foo         | /xyz           | /xyz/
// /foo/bar     | /foo         | <empty string> | /bar
// /foo/        | /foo         | <empty string> | /
// /foo         | /foo         | <empty string> | /
// /foo/        | /foo         | /              | /
// /foo         | /foo         | /              | /
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput) ReplacePrefixMatch() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPath) *string {
		if v == nil {
			return nil
		}
		return v.ReplacePrefixMatch
	}).(pulumi.StringPtrOutput)
}

// Type defines the type of path modifier. Additional types may be
// added in a future release of the API.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPath) *string {
		if v == nil {
			return nil
		}
		return v.Type
	}).(pulumi.StringPtrOutput)
}

// Path defines parameters used to modify the path of the incoming request.
// The modified path is then used to construct the `Location` header. When
// empty, the request path is used as-is.
//
// Support: Extended
type HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatch struct {
	// ReplaceFullPath specifies the value with which to replace the full path
	// of a request during a rewrite or redirect.
	ReplaceFullPath *string `pulumi:"replaceFullPath"`
	// ReplacePrefixMatch specifies the value with which to replace the prefix
	// match of a request during a rewrite or redirect. For example, a request
	// to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
	// of "/xyz" would be modified to "/xyz/bar".
	//
	// Note that this matches the behavior of the PathPrefix match type. This
	// matches full path elements. A path element refers to the list of labels
	// in the path split by the `/` separator. When specified, a trailing `/` is
	// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
	// match the prefix `/abc`, but the path `/abcd` would not.
	//
	// ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
	// Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
	// the implementation setting the Accepted Condition for the Route to `status: False`.
	//
	// Request Path | Prefix Match | Replace Prefix | Modified Path
	// -------------|--------------|----------------|----------
	// /foo/bar     | /foo         | /xyz           | /xyz/bar
	// /foo/bar     | /foo         | /xyz/          | /xyz/bar
	// /foo/bar     | /foo/        | /xyz           | /xyz/bar
	// /foo/bar     | /foo/        | /xyz/          | /xyz/bar
	// /foo         | /foo         | /xyz           | /xyz
	// /foo/        | /foo         | /xyz           | /xyz/
	// /foo/bar     | /foo         | <empty string> | /bar
	// /foo/        | /foo         | <empty string> | /
	// /foo         | /foo         | <empty string> | /
	// /foo/        | /foo         | /              | /
	// /foo         | /foo         | /              | /
	ReplacePrefixMatch *string `pulumi:"replacePrefixMatch"`
	// Type defines the type of path modifier. Additional types may be
	// added in a future release of the API.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	Type *string `pulumi:"type"`
}

// HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchArgs and HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchArgs{...}
type HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchOutput
}

// Path defines parameters used to modify the path of the incoming request.
// The modified path is then used to construct the `Location` header. When
// empty, the request path is used as-is.
//
// Support: Extended
type HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchArgs struct {
	// ReplaceFullPath specifies the value with which to replace the full path
	// of a request during a rewrite or redirect.
	ReplaceFullPath pulumi.StringPtrInput `pulumi:"replaceFullPath"`
	// ReplacePrefixMatch specifies the value with which to replace the prefix
	// match of a request during a rewrite or redirect. For example, a request
	// to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
	// of "/xyz" would be modified to "/xyz/bar".
	//
	// Note that this matches the behavior of the PathPrefix match type. This
	// matches full path elements. A path element refers to the list of labels
	// in the path split by the `/` separator. When specified, a trailing `/` is
	// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
	// match the prefix `/abc`, but the path `/abcd` would not.
	//
	// ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
	// Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
	// the implementation setting the Accepted Condition for the Route to `status: False`.
	//
	// Request Path | Prefix Match | Replace Prefix | Modified Path
	// -------------|--------------|----------------|----------
	// /foo/bar     | /foo         | /xyz           | /xyz/bar
	// /foo/bar     | /foo         | /xyz/          | /xyz/bar
	// /foo/bar     | /foo/        | /xyz           | /xyz/bar
	// /foo/bar     | /foo/        | /xyz/          | /xyz/bar
	// /foo         | /foo         | /xyz           | /xyz
	// /foo/        | /foo         | /xyz           | /xyz/
	// /foo/bar     | /foo         | <empty string> | /bar
	// /foo/        | /foo         | <empty string> | /
	// /foo         | /foo         | <empty string> | /
	// /foo/        | /foo         | /              | /
	// /foo         | /foo         | /              | /
	ReplacePrefixMatch pulumi.StringPtrInput `pulumi:"replacePrefixMatch"`
	// Type defines the type of path modifier. Additional types may be
	// added in a future release of the API.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchOutput)
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchOutput).ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchArgs, HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtr and HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrInput` via:
//
//	        HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrOutput
}

type httprouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrType HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchArgs

func HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtr(v *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchArgs) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrInput {
	return (*httprouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrType)(v)
}

func (*httprouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatch)(nil)).Elem()
}

func (i *httprouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrOutput)
}

// Path defines parameters used to modify the path of the incoming request.
// The modified path is then used to construct the `Location` header. When
// empty, the request path is used as-is.
//
// Support: Extended
type HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrOutput {
	return o.ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatch) *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatch {
		return &v
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrOutput)
}

// ReplaceFullPath specifies the value with which to replace the full path
// of a request during a rewrite or redirect.
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchOutput) ReplaceFullPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatch) *string { return v.ReplaceFullPath }).(pulumi.StringPtrOutput)
}

// ReplacePrefixMatch specifies the value with which to replace the prefix
// match of a request during a rewrite or redirect. For example, a request
// to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
// of "/xyz" would be modified to "/xyz/bar".
//
// Note that this matches the behavior of the PathPrefix match type. This
// matches full path elements. A path element refers to the list of labels
// in the path split by the `/` separator. When specified, a trailing `/` is
// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
// match the prefix `/abc`, but the path `/abcd` would not.
//
// ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
// Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
// the implementation setting the Accepted Condition for the Route to `status: False`.
//
// Request Path | Prefix Match | Replace Prefix | Modified Path
// -------------|--------------|----------------|----------
// /foo/bar     | /foo         | /xyz           | /xyz/bar
// /foo/bar     | /foo         | /xyz/          | /xyz/bar
// /foo/bar     | /foo/        | /xyz           | /xyz/bar
// /foo/bar     | /foo/        | /xyz/          | /xyz/bar
// /foo         | /foo         | /xyz           | /xyz
// /foo/        | /foo         | /xyz           | /xyz/
// /foo/bar     | /foo         | <empty string> | /bar
// /foo/        | /foo         | <empty string> | /
// /foo         | /foo         | <empty string> | /
// /foo/        | /foo         | /              | /
// /foo         | /foo         | /              | /
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchOutput) ReplacePrefixMatch() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatch) *string {
		return v.ReplacePrefixMatch
	}).(pulumi.StringPtrOutput)
}

// Type defines the type of path modifier. Additional types may be
// added in a future release of the API.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatch) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrOutput) Elem() HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatch) HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatch {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatch
		return ret
	}).(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchOutput)
}

// ReplaceFullPath specifies the value with which to replace the full path
// of a request during a rewrite or redirect.
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrOutput) ReplaceFullPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatch) *string {
		if v == nil {
			return nil
		}
		return v.ReplaceFullPath
	}).(pulumi.StringPtrOutput)
}

// ReplacePrefixMatch specifies the value with which to replace the prefix
// match of a request during a rewrite or redirect. For example, a request
// to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
// of "/xyz" would be modified to "/xyz/bar".
//
// Note that this matches the behavior of the PathPrefix match type. This
// matches full path elements. A path element refers to the list of labels
// in the path split by the `/` separator. When specified, a trailing `/` is
// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
// match the prefix `/abc`, but the path `/abcd` would not.
//
// ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
// Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
// the implementation setting the Accepted Condition for the Route to `status: False`.
//
// Request Path | Prefix Match | Replace Prefix | Modified Path
// -------------|--------------|----------------|----------
// /foo/bar     | /foo         | /xyz           | /xyz/bar
// /foo/bar     | /foo         | /xyz/          | /xyz/bar
// /foo/bar     | /foo/        | /xyz           | /xyz/bar
// /foo/bar     | /foo/        | /xyz/          | /xyz/bar
// /foo         | /foo         | /xyz           | /xyz
// /foo/        | /foo         | /xyz           | /xyz/
// /foo/bar     | /foo         | <empty string> | /bar
// /foo/        | /foo         | <empty string> | /
// /foo         | /foo         | <empty string> | /
// /foo/        | /foo         | /              | /
// /foo         | /foo         | /              | /
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrOutput) ReplacePrefixMatch() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatch) *string {
		if v == nil {
			return nil
		}
		return v.ReplacePrefixMatch
	}).(pulumi.StringPtrOutput)
}

// Type defines the type of path modifier. Additional types may be
// added in a future release of the API.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
func (o HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatch) *string {
		if v == nil {
			return nil
		}
		return v.Type
	}).(pulumi.StringPtrOutput)
}

// ResponseHeaderModifier defines a schema for a filter that modifies response
// headers.
//
// Support: Extended
type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifier struct {
	// Add adds the given header(s) (name, value) to the request
	// before the action. It appends to any existing values associated
	// with the header name.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   add:
	//   - name: "my-header"
	//     value: "bar,baz"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: foo,bar,baz
	Add []HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd `pulumi:"add"`
	// Remove the given header(s) from the HTTP request before the action. The
	// value of Remove is a list of HTTP header names. Note that the header
	// names are case-insensitive (see
	// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header1: foo
	//   my-header2: bar
	//   my-header3: baz
	//
	// Config:
	//   remove: ["my-header1", "my-header3"]
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header2: bar
	Remove []string `pulumi:"remove"`
	// Set overwrites the request with the given header (name, value)
	// before the action.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   set:
	//   - name: "my-header"
	//     value: "bar"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: bar
	Set []HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet `pulumi:"set"`
}

// HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs and HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs{...}
type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput
}

// ResponseHeaderModifier defines a schema for a filter that modifies response
// headers.
//
// Support: Extended
type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs struct {
	// Add adds the given header(s) (name, value) to the request
	// before the action. It appends to any existing values associated
	// with the header name.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   add:
	//   - name: "my-header"
	//     value: "bar,baz"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: foo,bar,baz
	Add HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayInput `pulumi:"add"`
	// Remove the given header(s) from the HTTP request before the action. The
	// value of Remove is a list of HTTP header names. Note that the header
	// names are case-insensitive (see
	// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header1: foo
	//   my-header2: bar
	//   my-header3: baz
	//
	// Config:
	//   remove: ["my-header1", "my-header3"]
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header2: bar
	Remove pulumi.StringArrayInput `pulumi:"remove"`
	// Set overwrites the request with the given header (name, value)
	// before the action.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   set:
	//   - name: "my-header"
	//     value: "bar"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: bar
	Set HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayInput `pulumi:"set"`
}

func (HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifier)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput)
}

func (i HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput).ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs, HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtr and HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrInput` via:
//
//	        HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput
}

type httprouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrType HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs

func HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtr(v *HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrInput {
	return (*httprouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrType)(v)
}

func (*httprouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifier)(nil)).Elem()
}

func (i *httprouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput)
}

// ResponseHeaderModifier defines a schema for a filter that modifies response
// headers.
//
// Support: Extended
type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifier)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput {
	return o.ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifier) *HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifier {
		return &v
	}).(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput)
}

// Add adds the given header(s) (name, value) to the request
// before the action. It appends to any existing values associated
// with the header name.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	add:
//	- name: "my-header"
//	  value: "bar,baz"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: foo,bar,baz
func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput) Add() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifier) []HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd {
		return v.Add
	}).(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput)
}

// Remove the given header(s) from the HTTP request before the action. The
// value of Remove is a list of HTTP header names. Note that the header
// names are case-insensitive (see
// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header1: foo
//	my-header2: bar
//	my-header3: baz
//
// Config:
//
//	remove: ["my-header1", "my-header3"]
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header2: bar
func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput) Remove() pulumi.StringArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifier) []string { return v.Remove }).(pulumi.StringArrayOutput)
}

// Set overwrites the request with the given header (name, value)
// before the action.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	set:
//	- name: "my-header"
//	  value: "bar"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: bar
func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput) Set() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifier) []HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet {
		return v.Set
	}).(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput)
}

type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifier)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput) Elem() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifier) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifier {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifier
		return ret
	}).(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput)
}

// Add adds the given header(s) (name, value) to the request
// before the action. It appends to any existing values associated
// with the header name.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	add:
//	- name: "my-header"
//	  value: "bar,baz"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: foo,bar,baz
func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput) Add() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifier) []HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd {
		if v == nil {
			return nil
		}
		return v.Add
	}).(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput)
}

// Remove the given header(s) from the HTTP request before the action. The
// value of Remove is a list of HTTP header names. Note that the header
// names are case-insensitive (see
// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header1: foo
//	my-header2: bar
//	my-header3: baz
//
// Config:
//
//	remove: ["my-header1", "my-header3"]
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header2: bar
func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput) Remove() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifier) []string {
		if v == nil {
			return nil
		}
		return v.Remove
	}).(pulumi.StringArrayOutput)
}

// Set overwrites the request with the given header (name, value)
// before the action.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	set:
//	- name: "my-header"
//	  value: "bar"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: bar
func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput) Set() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifier) []HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet {
		if v == nil {
			return nil
		}
		return v.Set
	}).(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name *string `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value *string `pulumi:"value"`
}

// HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArgs and HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArgs{...}
type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArgs struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArgs) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArgs) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput)
}

// HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArray and HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArray{ HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArgs{...} }
type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput
}

type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArray []HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddInput

func (HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArray) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArray) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput {
	return o
}

// Name is the name of the HTTP Header to be matched. Name matching MUST be
// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
//
// If multiple entries specify equivalent header names, the first entry with
// an equivalent name MUST be considered for a match. Subsequent entries
// with an equivalent header name MUST be ignored. Due to the
// case-insensitivity of header names, "foo" and "Foo" are considered
// equivalent.
func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Value is the value of HTTP Header to be matched.
func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput) Index(i pulumi.IntInput) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd {
		return vs[0].([]HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd)[vs[1].(int)]
	}).(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatch struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name *string `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value *string `pulumi:"value"`
}

// HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArgs and HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArgs{...}
type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchOutput
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArgs struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchOutput)
}

// HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArray and HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArray{ HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArgs{...} }
type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayOutput
}

type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArray []HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchInput

func (HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArray) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArray) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchOutput {
	return o
}

// Name is the name of the HTTP Header to be matched. Name matching MUST be
// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
//
// If multiple entries specify equivalent header names, the first entry with
// an equivalent name MUST be considered for a match. Subsequent entries
// with an equivalent header name MUST be ignored. Due to the
// case-insensitivity of header names, "foo" and "Foo" are considered
// equivalent.
func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Value is the value of HTTP Header to be matched.
func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatch) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayOutput) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayOutput) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayOutput) Index(i pulumi.IntInput) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatch {
		return vs[0].([]HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatch)[vs[1].(int)]
	}).(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchOutput)
}

// ResponseHeaderModifier defines a schema for a filter that modifies response
// headers.
//
// Support: Extended
type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatch struct {
	// Add adds the given header(s) (name, value) to the request
	// before the action. It appends to any existing values associated
	// with the header name.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   add:
	//   - name: "my-header"
	//     value: "bar,baz"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: foo,bar,baz
	Add []HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatch `pulumi:"add"`
	// Remove the given header(s) from the HTTP request before the action. The
	// value of Remove is a list of HTTP header names. Note that the header
	// names are case-insensitive (see
	// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header1: foo
	//   my-header2: bar
	//   my-header3: baz
	//
	// Config:
	//   remove: ["my-header1", "my-header3"]
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header2: bar
	Remove []string `pulumi:"remove"`
	// Set overwrites the request with the given header (name, value)
	// before the action.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   set:
	//   - name: "my-header"
	//     value: "bar"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: bar
	Set []HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatch `pulumi:"set"`
}

// HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchArgs and HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchArgs{...}
type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutput
}

// ResponseHeaderModifier defines a schema for a filter that modifies response
// headers.
//
// Support: Extended
type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchArgs struct {
	// Add adds the given header(s) (name, value) to the request
	// before the action. It appends to any existing values associated
	// with the header name.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   add:
	//   - name: "my-header"
	//     value: "bar,baz"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: foo,bar,baz
	Add HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayInput `pulumi:"add"`
	// Remove the given header(s) from the HTTP request before the action. The
	// value of Remove is a list of HTTP header names. Note that the header
	// names are case-insensitive (see
	// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header1: foo
	//   my-header2: bar
	//   my-header3: baz
	//
	// Config:
	//   remove: ["my-header1", "my-header3"]
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header2: bar
	Remove pulumi.StringArrayInput `pulumi:"remove"`
	// Set overwrites the request with the given header (name, value)
	// before the action.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   set:
	//   - name: "my-header"
	//     value: "bar"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: bar
	Set HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayInput `pulumi:"set"`
}

func (HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutput)
}

func (i HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutput).ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchArgs, HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtr and HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrInput` via:
//
//	        HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput
}

type httprouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrType HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchArgs

func HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtr(v *HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchArgs) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrInput {
	return (*httprouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrType)(v)
}

func (*httprouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatch)(nil)).Elem()
}

func (i *httprouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput)
}

// ResponseHeaderModifier defines a schema for a filter that modifies response
// headers.
//
// Support: Extended
type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput {
	return o.ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatch) *HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatch {
		return &v
	}).(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput)
}

// Add adds the given header(s) (name, value) to the request
// before the action. It appends to any existing values associated
// with the header name.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	add:
//	- name: "my-header"
//	  value: "bar,baz"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: foo,bar,baz
func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutput) Add() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatch) []HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatch {
		return v.Add
	}).(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayOutput)
}

// Remove the given header(s) from the HTTP request before the action. The
// value of Remove is a list of HTTP header names. Note that the header
// names are case-insensitive (see
// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header1: foo
//	my-header2: bar
//	my-header3: baz
//
// Config:
//
//	remove: ["my-header1", "my-header3"]
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header2: bar
func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutput) Remove() pulumi.StringArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatch) []string { return v.Remove }).(pulumi.StringArrayOutput)
}

// Set overwrites the request with the given header (name, value)
// before the action.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	set:
//	- name: "my-header"
//	  value: "bar"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: bar
func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutput) Set() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatch) []HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatch {
		return v.Set
	}).(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayOutput)
}

type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput) Elem() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatch) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatch {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatch
		return ret
	}).(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutput)
}

// Add adds the given header(s) (name, value) to the request
// before the action. It appends to any existing values associated
// with the header name.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	add:
//	- name: "my-header"
//	  value: "bar,baz"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: foo,bar,baz
func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput) Add() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatch) []HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatch {
		if v == nil {
			return nil
		}
		return v.Add
	}).(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayOutput)
}

// Remove the given header(s) from the HTTP request before the action. The
// value of Remove is a list of HTTP header names. Note that the header
// names are case-insensitive (see
// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header1: foo
//	my-header2: bar
//	my-header3: baz
//
// Config:
//
//	remove: ["my-header1", "my-header3"]
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header2: bar
func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput) Remove() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatch) []string {
		if v == nil {
			return nil
		}
		return v.Remove
	}).(pulumi.StringArrayOutput)
}

// Set overwrites the request with the given header (name, value)
// before the action.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	set:
//	- name: "my-header"
//	  value: "bar"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: bar
func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput) Set() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatch) []HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatch {
		if v == nil {
			return nil
		}
		return v.Set
	}).(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name *string `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value *string `pulumi:"value"`
}

// HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArgs and HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArgs{...}
type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArgs struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArgs) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArgs) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput)
}

// HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArray and HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArray{ HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArgs{...} }
type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput
}

type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArray []HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetInput

func (HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArray) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArray) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput {
	return o
}

// Name is the name of the HTTP Header to be matched. Name matching MUST be
// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
//
// If multiple entries specify equivalent header names, the first entry with
// an equivalent name MUST be considered for a match. Subsequent entries
// with an equivalent header name MUST be ignored. Due to the
// case-insensitivity of header names, "foo" and "Foo" are considered
// equivalent.
func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Value is the value of HTTP Header to be matched.
func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput) Index(i pulumi.IntInput) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet {
		return vs[0].([]HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet)[vs[1].(int)]
	}).(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatch struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name *string `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value *string `pulumi:"value"`
}

// HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArgs and HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArgs{...}
type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchOutput
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArgs struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchOutput)
}

// HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArray and HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArray{ HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArgs{...} }
type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayOutput
}

type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArray []HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchInput

func (HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArray) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArray) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchOutput {
	return o
}

// Name is the name of the HTTP Header to be matched. Name matching MUST be
// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
//
// If multiple entries specify equivalent header names, the first entry with
// an equivalent name MUST be considered for a match. Subsequent entries
// with an equivalent header name MUST be ignored. Due to the
// case-insensitivity of header names, "foo" and "Foo" are considered
// equivalent.
func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Value is the value of HTTP Header to be matched.
func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatch) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayOutput) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayOutput() HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayOutput) ToHTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayOutput) Index(i pulumi.IntInput) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatch {
		return vs[0].([]HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatch)[vs[1].(int)]
	}).(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchOutput)
}

// URLRewrite defines a schema for a filter that modifies a request during forwarding.
//
// Support: Extended
type HTTPRouteSpecRulesBackendRefsFiltersUrlRewrite struct {
	// Hostname is the value to be used to replace the Host header value during
	// forwarding.
	//
	// Support: Extended
	Hostname *string                                             `pulumi:"hostname"`
	Path     *HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePath `pulumi:"path"`
}

// HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteArgs and HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteArgs{...}
type HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutput() HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutput
}

// URLRewrite defines a schema for a filter that modifies a request during forwarding.
//
// Support: Extended
type HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteArgs struct {
	// Hostname is the value to be used to replace the Host header value during
	// forwarding.
	//
	// Support: Extended
	Hostname pulumi.StringPtrInput                                      `pulumi:"hostname"`
	Path     HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrInput `pulumi:"path"`
}

func (HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersUrlRewrite)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteArgs) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutput() HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteArgs) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutput)
}

func (i HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteArgs) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteArgs) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutput).ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteArgs, HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtr and HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrInput` via:
//
//	        HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput
}

type httprouteSpecRulesBackendRefsFiltersUrlRewritePtrType HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteArgs

func HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtr(v *HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteArgs) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrInput {
	return (*httprouteSpecRulesBackendRefsFiltersUrlRewritePtrType)(v)
}

func (*httprouteSpecRulesBackendRefsFiltersUrlRewritePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersUrlRewrite)(nil)).Elem()
}

func (i *httprouteSpecRulesBackendRefsFiltersUrlRewritePtrType) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesBackendRefsFiltersUrlRewritePtrType) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput)
}

// URLRewrite defines a schema for a filter that modifies a request during forwarding.
//
// Support: Extended
type HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersUrlRewrite)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutput) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutput() HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutput) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutput) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput {
	return o.ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutput) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesBackendRefsFiltersUrlRewrite) *HTTPRouteSpecRulesBackendRefsFiltersUrlRewrite {
		return &v
	}).(HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput)
}

// Hostname is the value to be used to replace the Host header value during
// forwarding.
//
// Support: Extended
func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutput) Hostname() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersUrlRewrite) *string { return v.Hostname }).(pulumi.StringPtrOutput)
}

func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutput) Path() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersUrlRewrite) *HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePath {
		return v.Path
	}).(HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput)
}

type HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersUrlRewrite)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput) Elem() HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersUrlRewrite) HTTPRouteSpecRulesBackendRefsFiltersUrlRewrite {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesBackendRefsFiltersUrlRewrite
		return ret
	}).(HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutput)
}

// Hostname is the value to be used to replace the Host header value during
// forwarding.
//
// Support: Extended
func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput) Hostname() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersUrlRewrite) *string {
		if v == nil {
			return nil
		}
		return v.Hostname
	}).(pulumi.StringPtrOutput)
}

func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput) Path() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersUrlRewrite) *HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePath {
		if v == nil {
			return nil
		}
		return v.Path
	}).(HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput)
}

// URLRewrite defines a schema for a filter that modifies a request during forwarding.
//
// Support: Extended
type HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatch struct {
	// Hostname is the value to be used to replace the Host header value during
	// forwarding.
	//
	// Support: Extended
	Hostname *string                                                  `pulumi:"hostname"`
	Path     *HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatch `pulumi:"path"`
}

// HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchArgs and HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchArgs{...}
type HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchOutput() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchOutput
}

// URLRewrite defines a schema for a filter that modifies a request during forwarding.
//
// Support: Extended
type HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchArgs struct {
	// Hostname is the value to be used to replace the Host header value during
	// forwarding.
	//
	// Support: Extended
	Hostname pulumi.StringPtrInput                                           `pulumi:"hostname"`
	Path     HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrInput `pulumi:"path"`
}

func (HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchOutput() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchOutput)
}

func (i HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchOutput).ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchArgs, HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtr and HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrInput` via:
//
//	        HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrOutput
}

type httprouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrType HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchArgs

func HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtr(v *HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchArgs) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrInput {
	return (*httprouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrType)(v)
}

func (*httprouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatch)(nil)).Elem()
}

func (i *httprouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrOutput)
}

// URLRewrite defines a schema for a filter that modifies a request during forwarding.
//
// Support: Extended
type HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchOutput() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrOutput {
	return o.ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatch) *HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatch {
		return &v
	}).(HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrOutput)
}

// Hostname is the value to be used to replace the Host header value during
// forwarding.
//
// Support: Extended
func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchOutput) Hostname() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatch) *string { return v.Hostname }).(pulumi.StringPtrOutput)
}

func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchOutput) Path() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatch) *HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatch {
		return v.Path
	}).(HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrOutput)
}

type HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrOutput) Elem() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatch) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatch {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatch
		return ret
	}).(HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchOutput)
}

// Hostname is the value to be used to replace the Host header value during
// forwarding.
//
// Support: Extended
func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrOutput) Hostname() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatch) *string {
		if v == nil {
			return nil
		}
		return v.Hostname
	}).(pulumi.StringPtrOutput)
}

func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrOutput) Path() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatch) *HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatch {
		if v == nil {
			return nil
		}
		return v.Path
	}).(HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrOutput)
}

// Path defines a path rewrite.
//
// Support: Extended
type HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePath struct {
	// ReplaceFullPath specifies the value with which to replace the full path
	// of a request during a rewrite or redirect.
	ReplaceFullPath *string `pulumi:"replaceFullPath"`
	// ReplacePrefixMatch specifies the value with which to replace the prefix
	// match of a request during a rewrite or redirect. For example, a request
	// to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
	// of "/xyz" would be modified to "/xyz/bar".
	//
	// Note that this matches the behavior of the PathPrefix match type. This
	// matches full path elements. A path element refers to the list of labels
	// in the path split by the `/` separator. When specified, a trailing `/` is
	// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
	// match the prefix `/abc`, but the path `/abcd` would not.
	//
	// ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
	// Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
	// the implementation setting the Accepted Condition for the Route to `status: False`.
	//
	// Request Path | Prefix Match | Replace Prefix | Modified Path
	// -------------|--------------|----------------|----------
	// /foo/bar     | /foo         | /xyz           | /xyz/bar
	// /foo/bar     | /foo         | /xyz/          | /xyz/bar
	// /foo/bar     | /foo/        | /xyz           | /xyz/bar
	// /foo/bar     | /foo/        | /xyz/          | /xyz/bar
	// /foo         | /foo         | /xyz           | /xyz
	// /foo/        | /foo         | /xyz           | /xyz/
	// /foo/bar     | /foo         | <empty string> | /bar
	// /foo/        | /foo         | <empty string> | /
	// /foo         | /foo         | <empty string> | /
	// /foo/        | /foo         | /              | /
	// /foo         | /foo         | /              | /
	ReplacePrefixMatch *string `pulumi:"replacePrefixMatch"`
	// Type defines the type of path modifier. Additional types may be
	// added in a future release of the API.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	Type *string `pulumi:"type"`
}

// HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathArgs and HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathArgs{...}
type HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutput() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutput
}

// Path defines a path rewrite.
//
// Support: Extended
type HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathArgs struct {
	// ReplaceFullPath specifies the value with which to replace the full path
	// of a request during a rewrite or redirect.
	ReplaceFullPath pulumi.StringPtrInput `pulumi:"replaceFullPath"`
	// ReplacePrefixMatch specifies the value with which to replace the prefix
	// match of a request during a rewrite or redirect. For example, a request
	// to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
	// of "/xyz" would be modified to "/xyz/bar".
	//
	// Note that this matches the behavior of the PathPrefix match type. This
	// matches full path elements. A path element refers to the list of labels
	// in the path split by the `/` separator. When specified, a trailing `/` is
	// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
	// match the prefix `/abc`, but the path `/abcd` would not.
	//
	// ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
	// Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
	// the implementation setting the Accepted Condition for the Route to `status: False`.
	//
	// Request Path | Prefix Match | Replace Prefix | Modified Path
	// -------------|--------------|----------------|----------
	// /foo/bar     | /foo         | /xyz           | /xyz/bar
	// /foo/bar     | /foo         | /xyz/          | /xyz/bar
	// /foo/bar     | /foo/        | /xyz           | /xyz/bar
	// /foo/bar     | /foo/        | /xyz/          | /xyz/bar
	// /foo         | /foo         | /xyz           | /xyz
	// /foo/        | /foo         | /xyz           | /xyz/
	// /foo/bar     | /foo         | <empty string> | /bar
	// /foo/        | /foo         | <empty string> | /
	// /foo         | /foo         | <empty string> | /
	// /foo/        | /foo         | /              | /
	// /foo         | /foo         | /              | /
	ReplacePrefixMatch pulumi.StringPtrInput `pulumi:"replacePrefixMatch"`
	// Type defines the type of path modifier. Additional types may be
	// added in a future release of the API.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePath)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathArgs) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutput() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathArgs) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutput)
}

func (i HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathArgs) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathArgs) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutput).ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathArgs, HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtr and HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrInput` via:
//
//	        HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput
}

type httprouteSpecRulesBackendRefsFiltersUrlRewritePathPtrType HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathArgs

func HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtr(v *HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathArgs) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrInput {
	return (*httprouteSpecRulesBackendRefsFiltersUrlRewritePathPtrType)(v)
}

func (*httprouteSpecRulesBackendRefsFiltersUrlRewritePathPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePath)(nil)).Elem()
}

func (i *httprouteSpecRulesBackendRefsFiltersUrlRewritePathPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesBackendRefsFiltersUrlRewritePathPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput)
}

// Path defines a path rewrite.
//
// Support: Extended
type HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePath)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutput) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutput() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutput) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutput) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput {
	return o.ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutput) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePath) *HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePath {
		return &v
	}).(HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput)
}

// ReplaceFullPath specifies the value with which to replace the full path
// of a request during a rewrite or redirect.
func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutput) ReplaceFullPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePath) *string { return v.ReplaceFullPath }).(pulumi.StringPtrOutput)
}

// ReplacePrefixMatch specifies the value with which to replace the prefix
// match of a request during a rewrite or redirect. For example, a request
// to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
// of "/xyz" would be modified to "/xyz/bar".
//
// Note that this matches the behavior of the PathPrefix match type. This
// matches full path elements. A path element refers to the list of labels
// in the path split by the `/` separator. When specified, a trailing `/` is
// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
// match the prefix `/abc`, but the path `/abcd` would not.
//
// ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
// Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
// the implementation setting the Accepted Condition for the Route to `status: False`.
//
// Request Path | Prefix Match | Replace Prefix | Modified Path
// -------------|--------------|----------------|----------
// /foo/bar     | /foo         | /xyz           | /xyz/bar
// /foo/bar     | /foo         | /xyz/          | /xyz/bar
// /foo/bar     | /foo/        | /xyz           | /xyz/bar
// /foo/bar     | /foo/        | /xyz/          | /xyz/bar
// /foo         | /foo         | /xyz           | /xyz
// /foo/        | /foo         | /xyz           | /xyz/
// /foo/bar     | /foo         | <empty string> | /bar
// /foo/        | /foo         | <empty string> | /
// /foo         | /foo         | <empty string> | /
// /foo/        | /foo         | /              | /
// /foo         | /foo         | /              | /
func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutput) ReplacePrefixMatch() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePath) *string { return v.ReplacePrefixMatch }).(pulumi.StringPtrOutput)
}

// Type defines the type of path modifier. Additional types may be
// added in a future release of the API.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePath) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePath)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput) Elem() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePath) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePath {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePath
		return ret
	}).(HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutput)
}

// ReplaceFullPath specifies the value with which to replace the full path
// of a request during a rewrite or redirect.
func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput) ReplaceFullPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePath) *string {
		if v == nil {
			return nil
		}
		return v.ReplaceFullPath
	}).(pulumi.StringPtrOutput)
}

// ReplacePrefixMatch specifies the value with which to replace the prefix
// match of a request during a rewrite or redirect. For example, a request
// to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
// of "/xyz" would be modified to "/xyz/bar".
//
// Note that this matches the behavior of the PathPrefix match type. This
// matches full path elements. A path element refers to the list of labels
// in the path split by the `/` separator. When specified, a trailing `/` is
// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
// match the prefix `/abc`, but the path `/abcd` would not.
//
// ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
// Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
// the implementation setting the Accepted Condition for the Route to `status: False`.
//
// Request Path | Prefix Match | Replace Prefix | Modified Path
// -------------|--------------|----------------|----------
// /foo/bar     | /foo         | /xyz           | /xyz/bar
// /foo/bar     | /foo         | /xyz/          | /xyz/bar
// /foo/bar     | /foo/        | /xyz           | /xyz/bar
// /foo/bar     | /foo/        | /xyz/          | /xyz/bar
// /foo         | /foo         | /xyz           | /xyz
// /foo/        | /foo         | /xyz           | /xyz/
// /foo/bar     | /foo         | <empty string> | /bar
// /foo/        | /foo         | <empty string> | /
// /foo         | /foo         | <empty string> | /
// /foo/        | /foo         | /              | /
// /foo         | /foo         | /              | /
func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput) ReplacePrefixMatch() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePath) *string {
		if v == nil {
			return nil
		}
		return v.ReplacePrefixMatch
	}).(pulumi.StringPtrOutput)
}

// Type defines the type of path modifier. Additional types may be
// added in a future release of the API.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePath) *string {
		if v == nil {
			return nil
		}
		return v.Type
	}).(pulumi.StringPtrOutput)
}

// Path defines a path rewrite.
//
// Support: Extended
type HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatch struct {
	// ReplaceFullPath specifies the value with which to replace the full path
	// of a request during a rewrite or redirect.
	ReplaceFullPath *string `pulumi:"replaceFullPath"`
	// ReplacePrefixMatch specifies the value with which to replace the prefix
	// match of a request during a rewrite or redirect. For example, a request
	// to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
	// of "/xyz" would be modified to "/xyz/bar".
	//
	// Note that this matches the behavior of the PathPrefix match type. This
	// matches full path elements. A path element refers to the list of labels
	// in the path split by the `/` separator. When specified, a trailing `/` is
	// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
	// match the prefix `/abc`, but the path `/abcd` would not.
	//
	// ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
	// Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
	// the implementation setting the Accepted Condition for the Route to `status: False`.
	//
	// Request Path | Prefix Match | Replace Prefix | Modified Path
	// -------------|--------------|----------------|----------
	// /foo/bar     | /foo         | /xyz           | /xyz/bar
	// /foo/bar     | /foo         | /xyz/          | /xyz/bar
	// /foo/bar     | /foo/        | /xyz           | /xyz/bar
	// /foo/bar     | /foo/        | /xyz/          | /xyz/bar
	// /foo         | /foo         | /xyz           | /xyz
	// /foo/        | /foo         | /xyz           | /xyz/
	// /foo/bar     | /foo         | <empty string> | /bar
	// /foo/        | /foo         | <empty string> | /
	// /foo         | /foo         | <empty string> | /
	// /foo/        | /foo         | /              | /
	// /foo         | /foo         | /              | /
	ReplacePrefixMatch *string `pulumi:"replacePrefixMatch"`
	// Type defines the type of path modifier. Additional types may be
	// added in a future release of the API.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	Type *string `pulumi:"type"`
}

// HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchArgs and HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchInput` via:
//
//	HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchArgs{...}
type HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchOutput() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchOutput
}

// Path defines a path rewrite.
//
// Support: Extended
type HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchArgs struct {
	// ReplaceFullPath specifies the value with which to replace the full path
	// of a request during a rewrite or redirect.
	ReplaceFullPath pulumi.StringPtrInput `pulumi:"replaceFullPath"`
	// ReplacePrefixMatch specifies the value with which to replace the prefix
	// match of a request during a rewrite or redirect. For example, a request
	// to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
	// of "/xyz" would be modified to "/xyz/bar".
	//
	// Note that this matches the behavior of the PathPrefix match type. This
	// matches full path elements. A path element refers to the list of labels
	// in the path split by the `/` separator. When specified, a trailing `/` is
	// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
	// match the prefix `/abc`, but the path `/abcd` would not.
	//
	// ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
	// Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
	// the implementation setting the Accepted Condition for the Route to `status: False`.
	//
	// Request Path | Prefix Match | Replace Prefix | Modified Path
	// -------------|--------------|----------------|----------
	// /foo/bar     | /foo         | /xyz           | /xyz/bar
	// /foo/bar     | /foo         | /xyz/          | /xyz/bar
	// /foo/bar     | /foo/        | /xyz           | /xyz/bar
	// /foo/bar     | /foo/        | /xyz/          | /xyz/bar
	// /foo         | /foo         | /xyz           | /xyz
	// /foo/        | /foo         | /xyz           | /xyz/
	// /foo/bar     | /foo         | <empty string> | /bar
	// /foo/        | /foo         | <empty string> | /
	// /foo         | /foo         | <empty string> | /
	// /foo/        | /foo         | /              | /
	// /foo         | /foo         | /              | /
	ReplacePrefixMatch pulumi.StringPtrInput `pulumi:"replacePrefixMatch"`
	// Type defines the type of path modifier. Additional types may be
	// added in a future release of the API.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchOutput() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchOutput)
}

func (i HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchArgs) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchOutput).ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrInput is an input type that accepts HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchArgs, HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtr and HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrInput` via:
//
//	        HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrOutput
	ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrOutput
}

type httprouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrType HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchArgs

func HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtr(v *HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchArgs) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrInput {
	return (*httprouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrType)(v)
}

func (*httprouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatch)(nil)).Elem()
}

func (i *httprouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrType) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrOutput)
}

// Path defines a path rewrite.
//
// Support: Extended
type HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchOutput() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrOutput {
	return o.ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchOutput) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatch) *HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatch {
		return &v
	}).(HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrOutput)
}

// ReplaceFullPath specifies the value with which to replace the full path
// of a request during a rewrite or redirect.
func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchOutput) ReplaceFullPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatch) *string { return v.ReplaceFullPath }).(pulumi.StringPtrOutput)
}

// ReplacePrefixMatch specifies the value with which to replace the prefix
// match of a request during a rewrite or redirect. For example, a request
// to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
// of "/xyz" would be modified to "/xyz/bar".
//
// Note that this matches the behavior of the PathPrefix match type. This
// matches full path elements. A path element refers to the list of labels
// in the path split by the `/` separator. When specified, a trailing `/` is
// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
// match the prefix `/abc`, but the path `/abcd` would not.
//
// ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
// Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
// the implementation setting the Accepted Condition for the Route to `status: False`.
//
// Request Path | Prefix Match | Replace Prefix | Modified Path
// -------------|--------------|----------------|----------
// /foo/bar     | /foo         | /xyz           | /xyz/bar
// /foo/bar     | /foo         | /xyz/          | /xyz/bar
// /foo/bar     | /foo/        | /xyz           | /xyz/bar
// /foo/bar     | /foo/        | /xyz/          | /xyz/bar
// /foo         | /foo         | /xyz           | /xyz
// /foo/        | /foo         | /xyz           | /xyz/
// /foo/bar     | /foo         | <empty string> | /bar
// /foo/        | /foo         | <empty string> | /
// /foo         | /foo         | <empty string> | /
// /foo/        | /foo         | /              | /
// /foo         | /foo         | /              | /
func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchOutput) ReplacePrefixMatch() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatch) *string { return v.ReplacePrefixMatch }).(pulumi.StringPtrOutput)
}

// Type defines the type of path modifier. Additional types may be
// added in a future release of the API.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatch) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrOutput() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrOutput) ToHTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrOutput) Elem() HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatch) HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatch {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatch
		return ret
	}).(HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchOutput)
}

// ReplaceFullPath specifies the value with which to replace the full path
// of a request during a rewrite or redirect.
func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrOutput) ReplaceFullPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatch) *string {
		if v == nil {
			return nil
		}
		return v.ReplaceFullPath
	}).(pulumi.StringPtrOutput)
}

// ReplacePrefixMatch specifies the value with which to replace the prefix
// match of a request during a rewrite or redirect. For example, a request
// to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
// of "/xyz" would be modified to "/xyz/bar".
//
// Note that this matches the behavior of the PathPrefix match type. This
// matches full path elements. A path element refers to the list of labels
// in the path split by the `/` separator. When specified, a trailing `/` is
// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
// match the prefix `/abc`, but the path `/abcd` would not.
//
// ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
// Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
// the implementation setting the Accepted Condition for the Route to `status: False`.
//
// Request Path | Prefix Match | Replace Prefix | Modified Path
// -------------|--------------|----------------|----------
// /foo/bar     | /foo         | /xyz           | /xyz/bar
// /foo/bar     | /foo         | /xyz/          | /xyz/bar
// /foo/bar     | /foo/        | /xyz           | /xyz/bar
// /foo/bar     | /foo/        | /xyz/          | /xyz/bar
// /foo         | /foo         | /xyz           | /xyz
// /foo/        | /foo         | /xyz           | /xyz/
// /foo/bar     | /foo         | <empty string> | /bar
// /foo/        | /foo         | <empty string> | /
// /foo         | /foo         | <empty string> | /
// /foo/        | /foo         | /              | /
// /foo         | /foo         | /              | /
func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrOutput) ReplacePrefixMatch() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatch) *string {
		if v == nil {
			return nil
		}
		return v.ReplacePrefixMatch
	}).(pulumi.StringPtrOutput)
}

// Type defines the type of path modifier. Additional types may be
// added in a future release of the API.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
func (o HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatch) *string {
		if v == nil {
			return nil
		}
		return v.Type
	}).(pulumi.StringPtrOutput)
}

// HTTPBackendRef defines how a HTTPRoute forwards a HTTP request.
//
// Note that when a namespace different than the local namespace is specified, a
// ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// <gateway:experimental:description>
//
// When the BackendRef points to a Kubernetes Service, implementations SHOULD
// honor the appProtocol field if it is set for the target Service Port.
//
// Implementations supporting appProtocol SHOULD recognize the Kubernetes
// Standard Application Protocols defined in KEP-3726.
//
// If a Service appProtocol isn't specified, an implementation MAY infer the
// backend protocol through its own means. Implementations MAY infer the
// protocol from the Route type referring to the backend Service.
//
// If a Route is not able to send traffic to the backend using the specified
// protocol then the backend is considered invalid. Implementations MUST set the
// "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.
//
// </gateway:experimental:description>
type HTTPRouteSpecRulesBackendRefsPatch struct {
	// Filters defined at this level should be executed if and only if the
	// request is being forwarded to the backend defined here.
	//
	// Support: Implementation-specific (For broader support of filters, use the
	// Filters field in HTTPRouteRule.)
	Filters []HTTPRouteSpecRulesBackendRefsFiltersPatch `pulumi:"filters"`
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group *string `pulumi:"group"`
	// Kind is the Kubernetes resource kind of the referent. For example
	// "Service".
	//
	// Defaults to "Service" when not specified.
	//
	// ExternalName services can refer to CNAME DNS records that may live
	// outside of the cluster and as such are difficult to reason about in
	// terms of conformance. They also may not be safe to forward to (see
	// CVE-2021-25740 for more information). Implementations SHOULD NOT
	// support ExternalName Services.
	//
	// Support: Core (Services with a type other than ExternalName)
	//
	// Support: Implementation-specific (Services with type ExternalName)
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	Name *string `pulumi:"name"`
	// Namespace is the namespace of the backend. When unspecified, the local
	// namespace is inferred.
	//
	// Note that when a namespace different than the local namespace is specified,
	// a ReferenceGrant object is required in the referent namespace to allow that
	// namespace's owner to accept the reference. See the ReferenceGrant
	// documentation for details.
	//
	// Support: Core
	Namespace *string `pulumi:"namespace"`
	// Port specifies the destination port number to use for this resource.
	// Port is required when the referent is a Kubernetes Service. In this
	// case, the port number is the service port number, not the target port.
	// For other resources, destination port might be derived from the referent
	// resource or this field.
	Port *int `pulumi:"port"`
	// Weight specifies the proportion of requests forwarded to the referenced
	// backend. This is computed as weight/(sum of all weights in this
	// BackendRefs list). For non-zero values, there may be some epsilon from
	// the exact proportion defined here depending on the precision an
	// implementation supports. Weight is not a percentage and the sum of
	// weights does not need to equal 100.
	//
	// If only one backend is specified and it has a weight greater than 0, 100%
	// of the traffic is forwarded to that backend. If weight is set to 0, no
	// traffic should be forwarded for this entry. If unspecified, weight
	// defaults to 1.
	//
	// Support for this field varies based on the context where used.
	Weight *int `pulumi:"weight"`
}

// HTTPRouteSpecRulesBackendRefsPatchInput is an input type that accepts HTTPRouteSpecRulesBackendRefsPatchArgs and HTTPRouteSpecRulesBackendRefsPatchOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsPatchInput` via:
//
//	HTTPRouteSpecRulesBackendRefsPatchArgs{...}
type HTTPRouteSpecRulesBackendRefsPatchInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsPatchOutput() HTTPRouteSpecRulesBackendRefsPatchOutput
	ToHTTPRouteSpecRulesBackendRefsPatchOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsPatchOutput
}

// HTTPBackendRef defines how a HTTPRoute forwards a HTTP request.
//
// Note that when a namespace different than the local namespace is specified, a
// ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// <gateway:experimental:description>
//
// When the BackendRef points to a Kubernetes Service, implementations SHOULD
// honor the appProtocol field if it is set for the target Service Port.
//
// Implementations supporting appProtocol SHOULD recognize the Kubernetes
// Standard Application Protocols defined in KEP-3726.
//
// If a Service appProtocol isn't specified, an implementation MAY infer the
// backend protocol through its own means. Implementations MAY infer the
// protocol from the Route type referring to the backend Service.
//
// If a Route is not able to send traffic to the backend using the specified
// protocol then the backend is considered invalid. Implementations MUST set the
// "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.
//
// </gateway:experimental:description>
type HTTPRouteSpecRulesBackendRefsPatchArgs struct {
	// Filters defined at this level should be executed if and only if the
	// request is being forwarded to the backend defined here.
	//
	// Support: Implementation-specific (For broader support of filters, use the
	// Filters field in HTTPRouteRule.)
	Filters HTTPRouteSpecRulesBackendRefsFiltersPatchArrayInput `pulumi:"filters"`
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is the Kubernetes resource kind of the referent. For example
	// "Service".
	//
	// Defaults to "Service" when not specified.
	//
	// ExternalName services can refer to CNAME DNS records that may live
	// outside of the cluster and as such are difficult to reason about in
	// terms of conformance. They also may not be safe to forward to (see
	// CVE-2021-25740 for more information). Implementations SHOULD NOT
	// support ExternalName Services.
	//
	// Support: Core (Services with a type other than ExternalName)
	//
	// Support: Implementation-specific (Services with type ExternalName)
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace is the namespace of the backend. When unspecified, the local
	// namespace is inferred.
	//
	// Note that when a namespace different than the local namespace is specified,
	// a ReferenceGrant object is required in the referent namespace to allow that
	// namespace's owner to accept the reference. See the ReferenceGrant
	// documentation for details.
	//
	// Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Port specifies the destination port number to use for this resource.
	// Port is required when the referent is a Kubernetes Service. In this
	// case, the port number is the service port number, not the target port.
	// For other resources, destination port might be derived from the referent
	// resource or this field.
	Port pulumi.IntPtrInput `pulumi:"port"`
	// Weight specifies the proportion of requests forwarded to the referenced
	// backend. This is computed as weight/(sum of all weights in this
	// BackendRefs list). For non-zero values, there may be some epsilon from
	// the exact proportion defined here depending on the precision an
	// implementation supports. Weight is not a percentage and the sum of
	// weights does not need to equal 100.
	//
	// If only one backend is specified and it has a weight greater than 0, 100%
	// of the traffic is forwarded to that backend. If weight is set to 0, no
	// traffic should be forwarded for this entry. If unspecified, weight
	// defaults to 1.
	//
	// Support for this field varies based on the context where used.
	Weight pulumi.IntPtrInput `pulumi:"weight"`
}

func (HTTPRouteSpecRulesBackendRefsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsPatchArgs) ToHTTPRouteSpecRulesBackendRefsPatchOutput() HTTPRouteSpecRulesBackendRefsPatchOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsPatchOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsPatchArgs) ToHTTPRouteSpecRulesBackendRefsPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsPatchOutput)
}

// HTTPRouteSpecRulesBackendRefsPatchArrayInput is an input type that accepts HTTPRouteSpecRulesBackendRefsPatchArray and HTTPRouteSpecRulesBackendRefsPatchArrayOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesBackendRefsPatchArrayInput` via:
//
//	HTTPRouteSpecRulesBackendRefsPatchArray{ HTTPRouteSpecRulesBackendRefsPatchArgs{...} }
type HTTPRouteSpecRulesBackendRefsPatchArrayInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesBackendRefsPatchArrayOutput() HTTPRouteSpecRulesBackendRefsPatchArrayOutput
	ToHTTPRouteSpecRulesBackendRefsPatchArrayOutputWithContext(context.Context) HTTPRouteSpecRulesBackendRefsPatchArrayOutput
}

type HTTPRouteSpecRulesBackendRefsPatchArray []HTTPRouteSpecRulesBackendRefsPatchInput

func (HTTPRouteSpecRulesBackendRefsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesBackendRefsPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesBackendRefsPatchArray) ToHTTPRouteSpecRulesBackendRefsPatchArrayOutput() HTTPRouteSpecRulesBackendRefsPatchArrayOutput {
	return i.ToHTTPRouteSpecRulesBackendRefsPatchArrayOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesBackendRefsPatchArray) ToHTTPRouteSpecRulesBackendRefsPatchArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesBackendRefsPatchArrayOutput)
}

// HTTPBackendRef defines how a HTTPRoute forwards a HTTP request.
//
// Note that when a namespace different than the local namespace is specified, a
// ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// <gateway:experimental:description>
//
// When the BackendRef points to a Kubernetes Service, implementations SHOULD
// honor the appProtocol field if it is set for the target Service Port.
//
// Implementations supporting appProtocol SHOULD recognize the Kubernetes
// Standard Application Protocols defined in KEP-3726.
//
// If a Service appProtocol isn't specified, an implementation MAY infer the
// backend protocol through its own means. Implementations MAY infer the
// protocol from the Route type referring to the backend Service.
//
// If a Route is not able to send traffic to the backend using the specified
// protocol then the backend is considered invalid. Implementations MUST set the
// "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.
//
// </gateway:experimental:description>
type HTTPRouteSpecRulesBackendRefsPatchOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsPatchOutput) ToHTTPRouteSpecRulesBackendRefsPatchOutput() HTTPRouteSpecRulesBackendRefsPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsPatchOutput) ToHTTPRouteSpecRulesBackendRefsPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsPatchOutput {
	return o
}

// Filters defined at this level should be executed if and only if the
// request is being forwarded to the backend defined here.
//
// Support: Implementation-specific (For broader support of filters, use the
// Filters field in HTTPRouteRule.)
func (o HTTPRouteSpecRulesBackendRefsPatchOutput) Filters() HTTPRouteSpecRulesBackendRefsFiltersPatchArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsPatch) []HTTPRouteSpecRulesBackendRefsFiltersPatch {
		return v.Filters
	}).(HTTPRouteSpecRulesBackendRefsFiltersPatchArrayOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o HTTPRouteSpecRulesBackendRefsPatchOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsPatch) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is the Kubernetes resource kind of the referent. For example
// "Service".
//
// Defaults to "Service" when not specified.
//
// ExternalName services can refer to CNAME DNS records that may live
// outside of the cluster and as such are difficult to reason about in
// terms of conformance. They also may not be safe to forward to (see
// CVE-2021-25740 for more information). Implementations SHOULD NOT
// support ExternalName Services.
//
// Support: Core (Services with a type other than ExternalName)
//
// Support: Implementation-specific (Services with type ExternalName)
func (o HTTPRouteSpecRulesBackendRefsPatchOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsPatch) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o HTTPRouteSpecRulesBackendRefsPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the backend. When unspecified, the local
// namespace is inferred.
//
// Note that when a namespace different than the local namespace is specified,
// a ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// Support: Core
func (o HTTPRouteSpecRulesBackendRefsPatchOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsPatch) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Port specifies the destination port number to use for this resource.
// Port is required when the referent is a Kubernetes Service. In this
// case, the port number is the service port number, not the target port.
// For other resources, destination port might be derived from the referent
// resource or this field.
func (o HTTPRouteSpecRulesBackendRefsPatchOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsPatch) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// Weight specifies the proportion of requests forwarded to the referenced
// backend. This is computed as weight/(sum of all weights in this
// BackendRefs list). For non-zero values, there may be some epsilon from
// the exact proportion defined here depending on the precision an
// implementation supports. Weight is not a percentage and the sum of
// weights does not need to equal 100.
//
// If only one backend is specified and it has a weight greater than 0, 100%
// of the traffic is forwarded to that backend. If weight is set to 0, no
// traffic should be forwarded for this entry. If unspecified, weight
// defaults to 1.
//
// Support for this field varies based on the context where used.
func (o HTTPRouteSpecRulesBackendRefsPatchOutput) Weight() pulumi.IntPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesBackendRefsPatch) *int { return v.Weight }).(pulumi.IntPtrOutput)
}

type HTTPRouteSpecRulesBackendRefsPatchArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesBackendRefsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesBackendRefsPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesBackendRefsPatchArrayOutput) ToHTTPRouteSpecRulesBackendRefsPatchArrayOutput() HTTPRouteSpecRulesBackendRefsPatchArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsPatchArrayOutput) ToHTTPRouteSpecRulesBackendRefsPatchArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesBackendRefsPatchArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesBackendRefsPatchArrayOutput) Index(i pulumi.IntInput) HTTPRouteSpecRulesBackendRefsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteSpecRulesBackendRefsPatch {
		return vs[0].([]HTTPRouteSpecRulesBackendRefsPatch)[vs[1].(int)]
	}).(HTTPRouteSpecRulesBackendRefsPatchOutput)
}

// HTTPRouteFilter defines processing steps that must be completed during the
// request or response lifecycle. HTTPRouteFilters are meant as an extension
// point to express processing that may be done in Gateway implementations. Some
// examples include request or response modification, implementing
// authentication strategies, rate-limiting, and traffic shaping. API
// guarantee/conformance is defined based on the type of the filter.
type HTTPRouteSpecRulesFilters struct {
	ExtensionRef           *HTTPRouteSpecRulesFiltersExtensionRef           `pulumi:"extensionRef"`
	RequestHeaderModifier  *HTTPRouteSpecRulesFiltersRequestHeaderModifier  `pulumi:"requestHeaderModifier"`
	RequestMirror          *HTTPRouteSpecRulesFiltersRequestMirror          `pulumi:"requestMirror"`
	RequestRedirect        *HTTPRouteSpecRulesFiltersRequestRedirect        `pulumi:"requestRedirect"`
	ResponseHeaderModifier *HTTPRouteSpecRulesFiltersResponseHeaderModifier `pulumi:"responseHeaderModifier"`
	// Type identifies the type of filter to apply. As with other API fields,
	// types are classified into three conformance levels:
	//
	// - Core: Filter types and their corresponding configuration defined by
	// "Support: Core" in this package, e.g. "RequestHeaderModifier". All
	// implementations must support core filters.
	//
	// - Extended: Filter types and their corresponding configuration defined by
	// "Support: Extended" in this package, e.g. "RequestMirror". Implementers
	// are encouraged to support extended filters.
	//
	// - Implementation-specific: Filters that are defined and supported by
	// specific vendors.
	// In the future, filters showing convergence in behavior across multiple
	// implementations will be considered for inclusion in extended or core
	// conformance levels. Filter-specific configuration for such filters
	// is specified using the ExtensionRef field. `Type` should be set to
	// "ExtensionRef" for custom filters.
	//
	// Implementers are encouraged to define custom implementation types to
	// extend the core API with implementation-specific behavior.
	//
	// If a reference to a custom filter type cannot be resolved, the filter
	// MUST NOT be skipped. Instead, requests that would have been processed by
	// that filter MUST receive a HTTP error response.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	Type       *string                              `pulumi:"type"`
	UrlRewrite *HTTPRouteSpecRulesFiltersUrlRewrite `pulumi:"urlRewrite"`
}

// HTTPRouteSpecRulesFiltersInput is an input type that accepts HTTPRouteSpecRulesFiltersArgs and HTTPRouteSpecRulesFiltersOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersInput` via:
//
//	HTTPRouteSpecRulesFiltersArgs{...}
type HTTPRouteSpecRulesFiltersInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersOutput() HTTPRouteSpecRulesFiltersOutput
	ToHTTPRouteSpecRulesFiltersOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersOutput
}

// HTTPRouteFilter defines processing steps that must be completed during the
// request or response lifecycle. HTTPRouteFilters are meant as an extension
// point to express processing that may be done in Gateway implementations. Some
// examples include request or response modification, implementing
// authentication strategies, rate-limiting, and traffic shaping. API
// guarantee/conformance is defined based on the type of the filter.
type HTTPRouteSpecRulesFiltersArgs struct {
	ExtensionRef           HTTPRouteSpecRulesFiltersExtensionRefPtrInput           `pulumi:"extensionRef"`
	RequestHeaderModifier  HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrInput  `pulumi:"requestHeaderModifier"`
	RequestMirror          HTTPRouteSpecRulesFiltersRequestMirrorPtrInput          `pulumi:"requestMirror"`
	RequestRedirect        HTTPRouteSpecRulesFiltersRequestRedirectPtrInput        `pulumi:"requestRedirect"`
	ResponseHeaderModifier HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrInput `pulumi:"responseHeaderModifier"`
	// Type identifies the type of filter to apply. As with other API fields,
	// types are classified into three conformance levels:
	//
	// - Core: Filter types and their corresponding configuration defined by
	// "Support: Core" in this package, e.g. "RequestHeaderModifier". All
	// implementations must support core filters.
	//
	// - Extended: Filter types and their corresponding configuration defined by
	// "Support: Extended" in this package, e.g. "RequestMirror". Implementers
	// are encouraged to support extended filters.
	//
	// - Implementation-specific: Filters that are defined and supported by
	// specific vendors.
	// In the future, filters showing convergence in behavior across multiple
	// implementations will be considered for inclusion in extended or core
	// conformance levels. Filter-specific configuration for such filters
	// is specified using the ExtensionRef field. `Type` should be set to
	// "ExtensionRef" for custom filters.
	//
	// Implementers are encouraged to define custom implementation types to
	// extend the core API with implementation-specific behavior.
	//
	// If a reference to a custom filter type cannot be resolved, the filter
	// MUST NOT be skipped. Instead, requests that would have been processed by
	// that filter MUST receive a HTTP error response.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	Type       pulumi.StringPtrInput                       `pulumi:"type"`
	UrlRewrite HTTPRouteSpecRulesFiltersUrlRewritePtrInput `pulumi:"urlRewrite"`
}

func (HTTPRouteSpecRulesFiltersArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFilters)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersArgs) ToHTTPRouteSpecRulesFiltersOutput() HTTPRouteSpecRulesFiltersOutput {
	return i.ToHTTPRouteSpecRulesFiltersOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersArgs) ToHTTPRouteSpecRulesFiltersOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersOutput)
}

// HTTPRouteSpecRulesFiltersArrayInput is an input type that accepts HTTPRouteSpecRulesFiltersArray and HTTPRouteSpecRulesFiltersArrayOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersArrayInput` via:
//
//	HTTPRouteSpecRulesFiltersArray{ HTTPRouteSpecRulesFiltersArgs{...} }
type HTTPRouteSpecRulesFiltersArrayInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersArrayOutput() HTTPRouteSpecRulesFiltersArrayOutput
	ToHTTPRouteSpecRulesFiltersArrayOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersArrayOutput
}

type HTTPRouteSpecRulesFiltersArray []HTTPRouteSpecRulesFiltersInput

func (HTTPRouteSpecRulesFiltersArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesFilters)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersArray) ToHTTPRouteSpecRulesFiltersArrayOutput() HTTPRouteSpecRulesFiltersArrayOutput {
	return i.ToHTTPRouteSpecRulesFiltersArrayOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersArray) ToHTTPRouteSpecRulesFiltersArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersArrayOutput)
}

// HTTPRouteFilter defines processing steps that must be completed during the
// request or response lifecycle. HTTPRouteFilters are meant as an extension
// point to express processing that may be done in Gateway implementations. Some
// examples include request or response modification, implementing
// authentication strategies, rate-limiting, and traffic shaping. API
// guarantee/conformance is defined based on the type of the filter.
type HTTPRouteSpecRulesFiltersOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFilters)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersOutput) ToHTTPRouteSpecRulesFiltersOutput() HTTPRouteSpecRulesFiltersOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersOutput) ToHTTPRouteSpecRulesFiltersOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersOutput) ExtensionRef() HTTPRouteSpecRulesFiltersExtensionRefPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFilters) *HTTPRouteSpecRulesFiltersExtensionRef { return v.ExtensionRef }).(HTTPRouteSpecRulesFiltersExtensionRefPtrOutput)
}

func (o HTTPRouteSpecRulesFiltersOutput) RequestHeaderModifier() HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFilters) *HTTPRouteSpecRulesFiltersRequestHeaderModifier {
		return v.RequestHeaderModifier
	}).(HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput)
}

func (o HTTPRouteSpecRulesFiltersOutput) RequestMirror() HTTPRouteSpecRulesFiltersRequestMirrorPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFilters) *HTTPRouteSpecRulesFiltersRequestMirror { return v.RequestMirror }).(HTTPRouteSpecRulesFiltersRequestMirrorPtrOutput)
}

func (o HTTPRouteSpecRulesFiltersOutput) RequestRedirect() HTTPRouteSpecRulesFiltersRequestRedirectPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFilters) *HTTPRouteSpecRulesFiltersRequestRedirect { return v.RequestRedirect }).(HTTPRouteSpecRulesFiltersRequestRedirectPtrOutput)
}

func (o HTTPRouteSpecRulesFiltersOutput) ResponseHeaderModifier() HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFilters) *HTTPRouteSpecRulesFiltersResponseHeaderModifier {
		return v.ResponseHeaderModifier
	}).(HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput)
}

// Type identifies the type of filter to apply. As with other API fields,
// types are classified into three conformance levels:
//
// - Core: Filter types and their corresponding configuration defined by
// "Support: Core" in this package, e.g. "RequestHeaderModifier". All
// implementations must support core filters.
//
// - Extended: Filter types and their corresponding configuration defined by
// "Support: Extended" in this package, e.g. "RequestMirror". Implementers
// are encouraged to support extended filters.
//
// - Implementation-specific: Filters that are defined and supported by
// specific vendors.
// In the future, filters showing convergence in behavior across multiple
// implementations will be considered for inclusion in extended or core
// conformance levels. Filter-specific configuration for such filters
// is specified using the ExtensionRef field. `Type` should be set to
// "ExtensionRef" for custom filters.
//
// Implementers are encouraged to define custom implementation types to
// extend the core API with implementation-specific behavior.
//
// If a reference to a custom filter type cannot be resolved, the filter
// MUST NOT be skipped. Instead, requests that would have been processed by
// that filter MUST receive a HTTP error response.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
func (o HTTPRouteSpecRulesFiltersOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFilters) *string { return v.Type }).(pulumi.StringPtrOutput)
}

func (o HTTPRouteSpecRulesFiltersOutput) UrlRewrite() HTTPRouteSpecRulesFiltersUrlRewritePtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFilters) *HTTPRouteSpecRulesFiltersUrlRewrite { return v.UrlRewrite }).(HTTPRouteSpecRulesFiltersUrlRewritePtrOutput)
}

type HTTPRouteSpecRulesFiltersArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesFilters)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersArrayOutput) ToHTTPRouteSpecRulesFiltersArrayOutput() HTTPRouteSpecRulesFiltersArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersArrayOutput) ToHTTPRouteSpecRulesFiltersArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersArrayOutput) Index(i pulumi.IntInput) HTTPRouteSpecRulesFiltersOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteSpecRulesFilters {
		return vs[0].([]HTTPRouteSpecRulesFilters)[vs[1].(int)]
	}).(HTTPRouteSpecRulesFiltersOutput)
}

// ExtensionRef is an optional, implementation-specific extension to the
// "filter" behavior.  For example, resource "myroutefilter" in group
// "networking.example.net"). ExtensionRef MUST NOT be used for core and
// extended filters.
//
// This filter can be used multiple times within the same rule.
//
// Support: Implementation-specific
type HTTPRouteSpecRulesFiltersExtensionRef struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group *string `pulumi:"group"`
	// Kind is kind of the referent. For example "HTTPRoute" or "Service".
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	Name *string `pulumi:"name"`
}

// HTTPRouteSpecRulesFiltersExtensionRefInput is an input type that accepts HTTPRouteSpecRulesFiltersExtensionRefArgs and HTTPRouteSpecRulesFiltersExtensionRefOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersExtensionRefInput` via:
//
//	HTTPRouteSpecRulesFiltersExtensionRefArgs{...}
type HTTPRouteSpecRulesFiltersExtensionRefInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersExtensionRefOutput() HTTPRouteSpecRulesFiltersExtensionRefOutput
	ToHTTPRouteSpecRulesFiltersExtensionRefOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersExtensionRefOutput
}

// ExtensionRef is an optional, implementation-specific extension to the
// "filter" behavior.  For example, resource "myroutefilter" in group
// "networking.example.net"). ExtensionRef MUST NOT be used for core and
// extended filters.
//
// This filter can be used multiple times within the same rule.
//
// Support: Implementation-specific
type HTTPRouteSpecRulesFiltersExtensionRefArgs struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is kind of the referent. For example "HTTPRoute" or "Service".
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (HTTPRouteSpecRulesFiltersExtensionRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersExtensionRef)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersExtensionRefArgs) ToHTTPRouteSpecRulesFiltersExtensionRefOutput() HTTPRouteSpecRulesFiltersExtensionRefOutput {
	return i.ToHTTPRouteSpecRulesFiltersExtensionRefOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersExtensionRefArgs) ToHTTPRouteSpecRulesFiltersExtensionRefOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersExtensionRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersExtensionRefOutput)
}

func (i HTTPRouteSpecRulesFiltersExtensionRefArgs) ToHTTPRouteSpecRulesFiltersExtensionRefPtrOutput() HTTPRouteSpecRulesFiltersExtensionRefPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersExtensionRefPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersExtensionRefArgs) ToHTTPRouteSpecRulesFiltersExtensionRefPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersExtensionRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersExtensionRefOutput).ToHTTPRouteSpecRulesFiltersExtensionRefPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesFiltersExtensionRefPtrInput is an input type that accepts HTTPRouteSpecRulesFiltersExtensionRefArgs, HTTPRouteSpecRulesFiltersExtensionRefPtr and HTTPRouteSpecRulesFiltersExtensionRefPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersExtensionRefPtrInput` via:
//
//	        HTTPRouteSpecRulesFiltersExtensionRefArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesFiltersExtensionRefPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersExtensionRefPtrOutput() HTTPRouteSpecRulesFiltersExtensionRefPtrOutput
	ToHTTPRouteSpecRulesFiltersExtensionRefPtrOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersExtensionRefPtrOutput
}

type httprouteSpecRulesFiltersExtensionRefPtrType HTTPRouteSpecRulesFiltersExtensionRefArgs

func HTTPRouteSpecRulesFiltersExtensionRefPtr(v *HTTPRouteSpecRulesFiltersExtensionRefArgs) HTTPRouteSpecRulesFiltersExtensionRefPtrInput {
	return (*httprouteSpecRulesFiltersExtensionRefPtrType)(v)
}

func (*httprouteSpecRulesFiltersExtensionRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersExtensionRef)(nil)).Elem()
}

func (i *httprouteSpecRulesFiltersExtensionRefPtrType) ToHTTPRouteSpecRulesFiltersExtensionRefPtrOutput() HTTPRouteSpecRulesFiltersExtensionRefPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersExtensionRefPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesFiltersExtensionRefPtrType) ToHTTPRouteSpecRulesFiltersExtensionRefPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersExtensionRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersExtensionRefPtrOutput)
}

// ExtensionRef is an optional, implementation-specific extension to the
// "filter" behavior.  For example, resource "myroutefilter" in group
// "networking.example.net"). ExtensionRef MUST NOT be used for core and
// extended filters.
//
// This filter can be used multiple times within the same rule.
//
// Support: Implementation-specific
type HTTPRouteSpecRulesFiltersExtensionRefOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersExtensionRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersExtensionRef)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersExtensionRefOutput) ToHTTPRouteSpecRulesFiltersExtensionRefOutput() HTTPRouteSpecRulesFiltersExtensionRefOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersExtensionRefOutput) ToHTTPRouteSpecRulesFiltersExtensionRefOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersExtensionRefOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersExtensionRefOutput) ToHTTPRouteSpecRulesFiltersExtensionRefPtrOutput() HTTPRouteSpecRulesFiltersExtensionRefPtrOutput {
	return o.ToHTTPRouteSpecRulesFiltersExtensionRefPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesFiltersExtensionRefOutput) ToHTTPRouteSpecRulesFiltersExtensionRefPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersExtensionRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesFiltersExtensionRef) *HTTPRouteSpecRulesFiltersExtensionRef {
		return &v
	}).(HTTPRouteSpecRulesFiltersExtensionRefPtrOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o HTTPRouteSpecRulesFiltersExtensionRefOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersExtensionRef) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent. For example "HTTPRoute" or "Service".
func (o HTTPRouteSpecRulesFiltersExtensionRefOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersExtensionRef) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o HTTPRouteSpecRulesFiltersExtensionRefOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersExtensionRef) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type HTTPRouteSpecRulesFiltersExtensionRefPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersExtensionRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersExtensionRef)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersExtensionRefPtrOutput) ToHTTPRouteSpecRulesFiltersExtensionRefPtrOutput() HTTPRouteSpecRulesFiltersExtensionRefPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersExtensionRefPtrOutput) ToHTTPRouteSpecRulesFiltersExtensionRefPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersExtensionRefPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersExtensionRefPtrOutput) Elem() HTTPRouteSpecRulesFiltersExtensionRefOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersExtensionRef) HTTPRouteSpecRulesFiltersExtensionRef {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesFiltersExtensionRef
		return ret
	}).(HTTPRouteSpecRulesFiltersExtensionRefOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o HTTPRouteSpecRulesFiltersExtensionRefPtrOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersExtensionRef) *string {
		if v == nil {
			return nil
		}
		return v.Group
	}).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent. For example "HTTPRoute" or "Service".
func (o HTTPRouteSpecRulesFiltersExtensionRefPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersExtensionRef) *string {
		if v == nil {
			return nil
		}
		return v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o HTTPRouteSpecRulesFiltersExtensionRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersExtensionRef) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// ExtensionRef is an optional, implementation-specific extension to the
// "filter" behavior.  For example, resource "myroutefilter" in group
// "networking.example.net"). ExtensionRef MUST NOT be used for core and
// extended filters.
//
// This filter can be used multiple times within the same rule.
//
// Support: Implementation-specific
type HTTPRouteSpecRulesFiltersExtensionRefPatch struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group *string `pulumi:"group"`
	// Kind is kind of the referent. For example "HTTPRoute" or "Service".
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	Name *string `pulumi:"name"`
}

// HTTPRouteSpecRulesFiltersExtensionRefPatchInput is an input type that accepts HTTPRouteSpecRulesFiltersExtensionRefPatchArgs and HTTPRouteSpecRulesFiltersExtensionRefPatchOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersExtensionRefPatchInput` via:
//
//	HTTPRouteSpecRulesFiltersExtensionRefPatchArgs{...}
type HTTPRouteSpecRulesFiltersExtensionRefPatchInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersExtensionRefPatchOutput() HTTPRouteSpecRulesFiltersExtensionRefPatchOutput
	ToHTTPRouteSpecRulesFiltersExtensionRefPatchOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersExtensionRefPatchOutput
}

// ExtensionRef is an optional, implementation-specific extension to the
// "filter" behavior.  For example, resource "myroutefilter" in group
// "networking.example.net"). ExtensionRef MUST NOT be used for core and
// extended filters.
//
// This filter can be used multiple times within the same rule.
//
// Support: Implementation-specific
type HTTPRouteSpecRulesFiltersExtensionRefPatchArgs struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is kind of the referent. For example "HTTPRoute" or "Service".
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (HTTPRouteSpecRulesFiltersExtensionRefPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersExtensionRefPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersExtensionRefPatchArgs) ToHTTPRouteSpecRulesFiltersExtensionRefPatchOutput() HTTPRouteSpecRulesFiltersExtensionRefPatchOutput {
	return i.ToHTTPRouteSpecRulesFiltersExtensionRefPatchOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersExtensionRefPatchArgs) ToHTTPRouteSpecRulesFiltersExtensionRefPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersExtensionRefPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersExtensionRefPatchOutput)
}

func (i HTTPRouteSpecRulesFiltersExtensionRefPatchArgs) ToHTTPRouteSpecRulesFiltersExtensionRefPatchPtrOutput() HTTPRouteSpecRulesFiltersExtensionRefPatchPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersExtensionRefPatchPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersExtensionRefPatchArgs) ToHTTPRouteSpecRulesFiltersExtensionRefPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersExtensionRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersExtensionRefPatchOutput).ToHTTPRouteSpecRulesFiltersExtensionRefPatchPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesFiltersExtensionRefPatchPtrInput is an input type that accepts HTTPRouteSpecRulesFiltersExtensionRefPatchArgs, HTTPRouteSpecRulesFiltersExtensionRefPatchPtr and HTTPRouteSpecRulesFiltersExtensionRefPatchPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersExtensionRefPatchPtrInput` via:
//
//	        HTTPRouteSpecRulesFiltersExtensionRefPatchArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesFiltersExtensionRefPatchPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersExtensionRefPatchPtrOutput() HTTPRouteSpecRulesFiltersExtensionRefPatchPtrOutput
	ToHTTPRouteSpecRulesFiltersExtensionRefPatchPtrOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersExtensionRefPatchPtrOutput
}

type httprouteSpecRulesFiltersExtensionRefPatchPtrType HTTPRouteSpecRulesFiltersExtensionRefPatchArgs

func HTTPRouteSpecRulesFiltersExtensionRefPatchPtr(v *HTTPRouteSpecRulesFiltersExtensionRefPatchArgs) HTTPRouteSpecRulesFiltersExtensionRefPatchPtrInput {
	return (*httprouteSpecRulesFiltersExtensionRefPatchPtrType)(v)
}

func (*httprouteSpecRulesFiltersExtensionRefPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersExtensionRefPatch)(nil)).Elem()
}

func (i *httprouteSpecRulesFiltersExtensionRefPatchPtrType) ToHTTPRouteSpecRulesFiltersExtensionRefPatchPtrOutput() HTTPRouteSpecRulesFiltersExtensionRefPatchPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersExtensionRefPatchPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesFiltersExtensionRefPatchPtrType) ToHTTPRouteSpecRulesFiltersExtensionRefPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersExtensionRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersExtensionRefPatchPtrOutput)
}

// ExtensionRef is an optional, implementation-specific extension to the
// "filter" behavior.  For example, resource "myroutefilter" in group
// "networking.example.net"). ExtensionRef MUST NOT be used for core and
// extended filters.
//
// This filter can be used multiple times within the same rule.
//
// Support: Implementation-specific
type HTTPRouteSpecRulesFiltersExtensionRefPatchOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersExtensionRefPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersExtensionRefPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersExtensionRefPatchOutput) ToHTTPRouteSpecRulesFiltersExtensionRefPatchOutput() HTTPRouteSpecRulesFiltersExtensionRefPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersExtensionRefPatchOutput) ToHTTPRouteSpecRulesFiltersExtensionRefPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersExtensionRefPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersExtensionRefPatchOutput) ToHTTPRouteSpecRulesFiltersExtensionRefPatchPtrOutput() HTTPRouteSpecRulesFiltersExtensionRefPatchPtrOutput {
	return o.ToHTTPRouteSpecRulesFiltersExtensionRefPatchPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesFiltersExtensionRefPatchOutput) ToHTTPRouteSpecRulesFiltersExtensionRefPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersExtensionRefPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesFiltersExtensionRefPatch) *HTTPRouteSpecRulesFiltersExtensionRefPatch {
		return &v
	}).(HTTPRouteSpecRulesFiltersExtensionRefPatchPtrOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o HTTPRouteSpecRulesFiltersExtensionRefPatchOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersExtensionRefPatch) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent. For example "HTTPRoute" or "Service".
func (o HTTPRouteSpecRulesFiltersExtensionRefPatchOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersExtensionRefPatch) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o HTTPRouteSpecRulesFiltersExtensionRefPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersExtensionRefPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type HTTPRouteSpecRulesFiltersExtensionRefPatchPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersExtensionRefPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersExtensionRefPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersExtensionRefPatchPtrOutput) ToHTTPRouteSpecRulesFiltersExtensionRefPatchPtrOutput() HTTPRouteSpecRulesFiltersExtensionRefPatchPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersExtensionRefPatchPtrOutput) ToHTTPRouteSpecRulesFiltersExtensionRefPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersExtensionRefPatchPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersExtensionRefPatchPtrOutput) Elem() HTTPRouteSpecRulesFiltersExtensionRefPatchOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersExtensionRefPatch) HTTPRouteSpecRulesFiltersExtensionRefPatch {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesFiltersExtensionRefPatch
		return ret
	}).(HTTPRouteSpecRulesFiltersExtensionRefPatchOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o HTTPRouteSpecRulesFiltersExtensionRefPatchPtrOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersExtensionRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Group
	}).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent. For example "HTTPRoute" or "Service".
func (o HTTPRouteSpecRulesFiltersExtensionRefPatchPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersExtensionRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o HTTPRouteSpecRulesFiltersExtensionRefPatchPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersExtensionRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// HTTPRouteFilter defines processing steps that must be completed during the
// request or response lifecycle. HTTPRouteFilters are meant as an extension
// point to express processing that may be done in Gateway implementations. Some
// examples include request or response modification, implementing
// authentication strategies, rate-limiting, and traffic shaping. API
// guarantee/conformance is defined based on the type of the filter.
type HTTPRouteSpecRulesFiltersPatch struct {
	ExtensionRef           *HTTPRouteSpecRulesFiltersExtensionRefPatch           `pulumi:"extensionRef"`
	RequestHeaderModifier  *HTTPRouteSpecRulesFiltersRequestHeaderModifierPatch  `pulumi:"requestHeaderModifier"`
	RequestMirror          *HTTPRouteSpecRulesFiltersRequestMirrorPatch          `pulumi:"requestMirror"`
	RequestRedirect        *HTTPRouteSpecRulesFiltersRequestRedirectPatch        `pulumi:"requestRedirect"`
	ResponseHeaderModifier *HTTPRouteSpecRulesFiltersResponseHeaderModifierPatch `pulumi:"responseHeaderModifier"`
	// Type identifies the type of filter to apply. As with other API fields,
	// types are classified into three conformance levels:
	//
	// - Core: Filter types and their corresponding configuration defined by
	// "Support: Core" in this package, e.g. "RequestHeaderModifier". All
	// implementations must support core filters.
	//
	// - Extended: Filter types and their corresponding configuration defined by
	// "Support: Extended" in this package, e.g. "RequestMirror". Implementers
	// are encouraged to support extended filters.
	//
	// - Implementation-specific: Filters that are defined and supported by
	// specific vendors.
	// In the future, filters showing convergence in behavior across multiple
	// implementations will be considered for inclusion in extended or core
	// conformance levels. Filter-specific configuration for such filters
	// is specified using the ExtensionRef field. `Type` should be set to
	// "ExtensionRef" for custom filters.
	//
	// Implementers are encouraged to define custom implementation types to
	// extend the core API with implementation-specific behavior.
	//
	// If a reference to a custom filter type cannot be resolved, the filter
	// MUST NOT be skipped. Instead, requests that would have been processed by
	// that filter MUST receive a HTTP error response.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	Type       *string                                   `pulumi:"type"`
	UrlRewrite *HTTPRouteSpecRulesFiltersUrlRewritePatch `pulumi:"urlRewrite"`
}

// HTTPRouteSpecRulesFiltersPatchInput is an input type that accepts HTTPRouteSpecRulesFiltersPatchArgs and HTTPRouteSpecRulesFiltersPatchOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersPatchInput` via:
//
//	HTTPRouteSpecRulesFiltersPatchArgs{...}
type HTTPRouteSpecRulesFiltersPatchInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersPatchOutput() HTTPRouteSpecRulesFiltersPatchOutput
	ToHTTPRouteSpecRulesFiltersPatchOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersPatchOutput
}

// HTTPRouteFilter defines processing steps that must be completed during the
// request or response lifecycle. HTTPRouteFilters are meant as an extension
// point to express processing that may be done in Gateway implementations. Some
// examples include request or response modification, implementing
// authentication strategies, rate-limiting, and traffic shaping. API
// guarantee/conformance is defined based on the type of the filter.
type HTTPRouteSpecRulesFiltersPatchArgs struct {
	ExtensionRef           HTTPRouteSpecRulesFiltersExtensionRefPatchPtrInput           `pulumi:"extensionRef"`
	RequestHeaderModifier  HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrInput  `pulumi:"requestHeaderModifier"`
	RequestMirror          HTTPRouteSpecRulesFiltersRequestMirrorPatchPtrInput          `pulumi:"requestMirror"`
	RequestRedirect        HTTPRouteSpecRulesFiltersRequestRedirectPatchPtrInput        `pulumi:"requestRedirect"`
	ResponseHeaderModifier HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrInput `pulumi:"responseHeaderModifier"`
	// Type identifies the type of filter to apply. As with other API fields,
	// types are classified into three conformance levels:
	//
	// - Core: Filter types and their corresponding configuration defined by
	// "Support: Core" in this package, e.g. "RequestHeaderModifier". All
	// implementations must support core filters.
	//
	// - Extended: Filter types and their corresponding configuration defined by
	// "Support: Extended" in this package, e.g. "RequestMirror". Implementers
	// are encouraged to support extended filters.
	//
	// - Implementation-specific: Filters that are defined and supported by
	// specific vendors.
	// In the future, filters showing convergence in behavior across multiple
	// implementations will be considered for inclusion in extended or core
	// conformance levels. Filter-specific configuration for such filters
	// is specified using the ExtensionRef field. `Type` should be set to
	// "ExtensionRef" for custom filters.
	//
	// Implementers are encouraged to define custom implementation types to
	// extend the core API with implementation-specific behavior.
	//
	// If a reference to a custom filter type cannot be resolved, the filter
	// MUST NOT be skipped. Instead, requests that would have been processed by
	// that filter MUST receive a HTTP error response.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	Type       pulumi.StringPtrInput                            `pulumi:"type"`
	UrlRewrite HTTPRouteSpecRulesFiltersUrlRewritePatchPtrInput `pulumi:"urlRewrite"`
}

func (HTTPRouteSpecRulesFiltersPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersPatchArgs) ToHTTPRouteSpecRulesFiltersPatchOutput() HTTPRouteSpecRulesFiltersPatchOutput {
	return i.ToHTTPRouteSpecRulesFiltersPatchOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersPatchArgs) ToHTTPRouteSpecRulesFiltersPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersPatchOutput)
}

// HTTPRouteSpecRulesFiltersPatchArrayInput is an input type that accepts HTTPRouteSpecRulesFiltersPatchArray and HTTPRouteSpecRulesFiltersPatchArrayOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersPatchArrayInput` via:
//
//	HTTPRouteSpecRulesFiltersPatchArray{ HTTPRouteSpecRulesFiltersPatchArgs{...} }
type HTTPRouteSpecRulesFiltersPatchArrayInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersPatchArrayOutput() HTTPRouteSpecRulesFiltersPatchArrayOutput
	ToHTTPRouteSpecRulesFiltersPatchArrayOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersPatchArrayOutput
}

type HTTPRouteSpecRulesFiltersPatchArray []HTTPRouteSpecRulesFiltersPatchInput

func (HTTPRouteSpecRulesFiltersPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesFiltersPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersPatchArray) ToHTTPRouteSpecRulesFiltersPatchArrayOutput() HTTPRouteSpecRulesFiltersPatchArrayOutput {
	return i.ToHTTPRouteSpecRulesFiltersPatchArrayOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersPatchArray) ToHTTPRouteSpecRulesFiltersPatchArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersPatchArrayOutput)
}

// HTTPRouteFilter defines processing steps that must be completed during the
// request or response lifecycle. HTTPRouteFilters are meant as an extension
// point to express processing that may be done in Gateway implementations. Some
// examples include request or response modification, implementing
// authentication strategies, rate-limiting, and traffic shaping. API
// guarantee/conformance is defined based on the type of the filter.
type HTTPRouteSpecRulesFiltersPatchOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersPatchOutput) ToHTTPRouteSpecRulesFiltersPatchOutput() HTTPRouteSpecRulesFiltersPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersPatchOutput) ToHTTPRouteSpecRulesFiltersPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersPatchOutput) ExtensionRef() HTTPRouteSpecRulesFiltersExtensionRefPatchPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersPatch) *HTTPRouteSpecRulesFiltersExtensionRefPatch {
		return v.ExtensionRef
	}).(HTTPRouteSpecRulesFiltersExtensionRefPatchPtrOutput)
}

func (o HTTPRouteSpecRulesFiltersPatchOutput) RequestHeaderModifier() HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersPatch) *HTTPRouteSpecRulesFiltersRequestHeaderModifierPatch {
		return v.RequestHeaderModifier
	}).(HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput)
}

func (o HTTPRouteSpecRulesFiltersPatchOutput) RequestMirror() HTTPRouteSpecRulesFiltersRequestMirrorPatchPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersPatch) *HTTPRouteSpecRulesFiltersRequestMirrorPatch {
		return v.RequestMirror
	}).(HTTPRouteSpecRulesFiltersRequestMirrorPatchPtrOutput)
}

func (o HTTPRouteSpecRulesFiltersPatchOutput) RequestRedirect() HTTPRouteSpecRulesFiltersRequestRedirectPatchPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersPatch) *HTTPRouteSpecRulesFiltersRequestRedirectPatch {
		return v.RequestRedirect
	}).(HTTPRouteSpecRulesFiltersRequestRedirectPatchPtrOutput)
}

func (o HTTPRouteSpecRulesFiltersPatchOutput) ResponseHeaderModifier() HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersPatch) *HTTPRouteSpecRulesFiltersResponseHeaderModifierPatch {
		return v.ResponseHeaderModifier
	}).(HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput)
}

// Type identifies the type of filter to apply. As with other API fields,
// types are classified into three conformance levels:
//
// - Core: Filter types and their corresponding configuration defined by
// "Support: Core" in this package, e.g. "RequestHeaderModifier". All
// implementations must support core filters.
//
// - Extended: Filter types and their corresponding configuration defined by
// "Support: Extended" in this package, e.g. "RequestMirror". Implementers
// are encouraged to support extended filters.
//
// - Implementation-specific: Filters that are defined and supported by
// specific vendors.
// In the future, filters showing convergence in behavior across multiple
// implementations will be considered for inclusion in extended or core
// conformance levels. Filter-specific configuration for such filters
// is specified using the ExtensionRef field. `Type` should be set to
// "ExtensionRef" for custom filters.
//
// Implementers are encouraged to define custom implementation types to
// extend the core API with implementation-specific behavior.
//
// If a reference to a custom filter type cannot be resolved, the filter
// MUST NOT be skipped. Instead, requests that would have been processed by
// that filter MUST receive a HTTP error response.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
func (o HTTPRouteSpecRulesFiltersPatchOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersPatch) *string { return v.Type }).(pulumi.StringPtrOutput)
}

func (o HTTPRouteSpecRulesFiltersPatchOutput) UrlRewrite() HTTPRouteSpecRulesFiltersUrlRewritePatchPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersPatch) *HTTPRouteSpecRulesFiltersUrlRewritePatch { return v.UrlRewrite }).(HTTPRouteSpecRulesFiltersUrlRewritePatchPtrOutput)
}

type HTTPRouteSpecRulesFiltersPatchArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesFiltersPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersPatchArrayOutput) ToHTTPRouteSpecRulesFiltersPatchArrayOutput() HTTPRouteSpecRulesFiltersPatchArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersPatchArrayOutput) ToHTTPRouteSpecRulesFiltersPatchArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersPatchArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersPatchArrayOutput) Index(i pulumi.IntInput) HTTPRouteSpecRulesFiltersPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteSpecRulesFiltersPatch {
		return vs[0].([]HTTPRouteSpecRulesFiltersPatch)[vs[1].(int)]
	}).(HTTPRouteSpecRulesFiltersPatchOutput)
}

// RequestHeaderModifier defines a schema for a filter that modifies request
// headers.
//
// Support: Core
type HTTPRouteSpecRulesFiltersRequestHeaderModifier struct {
	// Add adds the given header(s) (name, value) to the request
	// before the action. It appends to any existing values associated
	// with the header name.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   add:
	//   - name: "my-header"
	//     value: "bar,baz"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: foo,bar,baz
	Add []HTTPRouteSpecRulesFiltersRequestHeaderModifierAdd `pulumi:"add"`
	// Remove the given header(s) from the HTTP request before the action. The
	// value of Remove is a list of HTTP header names. Note that the header
	// names are case-insensitive (see
	// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header1: foo
	//   my-header2: bar
	//   my-header3: baz
	//
	// Config:
	//   remove: ["my-header1", "my-header3"]
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header2: bar
	Remove []string `pulumi:"remove"`
	// Set overwrites the request with the given header (name, value)
	// before the action.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   set:
	//   - name: "my-header"
	//     value: "bar"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: bar
	Set []HTTPRouteSpecRulesFiltersRequestHeaderModifierSet `pulumi:"set"`
}

// HTTPRouteSpecRulesFiltersRequestHeaderModifierInput is an input type that accepts HTTPRouteSpecRulesFiltersRequestHeaderModifierArgs and HTTPRouteSpecRulesFiltersRequestHeaderModifierOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersRequestHeaderModifierInput` via:
//
//	HTTPRouteSpecRulesFiltersRequestHeaderModifierArgs{...}
type HTTPRouteSpecRulesFiltersRequestHeaderModifierInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersRequestHeaderModifierOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierOutput
	ToHTTPRouteSpecRulesFiltersRequestHeaderModifierOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierOutput
}

// RequestHeaderModifier defines a schema for a filter that modifies request
// headers.
//
// Support: Core
type HTTPRouteSpecRulesFiltersRequestHeaderModifierArgs struct {
	// Add adds the given header(s) (name, value) to the request
	// before the action. It appends to any existing values associated
	// with the header name.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   add:
	//   - name: "my-header"
	//     value: "bar,baz"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: foo,bar,baz
	Add HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayInput `pulumi:"add"`
	// Remove the given header(s) from the HTTP request before the action. The
	// value of Remove is a list of HTTP header names. Note that the header
	// names are case-insensitive (see
	// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header1: foo
	//   my-header2: bar
	//   my-header3: baz
	//
	// Config:
	//   remove: ["my-header1", "my-header3"]
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header2: bar
	Remove pulumi.StringArrayInput `pulumi:"remove"`
	// Set overwrites the request with the given header (name, value)
	// before the action.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   set:
	//   - name: "my-header"
	//     value: "bar"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: bar
	Set HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayInput `pulumi:"set"`
}

func (HTTPRouteSpecRulesFiltersRequestHeaderModifierArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestHeaderModifier)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersRequestHeaderModifierArgs) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestHeaderModifierOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersRequestHeaderModifierArgs) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestHeaderModifierOutput)
}

func (i HTTPRouteSpecRulesFiltersRequestHeaderModifierArgs) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersRequestHeaderModifierArgs) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestHeaderModifierOutput).ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrInput is an input type that accepts HTTPRouteSpecRulesFiltersRequestHeaderModifierArgs, HTTPRouteSpecRulesFiltersRequestHeaderModifierPtr and HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrInput` via:
//
//	        HTTPRouteSpecRulesFiltersRequestHeaderModifierArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput
	ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput
}

type httprouteSpecRulesFiltersRequestHeaderModifierPtrType HTTPRouteSpecRulesFiltersRequestHeaderModifierArgs

func HTTPRouteSpecRulesFiltersRequestHeaderModifierPtr(v *HTTPRouteSpecRulesFiltersRequestHeaderModifierArgs) HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrInput {
	return (*httprouteSpecRulesFiltersRequestHeaderModifierPtrType)(v)
}

func (*httprouteSpecRulesFiltersRequestHeaderModifierPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersRequestHeaderModifier)(nil)).Elem()
}

func (i *httprouteSpecRulesFiltersRequestHeaderModifierPtrType) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesFiltersRequestHeaderModifierPtrType) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput)
}

// RequestHeaderModifier defines a schema for a filter that modifies request
// headers.
//
// Support: Core
type HTTPRouteSpecRulesFiltersRequestHeaderModifierOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersRequestHeaderModifierOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestHeaderModifier)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierOutput) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierOutput) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierOutput) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput {
	return o.ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierOutput) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesFiltersRequestHeaderModifier) *HTTPRouteSpecRulesFiltersRequestHeaderModifier {
		return &v
	}).(HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput)
}

// Add adds the given header(s) (name, value) to the request
// before the action. It appends to any existing values associated
// with the header name.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	add:
//	- name: "my-header"
//	  value: "bar,baz"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: foo,bar,baz
func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierOutput) Add() HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestHeaderModifier) []HTTPRouteSpecRulesFiltersRequestHeaderModifierAdd {
		return v.Add
	}).(HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput)
}

// Remove the given header(s) from the HTTP request before the action. The
// value of Remove is a list of HTTP header names. Note that the header
// names are case-insensitive (see
// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header1: foo
//	my-header2: bar
//	my-header3: baz
//
// Config:
//
//	remove: ["my-header1", "my-header3"]
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header2: bar
func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierOutput) Remove() pulumi.StringArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestHeaderModifier) []string { return v.Remove }).(pulumi.StringArrayOutput)
}

// Set overwrites the request with the given header (name, value)
// before the action.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	set:
//	- name: "my-header"
//	  value: "bar"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: bar
func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierOutput) Set() HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestHeaderModifier) []HTTPRouteSpecRulesFiltersRequestHeaderModifierSet {
		return v.Set
	}).(HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput)
}

type HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersRequestHeaderModifier)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput) Elem() HTTPRouteSpecRulesFiltersRequestHeaderModifierOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestHeaderModifier) HTTPRouteSpecRulesFiltersRequestHeaderModifier {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesFiltersRequestHeaderModifier
		return ret
	}).(HTTPRouteSpecRulesFiltersRequestHeaderModifierOutput)
}

// Add adds the given header(s) (name, value) to the request
// before the action. It appends to any existing values associated
// with the header name.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	add:
//	- name: "my-header"
//	  value: "bar,baz"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: foo,bar,baz
func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput) Add() HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestHeaderModifier) []HTTPRouteSpecRulesFiltersRequestHeaderModifierAdd {
		if v == nil {
			return nil
		}
		return v.Add
	}).(HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput)
}

// Remove the given header(s) from the HTTP request before the action. The
// value of Remove is a list of HTTP header names. Note that the header
// names are case-insensitive (see
// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header1: foo
//	my-header2: bar
//	my-header3: baz
//
// Config:
//
//	remove: ["my-header1", "my-header3"]
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header2: bar
func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput) Remove() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestHeaderModifier) []string {
		if v == nil {
			return nil
		}
		return v.Remove
	}).(pulumi.StringArrayOutput)
}

// Set overwrites the request with the given header (name, value)
// before the action.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	set:
//	- name: "my-header"
//	  value: "bar"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: bar
func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput) Set() HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestHeaderModifier) []HTTPRouteSpecRulesFiltersRequestHeaderModifierSet {
		if v == nil {
			return nil
		}
		return v.Set
	}).(HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesFiltersRequestHeaderModifierAdd struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name *string `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value *string `pulumi:"value"`
}

// HTTPRouteSpecRulesFiltersRequestHeaderModifierAddInput is an input type that accepts HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArgs and HTTPRouteSpecRulesFiltersRequestHeaderModifierAddOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersRequestHeaderModifierAddInput` via:
//
//	HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArgs{...}
type HTTPRouteSpecRulesFiltersRequestHeaderModifierAddInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersRequestHeaderModifierAddOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierAddOutput
	ToHTTPRouteSpecRulesFiltersRequestHeaderModifierAddOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierAddOutput
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArgs struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestHeaderModifierAdd)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArgs) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierAddOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierAddOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestHeaderModifierAddOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArgs) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierAddOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierAddOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestHeaderModifierAddOutput)
}

// HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayInput is an input type that accepts HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArray and HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayInput` via:
//
//	HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArray{ HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArgs{...} }
type HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput
	ToHTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput
}

type HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArray []HTTPRouteSpecRulesFiltersRequestHeaderModifierAddInput

func (HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesFiltersRequestHeaderModifierAdd)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArray) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArray) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesFiltersRequestHeaderModifierAddOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersRequestHeaderModifierAddOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestHeaderModifierAdd)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierAddOutput) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierAddOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierAddOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierAddOutput) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierAddOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierAddOutput {
	return o
}

// Name is the name of the HTTP Header to be matched. Name matching MUST be
// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
//
// If multiple entries specify equivalent header names, the first entry with
// an equivalent name MUST be considered for a match. Subsequent entries
// with an equivalent header name MUST be ignored. Due to the
// case-insensitivity of header names, "foo" and "Foo" are considered
// equivalent.
func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierAddOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestHeaderModifierAdd) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Value is the value of HTTP Header to be matched.
func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierAddOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestHeaderModifierAdd) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesFiltersRequestHeaderModifierAdd)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput) Index(i pulumi.IntInput) HTTPRouteSpecRulesFiltersRequestHeaderModifierAddOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteSpecRulesFiltersRequestHeaderModifierAdd {
		return vs[0].([]HTTPRouteSpecRulesFiltersRequestHeaderModifierAdd)[vs[1].(int)]
	}).(HTTPRouteSpecRulesFiltersRequestHeaderModifierAddOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatch struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name *string `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value *string `pulumi:"value"`
}

// HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchInput is an input type that accepts HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArgs and HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchInput` via:
//
//	HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArgs{...}
type HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchOutput
	ToHTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchOutput
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArgs struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArgs) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArgs) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchOutput)
}

// HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayInput is an input type that accepts HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArray and HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayInput` via:
//
//	HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArray{ HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArgs{...} }
type HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayOutput
	ToHTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayOutput
}

type HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArray []HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchInput

func (HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArray) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArray) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchOutput) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchOutput) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchOutput {
	return o
}

// Name is the name of the HTTP Header to be matched. Name matching MUST be
// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
//
// If multiple entries specify equivalent header names, the first entry with
// an equivalent name MUST be considered for a match. Subsequent entries
// with an equivalent header name MUST be ignored. Due to the
// case-insensitivity of header names, "foo" and "Foo" are considered
// equivalent.
func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Value is the value of HTTP Header to be matched.
func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatch) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayOutput) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayOutput) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayOutput) Index(i pulumi.IntInput) HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatch {
		return vs[0].([]HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatch)[vs[1].(int)]
	}).(HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchOutput)
}

// RequestHeaderModifier defines a schema for a filter that modifies request
// headers.
//
// Support: Core
type HTTPRouteSpecRulesFiltersRequestHeaderModifierPatch struct {
	// Add adds the given header(s) (name, value) to the request
	// before the action. It appends to any existing values associated
	// with the header name.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   add:
	//   - name: "my-header"
	//     value: "bar,baz"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: foo,bar,baz
	Add []HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatch `pulumi:"add"`
	// Remove the given header(s) from the HTTP request before the action. The
	// value of Remove is a list of HTTP header names. Note that the header
	// names are case-insensitive (see
	// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header1: foo
	//   my-header2: bar
	//   my-header3: baz
	//
	// Config:
	//   remove: ["my-header1", "my-header3"]
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header2: bar
	Remove []string `pulumi:"remove"`
	// Set overwrites the request with the given header (name, value)
	// before the action.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   set:
	//   - name: "my-header"
	//     value: "bar"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: bar
	Set []HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatch `pulumi:"set"`
}

// HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchInput is an input type that accepts HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchArgs and HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchInput` via:
//
//	HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchArgs{...}
type HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPatchOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchOutput
	ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPatchOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchOutput
}

// RequestHeaderModifier defines a schema for a filter that modifies request
// headers.
//
// Support: Core
type HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchArgs struct {
	// Add adds the given header(s) (name, value) to the request
	// before the action. It appends to any existing values associated
	// with the header name.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   add:
	//   - name: "my-header"
	//     value: "bar,baz"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: foo,bar,baz
	Add HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayInput `pulumi:"add"`
	// Remove the given header(s) from the HTTP request before the action. The
	// value of Remove is a list of HTTP header names. Note that the header
	// names are case-insensitive (see
	// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header1: foo
	//   my-header2: bar
	//   my-header3: baz
	//
	// Config:
	//   remove: ["my-header1", "my-header3"]
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header2: bar
	Remove pulumi.StringArrayInput `pulumi:"remove"`
	// Set overwrites the request with the given header (name, value)
	// before the action.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   set:
	//   - name: "my-header"
	//     value: "bar"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: bar
	Set HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayInput `pulumi:"set"`
}

func (HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestHeaderModifierPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchArgs) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPatchOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPatchOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchArgs) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchOutput)
}

func (i HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchArgs) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchArgs) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchOutput).ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrInput is an input type that accepts HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchArgs, HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtr and HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrInput` via:
//
//	        HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput
	ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput
}

type httprouteSpecRulesFiltersRequestHeaderModifierPatchPtrType HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchArgs

func HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtr(v *HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchArgs) HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrInput {
	return (*httprouteSpecRulesFiltersRequestHeaderModifierPatchPtrType)(v)
}

func (*httprouteSpecRulesFiltersRequestHeaderModifierPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersRequestHeaderModifierPatch)(nil)).Elem()
}

func (i *httprouteSpecRulesFiltersRequestHeaderModifierPatchPtrType) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesFiltersRequestHeaderModifierPatchPtrType) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput)
}

// RequestHeaderModifier defines a schema for a filter that modifies request
// headers.
//
// Support: Core
type HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestHeaderModifierPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchOutput) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPatchOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchOutput) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchOutput) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput {
	return o.ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchOutput) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesFiltersRequestHeaderModifierPatch) *HTTPRouteSpecRulesFiltersRequestHeaderModifierPatch {
		return &v
	}).(HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput)
}

// Add adds the given header(s) (name, value) to the request
// before the action. It appends to any existing values associated
// with the header name.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	add:
//	- name: "my-header"
//	  value: "bar,baz"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: foo,bar,baz
func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchOutput) Add() HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestHeaderModifierPatch) []HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatch {
		return v.Add
	}).(HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayOutput)
}

// Remove the given header(s) from the HTTP request before the action. The
// value of Remove is a list of HTTP header names. Note that the header
// names are case-insensitive (see
// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header1: foo
//	my-header2: bar
//	my-header3: baz
//
// Config:
//
//	remove: ["my-header1", "my-header3"]
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header2: bar
func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchOutput) Remove() pulumi.StringArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestHeaderModifierPatch) []string { return v.Remove }).(pulumi.StringArrayOutput)
}

// Set overwrites the request with the given header (name, value)
// before the action.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	set:
//	- name: "my-header"
//	  value: "bar"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: bar
func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchOutput) Set() HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestHeaderModifierPatch) []HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatch {
		return v.Set
	}).(HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayOutput)
}

type HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersRequestHeaderModifierPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput) Elem() HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestHeaderModifierPatch) HTTPRouteSpecRulesFiltersRequestHeaderModifierPatch {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesFiltersRequestHeaderModifierPatch
		return ret
	}).(HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchOutput)
}

// Add adds the given header(s) (name, value) to the request
// before the action. It appends to any existing values associated
// with the header name.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	add:
//	- name: "my-header"
//	  value: "bar,baz"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: foo,bar,baz
func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput) Add() HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestHeaderModifierPatch) []HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatch {
		if v == nil {
			return nil
		}
		return v.Add
	}).(HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayOutput)
}

// Remove the given header(s) from the HTTP request before the action. The
// value of Remove is a list of HTTP header names. Note that the header
// names are case-insensitive (see
// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header1: foo
//	my-header2: bar
//	my-header3: baz
//
// Config:
//
//	remove: ["my-header1", "my-header3"]
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header2: bar
func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput) Remove() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestHeaderModifierPatch) []string {
		if v == nil {
			return nil
		}
		return v.Remove
	}).(pulumi.StringArrayOutput)
}

// Set overwrites the request with the given header (name, value)
// before the action.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	set:
//	- name: "my-header"
//	  value: "bar"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: bar
func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput) Set() HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestHeaderModifierPatch) []HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatch {
		if v == nil {
			return nil
		}
		return v.Set
	}).(HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesFiltersRequestHeaderModifierSet struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name *string `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value *string `pulumi:"value"`
}

// HTTPRouteSpecRulesFiltersRequestHeaderModifierSetInput is an input type that accepts HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArgs and HTTPRouteSpecRulesFiltersRequestHeaderModifierSetOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersRequestHeaderModifierSetInput` via:
//
//	HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArgs{...}
type HTTPRouteSpecRulesFiltersRequestHeaderModifierSetInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersRequestHeaderModifierSetOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierSetOutput
	ToHTTPRouteSpecRulesFiltersRequestHeaderModifierSetOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierSetOutput
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArgs struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestHeaderModifierSet)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArgs) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierSetOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierSetOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestHeaderModifierSetOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArgs) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierSetOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierSetOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestHeaderModifierSetOutput)
}

// HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayInput is an input type that accepts HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArray and HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayInput` via:
//
//	HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArray{ HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArgs{...} }
type HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput
	ToHTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput
}

type HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArray []HTTPRouteSpecRulesFiltersRequestHeaderModifierSetInput

func (HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesFiltersRequestHeaderModifierSet)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArray) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArray) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesFiltersRequestHeaderModifierSetOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersRequestHeaderModifierSetOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestHeaderModifierSet)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierSetOutput) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierSetOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierSetOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierSetOutput) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierSetOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierSetOutput {
	return o
}

// Name is the name of the HTTP Header to be matched. Name matching MUST be
// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
//
// If multiple entries specify equivalent header names, the first entry with
// an equivalent name MUST be considered for a match. Subsequent entries
// with an equivalent header name MUST be ignored. Due to the
// case-insensitivity of header names, "foo" and "Foo" are considered
// equivalent.
func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierSetOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestHeaderModifierSet) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Value is the value of HTTP Header to be matched.
func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierSetOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestHeaderModifierSet) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesFiltersRequestHeaderModifierSet)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput) Index(i pulumi.IntInput) HTTPRouteSpecRulesFiltersRequestHeaderModifierSetOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteSpecRulesFiltersRequestHeaderModifierSet {
		return vs[0].([]HTTPRouteSpecRulesFiltersRequestHeaderModifierSet)[vs[1].(int)]
	}).(HTTPRouteSpecRulesFiltersRequestHeaderModifierSetOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatch struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name *string `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value *string `pulumi:"value"`
}

// HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchInput is an input type that accepts HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArgs and HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchInput` via:
//
//	HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArgs{...}
type HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchOutput
	ToHTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchOutput
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArgs struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArgs) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArgs) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchOutput)
}

// HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayInput is an input type that accepts HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArray and HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayInput` via:
//
//	HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArray{ HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArgs{...} }
type HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayOutput
	ToHTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayOutput
}

type HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArray []HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchInput

func (HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArray) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArray) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchOutput) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchOutput) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchOutput {
	return o
}

// Name is the name of the HTTP Header to be matched. Name matching MUST be
// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
//
// If multiple entries specify equivalent header names, the first entry with
// an equivalent name MUST be considered for a match. Subsequent entries
// with an equivalent header name MUST be ignored. Due to the
// case-insensitivity of header names, "foo" and "Foo" are considered
// equivalent.
func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Value is the value of HTTP Header to be matched.
func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatch) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayOutput) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayOutput() HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayOutput) ToHTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayOutput) Index(i pulumi.IntInput) HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatch {
		return vs[0].([]HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatch)[vs[1].(int)]
	}).(HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchOutput)
}

// RequestMirror defines a schema for a filter that mirrors requests.
// Requests are sent to the specified destination, but responses from
// that destination are ignored.
//
// This filter can be used multiple times within the same rule. Note that
// not all implementations will be able to support mirroring to multiple
// backends.
//
// Support: Extended
type HTTPRouteSpecRulesFiltersRequestMirror struct {
	BackendRef *HTTPRouteSpecRulesFiltersRequestMirrorBackendRef `pulumi:"backendRef"`
}

// HTTPRouteSpecRulesFiltersRequestMirrorInput is an input type that accepts HTTPRouteSpecRulesFiltersRequestMirrorArgs and HTTPRouteSpecRulesFiltersRequestMirrorOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersRequestMirrorInput` via:
//
//	HTTPRouteSpecRulesFiltersRequestMirrorArgs{...}
type HTTPRouteSpecRulesFiltersRequestMirrorInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersRequestMirrorOutput() HTTPRouteSpecRulesFiltersRequestMirrorOutput
	ToHTTPRouteSpecRulesFiltersRequestMirrorOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersRequestMirrorOutput
}

// RequestMirror defines a schema for a filter that mirrors requests.
// Requests are sent to the specified destination, but responses from
// that destination are ignored.
//
// This filter can be used multiple times within the same rule. Note that
// not all implementations will be able to support mirroring to multiple
// backends.
//
// Support: Extended
type HTTPRouteSpecRulesFiltersRequestMirrorArgs struct {
	BackendRef HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrInput `pulumi:"backendRef"`
}

func (HTTPRouteSpecRulesFiltersRequestMirrorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestMirror)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersRequestMirrorArgs) ToHTTPRouteSpecRulesFiltersRequestMirrorOutput() HTTPRouteSpecRulesFiltersRequestMirrorOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestMirrorOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersRequestMirrorArgs) ToHTTPRouteSpecRulesFiltersRequestMirrorOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestMirrorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestMirrorOutput)
}

func (i HTTPRouteSpecRulesFiltersRequestMirrorArgs) ToHTTPRouteSpecRulesFiltersRequestMirrorPtrOutput() HTTPRouteSpecRulesFiltersRequestMirrorPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestMirrorPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersRequestMirrorArgs) ToHTTPRouteSpecRulesFiltersRequestMirrorPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestMirrorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestMirrorOutput).ToHTTPRouteSpecRulesFiltersRequestMirrorPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesFiltersRequestMirrorPtrInput is an input type that accepts HTTPRouteSpecRulesFiltersRequestMirrorArgs, HTTPRouteSpecRulesFiltersRequestMirrorPtr and HTTPRouteSpecRulesFiltersRequestMirrorPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersRequestMirrorPtrInput` via:
//
//	        HTTPRouteSpecRulesFiltersRequestMirrorArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesFiltersRequestMirrorPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersRequestMirrorPtrOutput() HTTPRouteSpecRulesFiltersRequestMirrorPtrOutput
	ToHTTPRouteSpecRulesFiltersRequestMirrorPtrOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersRequestMirrorPtrOutput
}

type httprouteSpecRulesFiltersRequestMirrorPtrType HTTPRouteSpecRulesFiltersRequestMirrorArgs

func HTTPRouteSpecRulesFiltersRequestMirrorPtr(v *HTTPRouteSpecRulesFiltersRequestMirrorArgs) HTTPRouteSpecRulesFiltersRequestMirrorPtrInput {
	return (*httprouteSpecRulesFiltersRequestMirrorPtrType)(v)
}

func (*httprouteSpecRulesFiltersRequestMirrorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersRequestMirror)(nil)).Elem()
}

func (i *httprouteSpecRulesFiltersRequestMirrorPtrType) ToHTTPRouteSpecRulesFiltersRequestMirrorPtrOutput() HTTPRouteSpecRulesFiltersRequestMirrorPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestMirrorPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesFiltersRequestMirrorPtrType) ToHTTPRouteSpecRulesFiltersRequestMirrorPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestMirrorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestMirrorPtrOutput)
}

// RequestMirror defines a schema for a filter that mirrors requests.
// Requests are sent to the specified destination, but responses from
// that destination are ignored.
//
// This filter can be used multiple times within the same rule. Note that
// not all implementations will be able to support mirroring to multiple
// backends.
//
// Support: Extended
type HTTPRouteSpecRulesFiltersRequestMirrorOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersRequestMirrorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestMirror)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersRequestMirrorOutput) ToHTTPRouteSpecRulesFiltersRequestMirrorOutput() HTTPRouteSpecRulesFiltersRequestMirrorOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestMirrorOutput) ToHTTPRouteSpecRulesFiltersRequestMirrorOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestMirrorOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestMirrorOutput) ToHTTPRouteSpecRulesFiltersRequestMirrorPtrOutput() HTTPRouteSpecRulesFiltersRequestMirrorPtrOutput {
	return o.ToHTTPRouteSpecRulesFiltersRequestMirrorPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesFiltersRequestMirrorOutput) ToHTTPRouteSpecRulesFiltersRequestMirrorPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestMirrorPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesFiltersRequestMirror) *HTTPRouteSpecRulesFiltersRequestMirror {
		return &v
	}).(HTTPRouteSpecRulesFiltersRequestMirrorPtrOutput)
}

func (o HTTPRouteSpecRulesFiltersRequestMirrorOutput) BackendRef() HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestMirror) *HTTPRouteSpecRulesFiltersRequestMirrorBackendRef {
		return v.BackendRef
	}).(HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput)
}

type HTTPRouteSpecRulesFiltersRequestMirrorPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersRequestMirrorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersRequestMirror)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersRequestMirrorPtrOutput) ToHTTPRouteSpecRulesFiltersRequestMirrorPtrOutput() HTTPRouteSpecRulesFiltersRequestMirrorPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestMirrorPtrOutput) ToHTTPRouteSpecRulesFiltersRequestMirrorPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestMirrorPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestMirrorPtrOutput) Elem() HTTPRouteSpecRulesFiltersRequestMirrorOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestMirror) HTTPRouteSpecRulesFiltersRequestMirror {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesFiltersRequestMirror
		return ret
	}).(HTTPRouteSpecRulesFiltersRequestMirrorOutput)
}

func (o HTTPRouteSpecRulesFiltersRequestMirrorPtrOutput) BackendRef() HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestMirror) *HTTPRouteSpecRulesFiltersRequestMirrorBackendRef {
		if v == nil {
			return nil
		}
		return v.BackendRef
	}).(HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput)
}

// BackendRef references a resource where mirrored requests are sent.
//
// Mirrored requests must be sent only to a single destination endpoint
// within this BackendRef, irrespective of how many endpoints are present
// within this BackendRef.
//
// If the referent cannot be found, this BackendRef is invalid and must be
// dropped from the Gateway. The controller must ensure the "ResolvedRefs"
// condition on the Route status is set to `status: False` and not configure
// this backend in the underlying implementation.
//
// If there is a cross-namespace reference to an *existing* object
// that is not allowed by a ReferenceGrant, the controller must ensure the
// "ResolvedRefs"  condition on the Route is set to `status: False`,
// with the "RefNotPermitted" reason and not configure this backend in the
// underlying implementation.
//
// In either error case, the Message of the `ResolvedRefs` Condition
// should be used to provide more detail about the problem.
//
// Support: Extended for Kubernetes Service
//
// Support: Implementation-specific for any other resource
type HTTPRouteSpecRulesFiltersRequestMirrorBackendRef struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group *string `pulumi:"group"`
	// Kind is the Kubernetes resource kind of the referent. For example
	// "Service".
	//
	// Defaults to "Service" when not specified.
	//
	// ExternalName services can refer to CNAME DNS records that may live
	// outside of the cluster and as such are difficult to reason about in
	// terms of conformance. They also may not be safe to forward to (see
	// CVE-2021-25740 for more information). Implementations SHOULD NOT
	// support ExternalName Services.
	//
	// Support: Core (Services with a type other than ExternalName)
	//
	// Support: Implementation-specific (Services with type ExternalName)
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	Name *string `pulumi:"name"`
	// Namespace is the namespace of the backend. When unspecified, the local
	// namespace is inferred.
	//
	// Note that when a namespace different than the local namespace is specified,
	// a ReferenceGrant object is required in the referent namespace to allow that
	// namespace's owner to accept the reference. See the ReferenceGrant
	// documentation for details.
	//
	// Support: Core
	Namespace *string `pulumi:"namespace"`
	// Port specifies the destination port number to use for this resource.
	// Port is required when the referent is a Kubernetes Service. In this
	// case, the port number is the service port number, not the target port.
	// For other resources, destination port might be derived from the referent
	// resource or this field.
	Port *int `pulumi:"port"`
}

// HTTPRouteSpecRulesFiltersRequestMirrorBackendRefInput is an input type that accepts HTTPRouteSpecRulesFiltersRequestMirrorBackendRefArgs and HTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersRequestMirrorBackendRefInput` via:
//
//	HTTPRouteSpecRulesFiltersRequestMirrorBackendRefArgs{...}
type HTTPRouteSpecRulesFiltersRequestMirrorBackendRefInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutput() HTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutput
	ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutput
}

// BackendRef references a resource where mirrored requests are sent.
//
// Mirrored requests must be sent only to a single destination endpoint
// within this BackendRef, irrespective of how many endpoints are present
// within this BackendRef.
//
// If the referent cannot be found, this BackendRef is invalid and must be
// dropped from the Gateway. The controller must ensure the "ResolvedRefs"
// condition on the Route status is set to `status: False` and not configure
// this backend in the underlying implementation.
//
// If there is a cross-namespace reference to an *existing* object
// that is not allowed by a ReferenceGrant, the controller must ensure the
// "ResolvedRefs"  condition on the Route is set to `status: False`,
// with the "RefNotPermitted" reason and not configure this backend in the
// underlying implementation.
//
// In either error case, the Message of the `ResolvedRefs` Condition
// should be used to provide more detail about the problem.
//
// Support: Extended for Kubernetes Service
//
// Support: Implementation-specific for any other resource
type HTTPRouteSpecRulesFiltersRequestMirrorBackendRefArgs struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is the Kubernetes resource kind of the referent. For example
	// "Service".
	//
	// Defaults to "Service" when not specified.
	//
	// ExternalName services can refer to CNAME DNS records that may live
	// outside of the cluster and as such are difficult to reason about in
	// terms of conformance. They also may not be safe to forward to (see
	// CVE-2021-25740 for more information). Implementations SHOULD NOT
	// support ExternalName Services.
	//
	// Support: Core (Services with a type other than ExternalName)
	//
	// Support: Implementation-specific (Services with type ExternalName)
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace is the namespace of the backend. When unspecified, the local
	// namespace is inferred.
	//
	// Note that when a namespace different than the local namespace is specified,
	// a ReferenceGrant object is required in the referent namespace to allow that
	// namespace's owner to accept the reference. See the ReferenceGrant
	// documentation for details.
	//
	// Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Port specifies the destination port number to use for this resource.
	// Port is required when the referent is a Kubernetes Service. In this
	// case, the port number is the service port number, not the target port.
	// For other resources, destination port might be derived from the referent
	// resource or this field.
	Port pulumi.IntPtrInput `pulumi:"port"`
}

func (HTTPRouteSpecRulesFiltersRequestMirrorBackendRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestMirrorBackendRef)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersRequestMirrorBackendRefArgs) ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutput() HTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersRequestMirrorBackendRefArgs) ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutput)
}

func (i HTTPRouteSpecRulesFiltersRequestMirrorBackendRefArgs) ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput() HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersRequestMirrorBackendRefArgs) ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutput).ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrInput is an input type that accepts HTTPRouteSpecRulesFiltersRequestMirrorBackendRefArgs, HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtr and HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrInput` via:
//
//	        HTTPRouteSpecRulesFiltersRequestMirrorBackendRefArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput() HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput
	ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput
}

type httprouteSpecRulesFiltersRequestMirrorBackendRefPtrType HTTPRouteSpecRulesFiltersRequestMirrorBackendRefArgs

func HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtr(v *HTTPRouteSpecRulesFiltersRequestMirrorBackendRefArgs) HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrInput {
	return (*httprouteSpecRulesFiltersRequestMirrorBackendRefPtrType)(v)
}

func (*httprouteSpecRulesFiltersRequestMirrorBackendRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersRequestMirrorBackendRef)(nil)).Elem()
}

func (i *httprouteSpecRulesFiltersRequestMirrorBackendRefPtrType) ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput() HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesFiltersRequestMirrorBackendRefPtrType) ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput)
}

// BackendRef references a resource where mirrored requests are sent.
//
// Mirrored requests must be sent only to a single destination endpoint
// within this BackendRef, irrespective of how many endpoints are present
// within this BackendRef.
//
// If the referent cannot be found, this BackendRef is invalid and must be
// dropped from the Gateway. The controller must ensure the "ResolvedRefs"
// condition on the Route status is set to `status: False` and not configure
// this backend in the underlying implementation.
//
// If there is a cross-namespace reference to an *existing* object
// that is not allowed by a ReferenceGrant, the controller must ensure the
// "ResolvedRefs"  condition on the Route is set to `status: False`,
// with the "RefNotPermitted" reason and not configure this backend in the
// underlying implementation.
//
// In either error case, the Message of the `ResolvedRefs` Condition
// should be used to provide more detail about the problem.
//
// Support: Extended for Kubernetes Service
//
// Support: Implementation-specific for any other resource
type HTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestMirrorBackendRef)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutput) ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutput() HTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutput) ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutput) ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput() HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput {
	return o.ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutput) ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesFiltersRequestMirrorBackendRef) *HTTPRouteSpecRulesFiltersRequestMirrorBackendRef {
		return &v
	}).(HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestMirrorBackendRef) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is the Kubernetes resource kind of the referent. For example
// "Service".
//
// Defaults to "Service" when not specified.
//
// ExternalName services can refer to CNAME DNS records that may live
// outside of the cluster and as such are difficult to reason about in
// terms of conformance. They also may not be safe to forward to (see
// CVE-2021-25740 for more information). Implementations SHOULD NOT
// support ExternalName Services.
//
// Support: Core (Services with a type other than ExternalName)
//
// Support: Implementation-specific (Services with type ExternalName)
func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestMirrorBackendRef) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestMirrorBackendRef) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the backend. When unspecified, the local
// namespace is inferred.
//
// Note that when a namespace different than the local namespace is specified,
// a ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// Support: Core
func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestMirrorBackendRef) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Port specifies the destination port number to use for this resource.
// Port is required when the referent is a Kubernetes Service. In this
// case, the port number is the service port number, not the target port.
// For other resources, destination port might be derived from the referent
// resource or this field.
func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestMirrorBackendRef) *int { return v.Port }).(pulumi.IntPtrOutput)
}

type HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersRequestMirrorBackendRef)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput) ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput() HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput) ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput) Elem() HTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestMirrorBackendRef) HTTPRouteSpecRulesFiltersRequestMirrorBackendRef {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesFiltersRequestMirrorBackendRef
		return ret
	}).(HTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestMirrorBackendRef) *string {
		if v == nil {
			return nil
		}
		return v.Group
	}).(pulumi.StringPtrOutput)
}

// Kind is the Kubernetes resource kind of the referent. For example
// "Service".
//
// Defaults to "Service" when not specified.
//
// ExternalName services can refer to CNAME DNS records that may live
// outside of the cluster and as such are difficult to reason about in
// terms of conformance. They also may not be safe to forward to (see
// CVE-2021-25740 for more information). Implementations SHOULD NOT
// support ExternalName Services.
//
// Support: Core (Services with a type other than ExternalName)
//
// Support: Implementation-specific (Services with type ExternalName)
func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestMirrorBackendRef) *string {
		if v == nil {
			return nil
		}
		return v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestMirrorBackendRef) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the backend. When unspecified, the local
// namespace is inferred.
//
// Note that when a namespace different than the local namespace is specified,
// a ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// Support: Core
func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestMirrorBackendRef) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

// Port specifies the destination port number to use for this resource.
// Port is required when the referent is a Kubernetes Service. In this
// case, the port number is the service port number, not the target port.
// For other resources, destination port might be derived from the referent
// resource or this field.
func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestMirrorBackendRef) *int {
		if v == nil {
			return nil
		}
		return v.Port
	}).(pulumi.IntPtrOutput)
}

// BackendRef references a resource where mirrored requests are sent.
//
// Mirrored requests must be sent only to a single destination endpoint
// within this BackendRef, irrespective of how many endpoints are present
// within this BackendRef.
//
// If the referent cannot be found, this BackendRef is invalid and must be
// dropped from the Gateway. The controller must ensure the "ResolvedRefs"
// condition on the Route status is set to `status: False` and not configure
// this backend in the underlying implementation.
//
// If there is a cross-namespace reference to an *existing* object
// that is not allowed by a ReferenceGrant, the controller must ensure the
// "ResolvedRefs"  condition on the Route is set to `status: False`,
// with the "RefNotPermitted" reason and not configure this backend in the
// underlying implementation.
//
// In either error case, the Message of the `ResolvedRefs` Condition
// should be used to provide more detail about the problem.
//
// Support: Extended for Kubernetes Service
//
// Support: Implementation-specific for any other resource
type HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatch struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group *string `pulumi:"group"`
	// Kind is the Kubernetes resource kind of the referent. For example
	// "Service".
	//
	// Defaults to "Service" when not specified.
	//
	// ExternalName services can refer to CNAME DNS records that may live
	// outside of the cluster and as such are difficult to reason about in
	// terms of conformance. They also may not be safe to forward to (see
	// CVE-2021-25740 for more information). Implementations SHOULD NOT
	// support ExternalName Services.
	//
	// Support: Core (Services with a type other than ExternalName)
	//
	// Support: Implementation-specific (Services with type ExternalName)
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	Name *string `pulumi:"name"`
	// Namespace is the namespace of the backend. When unspecified, the local
	// namespace is inferred.
	//
	// Note that when a namespace different than the local namespace is specified,
	// a ReferenceGrant object is required in the referent namespace to allow that
	// namespace's owner to accept the reference. See the ReferenceGrant
	// documentation for details.
	//
	// Support: Core
	Namespace *string `pulumi:"namespace"`
	// Port specifies the destination port number to use for this resource.
	// Port is required when the referent is a Kubernetes Service. In this
	// case, the port number is the service port number, not the target port.
	// For other resources, destination port might be derived from the referent
	// resource or this field.
	Port *int `pulumi:"port"`
}

// HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchInput is an input type that accepts HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchArgs and HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchInput` via:
//
//	HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchArgs{...}
type HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutput() HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutput
	ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutput
}

// BackendRef references a resource where mirrored requests are sent.
//
// Mirrored requests must be sent only to a single destination endpoint
// within this BackendRef, irrespective of how many endpoints are present
// within this BackendRef.
//
// If the referent cannot be found, this BackendRef is invalid and must be
// dropped from the Gateway. The controller must ensure the "ResolvedRefs"
// condition on the Route status is set to `status: False` and not configure
// this backend in the underlying implementation.
//
// If there is a cross-namespace reference to an *existing* object
// that is not allowed by a ReferenceGrant, the controller must ensure the
// "ResolvedRefs"  condition on the Route is set to `status: False`,
// with the "RefNotPermitted" reason and not configure this backend in the
// underlying implementation.
//
// In either error case, the Message of the `ResolvedRefs` Condition
// should be used to provide more detail about the problem.
//
// Support: Extended for Kubernetes Service
//
// Support: Implementation-specific for any other resource
type HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchArgs struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is the Kubernetes resource kind of the referent. For example
	// "Service".
	//
	// Defaults to "Service" when not specified.
	//
	// ExternalName services can refer to CNAME DNS records that may live
	// outside of the cluster and as such are difficult to reason about in
	// terms of conformance. They also may not be safe to forward to (see
	// CVE-2021-25740 for more information). Implementations SHOULD NOT
	// support ExternalName Services.
	//
	// Support: Core (Services with a type other than ExternalName)
	//
	// Support: Implementation-specific (Services with type ExternalName)
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace is the namespace of the backend. When unspecified, the local
	// namespace is inferred.
	//
	// Note that when a namespace different than the local namespace is specified,
	// a ReferenceGrant object is required in the referent namespace to allow that
	// namespace's owner to accept the reference. See the ReferenceGrant
	// documentation for details.
	//
	// Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Port specifies the destination port number to use for this resource.
	// Port is required when the referent is a Kubernetes Service. In this
	// case, the port number is the service port number, not the target port.
	// For other resources, destination port might be derived from the referent
	// resource or this field.
	Port pulumi.IntPtrInput `pulumi:"port"`
}

func (HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchArgs) ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutput() HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchArgs) ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutput)
}

func (i HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchArgs) ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput() HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchArgs) ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutput).ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrInput is an input type that accepts HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchArgs, HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtr and HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrInput` via:
//
//	        HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput() HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput
	ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput
}

type httprouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrType HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchArgs

func HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtr(v *HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchArgs) HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrInput {
	return (*httprouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrType)(v)
}

func (*httprouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatch)(nil)).Elem()
}

func (i *httprouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrType) ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput() HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrType) ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput)
}

// BackendRef references a resource where mirrored requests are sent.
//
// Mirrored requests must be sent only to a single destination endpoint
// within this BackendRef, irrespective of how many endpoints are present
// within this BackendRef.
//
// If the referent cannot be found, this BackendRef is invalid and must be
// dropped from the Gateway. The controller must ensure the "ResolvedRefs"
// condition on the Route status is set to `status: False` and not configure
// this backend in the underlying implementation.
//
// If there is a cross-namespace reference to an *existing* object
// that is not allowed by a ReferenceGrant, the controller must ensure the
// "ResolvedRefs"  condition on the Route is set to `status: False`,
// with the "RefNotPermitted" reason and not configure this backend in the
// underlying implementation.
//
// In either error case, the Message of the `ResolvedRefs` Condition
// should be used to provide more detail about the problem.
//
// Support: Extended for Kubernetes Service
//
// Support: Implementation-specific for any other resource
type HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutput) ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutput() HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutput) ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutput) ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput() HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput {
	return o.ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutput) ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatch) *HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatch {
		return &v
	}).(HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatch) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is the Kubernetes resource kind of the referent. For example
// "Service".
//
// Defaults to "Service" when not specified.
//
// ExternalName services can refer to CNAME DNS records that may live
// outside of the cluster and as such are difficult to reason about in
// terms of conformance. They also may not be safe to forward to (see
// CVE-2021-25740 for more information). Implementations SHOULD NOT
// support ExternalName Services.
//
// Support: Core (Services with a type other than ExternalName)
//
// Support: Implementation-specific (Services with type ExternalName)
func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatch) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the backend. When unspecified, the local
// namespace is inferred.
//
// Note that when a namespace different than the local namespace is specified,
// a ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// Support: Core
func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatch) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Port specifies the destination port number to use for this resource.
// Port is required when the referent is a Kubernetes Service. In this
// case, the port number is the service port number, not the target port.
// For other resources, destination port might be derived from the referent
// resource or this field.
func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatch) *int { return v.Port }).(pulumi.IntPtrOutput)
}

type HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput) ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput() HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput) ToHTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput) Elem() HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatch) HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatch {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatch
		return ret
	}).(HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Group
	}).(pulumi.StringPtrOutput)
}

// Kind is the Kubernetes resource kind of the referent. For example
// "Service".
//
// Defaults to "Service" when not specified.
//
// ExternalName services can refer to CNAME DNS records that may live
// outside of the cluster and as such are difficult to reason about in
// terms of conformance. They also may not be safe to forward to (see
// CVE-2021-25740 for more information). Implementations SHOULD NOT
// support ExternalName Services.
//
// Support: Core (Services with a type other than ExternalName)
//
// Support: Implementation-specific (Services with type ExternalName)
func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the backend. When unspecified, the local
// namespace is inferred.
//
// Note that when a namespace different than the local namespace is specified,
// a ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// Support: Core
func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

// Port specifies the destination port number to use for this resource.
// Port is required when the referent is a Kubernetes Service. In this
// case, the port number is the service port number, not the target port.
// For other resources, destination port might be derived from the referent
// resource or this field.
func (o HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatch) *int {
		if v == nil {
			return nil
		}
		return v.Port
	}).(pulumi.IntPtrOutput)
}

// RequestMirror defines a schema for a filter that mirrors requests.
// Requests are sent to the specified destination, but responses from
// that destination are ignored.
//
// This filter can be used multiple times within the same rule. Note that
// not all implementations will be able to support mirroring to multiple
// backends.
//
// Support: Extended
type HTTPRouteSpecRulesFiltersRequestMirrorPatch struct {
	BackendRef *HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatch `pulumi:"backendRef"`
}

// HTTPRouteSpecRulesFiltersRequestMirrorPatchInput is an input type that accepts HTTPRouteSpecRulesFiltersRequestMirrorPatchArgs and HTTPRouteSpecRulesFiltersRequestMirrorPatchOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersRequestMirrorPatchInput` via:
//
//	HTTPRouteSpecRulesFiltersRequestMirrorPatchArgs{...}
type HTTPRouteSpecRulesFiltersRequestMirrorPatchInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersRequestMirrorPatchOutput() HTTPRouteSpecRulesFiltersRequestMirrorPatchOutput
	ToHTTPRouteSpecRulesFiltersRequestMirrorPatchOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersRequestMirrorPatchOutput
}

// RequestMirror defines a schema for a filter that mirrors requests.
// Requests are sent to the specified destination, but responses from
// that destination are ignored.
//
// This filter can be used multiple times within the same rule. Note that
// not all implementations will be able to support mirroring to multiple
// backends.
//
// Support: Extended
type HTTPRouteSpecRulesFiltersRequestMirrorPatchArgs struct {
	BackendRef HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrInput `pulumi:"backendRef"`
}

func (HTTPRouteSpecRulesFiltersRequestMirrorPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestMirrorPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersRequestMirrorPatchArgs) ToHTTPRouteSpecRulesFiltersRequestMirrorPatchOutput() HTTPRouteSpecRulesFiltersRequestMirrorPatchOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestMirrorPatchOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersRequestMirrorPatchArgs) ToHTTPRouteSpecRulesFiltersRequestMirrorPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestMirrorPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestMirrorPatchOutput)
}

func (i HTTPRouteSpecRulesFiltersRequestMirrorPatchArgs) ToHTTPRouteSpecRulesFiltersRequestMirrorPatchPtrOutput() HTTPRouteSpecRulesFiltersRequestMirrorPatchPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestMirrorPatchPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersRequestMirrorPatchArgs) ToHTTPRouteSpecRulesFiltersRequestMirrorPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestMirrorPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestMirrorPatchOutput).ToHTTPRouteSpecRulesFiltersRequestMirrorPatchPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesFiltersRequestMirrorPatchPtrInput is an input type that accepts HTTPRouteSpecRulesFiltersRequestMirrorPatchArgs, HTTPRouteSpecRulesFiltersRequestMirrorPatchPtr and HTTPRouteSpecRulesFiltersRequestMirrorPatchPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersRequestMirrorPatchPtrInput` via:
//
//	        HTTPRouteSpecRulesFiltersRequestMirrorPatchArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesFiltersRequestMirrorPatchPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersRequestMirrorPatchPtrOutput() HTTPRouteSpecRulesFiltersRequestMirrorPatchPtrOutput
	ToHTTPRouteSpecRulesFiltersRequestMirrorPatchPtrOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersRequestMirrorPatchPtrOutput
}

type httprouteSpecRulesFiltersRequestMirrorPatchPtrType HTTPRouteSpecRulesFiltersRequestMirrorPatchArgs

func HTTPRouteSpecRulesFiltersRequestMirrorPatchPtr(v *HTTPRouteSpecRulesFiltersRequestMirrorPatchArgs) HTTPRouteSpecRulesFiltersRequestMirrorPatchPtrInput {
	return (*httprouteSpecRulesFiltersRequestMirrorPatchPtrType)(v)
}

func (*httprouteSpecRulesFiltersRequestMirrorPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersRequestMirrorPatch)(nil)).Elem()
}

func (i *httprouteSpecRulesFiltersRequestMirrorPatchPtrType) ToHTTPRouteSpecRulesFiltersRequestMirrorPatchPtrOutput() HTTPRouteSpecRulesFiltersRequestMirrorPatchPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestMirrorPatchPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesFiltersRequestMirrorPatchPtrType) ToHTTPRouteSpecRulesFiltersRequestMirrorPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestMirrorPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestMirrorPatchPtrOutput)
}

// RequestMirror defines a schema for a filter that mirrors requests.
// Requests are sent to the specified destination, but responses from
// that destination are ignored.
//
// This filter can be used multiple times within the same rule. Note that
// not all implementations will be able to support mirroring to multiple
// backends.
//
// Support: Extended
type HTTPRouteSpecRulesFiltersRequestMirrorPatchOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersRequestMirrorPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestMirrorPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersRequestMirrorPatchOutput) ToHTTPRouteSpecRulesFiltersRequestMirrorPatchOutput() HTTPRouteSpecRulesFiltersRequestMirrorPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestMirrorPatchOutput) ToHTTPRouteSpecRulesFiltersRequestMirrorPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestMirrorPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestMirrorPatchOutput) ToHTTPRouteSpecRulesFiltersRequestMirrorPatchPtrOutput() HTTPRouteSpecRulesFiltersRequestMirrorPatchPtrOutput {
	return o.ToHTTPRouteSpecRulesFiltersRequestMirrorPatchPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesFiltersRequestMirrorPatchOutput) ToHTTPRouteSpecRulesFiltersRequestMirrorPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestMirrorPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesFiltersRequestMirrorPatch) *HTTPRouteSpecRulesFiltersRequestMirrorPatch {
		return &v
	}).(HTTPRouteSpecRulesFiltersRequestMirrorPatchPtrOutput)
}

func (o HTTPRouteSpecRulesFiltersRequestMirrorPatchOutput) BackendRef() HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestMirrorPatch) *HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatch {
		return v.BackendRef
	}).(HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput)
}

type HTTPRouteSpecRulesFiltersRequestMirrorPatchPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersRequestMirrorPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersRequestMirrorPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersRequestMirrorPatchPtrOutput) ToHTTPRouteSpecRulesFiltersRequestMirrorPatchPtrOutput() HTTPRouteSpecRulesFiltersRequestMirrorPatchPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestMirrorPatchPtrOutput) ToHTTPRouteSpecRulesFiltersRequestMirrorPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestMirrorPatchPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestMirrorPatchPtrOutput) Elem() HTTPRouteSpecRulesFiltersRequestMirrorPatchOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestMirrorPatch) HTTPRouteSpecRulesFiltersRequestMirrorPatch {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesFiltersRequestMirrorPatch
		return ret
	}).(HTTPRouteSpecRulesFiltersRequestMirrorPatchOutput)
}

func (o HTTPRouteSpecRulesFiltersRequestMirrorPatchPtrOutput) BackendRef() HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestMirrorPatch) *HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatch {
		if v == nil {
			return nil
		}
		return v.BackendRef
	}).(HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput)
}

// RequestRedirect defines a schema for a filter that responds to the
// request with an HTTP redirection.
//
// Support: Core
type HTTPRouteSpecRulesFiltersRequestRedirect struct {
	// Hostname is the hostname to be used in the value of the `Location`
	// header in the response.
	// When empty, the hostname in the `Host` header of the request is used.
	//
	// Support: Core
	Hostname *string                                       `pulumi:"hostname"`
	Path     *HTTPRouteSpecRulesFiltersRequestRedirectPath `pulumi:"path"`
	// Port is the port to be used in the value of the `Location`
	// header in the response.
	//
	// If no port is specified, the redirect port MUST be derived using the
	// following rules:
	//
	// * If redirect scheme is not-empty, the redirect port MUST be the well-known
	//   port associated with the redirect scheme. Specifically "http" to port 80
	//   and "https" to port 443. If the redirect scheme does not have a
	//   well-known port, the listener port of the Gateway SHOULD be used.
	// * If redirect scheme is empty, the redirect port MUST be the Gateway
	//   Listener port.
	//
	// Implementations SHOULD NOT add the port number in the 'Location'
	// header in the following cases:
	//
	// * A Location header that will use HTTP (whether that is determined via
	//   the Listener protocol or the Scheme field) _and_ use port 80.
	// * A Location header that will use HTTPS (whether that is determined via
	//   the Listener protocol or the Scheme field) _and_ use port 443.
	//
	// Support: Extended
	Port *int `pulumi:"port"`
	// Scheme is the scheme to be used in the value of the `Location` header in
	// the response. When empty, the scheme of the request is used.
	//
	// Scheme redirects can affect the port of the redirect, for more information,
	// refer to the documentation for the port field of this filter.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	//
	// Support: Extended
	Scheme *string `pulumi:"scheme"`
	// StatusCode is the HTTP status code to be used in response.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	//
	// Support: Core
	StatusCode *int `pulumi:"statusCode"`
}

// HTTPRouteSpecRulesFiltersRequestRedirectInput is an input type that accepts HTTPRouteSpecRulesFiltersRequestRedirectArgs and HTTPRouteSpecRulesFiltersRequestRedirectOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersRequestRedirectInput` via:
//
//	HTTPRouteSpecRulesFiltersRequestRedirectArgs{...}
type HTTPRouteSpecRulesFiltersRequestRedirectInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersRequestRedirectOutput() HTTPRouteSpecRulesFiltersRequestRedirectOutput
	ToHTTPRouteSpecRulesFiltersRequestRedirectOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersRequestRedirectOutput
}

// RequestRedirect defines a schema for a filter that responds to the
// request with an HTTP redirection.
//
// Support: Core
type HTTPRouteSpecRulesFiltersRequestRedirectArgs struct {
	// Hostname is the hostname to be used in the value of the `Location`
	// header in the response.
	// When empty, the hostname in the `Host` header of the request is used.
	//
	// Support: Core
	Hostname pulumi.StringPtrInput                                `pulumi:"hostname"`
	Path     HTTPRouteSpecRulesFiltersRequestRedirectPathPtrInput `pulumi:"path"`
	// Port is the port to be used in the value of the `Location`
	// header in the response.
	//
	// If no port is specified, the redirect port MUST be derived using the
	// following rules:
	//
	// * If redirect scheme is not-empty, the redirect port MUST be the well-known
	//   port associated with the redirect scheme. Specifically "http" to port 80
	//   and "https" to port 443. If the redirect scheme does not have a
	//   well-known port, the listener port of the Gateway SHOULD be used.
	// * If redirect scheme is empty, the redirect port MUST be the Gateway
	//   Listener port.
	//
	// Implementations SHOULD NOT add the port number in the 'Location'
	// header in the following cases:
	//
	// * A Location header that will use HTTP (whether that is determined via
	//   the Listener protocol or the Scheme field) _and_ use port 80.
	// * A Location header that will use HTTPS (whether that is determined via
	//   the Listener protocol or the Scheme field) _and_ use port 443.
	//
	// Support: Extended
	Port pulumi.IntPtrInput `pulumi:"port"`
	// Scheme is the scheme to be used in the value of the `Location` header in
	// the response. When empty, the scheme of the request is used.
	//
	// Scheme redirects can affect the port of the redirect, for more information,
	// refer to the documentation for the port field of this filter.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	//
	// Support: Extended
	Scheme pulumi.StringPtrInput `pulumi:"scheme"`
	// StatusCode is the HTTP status code to be used in response.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	//
	// Support: Core
	StatusCode pulumi.IntPtrInput `pulumi:"statusCode"`
}

func (HTTPRouteSpecRulesFiltersRequestRedirectArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestRedirect)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersRequestRedirectArgs) ToHTTPRouteSpecRulesFiltersRequestRedirectOutput() HTTPRouteSpecRulesFiltersRequestRedirectOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestRedirectOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersRequestRedirectArgs) ToHTTPRouteSpecRulesFiltersRequestRedirectOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestRedirectOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestRedirectOutput)
}

func (i HTTPRouteSpecRulesFiltersRequestRedirectArgs) ToHTTPRouteSpecRulesFiltersRequestRedirectPtrOutput() HTTPRouteSpecRulesFiltersRequestRedirectPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestRedirectPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersRequestRedirectArgs) ToHTTPRouteSpecRulesFiltersRequestRedirectPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestRedirectPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestRedirectOutput).ToHTTPRouteSpecRulesFiltersRequestRedirectPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesFiltersRequestRedirectPtrInput is an input type that accepts HTTPRouteSpecRulesFiltersRequestRedirectArgs, HTTPRouteSpecRulesFiltersRequestRedirectPtr and HTTPRouteSpecRulesFiltersRequestRedirectPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersRequestRedirectPtrInput` via:
//
//	        HTTPRouteSpecRulesFiltersRequestRedirectArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesFiltersRequestRedirectPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersRequestRedirectPtrOutput() HTTPRouteSpecRulesFiltersRequestRedirectPtrOutput
	ToHTTPRouteSpecRulesFiltersRequestRedirectPtrOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersRequestRedirectPtrOutput
}

type httprouteSpecRulesFiltersRequestRedirectPtrType HTTPRouteSpecRulesFiltersRequestRedirectArgs

func HTTPRouteSpecRulesFiltersRequestRedirectPtr(v *HTTPRouteSpecRulesFiltersRequestRedirectArgs) HTTPRouteSpecRulesFiltersRequestRedirectPtrInput {
	return (*httprouteSpecRulesFiltersRequestRedirectPtrType)(v)
}

func (*httprouteSpecRulesFiltersRequestRedirectPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersRequestRedirect)(nil)).Elem()
}

func (i *httprouteSpecRulesFiltersRequestRedirectPtrType) ToHTTPRouteSpecRulesFiltersRequestRedirectPtrOutput() HTTPRouteSpecRulesFiltersRequestRedirectPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestRedirectPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesFiltersRequestRedirectPtrType) ToHTTPRouteSpecRulesFiltersRequestRedirectPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestRedirectPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestRedirectPtrOutput)
}

// RequestRedirect defines a schema for a filter that responds to the
// request with an HTTP redirection.
//
// Support: Core
type HTTPRouteSpecRulesFiltersRequestRedirectOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersRequestRedirectOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestRedirect)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersRequestRedirectOutput) ToHTTPRouteSpecRulesFiltersRequestRedirectOutput() HTTPRouteSpecRulesFiltersRequestRedirectOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestRedirectOutput) ToHTTPRouteSpecRulesFiltersRequestRedirectOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestRedirectOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestRedirectOutput) ToHTTPRouteSpecRulesFiltersRequestRedirectPtrOutput() HTTPRouteSpecRulesFiltersRequestRedirectPtrOutput {
	return o.ToHTTPRouteSpecRulesFiltersRequestRedirectPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesFiltersRequestRedirectOutput) ToHTTPRouteSpecRulesFiltersRequestRedirectPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestRedirectPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesFiltersRequestRedirect) *HTTPRouteSpecRulesFiltersRequestRedirect {
		return &v
	}).(HTTPRouteSpecRulesFiltersRequestRedirectPtrOutput)
}

// Hostname is the hostname to be used in the value of the `Location`
// header in the response.
// When empty, the hostname in the `Host` header of the request is used.
//
// Support: Core
func (o HTTPRouteSpecRulesFiltersRequestRedirectOutput) Hostname() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestRedirect) *string { return v.Hostname }).(pulumi.StringPtrOutput)
}

func (o HTTPRouteSpecRulesFiltersRequestRedirectOutput) Path() HTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestRedirect) *HTTPRouteSpecRulesFiltersRequestRedirectPath {
		return v.Path
	}).(HTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput)
}

// Port is the port to be used in the value of the `Location`
// header in the response.
//
// If no port is specified, the redirect port MUST be derived using the
// following rules:
//
//   - If redirect scheme is not-empty, the redirect port MUST be the well-known
//     port associated with the redirect scheme. Specifically "http" to port 80
//     and "https" to port 443. If the redirect scheme does not have a
//     well-known port, the listener port of the Gateway SHOULD be used.
//   - If redirect scheme is empty, the redirect port MUST be the Gateway
//     Listener port.
//
// Implementations SHOULD NOT add the port number in the 'Location'
// header in the following cases:
//
//   - A Location header that will use HTTP (whether that is determined via
//     the Listener protocol or the Scheme field) _and_ use port 80.
//   - A Location header that will use HTTPS (whether that is determined via
//     the Listener protocol or the Scheme field) _and_ use port 443.
//
// Support: Extended
func (o HTTPRouteSpecRulesFiltersRequestRedirectOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestRedirect) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// Scheme is the scheme to be used in the value of the `Location` header in
// the response. When empty, the scheme of the request is used.
//
// Scheme redirects can affect the port of the redirect, for more information,
// refer to the documentation for the port field of this filter.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
//
// Support: Extended
func (o HTTPRouteSpecRulesFiltersRequestRedirectOutput) Scheme() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestRedirect) *string { return v.Scheme }).(pulumi.StringPtrOutput)
}

// StatusCode is the HTTP status code to be used in response.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
//
// Support: Core
func (o HTTPRouteSpecRulesFiltersRequestRedirectOutput) StatusCode() pulumi.IntPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestRedirect) *int { return v.StatusCode }).(pulumi.IntPtrOutput)
}

type HTTPRouteSpecRulesFiltersRequestRedirectPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersRequestRedirectPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersRequestRedirect)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersRequestRedirectPtrOutput) ToHTTPRouteSpecRulesFiltersRequestRedirectPtrOutput() HTTPRouteSpecRulesFiltersRequestRedirectPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestRedirectPtrOutput) ToHTTPRouteSpecRulesFiltersRequestRedirectPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestRedirectPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestRedirectPtrOutput) Elem() HTTPRouteSpecRulesFiltersRequestRedirectOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestRedirect) HTTPRouteSpecRulesFiltersRequestRedirect {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesFiltersRequestRedirect
		return ret
	}).(HTTPRouteSpecRulesFiltersRequestRedirectOutput)
}

// Hostname is the hostname to be used in the value of the `Location`
// header in the response.
// When empty, the hostname in the `Host` header of the request is used.
//
// Support: Core
func (o HTTPRouteSpecRulesFiltersRequestRedirectPtrOutput) Hostname() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestRedirect) *string {
		if v == nil {
			return nil
		}
		return v.Hostname
	}).(pulumi.StringPtrOutput)
}

func (o HTTPRouteSpecRulesFiltersRequestRedirectPtrOutput) Path() HTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestRedirect) *HTTPRouteSpecRulesFiltersRequestRedirectPath {
		if v == nil {
			return nil
		}
		return v.Path
	}).(HTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput)
}

// Port is the port to be used in the value of the `Location`
// header in the response.
//
// If no port is specified, the redirect port MUST be derived using the
// following rules:
//
//   - If redirect scheme is not-empty, the redirect port MUST be the well-known
//     port associated with the redirect scheme. Specifically "http" to port 80
//     and "https" to port 443. If the redirect scheme does not have a
//     well-known port, the listener port of the Gateway SHOULD be used.
//   - If redirect scheme is empty, the redirect port MUST be the Gateway
//     Listener port.
//
// Implementations SHOULD NOT add the port number in the 'Location'
// header in the following cases:
//
//   - A Location header that will use HTTP (whether that is determined via
//     the Listener protocol or the Scheme field) _and_ use port 80.
//   - A Location header that will use HTTPS (whether that is determined via
//     the Listener protocol or the Scheme field) _and_ use port 443.
//
// Support: Extended
func (o HTTPRouteSpecRulesFiltersRequestRedirectPtrOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestRedirect) *int {
		if v == nil {
			return nil
		}
		return v.Port
	}).(pulumi.IntPtrOutput)
}

// Scheme is the scheme to be used in the value of the `Location` header in
// the response. When empty, the scheme of the request is used.
//
// Scheme redirects can affect the port of the redirect, for more information,
// refer to the documentation for the port field of this filter.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
//
// Support: Extended
func (o HTTPRouteSpecRulesFiltersRequestRedirectPtrOutput) Scheme() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestRedirect) *string {
		if v == nil {
			return nil
		}
		return v.Scheme
	}).(pulumi.StringPtrOutput)
}

// StatusCode is the HTTP status code to be used in response.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
//
// Support: Core
func (o HTTPRouteSpecRulesFiltersRequestRedirectPtrOutput) StatusCode() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestRedirect) *int {
		if v == nil {
			return nil
		}
		return v.StatusCode
	}).(pulumi.IntPtrOutput)
}

// RequestRedirect defines a schema for a filter that responds to the
// request with an HTTP redirection.
//
// Support: Core
type HTTPRouteSpecRulesFiltersRequestRedirectPatch struct {
	// Hostname is the hostname to be used in the value of the `Location`
	// header in the response.
	// When empty, the hostname in the `Host` header of the request is used.
	//
	// Support: Core
	Hostname *string                                            `pulumi:"hostname"`
	Path     *HTTPRouteSpecRulesFiltersRequestRedirectPathPatch `pulumi:"path"`
	// Port is the port to be used in the value of the `Location`
	// header in the response.
	//
	// If no port is specified, the redirect port MUST be derived using the
	// following rules:
	//
	// * If redirect scheme is not-empty, the redirect port MUST be the well-known
	//   port associated with the redirect scheme. Specifically "http" to port 80
	//   and "https" to port 443. If the redirect scheme does not have a
	//   well-known port, the listener port of the Gateway SHOULD be used.
	// * If redirect scheme is empty, the redirect port MUST be the Gateway
	//   Listener port.
	//
	// Implementations SHOULD NOT add the port number in the 'Location'
	// header in the following cases:
	//
	// * A Location header that will use HTTP (whether that is determined via
	//   the Listener protocol or the Scheme field) _and_ use port 80.
	// * A Location header that will use HTTPS (whether that is determined via
	//   the Listener protocol or the Scheme field) _and_ use port 443.
	//
	// Support: Extended
	Port *int `pulumi:"port"`
	// Scheme is the scheme to be used in the value of the `Location` header in
	// the response. When empty, the scheme of the request is used.
	//
	// Scheme redirects can affect the port of the redirect, for more information,
	// refer to the documentation for the port field of this filter.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	//
	// Support: Extended
	Scheme *string `pulumi:"scheme"`
	// StatusCode is the HTTP status code to be used in response.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	//
	// Support: Core
	StatusCode *int `pulumi:"statusCode"`
}

// HTTPRouteSpecRulesFiltersRequestRedirectPatchInput is an input type that accepts HTTPRouteSpecRulesFiltersRequestRedirectPatchArgs and HTTPRouteSpecRulesFiltersRequestRedirectPatchOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersRequestRedirectPatchInput` via:
//
//	HTTPRouteSpecRulesFiltersRequestRedirectPatchArgs{...}
type HTTPRouteSpecRulesFiltersRequestRedirectPatchInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersRequestRedirectPatchOutput() HTTPRouteSpecRulesFiltersRequestRedirectPatchOutput
	ToHTTPRouteSpecRulesFiltersRequestRedirectPatchOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersRequestRedirectPatchOutput
}

// RequestRedirect defines a schema for a filter that responds to the
// request with an HTTP redirection.
//
// Support: Core
type HTTPRouteSpecRulesFiltersRequestRedirectPatchArgs struct {
	// Hostname is the hostname to be used in the value of the `Location`
	// header in the response.
	// When empty, the hostname in the `Host` header of the request is used.
	//
	// Support: Core
	Hostname pulumi.StringPtrInput                                     `pulumi:"hostname"`
	Path     HTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrInput `pulumi:"path"`
	// Port is the port to be used in the value of the `Location`
	// header in the response.
	//
	// If no port is specified, the redirect port MUST be derived using the
	// following rules:
	//
	// * If redirect scheme is not-empty, the redirect port MUST be the well-known
	//   port associated with the redirect scheme. Specifically "http" to port 80
	//   and "https" to port 443. If the redirect scheme does not have a
	//   well-known port, the listener port of the Gateway SHOULD be used.
	// * If redirect scheme is empty, the redirect port MUST be the Gateway
	//   Listener port.
	//
	// Implementations SHOULD NOT add the port number in the 'Location'
	// header in the following cases:
	//
	// * A Location header that will use HTTP (whether that is determined via
	//   the Listener protocol or the Scheme field) _and_ use port 80.
	// * A Location header that will use HTTPS (whether that is determined via
	//   the Listener protocol or the Scheme field) _and_ use port 443.
	//
	// Support: Extended
	Port pulumi.IntPtrInput `pulumi:"port"`
	// Scheme is the scheme to be used in the value of the `Location` header in
	// the response. When empty, the scheme of the request is used.
	//
	// Scheme redirects can affect the port of the redirect, for more information,
	// refer to the documentation for the port field of this filter.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	//
	// Support: Extended
	Scheme pulumi.StringPtrInput `pulumi:"scheme"`
	// StatusCode is the HTTP status code to be used in response.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	//
	// Support: Core
	StatusCode pulumi.IntPtrInput `pulumi:"statusCode"`
}

func (HTTPRouteSpecRulesFiltersRequestRedirectPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestRedirectPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersRequestRedirectPatchArgs) ToHTTPRouteSpecRulesFiltersRequestRedirectPatchOutput() HTTPRouteSpecRulesFiltersRequestRedirectPatchOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestRedirectPatchOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersRequestRedirectPatchArgs) ToHTTPRouteSpecRulesFiltersRequestRedirectPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestRedirectPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestRedirectPatchOutput)
}

func (i HTTPRouteSpecRulesFiltersRequestRedirectPatchArgs) ToHTTPRouteSpecRulesFiltersRequestRedirectPatchPtrOutput() HTTPRouteSpecRulesFiltersRequestRedirectPatchPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestRedirectPatchPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersRequestRedirectPatchArgs) ToHTTPRouteSpecRulesFiltersRequestRedirectPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestRedirectPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestRedirectPatchOutput).ToHTTPRouteSpecRulesFiltersRequestRedirectPatchPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesFiltersRequestRedirectPatchPtrInput is an input type that accepts HTTPRouteSpecRulesFiltersRequestRedirectPatchArgs, HTTPRouteSpecRulesFiltersRequestRedirectPatchPtr and HTTPRouteSpecRulesFiltersRequestRedirectPatchPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersRequestRedirectPatchPtrInput` via:
//
//	        HTTPRouteSpecRulesFiltersRequestRedirectPatchArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesFiltersRequestRedirectPatchPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersRequestRedirectPatchPtrOutput() HTTPRouteSpecRulesFiltersRequestRedirectPatchPtrOutput
	ToHTTPRouteSpecRulesFiltersRequestRedirectPatchPtrOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersRequestRedirectPatchPtrOutput
}

type httprouteSpecRulesFiltersRequestRedirectPatchPtrType HTTPRouteSpecRulesFiltersRequestRedirectPatchArgs

func HTTPRouteSpecRulesFiltersRequestRedirectPatchPtr(v *HTTPRouteSpecRulesFiltersRequestRedirectPatchArgs) HTTPRouteSpecRulesFiltersRequestRedirectPatchPtrInput {
	return (*httprouteSpecRulesFiltersRequestRedirectPatchPtrType)(v)
}

func (*httprouteSpecRulesFiltersRequestRedirectPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersRequestRedirectPatch)(nil)).Elem()
}

func (i *httprouteSpecRulesFiltersRequestRedirectPatchPtrType) ToHTTPRouteSpecRulesFiltersRequestRedirectPatchPtrOutput() HTTPRouteSpecRulesFiltersRequestRedirectPatchPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestRedirectPatchPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesFiltersRequestRedirectPatchPtrType) ToHTTPRouteSpecRulesFiltersRequestRedirectPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestRedirectPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestRedirectPatchPtrOutput)
}

// RequestRedirect defines a schema for a filter that responds to the
// request with an HTTP redirection.
//
// Support: Core
type HTTPRouteSpecRulesFiltersRequestRedirectPatchOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersRequestRedirectPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestRedirectPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersRequestRedirectPatchOutput) ToHTTPRouteSpecRulesFiltersRequestRedirectPatchOutput() HTTPRouteSpecRulesFiltersRequestRedirectPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestRedirectPatchOutput) ToHTTPRouteSpecRulesFiltersRequestRedirectPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestRedirectPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestRedirectPatchOutput) ToHTTPRouteSpecRulesFiltersRequestRedirectPatchPtrOutput() HTTPRouteSpecRulesFiltersRequestRedirectPatchPtrOutput {
	return o.ToHTTPRouteSpecRulesFiltersRequestRedirectPatchPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesFiltersRequestRedirectPatchOutput) ToHTTPRouteSpecRulesFiltersRequestRedirectPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestRedirectPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesFiltersRequestRedirectPatch) *HTTPRouteSpecRulesFiltersRequestRedirectPatch {
		return &v
	}).(HTTPRouteSpecRulesFiltersRequestRedirectPatchPtrOutput)
}

// Hostname is the hostname to be used in the value of the `Location`
// header in the response.
// When empty, the hostname in the `Host` header of the request is used.
//
// Support: Core
func (o HTTPRouteSpecRulesFiltersRequestRedirectPatchOutput) Hostname() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestRedirectPatch) *string { return v.Hostname }).(pulumi.StringPtrOutput)
}

func (o HTTPRouteSpecRulesFiltersRequestRedirectPatchOutput) Path() HTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestRedirectPatch) *HTTPRouteSpecRulesFiltersRequestRedirectPathPatch {
		return v.Path
	}).(HTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrOutput)
}

// Port is the port to be used in the value of the `Location`
// header in the response.
//
// If no port is specified, the redirect port MUST be derived using the
// following rules:
//
//   - If redirect scheme is not-empty, the redirect port MUST be the well-known
//     port associated with the redirect scheme. Specifically "http" to port 80
//     and "https" to port 443. If the redirect scheme does not have a
//     well-known port, the listener port of the Gateway SHOULD be used.
//   - If redirect scheme is empty, the redirect port MUST be the Gateway
//     Listener port.
//
// Implementations SHOULD NOT add the port number in the 'Location'
// header in the following cases:
//
//   - A Location header that will use HTTP (whether that is determined via
//     the Listener protocol or the Scheme field) _and_ use port 80.
//   - A Location header that will use HTTPS (whether that is determined via
//     the Listener protocol or the Scheme field) _and_ use port 443.
//
// Support: Extended
func (o HTTPRouteSpecRulesFiltersRequestRedirectPatchOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestRedirectPatch) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// Scheme is the scheme to be used in the value of the `Location` header in
// the response. When empty, the scheme of the request is used.
//
// Scheme redirects can affect the port of the redirect, for more information,
// refer to the documentation for the port field of this filter.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
//
// Support: Extended
func (o HTTPRouteSpecRulesFiltersRequestRedirectPatchOutput) Scheme() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestRedirectPatch) *string { return v.Scheme }).(pulumi.StringPtrOutput)
}

// StatusCode is the HTTP status code to be used in response.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
//
// Support: Core
func (o HTTPRouteSpecRulesFiltersRequestRedirectPatchOutput) StatusCode() pulumi.IntPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestRedirectPatch) *int { return v.StatusCode }).(pulumi.IntPtrOutput)
}

type HTTPRouteSpecRulesFiltersRequestRedirectPatchPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersRequestRedirectPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersRequestRedirectPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersRequestRedirectPatchPtrOutput) ToHTTPRouteSpecRulesFiltersRequestRedirectPatchPtrOutput() HTTPRouteSpecRulesFiltersRequestRedirectPatchPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestRedirectPatchPtrOutput) ToHTTPRouteSpecRulesFiltersRequestRedirectPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestRedirectPatchPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestRedirectPatchPtrOutput) Elem() HTTPRouteSpecRulesFiltersRequestRedirectPatchOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestRedirectPatch) HTTPRouteSpecRulesFiltersRequestRedirectPatch {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesFiltersRequestRedirectPatch
		return ret
	}).(HTTPRouteSpecRulesFiltersRequestRedirectPatchOutput)
}

// Hostname is the hostname to be used in the value of the `Location`
// header in the response.
// When empty, the hostname in the `Host` header of the request is used.
//
// Support: Core
func (o HTTPRouteSpecRulesFiltersRequestRedirectPatchPtrOutput) Hostname() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestRedirectPatch) *string {
		if v == nil {
			return nil
		}
		return v.Hostname
	}).(pulumi.StringPtrOutput)
}

func (o HTTPRouteSpecRulesFiltersRequestRedirectPatchPtrOutput) Path() HTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestRedirectPatch) *HTTPRouteSpecRulesFiltersRequestRedirectPathPatch {
		if v == nil {
			return nil
		}
		return v.Path
	}).(HTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrOutput)
}

// Port is the port to be used in the value of the `Location`
// header in the response.
//
// If no port is specified, the redirect port MUST be derived using the
// following rules:
//
//   - If redirect scheme is not-empty, the redirect port MUST be the well-known
//     port associated with the redirect scheme. Specifically "http" to port 80
//     and "https" to port 443. If the redirect scheme does not have a
//     well-known port, the listener port of the Gateway SHOULD be used.
//   - If redirect scheme is empty, the redirect port MUST be the Gateway
//     Listener port.
//
// Implementations SHOULD NOT add the port number in the 'Location'
// header in the following cases:
//
//   - A Location header that will use HTTP (whether that is determined via
//     the Listener protocol or the Scheme field) _and_ use port 80.
//   - A Location header that will use HTTPS (whether that is determined via
//     the Listener protocol or the Scheme field) _and_ use port 443.
//
// Support: Extended
func (o HTTPRouteSpecRulesFiltersRequestRedirectPatchPtrOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestRedirectPatch) *int {
		if v == nil {
			return nil
		}
		return v.Port
	}).(pulumi.IntPtrOutput)
}

// Scheme is the scheme to be used in the value of the `Location` header in
// the response. When empty, the scheme of the request is used.
//
// Scheme redirects can affect the port of the redirect, for more information,
// refer to the documentation for the port field of this filter.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
//
// Support: Extended
func (o HTTPRouteSpecRulesFiltersRequestRedirectPatchPtrOutput) Scheme() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestRedirectPatch) *string {
		if v == nil {
			return nil
		}
		return v.Scheme
	}).(pulumi.StringPtrOutput)
}

// StatusCode is the HTTP status code to be used in response.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
//
// Support: Core
func (o HTTPRouteSpecRulesFiltersRequestRedirectPatchPtrOutput) StatusCode() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestRedirectPatch) *int {
		if v == nil {
			return nil
		}
		return v.StatusCode
	}).(pulumi.IntPtrOutput)
}

// Path defines parameters used to modify the path of the incoming request.
// The modified path is then used to construct the `Location` header. When
// empty, the request path is used as-is.
//
// Support: Extended
type HTTPRouteSpecRulesFiltersRequestRedirectPath struct {
	// ReplaceFullPath specifies the value with which to replace the full path
	// of a request during a rewrite or redirect.
	ReplaceFullPath *string `pulumi:"replaceFullPath"`
	// ReplacePrefixMatch specifies the value with which to replace the prefix
	// match of a request during a rewrite or redirect. For example, a request
	// to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
	// of "/xyz" would be modified to "/xyz/bar".
	//
	// Note that this matches the behavior of the PathPrefix match type. This
	// matches full path elements. A path element refers to the list of labels
	// in the path split by the `/` separator. When specified, a trailing `/` is
	// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
	// match the prefix `/abc`, but the path `/abcd` would not.
	//
	// ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
	// Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
	// the implementation setting the Accepted Condition for the Route to `status: False`.
	//
	// Request Path | Prefix Match | Replace Prefix | Modified Path
	// -------------|--------------|----------------|----------
	// /foo/bar     | /foo         | /xyz           | /xyz/bar
	// /foo/bar     | /foo         | /xyz/          | /xyz/bar
	// /foo/bar     | /foo/        | /xyz           | /xyz/bar
	// /foo/bar     | /foo/        | /xyz/          | /xyz/bar
	// /foo         | /foo         | /xyz           | /xyz
	// /foo/        | /foo         | /xyz           | /xyz/
	// /foo/bar     | /foo         | <empty string> | /bar
	// /foo/        | /foo         | <empty string> | /
	// /foo         | /foo         | <empty string> | /
	// /foo/        | /foo         | /              | /
	// /foo         | /foo         | /              | /
	ReplacePrefixMatch *string `pulumi:"replacePrefixMatch"`
	// Type defines the type of path modifier. Additional types may be
	// added in a future release of the API.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	Type *string `pulumi:"type"`
}

// HTTPRouteSpecRulesFiltersRequestRedirectPathInput is an input type that accepts HTTPRouteSpecRulesFiltersRequestRedirectPathArgs and HTTPRouteSpecRulesFiltersRequestRedirectPathOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersRequestRedirectPathInput` via:
//
//	HTTPRouteSpecRulesFiltersRequestRedirectPathArgs{...}
type HTTPRouteSpecRulesFiltersRequestRedirectPathInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersRequestRedirectPathOutput() HTTPRouteSpecRulesFiltersRequestRedirectPathOutput
	ToHTTPRouteSpecRulesFiltersRequestRedirectPathOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersRequestRedirectPathOutput
}

// Path defines parameters used to modify the path of the incoming request.
// The modified path is then used to construct the `Location` header. When
// empty, the request path is used as-is.
//
// Support: Extended
type HTTPRouteSpecRulesFiltersRequestRedirectPathArgs struct {
	// ReplaceFullPath specifies the value with which to replace the full path
	// of a request during a rewrite or redirect.
	ReplaceFullPath pulumi.StringPtrInput `pulumi:"replaceFullPath"`
	// ReplacePrefixMatch specifies the value with which to replace the prefix
	// match of a request during a rewrite or redirect. For example, a request
	// to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
	// of "/xyz" would be modified to "/xyz/bar".
	//
	// Note that this matches the behavior of the PathPrefix match type. This
	// matches full path elements. A path element refers to the list of labels
	// in the path split by the `/` separator. When specified, a trailing `/` is
	// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
	// match the prefix `/abc`, but the path `/abcd` would not.
	//
	// ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
	// Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
	// the implementation setting the Accepted Condition for the Route to `status: False`.
	//
	// Request Path | Prefix Match | Replace Prefix | Modified Path
	// -------------|--------------|----------------|----------
	// /foo/bar     | /foo         | /xyz           | /xyz/bar
	// /foo/bar     | /foo         | /xyz/          | /xyz/bar
	// /foo/bar     | /foo/        | /xyz           | /xyz/bar
	// /foo/bar     | /foo/        | /xyz/          | /xyz/bar
	// /foo         | /foo         | /xyz           | /xyz
	// /foo/        | /foo         | /xyz           | /xyz/
	// /foo/bar     | /foo         | <empty string> | /bar
	// /foo/        | /foo         | <empty string> | /
	// /foo         | /foo         | <empty string> | /
	// /foo/        | /foo         | /              | /
	// /foo         | /foo         | /              | /
	ReplacePrefixMatch pulumi.StringPtrInput `pulumi:"replacePrefixMatch"`
	// Type defines the type of path modifier. Additional types may be
	// added in a future release of the API.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (HTTPRouteSpecRulesFiltersRequestRedirectPathArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestRedirectPath)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersRequestRedirectPathArgs) ToHTTPRouteSpecRulesFiltersRequestRedirectPathOutput() HTTPRouteSpecRulesFiltersRequestRedirectPathOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestRedirectPathOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersRequestRedirectPathArgs) ToHTTPRouteSpecRulesFiltersRequestRedirectPathOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestRedirectPathOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestRedirectPathOutput)
}

func (i HTTPRouteSpecRulesFiltersRequestRedirectPathArgs) ToHTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput() HTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersRequestRedirectPathArgs) ToHTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestRedirectPathOutput).ToHTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesFiltersRequestRedirectPathPtrInput is an input type that accepts HTTPRouteSpecRulesFiltersRequestRedirectPathArgs, HTTPRouteSpecRulesFiltersRequestRedirectPathPtr and HTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersRequestRedirectPathPtrInput` via:
//
//	        HTTPRouteSpecRulesFiltersRequestRedirectPathArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesFiltersRequestRedirectPathPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput() HTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput
	ToHTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput
}

type httprouteSpecRulesFiltersRequestRedirectPathPtrType HTTPRouteSpecRulesFiltersRequestRedirectPathArgs

func HTTPRouteSpecRulesFiltersRequestRedirectPathPtr(v *HTTPRouteSpecRulesFiltersRequestRedirectPathArgs) HTTPRouteSpecRulesFiltersRequestRedirectPathPtrInput {
	return (*httprouteSpecRulesFiltersRequestRedirectPathPtrType)(v)
}

func (*httprouteSpecRulesFiltersRequestRedirectPathPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersRequestRedirectPath)(nil)).Elem()
}

func (i *httprouteSpecRulesFiltersRequestRedirectPathPtrType) ToHTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput() HTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesFiltersRequestRedirectPathPtrType) ToHTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput)
}

// Path defines parameters used to modify the path of the incoming request.
// The modified path is then used to construct the `Location` header. When
// empty, the request path is used as-is.
//
// Support: Extended
type HTTPRouteSpecRulesFiltersRequestRedirectPathOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersRequestRedirectPathOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestRedirectPath)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersRequestRedirectPathOutput) ToHTTPRouteSpecRulesFiltersRequestRedirectPathOutput() HTTPRouteSpecRulesFiltersRequestRedirectPathOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestRedirectPathOutput) ToHTTPRouteSpecRulesFiltersRequestRedirectPathOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestRedirectPathOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestRedirectPathOutput) ToHTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput() HTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput {
	return o.ToHTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesFiltersRequestRedirectPathOutput) ToHTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesFiltersRequestRedirectPath) *HTTPRouteSpecRulesFiltersRequestRedirectPath {
		return &v
	}).(HTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput)
}

// ReplaceFullPath specifies the value with which to replace the full path
// of a request during a rewrite or redirect.
func (o HTTPRouteSpecRulesFiltersRequestRedirectPathOutput) ReplaceFullPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestRedirectPath) *string { return v.ReplaceFullPath }).(pulumi.StringPtrOutput)
}

// ReplacePrefixMatch specifies the value with which to replace the prefix
// match of a request during a rewrite or redirect. For example, a request
// to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
// of "/xyz" would be modified to "/xyz/bar".
//
// Note that this matches the behavior of the PathPrefix match type. This
// matches full path elements. A path element refers to the list of labels
// in the path split by the `/` separator. When specified, a trailing `/` is
// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
// match the prefix `/abc`, but the path `/abcd` would not.
//
// ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
// Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
// the implementation setting the Accepted Condition for the Route to `status: False`.
//
// Request Path | Prefix Match | Replace Prefix | Modified Path
// -------------|--------------|----------------|----------
// /foo/bar     | /foo         | /xyz           | /xyz/bar
// /foo/bar     | /foo         | /xyz/          | /xyz/bar
// /foo/bar     | /foo/        | /xyz           | /xyz/bar
// /foo/bar     | /foo/        | /xyz/          | /xyz/bar
// /foo         | /foo         | /xyz           | /xyz
// /foo/        | /foo         | /xyz           | /xyz/
// /foo/bar     | /foo         | <empty string> | /bar
// /foo/        | /foo         | <empty string> | /
// /foo         | /foo         | <empty string> | /
// /foo/        | /foo         | /              | /
// /foo         | /foo         | /              | /
func (o HTTPRouteSpecRulesFiltersRequestRedirectPathOutput) ReplacePrefixMatch() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestRedirectPath) *string { return v.ReplacePrefixMatch }).(pulumi.StringPtrOutput)
}

// Type defines the type of path modifier. Additional types may be
// added in a future release of the API.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
func (o HTTPRouteSpecRulesFiltersRequestRedirectPathOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestRedirectPath) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type HTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersRequestRedirectPath)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput) ToHTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput() HTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput) ToHTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput) Elem() HTTPRouteSpecRulesFiltersRequestRedirectPathOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestRedirectPath) HTTPRouteSpecRulesFiltersRequestRedirectPath {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesFiltersRequestRedirectPath
		return ret
	}).(HTTPRouteSpecRulesFiltersRequestRedirectPathOutput)
}

// ReplaceFullPath specifies the value with which to replace the full path
// of a request during a rewrite or redirect.
func (o HTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput) ReplaceFullPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestRedirectPath) *string {
		if v == nil {
			return nil
		}
		return v.ReplaceFullPath
	}).(pulumi.StringPtrOutput)
}

// ReplacePrefixMatch specifies the value with which to replace the prefix
// match of a request during a rewrite or redirect. For example, a request
// to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
// of "/xyz" would be modified to "/xyz/bar".
//
// Note that this matches the behavior of the PathPrefix match type. This
// matches full path elements. A path element refers to the list of labels
// in the path split by the `/` separator. When specified, a trailing `/` is
// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
// match the prefix `/abc`, but the path `/abcd` would not.
//
// ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
// Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
// the implementation setting the Accepted Condition for the Route to `status: False`.
//
// Request Path | Prefix Match | Replace Prefix | Modified Path
// -------------|--------------|----------------|----------
// /foo/bar     | /foo         | /xyz           | /xyz/bar
// /foo/bar     | /foo         | /xyz/          | /xyz/bar
// /foo/bar     | /foo/        | /xyz           | /xyz/bar
// /foo/bar     | /foo/        | /xyz/          | /xyz/bar
// /foo         | /foo         | /xyz           | /xyz
// /foo/        | /foo         | /xyz           | /xyz/
// /foo/bar     | /foo         | <empty string> | /bar
// /foo/        | /foo         | <empty string> | /
// /foo         | /foo         | <empty string> | /
// /foo/        | /foo         | /              | /
// /foo         | /foo         | /              | /
func (o HTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput) ReplacePrefixMatch() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestRedirectPath) *string {
		if v == nil {
			return nil
		}
		return v.ReplacePrefixMatch
	}).(pulumi.StringPtrOutput)
}

// Type defines the type of path modifier. Additional types may be
// added in a future release of the API.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
func (o HTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestRedirectPath) *string {
		if v == nil {
			return nil
		}
		return v.Type
	}).(pulumi.StringPtrOutput)
}

// Path defines parameters used to modify the path of the incoming request.
// The modified path is then used to construct the `Location` header. When
// empty, the request path is used as-is.
//
// Support: Extended
type HTTPRouteSpecRulesFiltersRequestRedirectPathPatch struct {
	// ReplaceFullPath specifies the value with which to replace the full path
	// of a request during a rewrite or redirect.
	ReplaceFullPath *string `pulumi:"replaceFullPath"`
	// ReplacePrefixMatch specifies the value with which to replace the prefix
	// match of a request during a rewrite or redirect. For example, a request
	// to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
	// of "/xyz" would be modified to "/xyz/bar".
	//
	// Note that this matches the behavior of the PathPrefix match type. This
	// matches full path elements. A path element refers to the list of labels
	// in the path split by the `/` separator. When specified, a trailing `/` is
	// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
	// match the prefix `/abc`, but the path `/abcd` would not.
	//
	// ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
	// Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
	// the implementation setting the Accepted Condition for the Route to `status: False`.
	//
	// Request Path | Prefix Match | Replace Prefix | Modified Path
	// -------------|--------------|----------------|----------
	// /foo/bar     | /foo         | /xyz           | /xyz/bar
	// /foo/bar     | /foo         | /xyz/          | /xyz/bar
	// /foo/bar     | /foo/        | /xyz           | /xyz/bar
	// /foo/bar     | /foo/        | /xyz/          | /xyz/bar
	// /foo         | /foo         | /xyz           | /xyz
	// /foo/        | /foo         | /xyz           | /xyz/
	// /foo/bar     | /foo         | <empty string> | /bar
	// /foo/        | /foo         | <empty string> | /
	// /foo         | /foo         | <empty string> | /
	// /foo/        | /foo         | /              | /
	// /foo         | /foo         | /              | /
	ReplacePrefixMatch *string `pulumi:"replacePrefixMatch"`
	// Type defines the type of path modifier. Additional types may be
	// added in a future release of the API.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	Type *string `pulumi:"type"`
}

// HTTPRouteSpecRulesFiltersRequestRedirectPathPatchInput is an input type that accepts HTTPRouteSpecRulesFiltersRequestRedirectPathPatchArgs and HTTPRouteSpecRulesFiltersRequestRedirectPathPatchOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersRequestRedirectPathPatchInput` via:
//
//	HTTPRouteSpecRulesFiltersRequestRedirectPathPatchArgs{...}
type HTTPRouteSpecRulesFiltersRequestRedirectPathPatchInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersRequestRedirectPathPatchOutput() HTTPRouteSpecRulesFiltersRequestRedirectPathPatchOutput
	ToHTTPRouteSpecRulesFiltersRequestRedirectPathPatchOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersRequestRedirectPathPatchOutput
}

// Path defines parameters used to modify the path of the incoming request.
// The modified path is then used to construct the `Location` header. When
// empty, the request path is used as-is.
//
// Support: Extended
type HTTPRouteSpecRulesFiltersRequestRedirectPathPatchArgs struct {
	// ReplaceFullPath specifies the value with which to replace the full path
	// of a request during a rewrite or redirect.
	ReplaceFullPath pulumi.StringPtrInput `pulumi:"replaceFullPath"`
	// ReplacePrefixMatch specifies the value with which to replace the prefix
	// match of a request during a rewrite or redirect. For example, a request
	// to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
	// of "/xyz" would be modified to "/xyz/bar".
	//
	// Note that this matches the behavior of the PathPrefix match type. This
	// matches full path elements. A path element refers to the list of labels
	// in the path split by the `/` separator. When specified, a trailing `/` is
	// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
	// match the prefix `/abc`, but the path `/abcd` would not.
	//
	// ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
	// Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
	// the implementation setting the Accepted Condition for the Route to `status: False`.
	//
	// Request Path | Prefix Match | Replace Prefix | Modified Path
	// -------------|--------------|----------------|----------
	// /foo/bar     | /foo         | /xyz           | /xyz/bar
	// /foo/bar     | /foo         | /xyz/          | /xyz/bar
	// /foo/bar     | /foo/        | /xyz           | /xyz/bar
	// /foo/bar     | /foo/        | /xyz/          | /xyz/bar
	// /foo         | /foo         | /xyz           | /xyz
	// /foo/        | /foo         | /xyz           | /xyz/
	// /foo/bar     | /foo         | <empty string> | /bar
	// /foo/        | /foo         | <empty string> | /
	// /foo         | /foo         | <empty string> | /
	// /foo/        | /foo         | /              | /
	// /foo         | /foo         | /              | /
	ReplacePrefixMatch pulumi.StringPtrInput `pulumi:"replacePrefixMatch"`
	// Type defines the type of path modifier. Additional types may be
	// added in a future release of the API.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (HTTPRouteSpecRulesFiltersRequestRedirectPathPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestRedirectPathPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersRequestRedirectPathPatchArgs) ToHTTPRouteSpecRulesFiltersRequestRedirectPathPatchOutput() HTTPRouteSpecRulesFiltersRequestRedirectPathPatchOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestRedirectPathPatchOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersRequestRedirectPathPatchArgs) ToHTTPRouteSpecRulesFiltersRequestRedirectPathPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestRedirectPathPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestRedirectPathPatchOutput)
}

func (i HTTPRouteSpecRulesFiltersRequestRedirectPathPatchArgs) ToHTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrOutput() HTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersRequestRedirectPathPatchArgs) ToHTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestRedirectPathPatchOutput).ToHTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrInput is an input type that accepts HTTPRouteSpecRulesFiltersRequestRedirectPathPatchArgs, HTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtr and HTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrInput` via:
//
//	        HTTPRouteSpecRulesFiltersRequestRedirectPathPatchArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrOutput() HTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrOutput
	ToHTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrOutput
}

type httprouteSpecRulesFiltersRequestRedirectPathPatchPtrType HTTPRouteSpecRulesFiltersRequestRedirectPathPatchArgs

func HTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtr(v *HTTPRouteSpecRulesFiltersRequestRedirectPathPatchArgs) HTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrInput {
	return (*httprouteSpecRulesFiltersRequestRedirectPathPatchPtrType)(v)
}

func (*httprouteSpecRulesFiltersRequestRedirectPathPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersRequestRedirectPathPatch)(nil)).Elem()
}

func (i *httprouteSpecRulesFiltersRequestRedirectPathPatchPtrType) ToHTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrOutput() HTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesFiltersRequestRedirectPathPatchPtrType) ToHTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrOutput)
}

// Path defines parameters used to modify the path of the incoming request.
// The modified path is then used to construct the `Location` header. When
// empty, the request path is used as-is.
//
// Support: Extended
type HTTPRouteSpecRulesFiltersRequestRedirectPathPatchOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersRequestRedirectPathPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestRedirectPathPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersRequestRedirectPathPatchOutput) ToHTTPRouteSpecRulesFiltersRequestRedirectPathPatchOutput() HTTPRouteSpecRulesFiltersRequestRedirectPathPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestRedirectPathPatchOutput) ToHTTPRouteSpecRulesFiltersRequestRedirectPathPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestRedirectPathPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestRedirectPathPatchOutput) ToHTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrOutput() HTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrOutput {
	return o.ToHTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesFiltersRequestRedirectPathPatchOutput) ToHTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesFiltersRequestRedirectPathPatch) *HTTPRouteSpecRulesFiltersRequestRedirectPathPatch {
		return &v
	}).(HTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrOutput)
}

// ReplaceFullPath specifies the value with which to replace the full path
// of a request during a rewrite or redirect.
func (o HTTPRouteSpecRulesFiltersRequestRedirectPathPatchOutput) ReplaceFullPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestRedirectPathPatch) *string { return v.ReplaceFullPath }).(pulumi.StringPtrOutput)
}

// ReplacePrefixMatch specifies the value with which to replace the prefix
// match of a request during a rewrite or redirect. For example, a request
// to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
// of "/xyz" would be modified to "/xyz/bar".
//
// Note that this matches the behavior of the PathPrefix match type. This
// matches full path elements. A path element refers to the list of labels
// in the path split by the `/` separator. When specified, a trailing `/` is
// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
// match the prefix `/abc`, but the path `/abcd` would not.
//
// ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
// Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
// the implementation setting the Accepted Condition for the Route to `status: False`.
//
// Request Path | Prefix Match | Replace Prefix | Modified Path
// -------------|--------------|----------------|----------
// /foo/bar     | /foo         | /xyz           | /xyz/bar
// /foo/bar     | /foo         | /xyz/          | /xyz/bar
// /foo/bar     | /foo/        | /xyz           | /xyz/bar
// /foo/bar     | /foo/        | /xyz/          | /xyz/bar
// /foo         | /foo         | /xyz           | /xyz
// /foo/        | /foo         | /xyz           | /xyz/
// /foo/bar     | /foo         | <empty string> | /bar
// /foo/        | /foo         | <empty string> | /
// /foo         | /foo         | <empty string> | /
// /foo/        | /foo         | /              | /
// /foo         | /foo         | /              | /
func (o HTTPRouteSpecRulesFiltersRequestRedirectPathPatchOutput) ReplacePrefixMatch() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestRedirectPathPatch) *string { return v.ReplacePrefixMatch }).(pulumi.StringPtrOutput)
}

// Type defines the type of path modifier. Additional types may be
// added in a future release of the API.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
func (o HTTPRouteSpecRulesFiltersRequestRedirectPathPatchOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersRequestRedirectPathPatch) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type HTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersRequestRedirectPathPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrOutput) ToHTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrOutput() HTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrOutput) ToHTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrOutput) Elem() HTTPRouteSpecRulesFiltersRequestRedirectPathPatchOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestRedirectPathPatch) HTTPRouteSpecRulesFiltersRequestRedirectPathPatch {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesFiltersRequestRedirectPathPatch
		return ret
	}).(HTTPRouteSpecRulesFiltersRequestRedirectPathPatchOutput)
}

// ReplaceFullPath specifies the value with which to replace the full path
// of a request during a rewrite or redirect.
func (o HTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrOutput) ReplaceFullPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestRedirectPathPatch) *string {
		if v == nil {
			return nil
		}
		return v.ReplaceFullPath
	}).(pulumi.StringPtrOutput)
}

// ReplacePrefixMatch specifies the value with which to replace the prefix
// match of a request during a rewrite or redirect. For example, a request
// to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
// of "/xyz" would be modified to "/xyz/bar".
//
// Note that this matches the behavior of the PathPrefix match type. This
// matches full path elements. A path element refers to the list of labels
// in the path split by the `/` separator. When specified, a trailing `/` is
// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
// match the prefix `/abc`, but the path `/abcd` would not.
//
// ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
// Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
// the implementation setting the Accepted Condition for the Route to `status: False`.
//
// Request Path | Prefix Match | Replace Prefix | Modified Path
// -------------|--------------|----------------|----------
// /foo/bar     | /foo         | /xyz           | /xyz/bar
// /foo/bar     | /foo         | /xyz/          | /xyz/bar
// /foo/bar     | /foo/        | /xyz           | /xyz/bar
// /foo/bar     | /foo/        | /xyz/          | /xyz/bar
// /foo         | /foo         | /xyz           | /xyz
// /foo/        | /foo         | /xyz           | /xyz/
// /foo/bar     | /foo         | <empty string> | /bar
// /foo/        | /foo         | <empty string> | /
// /foo         | /foo         | <empty string> | /
// /foo/        | /foo         | /              | /
// /foo         | /foo         | /              | /
func (o HTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrOutput) ReplacePrefixMatch() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestRedirectPathPatch) *string {
		if v == nil {
			return nil
		}
		return v.ReplacePrefixMatch
	}).(pulumi.StringPtrOutput)
}

// Type defines the type of path modifier. Additional types may be
// added in a future release of the API.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
func (o HTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersRequestRedirectPathPatch) *string {
		if v == nil {
			return nil
		}
		return v.Type
	}).(pulumi.StringPtrOutput)
}

// ResponseHeaderModifier defines a schema for a filter that modifies response
// headers.
//
// Support: Extended
type HTTPRouteSpecRulesFiltersResponseHeaderModifier struct {
	// Add adds the given header(s) (name, value) to the request
	// before the action. It appends to any existing values associated
	// with the header name.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   add:
	//   - name: "my-header"
	//     value: "bar,baz"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: foo,bar,baz
	Add []HTTPRouteSpecRulesFiltersResponseHeaderModifierAdd `pulumi:"add"`
	// Remove the given header(s) from the HTTP request before the action. The
	// value of Remove is a list of HTTP header names. Note that the header
	// names are case-insensitive (see
	// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header1: foo
	//   my-header2: bar
	//   my-header3: baz
	//
	// Config:
	//   remove: ["my-header1", "my-header3"]
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header2: bar
	Remove []string `pulumi:"remove"`
	// Set overwrites the request with the given header (name, value)
	// before the action.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   set:
	//   - name: "my-header"
	//     value: "bar"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: bar
	Set []HTTPRouteSpecRulesFiltersResponseHeaderModifierSet `pulumi:"set"`
}

// HTTPRouteSpecRulesFiltersResponseHeaderModifierInput is an input type that accepts HTTPRouteSpecRulesFiltersResponseHeaderModifierArgs and HTTPRouteSpecRulesFiltersResponseHeaderModifierOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersResponseHeaderModifierInput` via:
//
//	HTTPRouteSpecRulesFiltersResponseHeaderModifierArgs{...}
type HTTPRouteSpecRulesFiltersResponseHeaderModifierInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersResponseHeaderModifierOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierOutput
	ToHTTPRouteSpecRulesFiltersResponseHeaderModifierOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierOutput
}

// ResponseHeaderModifier defines a schema for a filter that modifies response
// headers.
//
// Support: Extended
type HTTPRouteSpecRulesFiltersResponseHeaderModifierArgs struct {
	// Add adds the given header(s) (name, value) to the request
	// before the action. It appends to any existing values associated
	// with the header name.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   add:
	//   - name: "my-header"
	//     value: "bar,baz"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: foo,bar,baz
	Add HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayInput `pulumi:"add"`
	// Remove the given header(s) from the HTTP request before the action. The
	// value of Remove is a list of HTTP header names. Note that the header
	// names are case-insensitive (see
	// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header1: foo
	//   my-header2: bar
	//   my-header3: baz
	//
	// Config:
	//   remove: ["my-header1", "my-header3"]
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header2: bar
	Remove pulumi.StringArrayInput `pulumi:"remove"`
	// Set overwrites the request with the given header (name, value)
	// before the action.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   set:
	//   - name: "my-header"
	//     value: "bar"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: bar
	Set HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayInput `pulumi:"set"`
}

func (HTTPRouteSpecRulesFiltersResponseHeaderModifierArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersResponseHeaderModifier)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersResponseHeaderModifierArgs) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierOutput {
	return i.ToHTTPRouteSpecRulesFiltersResponseHeaderModifierOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersResponseHeaderModifierArgs) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersResponseHeaderModifierOutput)
}

func (i HTTPRouteSpecRulesFiltersResponseHeaderModifierArgs) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersResponseHeaderModifierArgs) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersResponseHeaderModifierOutput).ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrInput is an input type that accepts HTTPRouteSpecRulesFiltersResponseHeaderModifierArgs, HTTPRouteSpecRulesFiltersResponseHeaderModifierPtr and HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrInput` via:
//
//	        HTTPRouteSpecRulesFiltersResponseHeaderModifierArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput
	ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput
}

type httprouteSpecRulesFiltersResponseHeaderModifierPtrType HTTPRouteSpecRulesFiltersResponseHeaderModifierArgs

func HTTPRouteSpecRulesFiltersResponseHeaderModifierPtr(v *HTTPRouteSpecRulesFiltersResponseHeaderModifierArgs) HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrInput {
	return (*httprouteSpecRulesFiltersResponseHeaderModifierPtrType)(v)
}

func (*httprouteSpecRulesFiltersResponseHeaderModifierPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersResponseHeaderModifier)(nil)).Elem()
}

func (i *httprouteSpecRulesFiltersResponseHeaderModifierPtrType) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesFiltersResponseHeaderModifierPtrType) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput)
}

// ResponseHeaderModifier defines a schema for a filter that modifies response
// headers.
//
// Support: Extended
type HTTPRouteSpecRulesFiltersResponseHeaderModifierOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersResponseHeaderModifierOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersResponseHeaderModifier)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierOutput) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierOutput) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierOutput) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput {
	return o.ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierOutput) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesFiltersResponseHeaderModifier) *HTTPRouteSpecRulesFiltersResponseHeaderModifier {
		return &v
	}).(HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput)
}

// Add adds the given header(s) (name, value) to the request
// before the action. It appends to any existing values associated
// with the header name.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	add:
//	- name: "my-header"
//	  value: "bar,baz"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: foo,bar,baz
func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierOutput) Add() HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersResponseHeaderModifier) []HTTPRouteSpecRulesFiltersResponseHeaderModifierAdd {
		return v.Add
	}).(HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput)
}

// Remove the given header(s) from the HTTP request before the action. The
// value of Remove is a list of HTTP header names. Note that the header
// names are case-insensitive (see
// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header1: foo
//	my-header2: bar
//	my-header3: baz
//
// Config:
//
//	remove: ["my-header1", "my-header3"]
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header2: bar
func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierOutput) Remove() pulumi.StringArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersResponseHeaderModifier) []string { return v.Remove }).(pulumi.StringArrayOutput)
}

// Set overwrites the request with the given header (name, value)
// before the action.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	set:
//	- name: "my-header"
//	  value: "bar"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: bar
func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierOutput) Set() HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersResponseHeaderModifier) []HTTPRouteSpecRulesFiltersResponseHeaderModifierSet {
		return v.Set
	}).(HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput)
}

type HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersResponseHeaderModifier)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput) Elem() HTTPRouteSpecRulesFiltersResponseHeaderModifierOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersResponseHeaderModifier) HTTPRouteSpecRulesFiltersResponseHeaderModifier {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesFiltersResponseHeaderModifier
		return ret
	}).(HTTPRouteSpecRulesFiltersResponseHeaderModifierOutput)
}

// Add adds the given header(s) (name, value) to the request
// before the action. It appends to any existing values associated
// with the header name.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	add:
//	- name: "my-header"
//	  value: "bar,baz"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: foo,bar,baz
func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput) Add() HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersResponseHeaderModifier) []HTTPRouteSpecRulesFiltersResponseHeaderModifierAdd {
		if v == nil {
			return nil
		}
		return v.Add
	}).(HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput)
}

// Remove the given header(s) from the HTTP request before the action. The
// value of Remove is a list of HTTP header names. Note that the header
// names are case-insensitive (see
// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header1: foo
//	my-header2: bar
//	my-header3: baz
//
// Config:
//
//	remove: ["my-header1", "my-header3"]
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header2: bar
func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput) Remove() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersResponseHeaderModifier) []string {
		if v == nil {
			return nil
		}
		return v.Remove
	}).(pulumi.StringArrayOutput)
}

// Set overwrites the request with the given header (name, value)
// before the action.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	set:
//	- name: "my-header"
//	  value: "bar"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: bar
func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput) Set() HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersResponseHeaderModifier) []HTTPRouteSpecRulesFiltersResponseHeaderModifierSet {
		if v == nil {
			return nil
		}
		return v.Set
	}).(HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesFiltersResponseHeaderModifierAdd struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name *string `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value *string `pulumi:"value"`
}

// HTTPRouteSpecRulesFiltersResponseHeaderModifierAddInput is an input type that accepts HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArgs and HTTPRouteSpecRulesFiltersResponseHeaderModifierAddOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersResponseHeaderModifierAddInput` via:
//
//	HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArgs{...}
type HTTPRouteSpecRulesFiltersResponseHeaderModifierAddInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersResponseHeaderModifierAddOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierAddOutput
	ToHTTPRouteSpecRulesFiltersResponseHeaderModifierAddOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierAddOutput
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArgs struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersResponseHeaderModifierAdd)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArgs) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierAddOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierAddOutput {
	return i.ToHTTPRouteSpecRulesFiltersResponseHeaderModifierAddOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArgs) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierAddOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierAddOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersResponseHeaderModifierAddOutput)
}

// HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayInput is an input type that accepts HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArray and HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayInput` via:
//
//	HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArray{ HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArgs{...} }
type HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput
	ToHTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput
}

type HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArray []HTTPRouteSpecRulesFiltersResponseHeaderModifierAddInput

func (HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesFiltersResponseHeaderModifierAdd)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArray) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput {
	return i.ToHTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArray) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesFiltersResponseHeaderModifierAddOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersResponseHeaderModifierAddOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersResponseHeaderModifierAdd)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierAddOutput) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierAddOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierAddOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierAddOutput) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierAddOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierAddOutput {
	return o
}

// Name is the name of the HTTP Header to be matched. Name matching MUST be
// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
//
// If multiple entries specify equivalent header names, the first entry with
// an equivalent name MUST be considered for a match. Subsequent entries
// with an equivalent header name MUST be ignored. Due to the
// case-insensitivity of header names, "foo" and "Foo" are considered
// equivalent.
func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierAddOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersResponseHeaderModifierAdd) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Value is the value of HTTP Header to be matched.
func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierAddOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersResponseHeaderModifierAdd) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesFiltersResponseHeaderModifierAdd)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput) Index(i pulumi.IntInput) HTTPRouteSpecRulesFiltersResponseHeaderModifierAddOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteSpecRulesFiltersResponseHeaderModifierAdd {
		return vs[0].([]HTTPRouteSpecRulesFiltersResponseHeaderModifierAdd)[vs[1].(int)]
	}).(HTTPRouteSpecRulesFiltersResponseHeaderModifierAddOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatch struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name *string `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value *string `pulumi:"value"`
}

// HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchInput is an input type that accepts HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArgs and HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchInput` via:
//
//	HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArgs{...}
type HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchOutput
	ToHTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchOutput
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArgs struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArgs) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchOutput {
	return i.ToHTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArgs) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchOutput)
}

// HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayInput is an input type that accepts HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArray and HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayInput` via:
//
//	HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArray{ HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArgs{...} }
type HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayOutput
	ToHTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayOutput
}

type HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArray []HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchInput

func (HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArray) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayOutput {
	return i.ToHTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArray) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchOutput) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchOutput) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchOutput {
	return o
}

// Name is the name of the HTTP Header to be matched. Name matching MUST be
// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
//
// If multiple entries specify equivalent header names, the first entry with
// an equivalent name MUST be considered for a match. Subsequent entries
// with an equivalent header name MUST be ignored. Due to the
// case-insensitivity of header names, "foo" and "Foo" are considered
// equivalent.
func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Value is the value of HTTP Header to be matched.
func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatch) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayOutput) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayOutput) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayOutput) Index(i pulumi.IntInput) HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatch {
		return vs[0].([]HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatch)[vs[1].(int)]
	}).(HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchOutput)
}

// ResponseHeaderModifier defines a schema for a filter that modifies response
// headers.
//
// Support: Extended
type HTTPRouteSpecRulesFiltersResponseHeaderModifierPatch struct {
	// Add adds the given header(s) (name, value) to the request
	// before the action. It appends to any existing values associated
	// with the header name.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   add:
	//   - name: "my-header"
	//     value: "bar,baz"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: foo,bar,baz
	Add []HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatch `pulumi:"add"`
	// Remove the given header(s) from the HTTP request before the action. The
	// value of Remove is a list of HTTP header names. Note that the header
	// names are case-insensitive (see
	// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header1: foo
	//   my-header2: bar
	//   my-header3: baz
	//
	// Config:
	//   remove: ["my-header1", "my-header3"]
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header2: bar
	Remove []string `pulumi:"remove"`
	// Set overwrites the request with the given header (name, value)
	// before the action.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   set:
	//   - name: "my-header"
	//     value: "bar"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: bar
	Set []HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatch `pulumi:"set"`
}

// HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchInput is an input type that accepts HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchArgs and HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchInput` via:
//
//	HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchArgs{...}
type HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPatchOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchOutput
	ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPatchOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchOutput
}

// ResponseHeaderModifier defines a schema for a filter that modifies response
// headers.
//
// Support: Extended
type HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchArgs struct {
	// Add adds the given header(s) (name, value) to the request
	// before the action. It appends to any existing values associated
	// with the header name.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   add:
	//   - name: "my-header"
	//     value: "bar,baz"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: foo,bar,baz
	Add HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayInput `pulumi:"add"`
	// Remove the given header(s) from the HTTP request before the action. The
	// value of Remove is a list of HTTP header names. Note that the header
	// names are case-insensitive (see
	// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header1: foo
	//   my-header2: bar
	//   my-header3: baz
	//
	// Config:
	//   remove: ["my-header1", "my-header3"]
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header2: bar
	Remove pulumi.StringArrayInput `pulumi:"remove"`
	// Set overwrites the request with the given header (name, value)
	// before the action.
	//
	// Input:
	//   GET /foo HTTP/1.1
	//   my-header: foo
	//
	// Config:
	//   set:
	//   - name: "my-header"
	//     value: "bar"
	//
	// Output:
	//   GET /foo HTTP/1.1
	//   my-header: bar
	Set HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayInput `pulumi:"set"`
}

func (HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersResponseHeaderModifierPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchArgs) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPatchOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchOutput {
	return i.ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPatchOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchArgs) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchOutput)
}

func (i HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchArgs) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchArgs) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchOutput).ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrInput is an input type that accepts HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchArgs, HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtr and HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrInput` via:
//
//	        HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput
	ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput
}

type httprouteSpecRulesFiltersResponseHeaderModifierPatchPtrType HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchArgs

func HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtr(v *HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchArgs) HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrInput {
	return (*httprouteSpecRulesFiltersResponseHeaderModifierPatchPtrType)(v)
}

func (*httprouteSpecRulesFiltersResponseHeaderModifierPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersResponseHeaderModifierPatch)(nil)).Elem()
}

func (i *httprouteSpecRulesFiltersResponseHeaderModifierPatchPtrType) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesFiltersResponseHeaderModifierPatchPtrType) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput)
}

// ResponseHeaderModifier defines a schema for a filter that modifies response
// headers.
//
// Support: Extended
type HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersResponseHeaderModifierPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchOutput) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPatchOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchOutput) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchOutput) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput {
	return o.ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchOutput) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesFiltersResponseHeaderModifierPatch) *HTTPRouteSpecRulesFiltersResponseHeaderModifierPatch {
		return &v
	}).(HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput)
}

// Add adds the given header(s) (name, value) to the request
// before the action. It appends to any existing values associated
// with the header name.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	add:
//	- name: "my-header"
//	  value: "bar,baz"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: foo,bar,baz
func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchOutput) Add() HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersResponseHeaderModifierPatch) []HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatch {
		return v.Add
	}).(HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayOutput)
}

// Remove the given header(s) from the HTTP request before the action. The
// value of Remove is a list of HTTP header names. Note that the header
// names are case-insensitive (see
// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header1: foo
//	my-header2: bar
//	my-header3: baz
//
// Config:
//
//	remove: ["my-header1", "my-header3"]
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header2: bar
func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchOutput) Remove() pulumi.StringArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersResponseHeaderModifierPatch) []string { return v.Remove }).(pulumi.StringArrayOutput)
}

// Set overwrites the request with the given header (name, value)
// before the action.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	set:
//	- name: "my-header"
//	  value: "bar"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: bar
func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchOutput) Set() HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersResponseHeaderModifierPatch) []HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatch {
		return v.Set
	}).(HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayOutput)
}

type HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersResponseHeaderModifierPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput) Elem() HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersResponseHeaderModifierPatch) HTTPRouteSpecRulesFiltersResponseHeaderModifierPatch {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesFiltersResponseHeaderModifierPatch
		return ret
	}).(HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchOutput)
}

// Add adds the given header(s) (name, value) to the request
// before the action. It appends to any existing values associated
// with the header name.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	add:
//	- name: "my-header"
//	  value: "bar,baz"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: foo,bar,baz
func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput) Add() HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersResponseHeaderModifierPatch) []HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatch {
		if v == nil {
			return nil
		}
		return v.Add
	}).(HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayOutput)
}

// Remove the given header(s) from the HTTP request before the action. The
// value of Remove is a list of HTTP header names. Note that the header
// names are case-insensitive (see
// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header1: foo
//	my-header2: bar
//	my-header3: baz
//
// Config:
//
//	remove: ["my-header1", "my-header3"]
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header2: bar
func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput) Remove() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersResponseHeaderModifierPatch) []string {
		if v == nil {
			return nil
		}
		return v.Remove
	}).(pulumi.StringArrayOutput)
}

// Set overwrites the request with the given header (name, value)
// before the action.
//
// Input:
//
//	GET /foo HTTP/1.1
//	my-header: foo
//
// Config:
//
//	set:
//	- name: "my-header"
//	  value: "bar"
//
// Output:
//
//	GET /foo HTTP/1.1
//	my-header: bar
func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput) Set() HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersResponseHeaderModifierPatch) []HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatch {
		if v == nil {
			return nil
		}
		return v.Set
	}).(HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesFiltersResponseHeaderModifierSet struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name *string `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value *string `pulumi:"value"`
}

// HTTPRouteSpecRulesFiltersResponseHeaderModifierSetInput is an input type that accepts HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArgs and HTTPRouteSpecRulesFiltersResponseHeaderModifierSetOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersResponseHeaderModifierSetInput` via:
//
//	HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArgs{...}
type HTTPRouteSpecRulesFiltersResponseHeaderModifierSetInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersResponseHeaderModifierSetOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierSetOutput
	ToHTTPRouteSpecRulesFiltersResponseHeaderModifierSetOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierSetOutput
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArgs struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersResponseHeaderModifierSet)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArgs) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierSetOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierSetOutput {
	return i.ToHTTPRouteSpecRulesFiltersResponseHeaderModifierSetOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArgs) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierSetOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierSetOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersResponseHeaderModifierSetOutput)
}

// HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayInput is an input type that accepts HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArray and HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayInput` via:
//
//	HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArray{ HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArgs{...} }
type HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput
	ToHTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput
}

type HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArray []HTTPRouteSpecRulesFiltersResponseHeaderModifierSetInput

func (HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesFiltersResponseHeaderModifierSet)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArray) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput {
	return i.ToHTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArray) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesFiltersResponseHeaderModifierSetOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersResponseHeaderModifierSetOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersResponseHeaderModifierSet)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierSetOutput) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierSetOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierSetOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierSetOutput) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierSetOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierSetOutput {
	return o
}

// Name is the name of the HTTP Header to be matched. Name matching MUST be
// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
//
// If multiple entries specify equivalent header names, the first entry with
// an equivalent name MUST be considered for a match. Subsequent entries
// with an equivalent header name MUST be ignored. Due to the
// case-insensitivity of header names, "foo" and "Foo" are considered
// equivalent.
func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierSetOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersResponseHeaderModifierSet) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Value is the value of HTTP Header to be matched.
func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierSetOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersResponseHeaderModifierSet) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesFiltersResponseHeaderModifierSet)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput) Index(i pulumi.IntInput) HTTPRouteSpecRulesFiltersResponseHeaderModifierSetOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteSpecRulesFiltersResponseHeaderModifierSet {
		return vs[0].([]HTTPRouteSpecRulesFiltersResponseHeaderModifierSet)[vs[1].(int)]
	}).(HTTPRouteSpecRulesFiltersResponseHeaderModifierSetOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatch struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name *string `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value *string `pulumi:"value"`
}

// HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchInput is an input type that accepts HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArgs and HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchInput` via:
//
//	HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArgs{...}
type HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchOutput
	ToHTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchOutput
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArgs struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, the first entry with
	// an equivalent name MUST be considered for a match. Subsequent entries
	// with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArgs) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchOutput {
	return i.ToHTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArgs) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchOutput)
}

// HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayInput is an input type that accepts HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArray and HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayInput` via:
//
//	HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArray{ HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArgs{...} }
type HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayOutput
	ToHTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayOutput
}

type HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArray []HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchInput

func (HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArray) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayOutput {
	return i.ToHTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArray) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchOutput) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchOutput) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchOutput {
	return o
}

// Name is the name of the HTTP Header to be matched. Name matching MUST be
// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
//
// If multiple entries specify equivalent header names, the first entry with
// an equivalent name MUST be considered for a match. Subsequent entries
// with an equivalent header name MUST be ignored. Due to the
// case-insensitivity of header names, "foo" and "Foo" are considered
// equivalent.
func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Value is the value of HTTP Header to be matched.
func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatch) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayOutput) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayOutput() HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayOutput) ToHTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayOutput) Index(i pulumi.IntInput) HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatch {
		return vs[0].([]HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatch)[vs[1].(int)]
	}).(HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchOutput)
}

// URLRewrite defines a schema for a filter that modifies a request during forwarding.
//
// Support: Extended
type HTTPRouteSpecRulesFiltersUrlRewrite struct {
	// Hostname is the value to be used to replace the Host header value during
	// forwarding.
	//
	// Support: Extended
	Hostname *string                                  `pulumi:"hostname"`
	Path     *HTTPRouteSpecRulesFiltersUrlRewritePath `pulumi:"path"`
}

// HTTPRouteSpecRulesFiltersUrlRewriteInput is an input type that accepts HTTPRouteSpecRulesFiltersUrlRewriteArgs and HTTPRouteSpecRulesFiltersUrlRewriteOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersUrlRewriteInput` via:
//
//	HTTPRouteSpecRulesFiltersUrlRewriteArgs{...}
type HTTPRouteSpecRulesFiltersUrlRewriteInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersUrlRewriteOutput() HTTPRouteSpecRulesFiltersUrlRewriteOutput
	ToHTTPRouteSpecRulesFiltersUrlRewriteOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersUrlRewriteOutput
}

// URLRewrite defines a schema for a filter that modifies a request during forwarding.
//
// Support: Extended
type HTTPRouteSpecRulesFiltersUrlRewriteArgs struct {
	// Hostname is the value to be used to replace the Host header value during
	// forwarding.
	//
	// Support: Extended
	Hostname pulumi.StringPtrInput                           `pulumi:"hostname"`
	Path     HTTPRouteSpecRulesFiltersUrlRewritePathPtrInput `pulumi:"path"`
}

func (HTTPRouteSpecRulesFiltersUrlRewriteArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersUrlRewrite)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersUrlRewriteArgs) ToHTTPRouteSpecRulesFiltersUrlRewriteOutput() HTTPRouteSpecRulesFiltersUrlRewriteOutput {
	return i.ToHTTPRouteSpecRulesFiltersUrlRewriteOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersUrlRewriteArgs) ToHTTPRouteSpecRulesFiltersUrlRewriteOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersUrlRewriteOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersUrlRewriteOutput)
}

func (i HTTPRouteSpecRulesFiltersUrlRewriteArgs) ToHTTPRouteSpecRulesFiltersUrlRewritePtrOutput() HTTPRouteSpecRulesFiltersUrlRewritePtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersUrlRewritePtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersUrlRewriteArgs) ToHTTPRouteSpecRulesFiltersUrlRewritePtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersUrlRewritePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersUrlRewriteOutput).ToHTTPRouteSpecRulesFiltersUrlRewritePtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesFiltersUrlRewritePtrInput is an input type that accepts HTTPRouteSpecRulesFiltersUrlRewriteArgs, HTTPRouteSpecRulesFiltersUrlRewritePtr and HTTPRouteSpecRulesFiltersUrlRewritePtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersUrlRewritePtrInput` via:
//
//	        HTTPRouteSpecRulesFiltersUrlRewriteArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesFiltersUrlRewritePtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersUrlRewritePtrOutput() HTTPRouteSpecRulesFiltersUrlRewritePtrOutput
	ToHTTPRouteSpecRulesFiltersUrlRewritePtrOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersUrlRewritePtrOutput
}

type httprouteSpecRulesFiltersUrlRewritePtrType HTTPRouteSpecRulesFiltersUrlRewriteArgs

func HTTPRouteSpecRulesFiltersUrlRewritePtr(v *HTTPRouteSpecRulesFiltersUrlRewriteArgs) HTTPRouteSpecRulesFiltersUrlRewritePtrInput {
	return (*httprouteSpecRulesFiltersUrlRewritePtrType)(v)
}

func (*httprouteSpecRulesFiltersUrlRewritePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersUrlRewrite)(nil)).Elem()
}

func (i *httprouteSpecRulesFiltersUrlRewritePtrType) ToHTTPRouteSpecRulesFiltersUrlRewritePtrOutput() HTTPRouteSpecRulesFiltersUrlRewritePtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersUrlRewritePtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesFiltersUrlRewritePtrType) ToHTTPRouteSpecRulesFiltersUrlRewritePtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersUrlRewritePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersUrlRewritePtrOutput)
}

// URLRewrite defines a schema for a filter that modifies a request during forwarding.
//
// Support: Extended
type HTTPRouteSpecRulesFiltersUrlRewriteOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersUrlRewriteOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersUrlRewrite)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersUrlRewriteOutput) ToHTTPRouteSpecRulesFiltersUrlRewriteOutput() HTTPRouteSpecRulesFiltersUrlRewriteOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersUrlRewriteOutput) ToHTTPRouteSpecRulesFiltersUrlRewriteOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersUrlRewriteOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersUrlRewriteOutput) ToHTTPRouteSpecRulesFiltersUrlRewritePtrOutput() HTTPRouteSpecRulesFiltersUrlRewritePtrOutput {
	return o.ToHTTPRouteSpecRulesFiltersUrlRewritePtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesFiltersUrlRewriteOutput) ToHTTPRouteSpecRulesFiltersUrlRewritePtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersUrlRewritePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesFiltersUrlRewrite) *HTTPRouteSpecRulesFiltersUrlRewrite {
		return &v
	}).(HTTPRouteSpecRulesFiltersUrlRewritePtrOutput)
}

// Hostname is the value to be used to replace the Host header value during
// forwarding.
//
// Support: Extended
func (o HTTPRouteSpecRulesFiltersUrlRewriteOutput) Hostname() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersUrlRewrite) *string { return v.Hostname }).(pulumi.StringPtrOutput)
}

func (o HTTPRouteSpecRulesFiltersUrlRewriteOutput) Path() HTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersUrlRewrite) *HTTPRouteSpecRulesFiltersUrlRewritePath { return v.Path }).(HTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput)
}

type HTTPRouteSpecRulesFiltersUrlRewritePtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersUrlRewritePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersUrlRewrite)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersUrlRewritePtrOutput) ToHTTPRouteSpecRulesFiltersUrlRewritePtrOutput() HTTPRouteSpecRulesFiltersUrlRewritePtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersUrlRewritePtrOutput) ToHTTPRouteSpecRulesFiltersUrlRewritePtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersUrlRewritePtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersUrlRewritePtrOutput) Elem() HTTPRouteSpecRulesFiltersUrlRewriteOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersUrlRewrite) HTTPRouteSpecRulesFiltersUrlRewrite {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesFiltersUrlRewrite
		return ret
	}).(HTTPRouteSpecRulesFiltersUrlRewriteOutput)
}

// Hostname is the value to be used to replace the Host header value during
// forwarding.
//
// Support: Extended
func (o HTTPRouteSpecRulesFiltersUrlRewritePtrOutput) Hostname() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersUrlRewrite) *string {
		if v == nil {
			return nil
		}
		return v.Hostname
	}).(pulumi.StringPtrOutput)
}

func (o HTTPRouteSpecRulesFiltersUrlRewritePtrOutput) Path() HTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersUrlRewrite) *HTTPRouteSpecRulesFiltersUrlRewritePath {
		if v == nil {
			return nil
		}
		return v.Path
	}).(HTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput)
}

// URLRewrite defines a schema for a filter that modifies a request during forwarding.
//
// Support: Extended
type HTTPRouteSpecRulesFiltersUrlRewritePatch struct {
	// Hostname is the value to be used to replace the Host header value during
	// forwarding.
	//
	// Support: Extended
	Hostname *string                                       `pulumi:"hostname"`
	Path     *HTTPRouteSpecRulesFiltersUrlRewritePathPatch `pulumi:"path"`
}

// HTTPRouteSpecRulesFiltersUrlRewritePatchInput is an input type that accepts HTTPRouteSpecRulesFiltersUrlRewritePatchArgs and HTTPRouteSpecRulesFiltersUrlRewritePatchOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersUrlRewritePatchInput` via:
//
//	HTTPRouteSpecRulesFiltersUrlRewritePatchArgs{...}
type HTTPRouteSpecRulesFiltersUrlRewritePatchInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersUrlRewritePatchOutput() HTTPRouteSpecRulesFiltersUrlRewritePatchOutput
	ToHTTPRouteSpecRulesFiltersUrlRewritePatchOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersUrlRewritePatchOutput
}

// URLRewrite defines a schema for a filter that modifies a request during forwarding.
//
// Support: Extended
type HTTPRouteSpecRulesFiltersUrlRewritePatchArgs struct {
	// Hostname is the value to be used to replace the Host header value during
	// forwarding.
	//
	// Support: Extended
	Hostname pulumi.StringPtrInput                                `pulumi:"hostname"`
	Path     HTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrInput `pulumi:"path"`
}

func (HTTPRouteSpecRulesFiltersUrlRewritePatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersUrlRewritePatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersUrlRewritePatchArgs) ToHTTPRouteSpecRulesFiltersUrlRewritePatchOutput() HTTPRouteSpecRulesFiltersUrlRewritePatchOutput {
	return i.ToHTTPRouteSpecRulesFiltersUrlRewritePatchOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersUrlRewritePatchArgs) ToHTTPRouteSpecRulesFiltersUrlRewritePatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersUrlRewritePatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersUrlRewritePatchOutput)
}

func (i HTTPRouteSpecRulesFiltersUrlRewritePatchArgs) ToHTTPRouteSpecRulesFiltersUrlRewritePatchPtrOutput() HTTPRouteSpecRulesFiltersUrlRewritePatchPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersUrlRewritePatchPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersUrlRewritePatchArgs) ToHTTPRouteSpecRulesFiltersUrlRewritePatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersUrlRewritePatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersUrlRewritePatchOutput).ToHTTPRouteSpecRulesFiltersUrlRewritePatchPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesFiltersUrlRewritePatchPtrInput is an input type that accepts HTTPRouteSpecRulesFiltersUrlRewritePatchArgs, HTTPRouteSpecRulesFiltersUrlRewritePatchPtr and HTTPRouteSpecRulesFiltersUrlRewritePatchPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersUrlRewritePatchPtrInput` via:
//
//	        HTTPRouteSpecRulesFiltersUrlRewritePatchArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesFiltersUrlRewritePatchPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersUrlRewritePatchPtrOutput() HTTPRouteSpecRulesFiltersUrlRewritePatchPtrOutput
	ToHTTPRouteSpecRulesFiltersUrlRewritePatchPtrOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersUrlRewritePatchPtrOutput
}

type httprouteSpecRulesFiltersUrlRewritePatchPtrType HTTPRouteSpecRulesFiltersUrlRewritePatchArgs

func HTTPRouteSpecRulesFiltersUrlRewritePatchPtr(v *HTTPRouteSpecRulesFiltersUrlRewritePatchArgs) HTTPRouteSpecRulesFiltersUrlRewritePatchPtrInput {
	return (*httprouteSpecRulesFiltersUrlRewritePatchPtrType)(v)
}

func (*httprouteSpecRulesFiltersUrlRewritePatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersUrlRewritePatch)(nil)).Elem()
}

func (i *httprouteSpecRulesFiltersUrlRewritePatchPtrType) ToHTTPRouteSpecRulesFiltersUrlRewritePatchPtrOutput() HTTPRouteSpecRulesFiltersUrlRewritePatchPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersUrlRewritePatchPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesFiltersUrlRewritePatchPtrType) ToHTTPRouteSpecRulesFiltersUrlRewritePatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersUrlRewritePatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersUrlRewritePatchPtrOutput)
}

// URLRewrite defines a schema for a filter that modifies a request during forwarding.
//
// Support: Extended
type HTTPRouteSpecRulesFiltersUrlRewritePatchOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersUrlRewritePatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersUrlRewritePatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersUrlRewritePatchOutput) ToHTTPRouteSpecRulesFiltersUrlRewritePatchOutput() HTTPRouteSpecRulesFiltersUrlRewritePatchOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersUrlRewritePatchOutput) ToHTTPRouteSpecRulesFiltersUrlRewritePatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersUrlRewritePatchOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersUrlRewritePatchOutput) ToHTTPRouteSpecRulesFiltersUrlRewritePatchPtrOutput() HTTPRouteSpecRulesFiltersUrlRewritePatchPtrOutput {
	return o.ToHTTPRouteSpecRulesFiltersUrlRewritePatchPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesFiltersUrlRewritePatchOutput) ToHTTPRouteSpecRulesFiltersUrlRewritePatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersUrlRewritePatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesFiltersUrlRewritePatch) *HTTPRouteSpecRulesFiltersUrlRewritePatch {
		return &v
	}).(HTTPRouteSpecRulesFiltersUrlRewritePatchPtrOutput)
}

// Hostname is the value to be used to replace the Host header value during
// forwarding.
//
// Support: Extended
func (o HTTPRouteSpecRulesFiltersUrlRewritePatchOutput) Hostname() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersUrlRewritePatch) *string { return v.Hostname }).(pulumi.StringPtrOutput)
}

func (o HTTPRouteSpecRulesFiltersUrlRewritePatchOutput) Path() HTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersUrlRewritePatch) *HTTPRouteSpecRulesFiltersUrlRewritePathPatch {
		return v.Path
	}).(HTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrOutput)
}

type HTTPRouteSpecRulesFiltersUrlRewritePatchPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersUrlRewritePatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersUrlRewritePatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersUrlRewritePatchPtrOutput) ToHTTPRouteSpecRulesFiltersUrlRewritePatchPtrOutput() HTTPRouteSpecRulesFiltersUrlRewritePatchPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersUrlRewritePatchPtrOutput) ToHTTPRouteSpecRulesFiltersUrlRewritePatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersUrlRewritePatchPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersUrlRewritePatchPtrOutput) Elem() HTTPRouteSpecRulesFiltersUrlRewritePatchOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersUrlRewritePatch) HTTPRouteSpecRulesFiltersUrlRewritePatch {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesFiltersUrlRewritePatch
		return ret
	}).(HTTPRouteSpecRulesFiltersUrlRewritePatchOutput)
}

// Hostname is the value to be used to replace the Host header value during
// forwarding.
//
// Support: Extended
func (o HTTPRouteSpecRulesFiltersUrlRewritePatchPtrOutput) Hostname() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersUrlRewritePatch) *string {
		if v == nil {
			return nil
		}
		return v.Hostname
	}).(pulumi.StringPtrOutput)
}

func (o HTTPRouteSpecRulesFiltersUrlRewritePatchPtrOutput) Path() HTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersUrlRewritePatch) *HTTPRouteSpecRulesFiltersUrlRewritePathPatch {
		if v == nil {
			return nil
		}
		return v.Path
	}).(HTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrOutput)
}

// Path defines a path rewrite.
//
// Support: Extended
type HTTPRouteSpecRulesFiltersUrlRewritePath struct {
	// ReplaceFullPath specifies the value with which to replace the full path
	// of a request during a rewrite or redirect.
	ReplaceFullPath *string `pulumi:"replaceFullPath"`
	// ReplacePrefixMatch specifies the value with which to replace the prefix
	// match of a request during a rewrite or redirect. For example, a request
	// to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
	// of "/xyz" would be modified to "/xyz/bar".
	//
	// Note that this matches the behavior of the PathPrefix match type. This
	// matches full path elements. A path element refers to the list of labels
	// in the path split by the `/` separator. When specified, a trailing `/` is
	// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
	// match the prefix `/abc`, but the path `/abcd` would not.
	//
	// ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
	// Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
	// the implementation setting the Accepted Condition for the Route to `status: False`.
	//
	// Request Path | Prefix Match | Replace Prefix | Modified Path
	// -------------|--------------|----------------|----------
	// /foo/bar     | /foo         | /xyz           | /xyz/bar
	// /foo/bar     | /foo         | /xyz/          | /xyz/bar
	// /foo/bar     | /foo/        | /xyz           | /xyz/bar
	// /foo/bar     | /foo/        | /xyz/          | /xyz/bar
	// /foo         | /foo         | /xyz           | /xyz
	// /foo/        | /foo         | /xyz           | /xyz/
	// /foo/bar     | /foo         | <empty string> | /bar
	// /foo/        | /foo         | <empty string> | /
	// /foo         | /foo         | <empty string> | /
	// /foo/        | /foo         | /              | /
	// /foo         | /foo         | /              | /
	ReplacePrefixMatch *string `pulumi:"replacePrefixMatch"`
	// Type defines the type of path modifier. Additional types may be
	// added in a future release of the API.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	Type *string `pulumi:"type"`
}

// HTTPRouteSpecRulesFiltersUrlRewritePathInput is an input type that accepts HTTPRouteSpecRulesFiltersUrlRewritePathArgs and HTTPRouteSpecRulesFiltersUrlRewritePathOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersUrlRewritePathInput` via:
//
//	HTTPRouteSpecRulesFiltersUrlRewritePathArgs{...}
type HTTPRouteSpecRulesFiltersUrlRewritePathInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersUrlRewritePathOutput() HTTPRouteSpecRulesFiltersUrlRewritePathOutput
	ToHTTPRouteSpecRulesFiltersUrlRewritePathOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersUrlRewritePathOutput
}

// Path defines a path rewrite.
//
// Support: Extended
type HTTPRouteSpecRulesFiltersUrlRewritePathArgs struct {
	// ReplaceFullPath specifies the value with which to replace the full path
	// of a request during a rewrite or redirect.
	ReplaceFullPath pulumi.StringPtrInput `pulumi:"replaceFullPath"`
	// ReplacePrefixMatch specifies the value with which to replace the prefix
	// match of a request during a rewrite or redirect. For example, a request
	// to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
	// of "/xyz" would be modified to "/xyz/bar".
	//
	// Note that this matches the behavior of the PathPrefix match type. This
	// matches full path elements. A path element refers to the list of labels
	// in the path split by the `/` separator. When specified, a trailing `/` is
	// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
	// match the prefix `/abc`, but the path `/abcd` would not.
	//
	// ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
	// Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
	// the implementation setting the Accepted Condition for the Route to `status: False`.
	//
	// Request Path | Prefix Match | Replace Prefix | Modified Path
	// -------------|--------------|----------------|----------
	// /foo/bar     | /foo         | /xyz           | /xyz/bar
	// /foo/bar     | /foo         | /xyz/          | /xyz/bar
	// /foo/bar     | /foo/        | /xyz           | /xyz/bar
	// /foo/bar     | /foo/        | /xyz/          | /xyz/bar
	// /foo         | /foo         | /xyz           | /xyz
	// /foo/        | /foo         | /xyz           | /xyz/
	// /foo/bar     | /foo         | <empty string> | /bar
	// /foo/        | /foo         | <empty string> | /
	// /foo         | /foo         | <empty string> | /
	// /foo/        | /foo         | /              | /
	// /foo         | /foo         | /              | /
	ReplacePrefixMatch pulumi.StringPtrInput `pulumi:"replacePrefixMatch"`
	// Type defines the type of path modifier. Additional types may be
	// added in a future release of the API.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (HTTPRouteSpecRulesFiltersUrlRewritePathArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersUrlRewritePath)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersUrlRewritePathArgs) ToHTTPRouteSpecRulesFiltersUrlRewritePathOutput() HTTPRouteSpecRulesFiltersUrlRewritePathOutput {
	return i.ToHTTPRouteSpecRulesFiltersUrlRewritePathOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersUrlRewritePathArgs) ToHTTPRouteSpecRulesFiltersUrlRewritePathOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersUrlRewritePathOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersUrlRewritePathOutput)
}

func (i HTTPRouteSpecRulesFiltersUrlRewritePathArgs) ToHTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput() HTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersUrlRewritePathPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersUrlRewritePathArgs) ToHTTPRouteSpecRulesFiltersUrlRewritePathPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersUrlRewritePathOutput).ToHTTPRouteSpecRulesFiltersUrlRewritePathPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesFiltersUrlRewritePathPtrInput is an input type that accepts HTTPRouteSpecRulesFiltersUrlRewritePathArgs, HTTPRouteSpecRulesFiltersUrlRewritePathPtr and HTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersUrlRewritePathPtrInput` via:
//
//	        HTTPRouteSpecRulesFiltersUrlRewritePathArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesFiltersUrlRewritePathPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput() HTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput
	ToHTTPRouteSpecRulesFiltersUrlRewritePathPtrOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput
}

type httprouteSpecRulesFiltersUrlRewritePathPtrType HTTPRouteSpecRulesFiltersUrlRewritePathArgs

func HTTPRouteSpecRulesFiltersUrlRewritePathPtr(v *HTTPRouteSpecRulesFiltersUrlRewritePathArgs) HTTPRouteSpecRulesFiltersUrlRewritePathPtrInput {
	return (*httprouteSpecRulesFiltersUrlRewritePathPtrType)(v)
}

func (*httprouteSpecRulesFiltersUrlRewritePathPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersUrlRewritePath)(nil)).Elem()
}

func (i *httprouteSpecRulesFiltersUrlRewritePathPtrType) ToHTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput() HTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersUrlRewritePathPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesFiltersUrlRewritePathPtrType) ToHTTPRouteSpecRulesFiltersUrlRewritePathPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput)
}

// Path defines a path rewrite.
//
// Support: Extended
type HTTPRouteSpecRulesFiltersUrlRewritePathOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersUrlRewritePathOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersUrlRewritePath)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersUrlRewritePathOutput) ToHTTPRouteSpecRulesFiltersUrlRewritePathOutput() HTTPRouteSpecRulesFiltersUrlRewritePathOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersUrlRewritePathOutput) ToHTTPRouteSpecRulesFiltersUrlRewritePathOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersUrlRewritePathOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersUrlRewritePathOutput) ToHTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput() HTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput {
	return o.ToHTTPRouteSpecRulesFiltersUrlRewritePathPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesFiltersUrlRewritePathOutput) ToHTTPRouteSpecRulesFiltersUrlRewritePathPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesFiltersUrlRewritePath) *HTTPRouteSpecRulesFiltersUrlRewritePath {
		return &v
	}).(HTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput)
}

// ReplaceFullPath specifies the value with which to replace the full path
// of a request during a rewrite or redirect.
func (o HTTPRouteSpecRulesFiltersUrlRewritePathOutput) ReplaceFullPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersUrlRewritePath) *string { return v.ReplaceFullPath }).(pulumi.StringPtrOutput)
}

// ReplacePrefixMatch specifies the value with which to replace the prefix
// match of a request during a rewrite or redirect. For example, a request
// to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
// of "/xyz" would be modified to "/xyz/bar".
//
// Note that this matches the behavior of the PathPrefix match type. This
// matches full path elements. A path element refers to the list of labels
// in the path split by the `/` separator. When specified, a trailing `/` is
// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
// match the prefix `/abc`, but the path `/abcd` would not.
//
// ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
// Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
// the implementation setting the Accepted Condition for the Route to `status: False`.
//
// Request Path | Prefix Match | Replace Prefix | Modified Path
// -------------|--------------|----------------|----------
// /foo/bar     | /foo         | /xyz           | /xyz/bar
// /foo/bar     | /foo         | /xyz/          | /xyz/bar
// /foo/bar     | /foo/        | /xyz           | /xyz/bar
// /foo/bar     | /foo/        | /xyz/          | /xyz/bar
// /foo         | /foo         | /xyz           | /xyz
// /foo/        | /foo         | /xyz           | /xyz/
// /foo/bar     | /foo         | <empty string> | /bar
// /foo/        | /foo         | <empty string> | /
// /foo         | /foo         | <empty string> | /
// /foo/        | /foo         | /              | /
// /foo         | /foo         | /              | /
func (o HTTPRouteSpecRulesFiltersUrlRewritePathOutput) ReplacePrefixMatch() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersUrlRewritePath) *string { return v.ReplacePrefixMatch }).(pulumi.StringPtrOutput)
}

// Type defines the type of path modifier. Additional types may be
// added in a future release of the API.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
func (o HTTPRouteSpecRulesFiltersUrlRewritePathOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersUrlRewritePath) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type HTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersUrlRewritePath)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput) ToHTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput() HTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput) ToHTTPRouteSpecRulesFiltersUrlRewritePathPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput) Elem() HTTPRouteSpecRulesFiltersUrlRewritePathOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersUrlRewritePath) HTTPRouteSpecRulesFiltersUrlRewritePath {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesFiltersUrlRewritePath
		return ret
	}).(HTTPRouteSpecRulesFiltersUrlRewritePathOutput)
}

// ReplaceFullPath specifies the value with which to replace the full path
// of a request during a rewrite or redirect.
func (o HTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput) ReplaceFullPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersUrlRewritePath) *string {
		if v == nil {
			return nil
		}
		return v.ReplaceFullPath
	}).(pulumi.StringPtrOutput)
}

// ReplacePrefixMatch specifies the value with which to replace the prefix
// match of a request during a rewrite or redirect. For example, a request
// to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
// of "/xyz" would be modified to "/xyz/bar".
//
// Note that this matches the behavior of the PathPrefix match type. This
// matches full path elements. A path element refers to the list of labels
// in the path split by the `/` separator. When specified, a trailing `/` is
// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
// match the prefix `/abc`, but the path `/abcd` would not.
//
// ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
// Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
// the implementation setting the Accepted Condition for the Route to `status: False`.
//
// Request Path | Prefix Match | Replace Prefix | Modified Path
// -------------|--------------|----------------|----------
// /foo/bar     | /foo         | /xyz           | /xyz/bar
// /foo/bar     | /foo         | /xyz/          | /xyz/bar
// /foo/bar     | /foo/        | /xyz           | /xyz/bar
// /foo/bar     | /foo/        | /xyz/          | /xyz/bar
// /foo         | /foo         | /xyz           | /xyz
// /foo/        | /foo         | /xyz           | /xyz/
// /foo/bar     | /foo         | <empty string> | /bar
// /foo/        | /foo         | <empty string> | /
// /foo         | /foo         | <empty string> | /
// /foo/        | /foo         | /              | /
// /foo         | /foo         | /              | /
func (o HTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput) ReplacePrefixMatch() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersUrlRewritePath) *string {
		if v == nil {
			return nil
		}
		return v.ReplacePrefixMatch
	}).(pulumi.StringPtrOutput)
}

// Type defines the type of path modifier. Additional types may be
// added in a future release of the API.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
func (o HTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersUrlRewritePath) *string {
		if v == nil {
			return nil
		}
		return v.Type
	}).(pulumi.StringPtrOutput)
}

// Path defines a path rewrite.
//
// Support: Extended
type HTTPRouteSpecRulesFiltersUrlRewritePathPatch struct {
	// ReplaceFullPath specifies the value with which to replace the full path
	// of a request during a rewrite or redirect.
	ReplaceFullPath *string `pulumi:"replaceFullPath"`
	// ReplacePrefixMatch specifies the value with which to replace the prefix
	// match of a request during a rewrite or redirect. For example, a request
	// to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
	// of "/xyz" would be modified to "/xyz/bar".
	//
	// Note that this matches the behavior of the PathPrefix match type. This
	// matches full path elements. A path element refers to the list of labels
	// in the path split by the `/` separator. When specified, a trailing `/` is
	// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
	// match the prefix `/abc`, but the path `/abcd` would not.
	//
	// ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
	// Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
	// the implementation setting the Accepted Condition for the Route to `status: False`.
	//
	// Request Path | Prefix Match | Replace Prefix | Modified Path
	// -------------|--------------|----------------|----------
	// /foo/bar     | /foo         | /xyz           | /xyz/bar
	// /foo/bar     | /foo         | /xyz/          | /xyz/bar
	// /foo/bar     | /foo/        | /xyz           | /xyz/bar
	// /foo/bar     | /foo/        | /xyz/          | /xyz/bar
	// /foo         | /foo         | /xyz           | /xyz
	// /foo/        | /foo         | /xyz           | /xyz/
	// /foo/bar     | /foo         | <empty string> | /bar
	// /foo/        | /foo         | <empty string> | /
	// /foo         | /foo         | <empty string> | /
	// /foo/        | /foo         | /              | /
	// /foo         | /foo         | /              | /
	ReplacePrefixMatch *string `pulumi:"replacePrefixMatch"`
	// Type defines the type of path modifier. Additional types may be
	// added in a future release of the API.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	Type *string `pulumi:"type"`
}

// HTTPRouteSpecRulesFiltersUrlRewritePathPatchInput is an input type that accepts HTTPRouteSpecRulesFiltersUrlRewritePathPatchArgs and HTTPRouteSpecRulesFiltersUrlRewritePathPatchOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersUrlRewritePathPatchInput` via:
//
//	HTTPRouteSpecRulesFiltersUrlRewritePathPatchArgs{...}
type HTTPRouteSpecRulesFiltersUrlRewritePathPatchInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersUrlRewritePathPatchOutput() HTTPRouteSpecRulesFiltersUrlRewritePathPatchOutput
	ToHTTPRouteSpecRulesFiltersUrlRewritePathPatchOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersUrlRewritePathPatchOutput
}

// Path defines a path rewrite.
//
// Support: Extended
type HTTPRouteSpecRulesFiltersUrlRewritePathPatchArgs struct {
	// ReplaceFullPath specifies the value with which to replace the full path
	// of a request during a rewrite or redirect.
	ReplaceFullPath pulumi.StringPtrInput `pulumi:"replaceFullPath"`
	// ReplacePrefixMatch specifies the value with which to replace the prefix
	// match of a request during a rewrite or redirect. For example, a request
	// to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
	// of "/xyz" would be modified to "/xyz/bar".
	//
	// Note that this matches the behavior of the PathPrefix match type. This
	// matches full path elements. A path element refers to the list of labels
	// in the path split by the `/` separator. When specified, a trailing `/` is
	// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
	// match the prefix `/abc`, but the path `/abcd` would not.
	//
	// ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
	// Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
	// the implementation setting the Accepted Condition for the Route to `status: False`.
	//
	// Request Path | Prefix Match | Replace Prefix | Modified Path
	// -------------|--------------|----------------|----------
	// /foo/bar     | /foo         | /xyz           | /xyz/bar
	// /foo/bar     | /foo         | /xyz/          | /xyz/bar
	// /foo/bar     | /foo/        | /xyz           | /xyz/bar
	// /foo/bar     | /foo/        | /xyz/          | /xyz/bar
	// /foo         | /foo         | /xyz           | /xyz
	// /foo/        | /foo         | /xyz           | /xyz/
	// /foo/bar     | /foo         | <empty string> | /bar
	// /foo/        | /foo         | <empty string> | /
	// /foo         | /foo         | <empty string> | /
	// /foo/        | /foo         | /              | /
	// /foo         | /foo         | /              | /
	ReplacePrefixMatch pulumi.StringPtrInput `pulumi:"replacePrefixMatch"`
	// Type defines the type of path modifier. Additional types may be
	// added in a future release of the API.
	//
	// Note that values may be added to this enum, implementations
	// must ensure that unknown values will not cause a crash.
	//
	// Unknown values here must result in the implementation setting the
	// Accepted Condition for the Route to `status: False`, with a
	// Reason of `UnsupportedValue`.
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (HTTPRouteSpecRulesFiltersUrlRewritePathPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersUrlRewritePathPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesFiltersUrlRewritePathPatchArgs) ToHTTPRouteSpecRulesFiltersUrlRewritePathPatchOutput() HTTPRouteSpecRulesFiltersUrlRewritePathPatchOutput {
	return i.ToHTTPRouteSpecRulesFiltersUrlRewritePathPatchOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersUrlRewritePathPatchArgs) ToHTTPRouteSpecRulesFiltersUrlRewritePathPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersUrlRewritePathPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersUrlRewritePathPatchOutput)
}

func (i HTTPRouteSpecRulesFiltersUrlRewritePathPatchArgs) ToHTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrOutput() HTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesFiltersUrlRewritePathPatchArgs) ToHTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersUrlRewritePathPatchOutput).ToHTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrInput is an input type that accepts HTTPRouteSpecRulesFiltersUrlRewritePathPatchArgs, HTTPRouteSpecRulesFiltersUrlRewritePathPatchPtr and HTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrInput` via:
//
//	        HTTPRouteSpecRulesFiltersUrlRewritePathPatchArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrOutput() HTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrOutput
	ToHTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrOutputWithContext(context.Context) HTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrOutput
}

type httprouteSpecRulesFiltersUrlRewritePathPatchPtrType HTTPRouteSpecRulesFiltersUrlRewritePathPatchArgs

func HTTPRouteSpecRulesFiltersUrlRewritePathPatchPtr(v *HTTPRouteSpecRulesFiltersUrlRewritePathPatchArgs) HTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrInput {
	return (*httprouteSpecRulesFiltersUrlRewritePathPatchPtrType)(v)
}

func (*httprouteSpecRulesFiltersUrlRewritePathPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersUrlRewritePathPatch)(nil)).Elem()
}

func (i *httprouteSpecRulesFiltersUrlRewritePathPatchPtrType) ToHTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrOutput() HTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrOutput {
	return i.ToHTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesFiltersUrlRewritePathPatchPtrType) ToHTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrOutput)
}

// Path defines a path rewrite.
//
// Support: Extended
type HTTPRouteSpecRulesFiltersUrlRewritePathPatchOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersUrlRewritePathPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesFiltersUrlRewritePathPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersUrlRewritePathPatchOutput) ToHTTPRouteSpecRulesFiltersUrlRewritePathPatchOutput() HTTPRouteSpecRulesFiltersUrlRewritePathPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersUrlRewritePathPatchOutput) ToHTTPRouteSpecRulesFiltersUrlRewritePathPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersUrlRewritePathPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersUrlRewritePathPatchOutput) ToHTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrOutput() HTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrOutput {
	return o.ToHTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesFiltersUrlRewritePathPatchOutput) ToHTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesFiltersUrlRewritePathPatch) *HTTPRouteSpecRulesFiltersUrlRewritePathPatch {
		return &v
	}).(HTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrOutput)
}

// ReplaceFullPath specifies the value with which to replace the full path
// of a request during a rewrite or redirect.
func (o HTTPRouteSpecRulesFiltersUrlRewritePathPatchOutput) ReplaceFullPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersUrlRewritePathPatch) *string { return v.ReplaceFullPath }).(pulumi.StringPtrOutput)
}

// ReplacePrefixMatch specifies the value with which to replace the prefix
// match of a request during a rewrite or redirect. For example, a request
// to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
// of "/xyz" would be modified to "/xyz/bar".
//
// Note that this matches the behavior of the PathPrefix match type. This
// matches full path elements. A path element refers to the list of labels
// in the path split by the `/` separator. When specified, a trailing `/` is
// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
// match the prefix `/abc`, but the path `/abcd` would not.
//
// ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
// Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
// the implementation setting the Accepted Condition for the Route to `status: False`.
//
// Request Path | Prefix Match | Replace Prefix | Modified Path
// -------------|--------------|----------------|----------
// /foo/bar     | /foo         | /xyz           | /xyz/bar
// /foo/bar     | /foo         | /xyz/          | /xyz/bar
// /foo/bar     | /foo/        | /xyz           | /xyz/bar
// /foo/bar     | /foo/        | /xyz/          | /xyz/bar
// /foo         | /foo         | /xyz           | /xyz
// /foo/        | /foo         | /xyz           | /xyz/
// /foo/bar     | /foo         | <empty string> | /bar
// /foo/        | /foo         | <empty string> | /
// /foo         | /foo         | <empty string> | /
// /foo/        | /foo         | /              | /
// /foo         | /foo         | /              | /
func (o HTTPRouteSpecRulesFiltersUrlRewritePathPatchOutput) ReplacePrefixMatch() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersUrlRewritePathPatch) *string { return v.ReplacePrefixMatch }).(pulumi.StringPtrOutput)
}

// Type defines the type of path modifier. Additional types may be
// added in a future release of the API.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
func (o HTTPRouteSpecRulesFiltersUrlRewritePathPatchOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesFiltersUrlRewritePathPatch) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type HTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesFiltersUrlRewritePathPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrOutput) ToHTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrOutput() HTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrOutput) ToHTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrOutput) Elem() HTTPRouteSpecRulesFiltersUrlRewritePathPatchOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersUrlRewritePathPatch) HTTPRouteSpecRulesFiltersUrlRewritePathPatch {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesFiltersUrlRewritePathPatch
		return ret
	}).(HTTPRouteSpecRulesFiltersUrlRewritePathPatchOutput)
}

// ReplaceFullPath specifies the value with which to replace the full path
// of a request during a rewrite or redirect.
func (o HTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrOutput) ReplaceFullPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersUrlRewritePathPatch) *string {
		if v == nil {
			return nil
		}
		return v.ReplaceFullPath
	}).(pulumi.StringPtrOutput)
}

// ReplacePrefixMatch specifies the value with which to replace the prefix
// match of a request during a rewrite or redirect. For example, a request
// to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
// of "/xyz" would be modified to "/xyz/bar".
//
// Note that this matches the behavior of the PathPrefix match type. This
// matches full path elements. A path element refers to the list of labels
// in the path split by the `/` separator. When specified, a trailing `/` is
// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
// match the prefix `/abc`, but the path `/abcd` would not.
//
// ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
// Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
// the implementation setting the Accepted Condition for the Route to `status: False`.
//
// Request Path | Prefix Match | Replace Prefix | Modified Path
// -------------|--------------|----------------|----------
// /foo/bar     | /foo         | /xyz           | /xyz/bar
// /foo/bar     | /foo         | /xyz/          | /xyz/bar
// /foo/bar     | /foo/        | /xyz           | /xyz/bar
// /foo/bar     | /foo/        | /xyz/          | /xyz/bar
// /foo         | /foo         | /xyz           | /xyz
// /foo/        | /foo         | /xyz           | /xyz/
// /foo/bar     | /foo         | <empty string> | /bar
// /foo/        | /foo         | <empty string> | /
// /foo         | /foo         | <empty string> | /
// /foo/        | /foo         | /              | /
// /foo         | /foo         | /              | /
func (o HTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrOutput) ReplacePrefixMatch() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersUrlRewritePathPatch) *string {
		if v == nil {
			return nil
		}
		return v.ReplacePrefixMatch
	}).(pulumi.StringPtrOutput)
}

// Type defines the type of path modifier. Additional types may be
// added in a future release of the API.
//
// Note that values may be added to this enum, implementations
// must ensure that unknown values will not cause a crash.
//
// Unknown values here must result in the implementation setting the
// Accepted Condition for the Route to `status: False`, with a
// Reason of `UnsupportedValue`.
func (o HTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesFiltersUrlRewritePathPatch) *string {
		if v == nil {
			return nil
		}
		return v.Type
	}).(pulumi.StringPtrOutput)
}

// HTTPRouteMatch defines the predicate used to match requests to a given
// action. Multiple match types are ANDed together, i.e. the match will
// evaluate to true only if all conditions are satisfied.
//
// For example, the match below will match a HTTP request only if its path
// starts with `/foo` AND it contains the `version: v1` header:
type HTTPRouteSpecRulesMatches struct {
	// Headers specifies HTTP request header matchers. Multiple match values are
	// ANDed together, meaning, a request must match all the specified headers
	// to select the route.
	Headers []HTTPRouteSpecRulesMatchesHeaders `pulumi:"headers"`
	// Method specifies HTTP method matcher.
	// When specified, this route will be matched only if the request has the
	// specified method.
	//
	// Support: Extended
	Method *string                        `pulumi:"method"`
	Path   *HTTPRouteSpecRulesMatchesPath `pulumi:"path"`
	// QueryParams specifies HTTP query parameter matchers. Multiple match
	// values are ANDed together, meaning, a request must match all the
	// specified query parameters to select the route.
	//
	// Support: Extended
	QueryParams []HTTPRouteSpecRulesMatchesQueryParams `pulumi:"queryParams"`
}

// HTTPRouteSpecRulesMatchesInput is an input type that accepts HTTPRouteSpecRulesMatchesArgs and HTTPRouteSpecRulesMatchesOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesMatchesInput` via:
//
//	HTTPRouteSpecRulesMatchesArgs{...}
type HTTPRouteSpecRulesMatchesInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesMatchesOutput() HTTPRouteSpecRulesMatchesOutput
	ToHTTPRouteSpecRulesMatchesOutputWithContext(context.Context) HTTPRouteSpecRulesMatchesOutput
}

// HTTPRouteMatch defines the predicate used to match requests to a given
// action. Multiple match types are ANDed together, i.e. the match will
// evaluate to true only if all conditions are satisfied.
//
// For example, the match below will match a HTTP request only if its path
// starts with `/foo` AND it contains the `version: v1` header:
type HTTPRouteSpecRulesMatchesArgs struct {
	// Headers specifies HTTP request header matchers. Multiple match values are
	// ANDed together, meaning, a request must match all the specified headers
	// to select the route.
	Headers HTTPRouteSpecRulesMatchesHeadersArrayInput `pulumi:"headers"`
	// Method specifies HTTP method matcher.
	// When specified, this route will be matched only if the request has the
	// specified method.
	//
	// Support: Extended
	Method pulumi.StringPtrInput                 `pulumi:"method"`
	Path   HTTPRouteSpecRulesMatchesPathPtrInput `pulumi:"path"`
	// QueryParams specifies HTTP query parameter matchers. Multiple match
	// values are ANDed together, meaning, a request must match all the
	// specified query parameters to select the route.
	//
	// Support: Extended
	QueryParams HTTPRouteSpecRulesMatchesQueryParamsArrayInput `pulumi:"queryParams"`
}

func (HTTPRouteSpecRulesMatchesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesMatches)(nil)).Elem()
}

func (i HTTPRouteSpecRulesMatchesArgs) ToHTTPRouteSpecRulesMatchesOutput() HTTPRouteSpecRulesMatchesOutput {
	return i.ToHTTPRouteSpecRulesMatchesOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesMatchesArgs) ToHTTPRouteSpecRulesMatchesOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesMatchesOutput)
}

// HTTPRouteSpecRulesMatchesArrayInput is an input type that accepts HTTPRouteSpecRulesMatchesArray and HTTPRouteSpecRulesMatchesArrayOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesMatchesArrayInput` via:
//
//	HTTPRouteSpecRulesMatchesArray{ HTTPRouteSpecRulesMatchesArgs{...} }
type HTTPRouteSpecRulesMatchesArrayInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesMatchesArrayOutput() HTTPRouteSpecRulesMatchesArrayOutput
	ToHTTPRouteSpecRulesMatchesArrayOutputWithContext(context.Context) HTTPRouteSpecRulesMatchesArrayOutput
}

type HTTPRouteSpecRulesMatchesArray []HTTPRouteSpecRulesMatchesInput

func (HTTPRouteSpecRulesMatchesArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesMatches)(nil)).Elem()
}

func (i HTTPRouteSpecRulesMatchesArray) ToHTTPRouteSpecRulesMatchesArrayOutput() HTTPRouteSpecRulesMatchesArrayOutput {
	return i.ToHTTPRouteSpecRulesMatchesArrayOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesMatchesArray) ToHTTPRouteSpecRulesMatchesArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesMatchesArrayOutput)
}

// HTTPRouteMatch defines the predicate used to match requests to a given
// action. Multiple match types are ANDed together, i.e. the match will
// evaluate to true only if all conditions are satisfied.
//
// For example, the match below will match a HTTP request only if its path
// starts with `/foo` AND it contains the `version: v1` header:
type HTTPRouteSpecRulesMatchesOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesMatchesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesMatches)(nil)).Elem()
}

func (o HTTPRouteSpecRulesMatchesOutput) ToHTTPRouteSpecRulesMatchesOutput() HTTPRouteSpecRulesMatchesOutput {
	return o
}

func (o HTTPRouteSpecRulesMatchesOutput) ToHTTPRouteSpecRulesMatchesOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesOutput {
	return o
}

// Headers specifies HTTP request header matchers. Multiple match values are
// ANDed together, meaning, a request must match all the specified headers
// to select the route.
func (o HTTPRouteSpecRulesMatchesOutput) Headers() HTTPRouteSpecRulesMatchesHeadersArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesMatches) []HTTPRouteSpecRulesMatchesHeaders { return v.Headers }).(HTTPRouteSpecRulesMatchesHeadersArrayOutput)
}

// Method specifies HTTP method matcher.
// When specified, this route will be matched only if the request has the
// specified method.
//
// Support: Extended
func (o HTTPRouteSpecRulesMatchesOutput) Method() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesMatches) *string { return v.Method }).(pulumi.StringPtrOutput)
}

func (o HTTPRouteSpecRulesMatchesOutput) Path() HTTPRouteSpecRulesMatchesPathPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesMatches) *HTTPRouteSpecRulesMatchesPath { return v.Path }).(HTTPRouteSpecRulesMatchesPathPtrOutput)
}

// QueryParams specifies HTTP query parameter matchers. Multiple match
// values are ANDed together, meaning, a request must match all the
// specified query parameters to select the route.
//
// Support: Extended
func (o HTTPRouteSpecRulesMatchesOutput) QueryParams() HTTPRouteSpecRulesMatchesQueryParamsArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesMatches) []HTTPRouteSpecRulesMatchesQueryParams { return v.QueryParams }).(HTTPRouteSpecRulesMatchesQueryParamsArrayOutput)
}

type HTTPRouteSpecRulesMatchesArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesMatchesArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesMatches)(nil)).Elem()
}

func (o HTTPRouteSpecRulesMatchesArrayOutput) ToHTTPRouteSpecRulesMatchesArrayOutput() HTTPRouteSpecRulesMatchesArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesMatchesArrayOutput) ToHTTPRouteSpecRulesMatchesArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesMatchesArrayOutput) Index(i pulumi.IntInput) HTTPRouteSpecRulesMatchesOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteSpecRulesMatches {
		return vs[0].([]HTTPRouteSpecRulesMatches)[vs[1].(int)]
	}).(HTTPRouteSpecRulesMatchesOutput)
}

// HTTPHeaderMatch describes how to select a HTTP route by matching HTTP request
// headers.
type HTTPRouteSpecRulesMatchesHeaders struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, only the first
	// entry with an equivalent name MUST be considered for a match. Subsequent
	// entries with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	//
	// When a header is repeated in an HTTP request, it is
	// implementation-specific behavior as to how this is represented.
	// Generally, proxies should follow the guidance from the RFC:
	// https://www.rfc-editor.org/rfc/rfc7230.html#section-3.2.2 regarding
	// processing a repeated header, with special handling for "Set-Cookie".
	Name *string `pulumi:"name"`
	// Type specifies how to match against the value of the header.
	//
	// Support: Core (Exact)
	//
	// Support: Implementation-specific (RegularExpression)
	//
	// Since RegularExpression HeaderMatchType has implementation-specific
	// conformance, implementations can support POSIX, PCRE or any other dialects
	// of regular expressions. Please read the implementation's documentation to
	// determine the supported dialect.
	Type *string `pulumi:"type"`
	// Value is the value of HTTP Header to be matched.
	Value *string `pulumi:"value"`
}

// HTTPRouteSpecRulesMatchesHeadersInput is an input type that accepts HTTPRouteSpecRulesMatchesHeadersArgs and HTTPRouteSpecRulesMatchesHeadersOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesMatchesHeadersInput` via:
//
//	HTTPRouteSpecRulesMatchesHeadersArgs{...}
type HTTPRouteSpecRulesMatchesHeadersInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesMatchesHeadersOutput() HTTPRouteSpecRulesMatchesHeadersOutput
	ToHTTPRouteSpecRulesMatchesHeadersOutputWithContext(context.Context) HTTPRouteSpecRulesMatchesHeadersOutput
}

// HTTPHeaderMatch describes how to select a HTTP route by matching HTTP request
// headers.
type HTTPRouteSpecRulesMatchesHeadersArgs struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, only the first
	// entry with an equivalent name MUST be considered for a match. Subsequent
	// entries with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	//
	// When a header is repeated in an HTTP request, it is
	// implementation-specific behavior as to how this is represented.
	// Generally, proxies should follow the guidance from the RFC:
	// https://www.rfc-editor.org/rfc/rfc7230.html#section-3.2.2 regarding
	// processing a repeated header, with special handling for "Set-Cookie".
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Type specifies how to match against the value of the header.
	//
	// Support: Core (Exact)
	//
	// Support: Implementation-specific (RegularExpression)
	//
	// Since RegularExpression HeaderMatchType has implementation-specific
	// conformance, implementations can support POSIX, PCRE or any other dialects
	// of regular expressions. Please read the implementation's documentation to
	// determine the supported dialect.
	Type pulumi.StringPtrInput `pulumi:"type"`
	// Value is the value of HTTP Header to be matched.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (HTTPRouteSpecRulesMatchesHeadersArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesMatchesHeaders)(nil)).Elem()
}

func (i HTTPRouteSpecRulesMatchesHeadersArgs) ToHTTPRouteSpecRulesMatchesHeadersOutput() HTTPRouteSpecRulesMatchesHeadersOutput {
	return i.ToHTTPRouteSpecRulesMatchesHeadersOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesMatchesHeadersArgs) ToHTTPRouteSpecRulesMatchesHeadersOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesHeadersOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesMatchesHeadersOutput)
}

// HTTPRouteSpecRulesMatchesHeadersArrayInput is an input type that accepts HTTPRouteSpecRulesMatchesHeadersArray and HTTPRouteSpecRulesMatchesHeadersArrayOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesMatchesHeadersArrayInput` via:
//
//	HTTPRouteSpecRulesMatchesHeadersArray{ HTTPRouteSpecRulesMatchesHeadersArgs{...} }
type HTTPRouteSpecRulesMatchesHeadersArrayInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesMatchesHeadersArrayOutput() HTTPRouteSpecRulesMatchesHeadersArrayOutput
	ToHTTPRouteSpecRulesMatchesHeadersArrayOutputWithContext(context.Context) HTTPRouteSpecRulesMatchesHeadersArrayOutput
}

type HTTPRouteSpecRulesMatchesHeadersArray []HTTPRouteSpecRulesMatchesHeadersInput

func (HTTPRouteSpecRulesMatchesHeadersArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesMatchesHeaders)(nil)).Elem()
}

func (i HTTPRouteSpecRulesMatchesHeadersArray) ToHTTPRouteSpecRulesMatchesHeadersArrayOutput() HTTPRouteSpecRulesMatchesHeadersArrayOutput {
	return i.ToHTTPRouteSpecRulesMatchesHeadersArrayOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesMatchesHeadersArray) ToHTTPRouteSpecRulesMatchesHeadersArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesHeadersArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesMatchesHeadersArrayOutput)
}

// HTTPHeaderMatch describes how to select a HTTP route by matching HTTP request
// headers.
type HTTPRouteSpecRulesMatchesHeadersOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesMatchesHeadersOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesMatchesHeaders)(nil)).Elem()
}

func (o HTTPRouteSpecRulesMatchesHeadersOutput) ToHTTPRouteSpecRulesMatchesHeadersOutput() HTTPRouteSpecRulesMatchesHeadersOutput {
	return o
}

func (o HTTPRouteSpecRulesMatchesHeadersOutput) ToHTTPRouteSpecRulesMatchesHeadersOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesHeadersOutput {
	return o
}

// Name is the name of the HTTP Header to be matched. Name matching MUST be
// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
//
// If multiple entries specify equivalent header names, only the first
// entry with an equivalent name MUST be considered for a match. Subsequent
// entries with an equivalent header name MUST be ignored. Due to the
// case-insensitivity of header names, "foo" and "Foo" are considered
// equivalent.
//
// When a header is repeated in an HTTP request, it is
// implementation-specific behavior as to how this is represented.
// Generally, proxies should follow the guidance from the RFC:
// https://www.rfc-editor.org/rfc/rfc7230.html#section-3.2.2 regarding
// processing a repeated header, with special handling for "Set-Cookie".
func (o HTTPRouteSpecRulesMatchesHeadersOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesMatchesHeaders) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Type specifies how to match against the value of the header.
//
// Support: Core (Exact)
//
// Support: Implementation-specific (RegularExpression)
//
// Since RegularExpression HeaderMatchType has implementation-specific
// conformance, implementations can support POSIX, PCRE or any other dialects
// of regular expressions. Please read the implementation's documentation to
// determine the supported dialect.
func (o HTTPRouteSpecRulesMatchesHeadersOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesMatchesHeaders) *string { return v.Type }).(pulumi.StringPtrOutput)
}

// Value is the value of HTTP Header to be matched.
func (o HTTPRouteSpecRulesMatchesHeadersOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesMatchesHeaders) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type HTTPRouteSpecRulesMatchesHeadersArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesMatchesHeadersArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesMatchesHeaders)(nil)).Elem()
}

func (o HTTPRouteSpecRulesMatchesHeadersArrayOutput) ToHTTPRouteSpecRulesMatchesHeadersArrayOutput() HTTPRouteSpecRulesMatchesHeadersArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesMatchesHeadersArrayOutput) ToHTTPRouteSpecRulesMatchesHeadersArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesHeadersArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesMatchesHeadersArrayOutput) Index(i pulumi.IntInput) HTTPRouteSpecRulesMatchesHeadersOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteSpecRulesMatchesHeaders {
		return vs[0].([]HTTPRouteSpecRulesMatchesHeaders)[vs[1].(int)]
	}).(HTTPRouteSpecRulesMatchesHeadersOutput)
}

// HTTPHeaderMatch describes how to select a HTTP route by matching HTTP request
// headers.
type HTTPRouteSpecRulesMatchesHeadersPatch struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, only the first
	// entry with an equivalent name MUST be considered for a match. Subsequent
	// entries with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	//
	// When a header is repeated in an HTTP request, it is
	// implementation-specific behavior as to how this is represented.
	// Generally, proxies should follow the guidance from the RFC:
	// https://www.rfc-editor.org/rfc/rfc7230.html#section-3.2.2 regarding
	// processing a repeated header, with special handling for "Set-Cookie".
	Name *string `pulumi:"name"`
	// Type specifies how to match against the value of the header.
	//
	// Support: Core (Exact)
	//
	// Support: Implementation-specific (RegularExpression)
	//
	// Since RegularExpression HeaderMatchType has implementation-specific
	// conformance, implementations can support POSIX, PCRE or any other dialects
	// of regular expressions. Please read the implementation's documentation to
	// determine the supported dialect.
	Type *string `pulumi:"type"`
	// Value is the value of HTTP Header to be matched.
	Value *string `pulumi:"value"`
}

// HTTPRouteSpecRulesMatchesHeadersPatchInput is an input type that accepts HTTPRouteSpecRulesMatchesHeadersPatchArgs and HTTPRouteSpecRulesMatchesHeadersPatchOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesMatchesHeadersPatchInput` via:
//
//	HTTPRouteSpecRulesMatchesHeadersPatchArgs{...}
type HTTPRouteSpecRulesMatchesHeadersPatchInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesMatchesHeadersPatchOutput() HTTPRouteSpecRulesMatchesHeadersPatchOutput
	ToHTTPRouteSpecRulesMatchesHeadersPatchOutputWithContext(context.Context) HTTPRouteSpecRulesMatchesHeadersPatchOutput
}

// HTTPHeaderMatch describes how to select a HTTP route by matching HTTP request
// headers.
type HTTPRouteSpecRulesMatchesHeadersPatchArgs struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be
	// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//
	// If multiple entries specify equivalent header names, only the first
	// entry with an equivalent name MUST be considered for a match. Subsequent
	// entries with an equivalent header name MUST be ignored. Due to the
	// case-insensitivity of header names, "foo" and "Foo" are considered
	// equivalent.
	//
	// When a header is repeated in an HTTP request, it is
	// implementation-specific behavior as to how this is represented.
	// Generally, proxies should follow the guidance from the RFC:
	// https://www.rfc-editor.org/rfc/rfc7230.html#section-3.2.2 regarding
	// processing a repeated header, with special handling for "Set-Cookie".
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Type specifies how to match against the value of the header.
	//
	// Support: Core (Exact)
	//
	// Support: Implementation-specific (RegularExpression)
	//
	// Since RegularExpression HeaderMatchType has implementation-specific
	// conformance, implementations can support POSIX, PCRE or any other dialects
	// of regular expressions. Please read the implementation's documentation to
	// determine the supported dialect.
	Type pulumi.StringPtrInput `pulumi:"type"`
	// Value is the value of HTTP Header to be matched.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (HTTPRouteSpecRulesMatchesHeadersPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesMatchesHeadersPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesMatchesHeadersPatchArgs) ToHTTPRouteSpecRulesMatchesHeadersPatchOutput() HTTPRouteSpecRulesMatchesHeadersPatchOutput {
	return i.ToHTTPRouteSpecRulesMatchesHeadersPatchOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesMatchesHeadersPatchArgs) ToHTTPRouteSpecRulesMatchesHeadersPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesHeadersPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesMatchesHeadersPatchOutput)
}

// HTTPRouteSpecRulesMatchesHeadersPatchArrayInput is an input type that accepts HTTPRouteSpecRulesMatchesHeadersPatchArray and HTTPRouteSpecRulesMatchesHeadersPatchArrayOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesMatchesHeadersPatchArrayInput` via:
//
//	HTTPRouteSpecRulesMatchesHeadersPatchArray{ HTTPRouteSpecRulesMatchesHeadersPatchArgs{...} }
type HTTPRouteSpecRulesMatchesHeadersPatchArrayInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesMatchesHeadersPatchArrayOutput() HTTPRouteSpecRulesMatchesHeadersPatchArrayOutput
	ToHTTPRouteSpecRulesMatchesHeadersPatchArrayOutputWithContext(context.Context) HTTPRouteSpecRulesMatchesHeadersPatchArrayOutput
}

type HTTPRouteSpecRulesMatchesHeadersPatchArray []HTTPRouteSpecRulesMatchesHeadersPatchInput

func (HTTPRouteSpecRulesMatchesHeadersPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesMatchesHeadersPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesMatchesHeadersPatchArray) ToHTTPRouteSpecRulesMatchesHeadersPatchArrayOutput() HTTPRouteSpecRulesMatchesHeadersPatchArrayOutput {
	return i.ToHTTPRouteSpecRulesMatchesHeadersPatchArrayOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesMatchesHeadersPatchArray) ToHTTPRouteSpecRulesMatchesHeadersPatchArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesHeadersPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesMatchesHeadersPatchArrayOutput)
}

// HTTPHeaderMatch describes how to select a HTTP route by matching HTTP request
// headers.
type HTTPRouteSpecRulesMatchesHeadersPatchOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesMatchesHeadersPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesMatchesHeadersPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesMatchesHeadersPatchOutput) ToHTTPRouteSpecRulesMatchesHeadersPatchOutput() HTTPRouteSpecRulesMatchesHeadersPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesMatchesHeadersPatchOutput) ToHTTPRouteSpecRulesMatchesHeadersPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesHeadersPatchOutput {
	return o
}

// Name is the name of the HTTP Header to be matched. Name matching MUST be
// case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
//
// If multiple entries specify equivalent header names, only the first
// entry with an equivalent name MUST be considered for a match. Subsequent
// entries with an equivalent header name MUST be ignored. Due to the
// case-insensitivity of header names, "foo" and "Foo" are considered
// equivalent.
//
// When a header is repeated in an HTTP request, it is
// implementation-specific behavior as to how this is represented.
// Generally, proxies should follow the guidance from the RFC:
// https://www.rfc-editor.org/rfc/rfc7230.html#section-3.2.2 regarding
// processing a repeated header, with special handling for "Set-Cookie".
func (o HTTPRouteSpecRulesMatchesHeadersPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesMatchesHeadersPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Type specifies how to match against the value of the header.
//
// Support: Core (Exact)
//
// Support: Implementation-specific (RegularExpression)
//
// Since RegularExpression HeaderMatchType has implementation-specific
// conformance, implementations can support POSIX, PCRE or any other dialects
// of regular expressions. Please read the implementation's documentation to
// determine the supported dialect.
func (o HTTPRouteSpecRulesMatchesHeadersPatchOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesMatchesHeadersPatch) *string { return v.Type }).(pulumi.StringPtrOutput)
}

// Value is the value of HTTP Header to be matched.
func (o HTTPRouteSpecRulesMatchesHeadersPatchOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesMatchesHeadersPatch) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type HTTPRouteSpecRulesMatchesHeadersPatchArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesMatchesHeadersPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesMatchesHeadersPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesMatchesHeadersPatchArrayOutput) ToHTTPRouteSpecRulesMatchesHeadersPatchArrayOutput() HTTPRouteSpecRulesMatchesHeadersPatchArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesMatchesHeadersPatchArrayOutput) ToHTTPRouteSpecRulesMatchesHeadersPatchArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesHeadersPatchArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesMatchesHeadersPatchArrayOutput) Index(i pulumi.IntInput) HTTPRouteSpecRulesMatchesHeadersPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteSpecRulesMatchesHeadersPatch {
		return vs[0].([]HTTPRouteSpecRulesMatchesHeadersPatch)[vs[1].(int)]
	}).(HTTPRouteSpecRulesMatchesHeadersPatchOutput)
}

// HTTPRouteMatch defines the predicate used to match requests to a given
// action. Multiple match types are ANDed together, i.e. the match will
// evaluate to true only if all conditions are satisfied.
//
// For example, the match below will match a HTTP request only if its path
// starts with `/foo` AND it contains the `version: v1` header:
type HTTPRouteSpecRulesMatchesPatch struct {
	// Headers specifies HTTP request header matchers. Multiple match values are
	// ANDed together, meaning, a request must match all the specified headers
	// to select the route.
	Headers []HTTPRouteSpecRulesMatchesHeadersPatch `pulumi:"headers"`
	// Method specifies HTTP method matcher.
	// When specified, this route will be matched only if the request has the
	// specified method.
	//
	// Support: Extended
	Method *string                             `pulumi:"method"`
	Path   *HTTPRouteSpecRulesMatchesPathPatch `pulumi:"path"`
	// QueryParams specifies HTTP query parameter matchers. Multiple match
	// values are ANDed together, meaning, a request must match all the
	// specified query parameters to select the route.
	//
	// Support: Extended
	QueryParams []HTTPRouteSpecRulesMatchesQueryParamsPatch `pulumi:"queryParams"`
}

// HTTPRouteSpecRulesMatchesPatchInput is an input type that accepts HTTPRouteSpecRulesMatchesPatchArgs and HTTPRouteSpecRulesMatchesPatchOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesMatchesPatchInput` via:
//
//	HTTPRouteSpecRulesMatchesPatchArgs{...}
type HTTPRouteSpecRulesMatchesPatchInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesMatchesPatchOutput() HTTPRouteSpecRulesMatchesPatchOutput
	ToHTTPRouteSpecRulesMatchesPatchOutputWithContext(context.Context) HTTPRouteSpecRulesMatchesPatchOutput
}

// HTTPRouteMatch defines the predicate used to match requests to a given
// action. Multiple match types are ANDed together, i.e. the match will
// evaluate to true only if all conditions are satisfied.
//
// For example, the match below will match a HTTP request only if its path
// starts with `/foo` AND it contains the `version: v1` header:
type HTTPRouteSpecRulesMatchesPatchArgs struct {
	// Headers specifies HTTP request header matchers. Multiple match values are
	// ANDed together, meaning, a request must match all the specified headers
	// to select the route.
	Headers HTTPRouteSpecRulesMatchesHeadersPatchArrayInput `pulumi:"headers"`
	// Method specifies HTTP method matcher.
	// When specified, this route will be matched only if the request has the
	// specified method.
	//
	// Support: Extended
	Method pulumi.StringPtrInput                      `pulumi:"method"`
	Path   HTTPRouteSpecRulesMatchesPathPatchPtrInput `pulumi:"path"`
	// QueryParams specifies HTTP query parameter matchers. Multiple match
	// values are ANDed together, meaning, a request must match all the
	// specified query parameters to select the route.
	//
	// Support: Extended
	QueryParams HTTPRouteSpecRulesMatchesQueryParamsPatchArrayInput `pulumi:"queryParams"`
}

func (HTTPRouteSpecRulesMatchesPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesMatchesPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesMatchesPatchArgs) ToHTTPRouteSpecRulesMatchesPatchOutput() HTTPRouteSpecRulesMatchesPatchOutput {
	return i.ToHTTPRouteSpecRulesMatchesPatchOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesMatchesPatchArgs) ToHTTPRouteSpecRulesMatchesPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesMatchesPatchOutput)
}

// HTTPRouteSpecRulesMatchesPatchArrayInput is an input type that accepts HTTPRouteSpecRulesMatchesPatchArray and HTTPRouteSpecRulesMatchesPatchArrayOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesMatchesPatchArrayInput` via:
//
//	HTTPRouteSpecRulesMatchesPatchArray{ HTTPRouteSpecRulesMatchesPatchArgs{...} }
type HTTPRouteSpecRulesMatchesPatchArrayInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesMatchesPatchArrayOutput() HTTPRouteSpecRulesMatchesPatchArrayOutput
	ToHTTPRouteSpecRulesMatchesPatchArrayOutputWithContext(context.Context) HTTPRouteSpecRulesMatchesPatchArrayOutput
}

type HTTPRouteSpecRulesMatchesPatchArray []HTTPRouteSpecRulesMatchesPatchInput

func (HTTPRouteSpecRulesMatchesPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesMatchesPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesMatchesPatchArray) ToHTTPRouteSpecRulesMatchesPatchArrayOutput() HTTPRouteSpecRulesMatchesPatchArrayOutput {
	return i.ToHTTPRouteSpecRulesMatchesPatchArrayOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesMatchesPatchArray) ToHTTPRouteSpecRulesMatchesPatchArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesMatchesPatchArrayOutput)
}

// HTTPRouteMatch defines the predicate used to match requests to a given
// action. Multiple match types are ANDed together, i.e. the match will
// evaluate to true only if all conditions are satisfied.
//
// For example, the match below will match a HTTP request only if its path
// starts with `/foo` AND it contains the `version: v1` header:
type HTTPRouteSpecRulesMatchesPatchOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesMatchesPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesMatchesPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesMatchesPatchOutput) ToHTTPRouteSpecRulesMatchesPatchOutput() HTTPRouteSpecRulesMatchesPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesMatchesPatchOutput) ToHTTPRouteSpecRulesMatchesPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesPatchOutput {
	return o
}

// Headers specifies HTTP request header matchers. Multiple match values are
// ANDed together, meaning, a request must match all the specified headers
// to select the route.
func (o HTTPRouteSpecRulesMatchesPatchOutput) Headers() HTTPRouteSpecRulesMatchesHeadersPatchArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesMatchesPatch) []HTTPRouteSpecRulesMatchesHeadersPatch { return v.Headers }).(HTTPRouteSpecRulesMatchesHeadersPatchArrayOutput)
}

// Method specifies HTTP method matcher.
// When specified, this route will be matched only if the request has the
// specified method.
//
// Support: Extended
func (o HTTPRouteSpecRulesMatchesPatchOutput) Method() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesMatchesPatch) *string { return v.Method }).(pulumi.StringPtrOutput)
}

func (o HTTPRouteSpecRulesMatchesPatchOutput) Path() HTTPRouteSpecRulesMatchesPathPatchPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesMatchesPatch) *HTTPRouteSpecRulesMatchesPathPatch { return v.Path }).(HTTPRouteSpecRulesMatchesPathPatchPtrOutput)
}

// QueryParams specifies HTTP query parameter matchers. Multiple match
// values are ANDed together, meaning, a request must match all the
// specified query parameters to select the route.
//
// Support: Extended
func (o HTTPRouteSpecRulesMatchesPatchOutput) QueryParams() HTTPRouteSpecRulesMatchesQueryParamsPatchArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesMatchesPatch) []HTTPRouteSpecRulesMatchesQueryParamsPatch {
		return v.QueryParams
	}).(HTTPRouteSpecRulesMatchesQueryParamsPatchArrayOutput)
}

type HTTPRouteSpecRulesMatchesPatchArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesMatchesPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesMatchesPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesMatchesPatchArrayOutput) ToHTTPRouteSpecRulesMatchesPatchArrayOutput() HTTPRouteSpecRulesMatchesPatchArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesMatchesPatchArrayOutput) ToHTTPRouteSpecRulesMatchesPatchArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesPatchArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesMatchesPatchArrayOutput) Index(i pulumi.IntInput) HTTPRouteSpecRulesMatchesPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteSpecRulesMatchesPatch {
		return vs[0].([]HTTPRouteSpecRulesMatchesPatch)[vs[1].(int)]
	}).(HTTPRouteSpecRulesMatchesPatchOutput)
}

// Path specifies a HTTP request path matcher. If this field is not
// specified, a default prefix match on the "/" path is provided.
type HTTPRouteSpecRulesMatchesPath struct {
	// Type specifies how to match against the path Value.
	//
	// Support: Core (Exact, PathPrefix)
	//
	// Support: Implementation-specific (RegularExpression)
	Type *string `pulumi:"type"`
	// Value of the HTTP path to match against.
	Value *string `pulumi:"value"`
}

// HTTPRouteSpecRulesMatchesPathInput is an input type that accepts HTTPRouteSpecRulesMatchesPathArgs and HTTPRouteSpecRulesMatchesPathOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesMatchesPathInput` via:
//
//	HTTPRouteSpecRulesMatchesPathArgs{...}
type HTTPRouteSpecRulesMatchesPathInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesMatchesPathOutput() HTTPRouteSpecRulesMatchesPathOutput
	ToHTTPRouteSpecRulesMatchesPathOutputWithContext(context.Context) HTTPRouteSpecRulesMatchesPathOutput
}

// Path specifies a HTTP request path matcher. If this field is not
// specified, a default prefix match on the "/" path is provided.
type HTTPRouteSpecRulesMatchesPathArgs struct {
	// Type specifies how to match against the path Value.
	//
	// Support: Core (Exact, PathPrefix)
	//
	// Support: Implementation-specific (RegularExpression)
	Type pulumi.StringPtrInput `pulumi:"type"`
	// Value of the HTTP path to match against.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (HTTPRouteSpecRulesMatchesPathArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesMatchesPath)(nil)).Elem()
}

func (i HTTPRouteSpecRulesMatchesPathArgs) ToHTTPRouteSpecRulesMatchesPathOutput() HTTPRouteSpecRulesMatchesPathOutput {
	return i.ToHTTPRouteSpecRulesMatchesPathOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesMatchesPathArgs) ToHTTPRouteSpecRulesMatchesPathOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesPathOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesMatchesPathOutput)
}

func (i HTTPRouteSpecRulesMatchesPathArgs) ToHTTPRouteSpecRulesMatchesPathPtrOutput() HTTPRouteSpecRulesMatchesPathPtrOutput {
	return i.ToHTTPRouteSpecRulesMatchesPathPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesMatchesPathArgs) ToHTTPRouteSpecRulesMatchesPathPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesPathPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesMatchesPathOutput).ToHTTPRouteSpecRulesMatchesPathPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesMatchesPathPtrInput is an input type that accepts HTTPRouteSpecRulesMatchesPathArgs, HTTPRouteSpecRulesMatchesPathPtr and HTTPRouteSpecRulesMatchesPathPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesMatchesPathPtrInput` via:
//
//	        HTTPRouteSpecRulesMatchesPathArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesMatchesPathPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesMatchesPathPtrOutput() HTTPRouteSpecRulesMatchesPathPtrOutput
	ToHTTPRouteSpecRulesMatchesPathPtrOutputWithContext(context.Context) HTTPRouteSpecRulesMatchesPathPtrOutput
}

type httprouteSpecRulesMatchesPathPtrType HTTPRouteSpecRulesMatchesPathArgs

func HTTPRouteSpecRulesMatchesPathPtr(v *HTTPRouteSpecRulesMatchesPathArgs) HTTPRouteSpecRulesMatchesPathPtrInput {
	return (*httprouteSpecRulesMatchesPathPtrType)(v)
}

func (*httprouteSpecRulesMatchesPathPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesMatchesPath)(nil)).Elem()
}

func (i *httprouteSpecRulesMatchesPathPtrType) ToHTTPRouteSpecRulesMatchesPathPtrOutput() HTTPRouteSpecRulesMatchesPathPtrOutput {
	return i.ToHTTPRouteSpecRulesMatchesPathPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesMatchesPathPtrType) ToHTTPRouteSpecRulesMatchesPathPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesPathPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesMatchesPathPtrOutput)
}

// Path specifies a HTTP request path matcher. If this field is not
// specified, a default prefix match on the "/" path is provided.
type HTTPRouteSpecRulesMatchesPathOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesMatchesPathOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesMatchesPath)(nil)).Elem()
}

func (o HTTPRouteSpecRulesMatchesPathOutput) ToHTTPRouteSpecRulesMatchesPathOutput() HTTPRouteSpecRulesMatchesPathOutput {
	return o
}

func (o HTTPRouteSpecRulesMatchesPathOutput) ToHTTPRouteSpecRulesMatchesPathOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesPathOutput {
	return o
}

func (o HTTPRouteSpecRulesMatchesPathOutput) ToHTTPRouteSpecRulesMatchesPathPtrOutput() HTTPRouteSpecRulesMatchesPathPtrOutput {
	return o.ToHTTPRouteSpecRulesMatchesPathPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesMatchesPathOutput) ToHTTPRouteSpecRulesMatchesPathPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesPathPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesMatchesPath) *HTTPRouteSpecRulesMatchesPath {
		return &v
	}).(HTTPRouteSpecRulesMatchesPathPtrOutput)
}

// Type specifies how to match against the path Value.
//
// Support: Core (Exact, PathPrefix)
//
// Support: Implementation-specific (RegularExpression)
func (o HTTPRouteSpecRulesMatchesPathOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesMatchesPath) *string { return v.Type }).(pulumi.StringPtrOutput)
}

// Value of the HTTP path to match against.
func (o HTTPRouteSpecRulesMatchesPathOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesMatchesPath) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type HTTPRouteSpecRulesMatchesPathPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesMatchesPathPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesMatchesPath)(nil)).Elem()
}

func (o HTTPRouteSpecRulesMatchesPathPtrOutput) ToHTTPRouteSpecRulesMatchesPathPtrOutput() HTTPRouteSpecRulesMatchesPathPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesMatchesPathPtrOutput) ToHTTPRouteSpecRulesMatchesPathPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesPathPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesMatchesPathPtrOutput) Elem() HTTPRouteSpecRulesMatchesPathOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesMatchesPath) HTTPRouteSpecRulesMatchesPath {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesMatchesPath
		return ret
	}).(HTTPRouteSpecRulesMatchesPathOutput)
}

// Type specifies how to match against the path Value.
//
// Support: Core (Exact, PathPrefix)
//
// Support: Implementation-specific (RegularExpression)
func (o HTTPRouteSpecRulesMatchesPathPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesMatchesPath) *string {
		if v == nil {
			return nil
		}
		return v.Type
	}).(pulumi.StringPtrOutput)
}

// Value of the HTTP path to match against.
func (o HTTPRouteSpecRulesMatchesPathPtrOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesMatchesPath) *string {
		if v == nil {
			return nil
		}
		return v.Value
	}).(pulumi.StringPtrOutput)
}

// Path specifies a HTTP request path matcher. If this field is not
// specified, a default prefix match on the "/" path is provided.
type HTTPRouteSpecRulesMatchesPathPatch struct {
	// Type specifies how to match against the path Value.
	//
	// Support: Core (Exact, PathPrefix)
	//
	// Support: Implementation-specific (RegularExpression)
	Type *string `pulumi:"type"`
	// Value of the HTTP path to match against.
	Value *string `pulumi:"value"`
}

// HTTPRouteSpecRulesMatchesPathPatchInput is an input type that accepts HTTPRouteSpecRulesMatchesPathPatchArgs and HTTPRouteSpecRulesMatchesPathPatchOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesMatchesPathPatchInput` via:
//
//	HTTPRouteSpecRulesMatchesPathPatchArgs{...}
type HTTPRouteSpecRulesMatchesPathPatchInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesMatchesPathPatchOutput() HTTPRouteSpecRulesMatchesPathPatchOutput
	ToHTTPRouteSpecRulesMatchesPathPatchOutputWithContext(context.Context) HTTPRouteSpecRulesMatchesPathPatchOutput
}

// Path specifies a HTTP request path matcher. If this field is not
// specified, a default prefix match on the "/" path is provided.
type HTTPRouteSpecRulesMatchesPathPatchArgs struct {
	// Type specifies how to match against the path Value.
	//
	// Support: Core (Exact, PathPrefix)
	//
	// Support: Implementation-specific (RegularExpression)
	Type pulumi.StringPtrInput `pulumi:"type"`
	// Value of the HTTP path to match against.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (HTTPRouteSpecRulesMatchesPathPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesMatchesPathPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesMatchesPathPatchArgs) ToHTTPRouteSpecRulesMatchesPathPatchOutput() HTTPRouteSpecRulesMatchesPathPatchOutput {
	return i.ToHTTPRouteSpecRulesMatchesPathPatchOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesMatchesPathPatchArgs) ToHTTPRouteSpecRulesMatchesPathPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesPathPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesMatchesPathPatchOutput)
}

func (i HTTPRouteSpecRulesMatchesPathPatchArgs) ToHTTPRouteSpecRulesMatchesPathPatchPtrOutput() HTTPRouteSpecRulesMatchesPathPatchPtrOutput {
	return i.ToHTTPRouteSpecRulesMatchesPathPatchPtrOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesMatchesPathPatchArgs) ToHTTPRouteSpecRulesMatchesPathPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesPathPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesMatchesPathPatchOutput).ToHTTPRouteSpecRulesMatchesPathPatchPtrOutputWithContext(ctx)
}

// HTTPRouteSpecRulesMatchesPathPatchPtrInput is an input type that accepts HTTPRouteSpecRulesMatchesPathPatchArgs, HTTPRouteSpecRulesMatchesPathPatchPtr and HTTPRouteSpecRulesMatchesPathPatchPtrOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesMatchesPathPatchPtrInput` via:
//
//	        HTTPRouteSpecRulesMatchesPathPatchArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteSpecRulesMatchesPathPatchPtrInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesMatchesPathPatchPtrOutput() HTTPRouteSpecRulesMatchesPathPatchPtrOutput
	ToHTTPRouteSpecRulesMatchesPathPatchPtrOutputWithContext(context.Context) HTTPRouteSpecRulesMatchesPathPatchPtrOutput
}

type httprouteSpecRulesMatchesPathPatchPtrType HTTPRouteSpecRulesMatchesPathPatchArgs

func HTTPRouteSpecRulesMatchesPathPatchPtr(v *HTTPRouteSpecRulesMatchesPathPatchArgs) HTTPRouteSpecRulesMatchesPathPatchPtrInput {
	return (*httprouteSpecRulesMatchesPathPatchPtrType)(v)
}

func (*httprouteSpecRulesMatchesPathPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesMatchesPathPatch)(nil)).Elem()
}

func (i *httprouteSpecRulesMatchesPathPatchPtrType) ToHTTPRouteSpecRulesMatchesPathPatchPtrOutput() HTTPRouteSpecRulesMatchesPathPatchPtrOutput {
	return i.ToHTTPRouteSpecRulesMatchesPathPatchPtrOutputWithContext(context.Background())
}

func (i *httprouteSpecRulesMatchesPathPatchPtrType) ToHTTPRouteSpecRulesMatchesPathPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesPathPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesMatchesPathPatchPtrOutput)
}

// Path specifies a HTTP request path matcher. If this field is not
// specified, a default prefix match on the "/" path is provided.
type HTTPRouteSpecRulesMatchesPathPatchOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesMatchesPathPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesMatchesPathPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesMatchesPathPatchOutput) ToHTTPRouteSpecRulesMatchesPathPatchOutput() HTTPRouteSpecRulesMatchesPathPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesMatchesPathPatchOutput) ToHTTPRouteSpecRulesMatchesPathPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesPathPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesMatchesPathPatchOutput) ToHTTPRouteSpecRulesMatchesPathPatchPtrOutput() HTTPRouteSpecRulesMatchesPathPatchPtrOutput {
	return o.ToHTTPRouteSpecRulesMatchesPathPatchPtrOutputWithContext(context.Background())
}

func (o HTTPRouteSpecRulesMatchesPathPatchOutput) ToHTTPRouteSpecRulesMatchesPathPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesPathPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteSpecRulesMatchesPathPatch) *HTTPRouteSpecRulesMatchesPathPatch {
		return &v
	}).(HTTPRouteSpecRulesMatchesPathPatchPtrOutput)
}

// Type specifies how to match against the path Value.
//
// Support: Core (Exact, PathPrefix)
//
// Support: Implementation-specific (RegularExpression)
func (o HTTPRouteSpecRulesMatchesPathPatchOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesMatchesPathPatch) *string { return v.Type }).(pulumi.StringPtrOutput)
}

// Value of the HTTP path to match against.
func (o HTTPRouteSpecRulesMatchesPathPatchOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesMatchesPathPatch) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type HTTPRouteSpecRulesMatchesPathPatchPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesMatchesPathPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteSpecRulesMatchesPathPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesMatchesPathPatchPtrOutput) ToHTTPRouteSpecRulesMatchesPathPatchPtrOutput() HTTPRouteSpecRulesMatchesPathPatchPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesMatchesPathPatchPtrOutput) ToHTTPRouteSpecRulesMatchesPathPatchPtrOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesPathPatchPtrOutput {
	return o
}

func (o HTTPRouteSpecRulesMatchesPathPatchPtrOutput) Elem() HTTPRouteSpecRulesMatchesPathPatchOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesMatchesPathPatch) HTTPRouteSpecRulesMatchesPathPatch {
		if v != nil {
			return *v
		}
		var ret HTTPRouteSpecRulesMatchesPathPatch
		return ret
	}).(HTTPRouteSpecRulesMatchesPathPatchOutput)
}

// Type specifies how to match against the path Value.
//
// Support: Core (Exact, PathPrefix)
//
// Support: Implementation-specific (RegularExpression)
func (o HTTPRouteSpecRulesMatchesPathPatchPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesMatchesPathPatch) *string {
		if v == nil {
			return nil
		}
		return v.Type
	}).(pulumi.StringPtrOutput)
}

// Value of the HTTP path to match against.
func (o HTTPRouteSpecRulesMatchesPathPatchPtrOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteSpecRulesMatchesPathPatch) *string {
		if v == nil {
			return nil
		}
		return v.Value
	}).(pulumi.StringPtrOutput)
}

// HTTPQueryParamMatch describes how to select a HTTP route by matching HTTP
// query parameters.
type HTTPRouteSpecRulesMatchesQueryParams struct {
	// Name is the name of the HTTP query param to be matched. This must be an
	// exact string match. (See
	// https://tools.ietf.org/html/rfc7230#section-2.7.3).
	//
	// If multiple entries specify equivalent query param names, only the first
	// entry with an equivalent name MUST be considered for a match. Subsequent
	// entries with an equivalent query param name MUST be ignored.
	//
	// If a query param is repeated in an HTTP request, the behavior is
	// purposely left undefined, since different data planes have different
	// capabilities. However, it is *recommended* that implementations should
	// match against the first value of the param if the data plane supports it,
	// as this behavior is expected in other load balancing contexts outside of
	// the Gateway API.
	//
	// Users SHOULD NOT route traffic based on repeated query params to guard
	// themselves against potential differences in the implementations.
	Name *string `pulumi:"name"`
	// Type specifies how to match against the value of the query parameter.
	//
	// Support: Extended (Exact)
	//
	// Support: Implementation-specific (RegularExpression)
	//
	// Since RegularExpression QueryParamMatchType has Implementation-specific
	// conformance, implementations can support POSIX, PCRE or any other
	// dialects of regular expressions. Please read the implementation's
	// documentation to determine the supported dialect.
	Type *string `pulumi:"type"`
	// Value is the value of HTTP query param to be matched.
	Value *string `pulumi:"value"`
}

// HTTPRouteSpecRulesMatchesQueryParamsInput is an input type that accepts HTTPRouteSpecRulesMatchesQueryParamsArgs and HTTPRouteSpecRulesMatchesQueryParamsOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesMatchesQueryParamsInput` via:
//
//	HTTPRouteSpecRulesMatchesQueryParamsArgs{...}
type HTTPRouteSpecRulesMatchesQueryParamsInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesMatchesQueryParamsOutput() HTTPRouteSpecRulesMatchesQueryParamsOutput
	ToHTTPRouteSpecRulesMatchesQueryParamsOutputWithContext(context.Context) HTTPRouteSpecRulesMatchesQueryParamsOutput
}

// HTTPQueryParamMatch describes how to select a HTTP route by matching HTTP
// query parameters.
type HTTPRouteSpecRulesMatchesQueryParamsArgs struct {
	// Name is the name of the HTTP query param to be matched. This must be an
	// exact string match. (See
	// https://tools.ietf.org/html/rfc7230#section-2.7.3).
	//
	// If multiple entries specify equivalent query param names, only the first
	// entry with an equivalent name MUST be considered for a match. Subsequent
	// entries with an equivalent query param name MUST be ignored.
	//
	// If a query param is repeated in an HTTP request, the behavior is
	// purposely left undefined, since different data planes have different
	// capabilities. However, it is *recommended* that implementations should
	// match against the first value of the param if the data plane supports it,
	// as this behavior is expected in other load balancing contexts outside of
	// the Gateway API.
	//
	// Users SHOULD NOT route traffic based on repeated query params to guard
	// themselves against potential differences in the implementations.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Type specifies how to match against the value of the query parameter.
	//
	// Support: Extended (Exact)
	//
	// Support: Implementation-specific (RegularExpression)
	//
	// Since RegularExpression QueryParamMatchType has Implementation-specific
	// conformance, implementations can support POSIX, PCRE or any other
	// dialects of regular expressions. Please read the implementation's
	// documentation to determine the supported dialect.
	Type pulumi.StringPtrInput `pulumi:"type"`
	// Value is the value of HTTP query param to be matched.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (HTTPRouteSpecRulesMatchesQueryParamsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesMatchesQueryParams)(nil)).Elem()
}

func (i HTTPRouteSpecRulesMatchesQueryParamsArgs) ToHTTPRouteSpecRulesMatchesQueryParamsOutput() HTTPRouteSpecRulesMatchesQueryParamsOutput {
	return i.ToHTTPRouteSpecRulesMatchesQueryParamsOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesMatchesQueryParamsArgs) ToHTTPRouteSpecRulesMatchesQueryParamsOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesQueryParamsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesMatchesQueryParamsOutput)
}

// HTTPRouteSpecRulesMatchesQueryParamsArrayInput is an input type that accepts HTTPRouteSpecRulesMatchesQueryParamsArray and HTTPRouteSpecRulesMatchesQueryParamsArrayOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesMatchesQueryParamsArrayInput` via:
//
//	HTTPRouteSpecRulesMatchesQueryParamsArray{ HTTPRouteSpecRulesMatchesQueryParamsArgs{...} }
type HTTPRouteSpecRulesMatchesQueryParamsArrayInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesMatchesQueryParamsArrayOutput() HTTPRouteSpecRulesMatchesQueryParamsArrayOutput
	ToHTTPRouteSpecRulesMatchesQueryParamsArrayOutputWithContext(context.Context) HTTPRouteSpecRulesMatchesQueryParamsArrayOutput
}

type HTTPRouteSpecRulesMatchesQueryParamsArray []HTTPRouteSpecRulesMatchesQueryParamsInput

func (HTTPRouteSpecRulesMatchesQueryParamsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesMatchesQueryParams)(nil)).Elem()
}

func (i HTTPRouteSpecRulesMatchesQueryParamsArray) ToHTTPRouteSpecRulesMatchesQueryParamsArrayOutput() HTTPRouteSpecRulesMatchesQueryParamsArrayOutput {
	return i.ToHTTPRouteSpecRulesMatchesQueryParamsArrayOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesMatchesQueryParamsArray) ToHTTPRouteSpecRulesMatchesQueryParamsArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesQueryParamsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesMatchesQueryParamsArrayOutput)
}

// HTTPQueryParamMatch describes how to select a HTTP route by matching HTTP
// query parameters.
type HTTPRouteSpecRulesMatchesQueryParamsOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesMatchesQueryParamsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesMatchesQueryParams)(nil)).Elem()
}

func (o HTTPRouteSpecRulesMatchesQueryParamsOutput) ToHTTPRouteSpecRulesMatchesQueryParamsOutput() HTTPRouteSpecRulesMatchesQueryParamsOutput {
	return o
}

func (o HTTPRouteSpecRulesMatchesQueryParamsOutput) ToHTTPRouteSpecRulesMatchesQueryParamsOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesQueryParamsOutput {
	return o
}

// Name is the name of the HTTP query param to be matched. This must be an
// exact string match. (See
// https://tools.ietf.org/html/rfc7230#section-2.7.3).
//
// If multiple entries specify equivalent query param names, only the first
// entry with an equivalent name MUST be considered for a match. Subsequent
// entries with an equivalent query param name MUST be ignored.
//
// If a query param is repeated in an HTTP request, the behavior is
// purposely left undefined, since different data planes have different
// capabilities. However, it is *recommended* that implementations should
// match against the first value of the param if the data plane supports it,
// as this behavior is expected in other load balancing contexts outside of
// the Gateway API.
//
// Users SHOULD NOT route traffic based on repeated query params to guard
// themselves against potential differences in the implementations.
func (o HTTPRouteSpecRulesMatchesQueryParamsOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesMatchesQueryParams) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Type specifies how to match against the value of the query parameter.
//
// Support: Extended (Exact)
//
// Support: Implementation-specific (RegularExpression)
//
// Since RegularExpression QueryParamMatchType has Implementation-specific
// conformance, implementations can support POSIX, PCRE or any other
// dialects of regular expressions. Please read the implementation's
// documentation to determine the supported dialect.
func (o HTTPRouteSpecRulesMatchesQueryParamsOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesMatchesQueryParams) *string { return v.Type }).(pulumi.StringPtrOutput)
}

// Value is the value of HTTP query param to be matched.
func (o HTTPRouteSpecRulesMatchesQueryParamsOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesMatchesQueryParams) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type HTTPRouteSpecRulesMatchesQueryParamsArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesMatchesQueryParamsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesMatchesQueryParams)(nil)).Elem()
}

func (o HTTPRouteSpecRulesMatchesQueryParamsArrayOutput) ToHTTPRouteSpecRulesMatchesQueryParamsArrayOutput() HTTPRouteSpecRulesMatchesQueryParamsArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesMatchesQueryParamsArrayOutput) ToHTTPRouteSpecRulesMatchesQueryParamsArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesQueryParamsArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesMatchesQueryParamsArrayOutput) Index(i pulumi.IntInput) HTTPRouteSpecRulesMatchesQueryParamsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteSpecRulesMatchesQueryParams {
		return vs[0].([]HTTPRouteSpecRulesMatchesQueryParams)[vs[1].(int)]
	}).(HTTPRouteSpecRulesMatchesQueryParamsOutput)
}

// HTTPQueryParamMatch describes how to select a HTTP route by matching HTTP
// query parameters.
type HTTPRouteSpecRulesMatchesQueryParamsPatch struct {
	// Name is the name of the HTTP query param to be matched. This must be an
	// exact string match. (See
	// https://tools.ietf.org/html/rfc7230#section-2.7.3).
	//
	// If multiple entries specify equivalent query param names, only the first
	// entry with an equivalent name MUST be considered for a match. Subsequent
	// entries with an equivalent query param name MUST be ignored.
	//
	// If a query param is repeated in an HTTP request, the behavior is
	// purposely left undefined, since different data planes have different
	// capabilities. However, it is *recommended* that implementations should
	// match against the first value of the param if the data plane supports it,
	// as this behavior is expected in other load balancing contexts outside of
	// the Gateway API.
	//
	// Users SHOULD NOT route traffic based on repeated query params to guard
	// themselves against potential differences in the implementations.
	Name *string `pulumi:"name"`
	// Type specifies how to match against the value of the query parameter.
	//
	// Support: Extended (Exact)
	//
	// Support: Implementation-specific (RegularExpression)
	//
	// Since RegularExpression QueryParamMatchType has Implementation-specific
	// conformance, implementations can support POSIX, PCRE or any other
	// dialects of regular expressions. Please read the implementation's
	// documentation to determine the supported dialect.
	Type *string `pulumi:"type"`
	// Value is the value of HTTP query param to be matched.
	Value *string `pulumi:"value"`
}

// HTTPRouteSpecRulesMatchesQueryParamsPatchInput is an input type that accepts HTTPRouteSpecRulesMatchesQueryParamsPatchArgs and HTTPRouteSpecRulesMatchesQueryParamsPatchOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesMatchesQueryParamsPatchInput` via:
//
//	HTTPRouteSpecRulesMatchesQueryParamsPatchArgs{...}
type HTTPRouteSpecRulesMatchesQueryParamsPatchInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesMatchesQueryParamsPatchOutput() HTTPRouteSpecRulesMatchesQueryParamsPatchOutput
	ToHTTPRouteSpecRulesMatchesQueryParamsPatchOutputWithContext(context.Context) HTTPRouteSpecRulesMatchesQueryParamsPatchOutput
}

// HTTPQueryParamMatch describes how to select a HTTP route by matching HTTP
// query parameters.
type HTTPRouteSpecRulesMatchesQueryParamsPatchArgs struct {
	// Name is the name of the HTTP query param to be matched. This must be an
	// exact string match. (See
	// https://tools.ietf.org/html/rfc7230#section-2.7.3).
	//
	// If multiple entries specify equivalent query param names, only the first
	// entry with an equivalent name MUST be considered for a match. Subsequent
	// entries with an equivalent query param name MUST be ignored.
	//
	// If a query param is repeated in an HTTP request, the behavior is
	// purposely left undefined, since different data planes have different
	// capabilities. However, it is *recommended* that implementations should
	// match against the first value of the param if the data plane supports it,
	// as this behavior is expected in other load balancing contexts outside of
	// the Gateway API.
	//
	// Users SHOULD NOT route traffic based on repeated query params to guard
	// themselves against potential differences in the implementations.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Type specifies how to match against the value of the query parameter.
	//
	// Support: Extended (Exact)
	//
	// Support: Implementation-specific (RegularExpression)
	//
	// Since RegularExpression QueryParamMatchType has Implementation-specific
	// conformance, implementations can support POSIX, PCRE or any other
	// dialects of regular expressions. Please read the implementation's
	// documentation to determine the supported dialect.
	Type pulumi.StringPtrInput `pulumi:"type"`
	// Value is the value of HTTP query param to be matched.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (HTTPRouteSpecRulesMatchesQueryParamsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesMatchesQueryParamsPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesMatchesQueryParamsPatchArgs) ToHTTPRouteSpecRulesMatchesQueryParamsPatchOutput() HTTPRouteSpecRulesMatchesQueryParamsPatchOutput {
	return i.ToHTTPRouteSpecRulesMatchesQueryParamsPatchOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesMatchesQueryParamsPatchArgs) ToHTTPRouteSpecRulesMatchesQueryParamsPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesQueryParamsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesMatchesQueryParamsPatchOutput)
}

// HTTPRouteSpecRulesMatchesQueryParamsPatchArrayInput is an input type that accepts HTTPRouteSpecRulesMatchesQueryParamsPatchArray and HTTPRouteSpecRulesMatchesQueryParamsPatchArrayOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesMatchesQueryParamsPatchArrayInput` via:
//
//	HTTPRouteSpecRulesMatchesQueryParamsPatchArray{ HTTPRouteSpecRulesMatchesQueryParamsPatchArgs{...} }
type HTTPRouteSpecRulesMatchesQueryParamsPatchArrayInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesMatchesQueryParamsPatchArrayOutput() HTTPRouteSpecRulesMatchesQueryParamsPatchArrayOutput
	ToHTTPRouteSpecRulesMatchesQueryParamsPatchArrayOutputWithContext(context.Context) HTTPRouteSpecRulesMatchesQueryParamsPatchArrayOutput
}

type HTTPRouteSpecRulesMatchesQueryParamsPatchArray []HTTPRouteSpecRulesMatchesQueryParamsPatchInput

func (HTTPRouteSpecRulesMatchesQueryParamsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesMatchesQueryParamsPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesMatchesQueryParamsPatchArray) ToHTTPRouteSpecRulesMatchesQueryParamsPatchArrayOutput() HTTPRouteSpecRulesMatchesQueryParamsPatchArrayOutput {
	return i.ToHTTPRouteSpecRulesMatchesQueryParamsPatchArrayOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesMatchesQueryParamsPatchArray) ToHTTPRouteSpecRulesMatchesQueryParamsPatchArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesQueryParamsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesMatchesQueryParamsPatchArrayOutput)
}

// HTTPQueryParamMatch describes how to select a HTTP route by matching HTTP
// query parameters.
type HTTPRouteSpecRulesMatchesQueryParamsPatchOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesMatchesQueryParamsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesMatchesQueryParamsPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesMatchesQueryParamsPatchOutput) ToHTTPRouteSpecRulesMatchesQueryParamsPatchOutput() HTTPRouteSpecRulesMatchesQueryParamsPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesMatchesQueryParamsPatchOutput) ToHTTPRouteSpecRulesMatchesQueryParamsPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesQueryParamsPatchOutput {
	return o
}

// Name is the name of the HTTP query param to be matched. This must be an
// exact string match. (See
// https://tools.ietf.org/html/rfc7230#section-2.7.3).
//
// If multiple entries specify equivalent query param names, only the first
// entry with an equivalent name MUST be considered for a match. Subsequent
// entries with an equivalent query param name MUST be ignored.
//
// If a query param is repeated in an HTTP request, the behavior is
// purposely left undefined, since different data planes have different
// capabilities. However, it is *recommended* that implementations should
// match against the first value of the param if the data plane supports it,
// as this behavior is expected in other load balancing contexts outside of
// the Gateway API.
//
// Users SHOULD NOT route traffic based on repeated query params to guard
// themselves against potential differences in the implementations.
func (o HTTPRouteSpecRulesMatchesQueryParamsPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesMatchesQueryParamsPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Type specifies how to match against the value of the query parameter.
//
// Support: Extended (Exact)
//
// Support: Implementation-specific (RegularExpression)
//
// Since RegularExpression QueryParamMatchType has Implementation-specific
// conformance, implementations can support POSIX, PCRE or any other
// dialects of regular expressions. Please read the implementation's
// documentation to determine the supported dialect.
func (o HTTPRouteSpecRulesMatchesQueryParamsPatchOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesMatchesQueryParamsPatch) *string { return v.Type }).(pulumi.StringPtrOutput)
}

// Value is the value of HTTP query param to be matched.
func (o HTTPRouteSpecRulesMatchesQueryParamsPatchOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesMatchesQueryParamsPatch) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type HTTPRouteSpecRulesMatchesQueryParamsPatchArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesMatchesQueryParamsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesMatchesQueryParamsPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesMatchesQueryParamsPatchArrayOutput) ToHTTPRouteSpecRulesMatchesQueryParamsPatchArrayOutput() HTTPRouteSpecRulesMatchesQueryParamsPatchArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesMatchesQueryParamsPatchArrayOutput) ToHTTPRouteSpecRulesMatchesQueryParamsPatchArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesMatchesQueryParamsPatchArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesMatchesQueryParamsPatchArrayOutput) Index(i pulumi.IntInput) HTTPRouteSpecRulesMatchesQueryParamsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteSpecRulesMatchesQueryParamsPatch {
		return vs[0].([]HTTPRouteSpecRulesMatchesQueryParamsPatch)[vs[1].(int)]
	}).(HTTPRouteSpecRulesMatchesQueryParamsPatchOutput)
}

// HTTPRouteRule defines semantics for matching an HTTP request based on
// conditions (matches), processing it (filters), and forwarding the request to
// an API object (backendRefs).
type HTTPRouteSpecRulesPatch struct {
	// BackendRefs defines the backend(s) where matching requests should be
	// sent.
	//
	// Failure behavior here depends on how many BackendRefs are specified and
	// how many are invalid.
	//
	// If *all* entries in BackendRefs are invalid, and there are also no filters
	// specified in this route rule, *all* traffic which matches this rule MUST
	// receive a 500 status code.
	//
	// See the HTTPBackendRef definition for the rules about what makes a single
	// HTTPBackendRef invalid.
	//
	// When a HTTPBackendRef is invalid, 500 status codes MUST be returned for
	// requests that would have otherwise been routed to an invalid backend. If
	// multiple backends are specified, and some are invalid, the proportion of
	// requests that would otherwise have been routed to an invalid backend
	// MUST receive a 500 status code.
	//
	// For example, if two backends are specified with equal weights, and one is
	// invalid, 50 percent of traffic must receive a 500. Implementations may
	// choose how that 50 percent is determined.
	//
	// Support: Core for Kubernetes Service
	//
	// Support: Extended for Kubernetes ServiceImport
	//
	// Support: Implementation-specific for any other resource
	//
	// Support for weight: Core
	BackendRefs []HTTPRouteSpecRulesBackendRefsPatch `pulumi:"backendRefs"`
	// Filters define the filters that are applied to requests that match
	// this rule.
	//
	// Wherever possible, implementations SHOULD implement filters in the order
	// they are specified.
	//
	// Implementations MAY choose to implement this ordering strictly, rejecting
	// any combination or order of filters that can not be supported. If implementations
	// choose a strict interpretation of filter ordering, they MUST clearly document
	// that behavior.
	//
	// To reject an invalid combination or order of filters, implementations SHOULD
	// consider the Route Rules with this configuration invalid. If all Route Rules
	// in a Route are invalid, the entire Route would be considered invalid. If only
	// a portion of Route Rules are invalid, implementations MUST set the
	// "PartiallyInvalid" condition for the Route.
	//
	// Conformance-levels at this level are defined based on the type of filter:
	//
	// - ALL core filters MUST be supported by all implementations.
	// - Implementers are encouraged to support extended filters.
	// - Implementation-specific custom filters have no API guarantees across
	//   implementations.
	//
	// Specifying the same filter multiple times is not supported unless explicitly
	// indicated in the filter.
	//
	// All filters are expected to be compatible with each other except for the
	// URLRewrite and RequestRedirect filters, which may not be combined. If an
	// implementation can not support other combinations of filters, they must clearly
	// document that limitation. In cases where incompatible or unsupported
	// filters are specified and cause the `Accepted` condition to be set to status
	// `False`, implementations may use the `IncompatibleFilters` reason to specify
	// this configuration error.
	//
	// Support: Core
	Filters []HTTPRouteSpecRulesFiltersPatch `pulumi:"filters"`
	// Matches define conditions used for matching the rule against incoming
	// HTTP requests. Each match is independent, i.e. this rule will be matched
	// if **any** one of the matches is satisfied.
	//
	// For example, take the following matches configuration:
	//
	// For a request to match against this rule, a request must satisfy
	// EITHER of the two conditions:
	//
	// - path prefixed with `/foo` AND contains the header `version: v2`
	// - path prefix of `/v2/foo`
	//
	// See the documentation for HTTPRouteMatch on how to specify multiple
	// match conditions that should be ANDed together.
	//
	// If no matches are specified, the default is a prefix
	// path match on "/", which has the effect of matching every
	// HTTP request.
	//
	// Proxy or Load Balancer routing configuration generated from HTTPRoutes
	// MUST prioritize matches based on the following criteria, continuing on
	// ties. Across all rules specified on applicable Routes, precedence must be
	// given to the match having:
	//
	// * "Exact" path match.
	// * "Prefix" path match with largest number of characters.
	// * Method match.
	// * Largest number of header matches.
	// * Largest number of query param matches.
	//
	// Note: The precedence of RegularExpression path matches are implementation-specific.
	//
	// If ties still exist across multiple Routes, matching precedence MUST be
	// determined in order of the following criteria, continuing on ties:
	//
	// * The oldest Route based on creation timestamp.
	// * The Route appearing first in alphabetical order by
	//   "{namespace}/{name}".
	//
	// If ties still exist within an HTTPRoute, matching precedence MUST be granted
	// to the FIRST matching rule (in list order) with a match meeting the above
	// criteria.
	//
	// When no rules matching a request have been successfully attached to the
	// parent a request is coming from, a HTTP 404 status code MUST be returned.
	Matches []HTTPRouteSpecRulesMatchesPatch `pulumi:"matches"`
}

// HTTPRouteSpecRulesPatchInput is an input type that accepts HTTPRouteSpecRulesPatchArgs and HTTPRouteSpecRulesPatchOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesPatchInput` via:
//
//	HTTPRouteSpecRulesPatchArgs{...}
type HTTPRouteSpecRulesPatchInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesPatchOutput() HTTPRouteSpecRulesPatchOutput
	ToHTTPRouteSpecRulesPatchOutputWithContext(context.Context) HTTPRouteSpecRulesPatchOutput
}

// HTTPRouteRule defines semantics for matching an HTTP request based on
// conditions (matches), processing it (filters), and forwarding the request to
// an API object (backendRefs).
type HTTPRouteSpecRulesPatchArgs struct {
	// BackendRefs defines the backend(s) where matching requests should be
	// sent.
	//
	// Failure behavior here depends on how many BackendRefs are specified and
	// how many are invalid.
	//
	// If *all* entries in BackendRefs are invalid, and there are also no filters
	// specified in this route rule, *all* traffic which matches this rule MUST
	// receive a 500 status code.
	//
	// See the HTTPBackendRef definition for the rules about what makes a single
	// HTTPBackendRef invalid.
	//
	// When a HTTPBackendRef is invalid, 500 status codes MUST be returned for
	// requests that would have otherwise been routed to an invalid backend. If
	// multiple backends are specified, and some are invalid, the proportion of
	// requests that would otherwise have been routed to an invalid backend
	// MUST receive a 500 status code.
	//
	// For example, if two backends are specified with equal weights, and one is
	// invalid, 50 percent of traffic must receive a 500. Implementations may
	// choose how that 50 percent is determined.
	//
	// Support: Core for Kubernetes Service
	//
	// Support: Extended for Kubernetes ServiceImport
	//
	// Support: Implementation-specific for any other resource
	//
	// Support for weight: Core
	BackendRefs HTTPRouteSpecRulesBackendRefsPatchArrayInput `pulumi:"backendRefs"`
	// Filters define the filters that are applied to requests that match
	// this rule.
	//
	// Wherever possible, implementations SHOULD implement filters in the order
	// they are specified.
	//
	// Implementations MAY choose to implement this ordering strictly, rejecting
	// any combination or order of filters that can not be supported. If implementations
	// choose a strict interpretation of filter ordering, they MUST clearly document
	// that behavior.
	//
	// To reject an invalid combination or order of filters, implementations SHOULD
	// consider the Route Rules with this configuration invalid. If all Route Rules
	// in a Route are invalid, the entire Route would be considered invalid. If only
	// a portion of Route Rules are invalid, implementations MUST set the
	// "PartiallyInvalid" condition for the Route.
	//
	// Conformance-levels at this level are defined based on the type of filter:
	//
	// - ALL core filters MUST be supported by all implementations.
	// - Implementers are encouraged to support extended filters.
	// - Implementation-specific custom filters have no API guarantees across
	//   implementations.
	//
	// Specifying the same filter multiple times is not supported unless explicitly
	// indicated in the filter.
	//
	// All filters are expected to be compatible with each other except for the
	// URLRewrite and RequestRedirect filters, which may not be combined. If an
	// implementation can not support other combinations of filters, they must clearly
	// document that limitation. In cases where incompatible or unsupported
	// filters are specified and cause the `Accepted` condition to be set to status
	// `False`, implementations may use the `IncompatibleFilters` reason to specify
	// this configuration error.
	//
	// Support: Core
	Filters HTTPRouteSpecRulesFiltersPatchArrayInput `pulumi:"filters"`
	// Matches define conditions used for matching the rule against incoming
	// HTTP requests. Each match is independent, i.e. this rule will be matched
	// if **any** one of the matches is satisfied.
	//
	// For example, take the following matches configuration:
	//
	// For a request to match against this rule, a request must satisfy
	// EITHER of the two conditions:
	//
	// - path prefixed with `/foo` AND contains the header `version: v2`
	// - path prefix of `/v2/foo`
	//
	// See the documentation for HTTPRouteMatch on how to specify multiple
	// match conditions that should be ANDed together.
	//
	// If no matches are specified, the default is a prefix
	// path match on "/", which has the effect of matching every
	// HTTP request.
	//
	// Proxy or Load Balancer routing configuration generated from HTTPRoutes
	// MUST prioritize matches based on the following criteria, continuing on
	// ties. Across all rules specified on applicable Routes, precedence must be
	// given to the match having:
	//
	// * "Exact" path match.
	// * "Prefix" path match with largest number of characters.
	// * Method match.
	// * Largest number of header matches.
	// * Largest number of query param matches.
	//
	// Note: The precedence of RegularExpression path matches are implementation-specific.
	//
	// If ties still exist across multiple Routes, matching precedence MUST be
	// determined in order of the following criteria, continuing on ties:
	//
	// * The oldest Route based on creation timestamp.
	// * The Route appearing first in alphabetical order by
	//   "{namespace}/{name}".
	//
	// If ties still exist within an HTTPRoute, matching precedence MUST be granted
	// to the FIRST matching rule (in list order) with a match meeting the above
	// criteria.
	//
	// When no rules matching a request have been successfully attached to the
	// parent a request is coming from, a HTTP 404 status code MUST be returned.
	Matches HTTPRouteSpecRulesMatchesPatchArrayInput `pulumi:"matches"`
}

func (HTTPRouteSpecRulesPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesPatchArgs) ToHTTPRouteSpecRulesPatchOutput() HTTPRouteSpecRulesPatchOutput {
	return i.ToHTTPRouteSpecRulesPatchOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesPatchArgs) ToHTTPRouteSpecRulesPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesPatchOutput)
}

// HTTPRouteSpecRulesPatchArrayInput is an input type that accepts HTTPRouteSpecRulesPatchArray and HTTPRouteSpecRulesPatchArrayOutput values.
// You can construct a concrete instance of `HTTPRouteSpecRulesPatchArrayInput` via:
//
//	HTTPRouteSpecRulesPatchArray{ HTTPRouteSpecRulesPatchArgs{...} }
type HTTPRouteSpecRulesPatchArrayInput interface {
	pulumi.Input

	ToHTTPRouteSpecRulesPatchArrayOutput() HTTPRouteSpecRulesPatchArrayOutput
	ToHTTPRouteSpecRulesPatchArrayOutputWithContext(context.Context) HTTPRouteSpecRulesPatchArrayOutput
}

type HTTPRouteSpecRulesPatchArray []HTTPRouteSpecRulesPatchInput

func (HTTPRouteSpecRulesPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesPatch)(nil)).Elem()
}

func (i HTTPRouteSpecRulesPatchArray) ToHTTPRouteSpecRulesPatchArrayOutput() HTTPRouteSpecRulesPatchArrayOutput {
	return i.ToHTTPRouteSpecRulesPatchArrayOutputWithContext(context.Background())
}

func (i HTTPRouteSpecRulesPatchArray) ToHTTPRouteSpecRulesPatchArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteSpecRulesPatchArrayOutput)
}

// HTTPRouteRule defines semantics for matching an HTTP request based on
// conditions (matches), processing it (filters), and forwarding the request to
// an API object (backendRefs).
type HTTPRouteSpecRulesPatchOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteSpecRulesPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesPatchOutput) ToHTTPRouteSpecRulesPatchOutput() HTTPRouteSpecRulesPatchOutput {
	return o
}

func (o HTTPRouteSpecRulesPatchOutput) ToHTTPRouteSpecRulesPatchOutputWithContext(ctx context.Context) HTTPRouteSpecRulesPatchOutput {
	return o
}

// BackendRefs defines the backend(s) where matching requests should be
// sent.
//
// Failure behavior here depends on how many BackendRefs are specified and
// how many are invalid.
//
// If *all* entries in BackendRefs are invalid, and there are also no filters
// specified in this route rule, *all* traffic which matches this rule MUST
// receive a 500 status code.
//
// See the HTTPBackendRef definition for the rules about what makes a single
// HTTPBackendRef invalid.
//
// When a HTTPBackendRef is invalid, 500 status codes MUST be returned for
// requests that would have otherwise been routed to an invalid backend. If
// multiple backends are specified, and some are invalid, the proportion of
// requests that would otherwise have been routed to an invalid backend
// MUST receive a 500 status code.
//
// For example, if two backends are specified with equal weights, and one is
// invalid, 50 percent of traffic must receive a 500. Implementations may
// choose how that 50 percent is determined.
//
// Support: Core for Kubernetes Service
//
// Support: Extended for Kubernetes ServiceImport
//
// Support: Implementation-specific for any other resource
//
// Support for weight: Core
func (o HTTPRouteSpecRulesPatchOutput) BackendRefs() HTTPRouteSpecRulesBackendRefsPatchArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesPatch) []HTTPRouteSpecRulesBackendRefsPatch { return v.BackendRefs }).(HTTPRouteSpecRulesBackendRefsPatchArrayOutput)
}

// Filters define the filters that are applied to requests that match
// this rule.
//
// Wherever possible, implementations SHOULD implement filters in the order
// they are specified.
//
// Implementations MAY choose to implement this ordering strictly, rejecting
// any combination or order of filters that can not be supported. If implementations
// choose a strict interpretation of filter ordering, they MUST clearly document
// that behavior.
//
// To reject an invalid combination or order of filters, implementations SHOULD
// consider the Route Rules with this configuration invalid. If all Route Rules
// in a Route are invalid, the entire Route would be considered invalid. If only
// a portion of Route Rules are invalid, implementations MUST set the
// "PartiallyInvalid" condition for the Route.
//
// Conformance-levels at this level are defined based on the type of filter:
//
//   - ALL core filters MUST be supported by all implementations.
//   - Implementers are encouraged to support extended filters.
//   - Implementation-specific custom filters have no API guarantees across
//     implementations.
//
// Specifying the same filter multiple times is not supported unless explicitly
// indicated in the filter.
//
// All filters are expected to be compatible with each other except for the
// URLRewrite and RequestRedirect filters, which may not be combined. If an
// implementation can not support other combinations of filters, they must clearly
// document that limitation. In cases where incompatible or unsupported
// filters are specified and cause the `Accepted` condition to be set to status
// `False`, implementations may use the `IncompatibleFilters` reason to specify
// this configuration error.
//
// Support: Core
func (o HTTPRouteSpecRulesPatchOutput) Filters() HTTPRouteSpecRulesFiltersPatchArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesPatch) []HTTPRouteSpecRulesFiltersPatch { return v.Filters }).(HTTPRouteSpecRulesFiltersPatchArrayOutput)
}

// Matches define conditions used for matching the rule against incoming
// HTTP requests. Each match is independent, i.e. this rule will be matched
// if **any** one of the matches is satisfied.
//
// For example, take the following matches configuration:
//
// For a request to match against this rule, a request must satisfy
// EITHER of the two conditions:
//
// - path prefixed with `/foo` AND contains the header `version: v2`
// - path prefix of `/v2/foo`
//
// See the documentation for HTTPRouteMatch on how to specify multiple
// match conditions that should be ANDed together.
//
// If no matches are specified, the default is a prefix
// path match on "/", which has the effect of matching every
// HTTP request.
//
// Proxy or Load Balancer routing configuration generated from HTTPRoutes
// MUST prioritize matches based on the following criteria, continuing on
// ties. Across all rules specified on applicable Routes, precedence must be
// given to the match having:
//
// * "Exact" path match.
// * "Prefix" path match with largest number of characters.
// * Method match.
// * Largest number of header matches.
// * Largest number of query param matches.
//
// Note: The precedence of RegularExpression path matches are implementation-specific.
//
// If ties still exist across multiple Routes, matching precedence MUST be
// determined in order of the following criteria, continuing on ties:
//
//   - The oldest Route based on creation timestamp.
//   - The Route appearing first in alphabetical order by
//     "{namespace}/{name}".
//
// If ties still exist within an HTTPRoute, matching precedence MUST be granted
// to the FIRST matching rule (in list order) with a match meeting the above
// criteria.
//
// When no rules matching a request have been successfully attached to the
// parent a request is coming from, a HTTP 404 status code MUST be returned.
func (o HTTPRouteSpecRulesPatchOutput) Matches() HTTPRouteSpecRulesMatchesPatchArrayOutput {
	return o.ApplyT(func(v HTTPRouteSpecRulesPatch) []HTTPRouteSpecRulesMatchesPatch { return v.Matches }).(HTTPRouteSpecRulesMatchesPatchArrayOutput)
}

type HTTPRouteSpecRulesPatchArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteSpecRulesPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteSpecRulesPatch)(nil)).Elem()
}

func (o HTTPRouteSpecRulesPatchArrayOutput) ToHTTPRouteSpecRulesPatchArrayOutput() HTTPRouteSpecRulesPatchArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesPatchArrayOutput) ToHTTPRouteSpecRulesPatchArrayOutputWithContext(ctx context.Context) HTTPRouteSpecRulesPatchArrayOutput {
	return o
}

func (o HTTPRouteSpecRulesPatchArrayOutput) Index(i pulumi.IntInput) HTTPRouteSpecRulesPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteSpecRulesPatch {
		return vs[0].([]HTTPRouteSpecRulesPatch)[vs[1].(int)]
	}).(HTTPRouteSpecRulesPatchOutput)
}

// Status defines the current state of HTTPRoute.
type HTTPRouteStatus struct {
	// Parents is a list of parent resources (usually Gateways) that are
	// associated with the route, and the status of the route with respect to
	// each parent. When this route attaches to a parent, the controller that
	// manages the parent must add an entry to this list when the controller
	// first sees the route and should update the entry as appropriate when the
	// route or gateway is modified.
	//
	// Note that parent references that cannot be resolved by an implementation
	// of this API will not be added to this list. Implementations of this API
	// can only populate Route status for the Gateways/parent resources they are
	// responsible for.
	//
	// A maximum of 32 Gateways will be represented in this list. An empty list
	// means the route has not been attached to any Gateway.
	Parents []HTTPRouteStatusParents `pulumi:"parents"`
}

// HTTPRouteStatusInput is an input type that accepts HTTPRouteStatusArgs and HTTPRouteStatusOutput values.
// You can construct a concrete instance of `HTTPRouteStatusInput` via:
//
//	HTTPRouteStatusArgs{...}
type HTTPRouteStatusInput interface {
	pulumi.Input

	ToHTTPRouteStatusOutput() HTTPRouteStatusOutput
	ToHTTPRouteStatusOutputWithContext(context.Context) HTTPRouteStatusOutput
}

// Status defines the current state of HTTPRoute.
type HTTPRouteStatusArgs struct {
	// Parents is a list of parent resources (usually Gateways) that are
	// associated with the route, and the status of the route with respect to
	// each parent. When this route attaches to a parent, the controller that
	// manages the parent must add an entry to this list when the controller
	// first sees the route and should update the entry as appropriate when the
	// route or gateway is modified.
	//
	// Note that parent references that cannot be resolved by an implementation
	// of this API will not be added to this list. Implementations of this API
	// can only populate Route status for the Gateways/parent resources they are
	// responsible for.
	//
	// A maximum of 32 Gateways will be represented in this list. An empty list
	// means the route has not been attached to any Gateway.
	Parents HTTPRouteStatusParentsArrayInput `pulumi:"parents"`
}

func (HTTPRouteStatusArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteStatus)(nil)).Elem()
}

func (i HTTPRouteStatusArgs) ToHTTPRouteStatusOutput() HTTPRouteStatusOutput {
	return i.ToHTTPRouteStatusOutputWithContext(context.Background())
}

func (i HTTPRouteStatusArgs) ToHTTPRouteStatusOutputWithContext(ctx context.Context) HTTPRouteStatusOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteStatusOutput)
}

func (i HTTPRouteStatusArgs) ToHTTPRouteStatusPtrOutput() HTTPRouteStatusPtrOutput {
	return i.ToHTTPRouteStatusPtrOutputWithContext(context.Background())
}

func (i HTTPRouteStatusArgs) ToHTTPRouteStatusPtrOutputWithContext(ctx context.Context) HTTPRouteStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteStatusOutput).ToHTTPRouteStatusPtrOutputWithContext(ctx)
}

// HTTPRouteStatusPtrInput is an input type that accepts HTTPRouteStatusArgs, HTTPRouteStatusPtr and HTTPRouteStatusPtrOutput values.
// You can construct a concrete instance of `HTTPRouteStatusPtrInput` via:
//
//	        HTTPRouteStatusArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteStatusPtrInput interface {
	pulumi.Input

	ToHTTPRouteStatusPtrOutput() HTTPRouteStatusPtrOutput
	ToHTTPRouteStatusPtrOutputWithContext(context.Context) HTTPRouteStatusPtrOutput
}

type httprouteStatusPtrType HTTPRouteStatusArgs

func HTTPRouteStatusPtr(v *HTTPRouteStatusArgs) HTTPRouteStatusPtrInput {
	return (*httprouteStatusPtrType)(v)
}

func (*httprouteStatusPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteStatus)(nil)).Elem()
}

func (i *httprouteStatusPtrType) ToHTTPRouteStatusPtrOutput() HTTPRouteStatusPtrOutput {
	return i.ToHTTPRouteStatusPtrOutputWithContext(context.Background())
}

func (i *httprouteStatusPtrType) ToHTTPRouteStatusPtrOutputWithContext(ctx context.Context) HTTPRouteStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteStatusPtrOutput)
}

// Status defines the current state of HTTPRoute.
type HTTPRouteStatusOutput struct{ *pulumi.OutputState }

func (HTTPRouteStatusOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteStatus)(nil)).Elem()
}

func (o HTTPRouteStatusOutput) ToHTTPRouteStatusOutput() HTTPRouteStatusOutput {
	return o
}

func (o HTTPRouteStatusOutput) ToHTTPRouteStatusOutputWithContext(ctx context.Context) HTTPRouteStatusOutput {
	return o
}

func (o HTTPRouteStatusOutput) ToHTTPRouteStatusPtrOutput() HTTPRouteStatusPtrOutput {
	return o.ToHTTPRouteStatusPtrOutputWithContext(context.Background())
}

func (o HTTPRouteStatusOutput) ToHTTPRouteStatusPtrOutputWithContext(ctx context.Context) HTTPRouteStatusPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteStatus) *HTTPRouteStatus {
		return &v
	}).(HTTPRouteStatusPtrOutput)
}

// Parents is a list of parent resources (usually Gateways) that are
// associated with the route, and the status of the route with respect to
// each parent. When this route attaches to a parent, the controller that
// manages the parent must add an entry to this list when the controller
// first sees the route and should update the entry as appropriate when the
// route or gateway is modified.
//
// Note that parent references that cannot be resolved by an implementation
// of this API will not be added to this list. Implementations of this API
// can only populate Route status for the Gateways/parent resources they are
// responsible for.
//
// A maximum of 32 Gateways will be represented in this list. An empty list
// means the route has not been attached to any Gateway.
func (o HTTPRouteStatusOutput) Parents() HTTPRouteStatusParentsArrayOutput {
	return o.ApplyT(func(v HTTPRouteStatus) []HTTPRouteStatusParents { return v.Parents }).(HTTPRouteStatusParentsArrayOutput)
}

type HTTPRouteStatusPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteStatusPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteStatus)(nil)).Elem()
}

func (o HTTPRouteStatusPtrOutput) ToHTTPRouteStatusPtrOutput() HTTPRouteStatusPtrOutput {
	return o
}

func (o HTTPRouteStatusPtrOutput) ToHTTPRouteStatusPtrOutputWithContext(ctx context.Context) HTTPRouteStatusPtrOutput {
	return o
}

func (o HTTPRouteStatusPtrOutput) Elem() HTTPRouteStatusOutput {
	return o.ApplyT(func(v *HTTPRouteStatus) HTTPRouteStatus {
		if v != nil {
			return *v
		}
		var ret HTTPRouteStatus
		return ret
	}).(HTTPRouteStatusOutput)
}

// Parents is a list of parent resources (usually Gateways) that are
// associated with the route, and the status of the route with respect to
// each parent. When this route attaches to a parent, the controller that
// manages the parent must add an entry to this list when the controller
// first sees the route and should update the entry as appropriate when the
// route or gateway is modified.
//
// Note that parent references that cannot be resolved by an implementation
// of this API will not be added to this list. Implementations of this API
// can only populate Route status for the Gateways/parent resources they are
// responsible for.
//
// A maximum of 32 Gateways will be represented in this list. An empty list
// means the route has not been attached to any Gateway.
func (o HTTPRouteStatusPtrOutput) Parents() HTTPRouteStatusParentsArrayOutput {
	return o.ApplyT(func(v *HTTPRouteStatus) []HTTPRouteStatusParents {
		if v == nil {
			return nil
		}
		return v.Parents
	}).(HTTPRouteStatusParentsArrayOutput)
}

// RouteParentStatus describes the status of a route with respect to an
// associated Parent.
type HTTPRouteStatusParents struct {
	// Conditions describes the status of the route with respect to the Gateway.
	// Note that the route's availability is also subject to the Gateway's own
	// status conditions and listener status.
	//
	// If the Route's ParentRef specifies an existing Gateway that supports
	// Routes of this kind AND that Gateway's controller has sufficient access,
	// then that Gateway's controller MUST set the "Accepted" condition on the
	// Route, to indicate whether the route has been accepted or rejected by the
	// Gateway, and why.
	//
	// A Route MUST be considered "Accepted" if at least one of the Route's
	// rules is implemented by the Gateway.
	//
	// There are a number of cases where the "Accepted" condition may not be set
	// due to lack of controller visibility, that includes when:
	//
	// * The Route refers to a non-existent parent.
	// * The Route is of a type that the controller does not support.
	// * The Route is in a namespace the controller does not have access to.
	Conditions []HTTPRouteStatusParentsConditions `pulumi:"conditions"`
	// ControllerName is a domain/path string that indicates the name of the
	// controller that wrote this status. This corresponds with the
	// controllerName field on GatewayClass.
	//
	// Example: "example.net/gateway-controller".
	//
	// The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
	// valid Kubernetes names
	// (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
	//
	// Controllers MUST populate this field when writing status. Controllers should ensure that
	// entries to status populated with their ControllerName are cleaned up when they are no
	// longer necessary.
	ControllerName *string                          `pulumi:"controllerName"`
	ParentRef      *HTTPRouteStatusParentsParentRef `pulumi:"parentRef"`
}

// HTTPRouteStatusParentsInput is an input type that accepts HTTPRouteStatusParentsArgs and HTTPRouteStatusParentsOutput values.
// You can construct a concrete instance of `HTTPRouteStatusParentsInput` via:
//
//	HTTPRouteStatusParentsArgs{...}
type HTTPRouteStatusParentsInput interface {
	pulumi.Input

	ToHTTPRouteStatusParentsOutput() HTTPRouteStatusParentsOutput
	ToHTTPRouteStatusParentsOutputWithContext(context.Context) HTTPRouteStatusParentsOutput
}

// RouteParentStatus describes the status of a route with respect to an
// associated Parent.
type HTTPRouteStatusParentsArgs struct {
	// Conditions describes the status of the route with respect to the Gateway.
	// Note that the route's availability is also subject to the Gateway's own
	// status conditions and listener status.
	//
	// If the Route's ParentRef specifies an existing Gateway that supports
	// Routes of this kind AND that Gateway's controller has sufficient access,
	// then that Gateway's controller MUST set the "Accepted" condition on the
	// Route, to indicate whether the route has been accepted or rejected by the
	// Gateway, and why.
	//
	// A Route MUST be considered "Accepted" if at least one of the Route's
	// rules is implemented by the Gateway.
	//
	// There are a number of cases where the "Accepted" condition may not be set
	// due to lack of controller visibility, that includes when:
	//
	// * The Route refers to a non-existent parent.
	// * The Route is of a type that the controller does not support.
	// * The Route is in a namespace the controller does not have access to.
	Conditions HTTPRouteStatusParentsConditionsArrayInput `pulumi:"conditions"`
	// ControllerName is a domain/path string that indicates the name of the
	// controller that wrote this status. This corresponds with the
	// controllerName field on GatewayClass.
	//
	// Example: "example.net/gateway-controller".
	//
	// The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
	// valid Kubernetes names
	// (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
	//
	// Controllers MUST populate this field when writing status. Controllers should ensure that
	// entries to status populated with their ControllerName are cleaned up when they are no
	// longer necessary.
	ControllerName pulumi.StringPtrInput                   `pulumi:"controllerName"`
	ParentRef      HTTPRouteStatusParentsParentRefPtrInput `pulumi:"parentRef"`
}

func (HTTPRouteStatusParentsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteStatusParents)(nil)).Elem()
}

func (i HTTPRouteStatusParentsArgs) ToHTTPRouteStatusParentsOutput() HTTPRouteStatusParentsOutput {
	return i.ToHTTPRouteStatusParentsOutputWithContext(context.Background())
}

func (i HTTPRouteStatusParentsArgs) ToHTTPRouteStatusParentsOutputWithContext(ctx context.Context) HTTPRouteStatusParentsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteStatusParentsOutput)
}

// HTTPRouteStatusParentsArrayInput is an input type that accepts HTTPRouteStatusParentsArray and HTTPRouteStatusParentsArrayOutput values.
// You can construct a concrete instance of `HTTPRouteStatusParentsArrayInput` via:
//
//	HTTPRouteStatusParentsArray{ HTTPRouteStatusParentsArgs{...} }
type HTTPRouteStatusParentsArrayInput interface {
	pulumi.Input

	ToHTTPRouteStatusParentsArrayOutput() HTTPRouteStatusParentsArrayOutput
	ToHTTPRouteStatusParentsArrayOutputWithContext(context.Context) HTTPRouteStatusParentsArrayOutput
}

type HTTPRouteStatusParentsArray []HTTPRouteStatusParentsInput

func (HTTPRouteStatusParentsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteStatusParents)(nil)).Elem()
}

func (i HTTPRouteStatusParentsArray) ToHTTPRouteStatusParentsArrayOutput() HTTPRouteStatusParentsArrayOutput {
	return i.ToHTTPRouteStatusParentsArrayOutputWithContext(context.Background())
}

func (i HTTPRouteStatusParentsArray) ToHTTPRouteStatusParentsArrayOutputWithContext(ctx context.Context) HTTPRouteStatusParentsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteStatusParentsArrayOutput)
}

// RouteParentStatus describes the status of a route with respect to an
// associated Parent.
type HTTPRouteStatusParentsOutput struct{ *pulumi.OutputState }

func (HTTPRouteStatusParentsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteStatusParents)(nil)).Elem()
}

func (o HTTPRouteStatusParentsOutput) ToHTTPRouteStatusParentsOutput() HTTPRouteStatusParentsOutput {
	return o
}

func (o HTTPRouteStatusParentsOutput) ToHTTPRouteStatusParentsOutputWithContext(ctx context.Context) HTTPRouteStatusParentsOutput {
	return o
}

// Conditions describes the status of the route with respect to the Gateway.
// Note that the route's availability is also subject to the Gateway's own
// status conditions and listener status.
//
// If the Route's ParentRef specifies an existing Gateway that supports
// Routes of this kind AND that Gateway's controller has sufficient access,
// then that Gateway's controller MUST set the "Accepted" condition on the
// Route, to indicate whether the route has been accepted or rejected by the
// Gateway, and why.
//
// A Route MUST be considered "Accepted" if at least one of the Route's
// rules is implemented by the Gateway.
//
// There are a number of cases where the "Accepted" condition may not be set
// due to lack of controller visibility, that includes when:
//
// * The Route refers to a non-existent parent.
// * The Route is of a type that the controller does not support.
// * The Route is in a namespace the controller does not have access to.
func (o HTTPRouteStatusParentsOutput) Conditions() HTTPRouteStatusParentsConditionsArrayOutput {
	return o.ApplyT(func(v HTTPRouteStatusParents) []HTTPRouteStatusParentsConditions { return v.Conditions }).(HTTPRouteStatusParentsConditionsArrayOutput)
}

// ControllerName is a domain/path string that indicates the name of the
// controller that wrote this status. This corresponds with the
// controllerName field on GatewayClass.
//
// Example: "example.net/gateway-controller".
//
// The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
// valid Kubernetes names
// (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
//
// Controllers MUST populate this field when writing status. Controllers should ensure that
// entries to status populated with their ControllerName are cleaned up when they are no
// longer necessary.
func (o HTTPRouteStatusParentsOutput) ControllerName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteStatusParents) *string { return v.ControllerName }).(pulumi.StringPtrOutput)
}

func (o HTTPRouteStatusParentsOutput) ParentRef() HTTPRouteStatusParentsParentRefPtrOutput {
	return o.ApplyT(func(v HTTPRouteStatusParents) *HTTPRouteStatusParentsParentRef { return v.ParentRef }).(HTTPRouteStatusParentsParentRefPtrOutput)
}

type HTTPRouteStatusParentsArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteStatusParentsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteStatusParents)(nil)).Elem()
}

func (o HTTPRouteStatusParentsArrayOutput) ToHTTPRouteStatusParentsArrayOutput() HTTPRouteStatusParentsArrayOutput {
	return o
}

func (o HTTPRouteStatusParentsArrayOutput) ToHTTPRouteStatusParentsArrayOutputWithContext(ctx context.Context) HTTPRouteStatusParentsArrayOutput {
	return o
}

func (o HTTPRouteStatusParentsArrayOutput) Index(i pulumi.IntInput) HTTPRouteStatusParentsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteStatusParents {
		return vs[0].([]HTTPRouteStatusParents)[vs[1].(int)]
	}).(HTTPRouteStatusParentsOutput)
}

// Condition contains details for one aspect of the current state of this API Resource.
// ---
// This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{
//	    // Represents the observations of a foo's current state.
//	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
//	    // +patchMergeKey=type
//	    // +patchStrategy=merge
//	    // +listType=map
//	    // +listMapKey=type
//	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//
//
//	    // other fields
//	}
type HTTPRouteStatusParentsConditions struct {
	// lastTransitionTime is the last time the condition transitioned from one status to another.
	// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	LastTransitionTime *string `pulumi:"lastTransitionTime"`
	// message is a human readable message indicating details about the transition.
	// This may be an empty string.
	Message *string `pulumi:"message"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon.
	// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
	// with respect to the current state of the instance.
	ObservedGeneration *int `pulumi:"observedGeneration"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition.
	// Producers of specific condition types may define expected values and meanings for this field,
	// and whether the values are considered a guaranteed API.
	// The value should be a CamelCase string.
	// This field may not be empty.
	Reason *string `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status *string `pulumi:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase.
	// ---
	// Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
	// useful (see .node.status.conditions), the ability to deconflict is important.
	// The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
	Type *string `pulumi:"type"`
}

// HTTPRouteStatusParentsConditionsInput is an input type that accepts HTTPRouteStatusParentsConditionsArgs and HTTPRouteStatusParentsConditionsOutput values.
// You can construct a concrete instance of `HTTPRouteStatusParentsConditionsInput` via:
//
//	HTTPRouteStatusParentsConditionsArgs{...}
type HTTPRouteStatusParentsConditionsInput interface {
	pulumi.Input

	ToHTTPRouteStatusParentsConditionsOutput() HTTPRouteStatusParentsConditionsOutput
	ToHTTPRouteStatusParentsConditionsOutputWithContext(context.Context) HTTPRouteStatusParentsConditionsOutput
}

// Condition contains details for one aspect of the current state of this API Resource.
// ---
// This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{
//	    // Represents the observations of a foo's current state.
//	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
//	    // +patchMergeKey=type
//	    // +patchStrategy=merge
//	    // +listType=map
//	    // +listMapKey=type
//	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//
//
//	    // other fields
//	}
type HTTPRouteStatusParentsConditionsArgs struct {
	// lastTransitionTime is the last time the condition transitioned from one status to another.
	// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	LastTransitionTime pulumi.StringPtrInput `pulumi:"lastTransitionTime"`
	// message is a human readable message indicating details about the transition.
	// This may be an empty string.
	Message pulumi.StringPtrInput `pulumi:"message"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon.
	// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
	// with respect to the current state of the instance.
	ObservedGeneration pulumi.IntPtrInput `pulumi:"observedGeneration"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition.
	// Producers of specific condition types may define expected values and meanings for this field,
	// and whether the values are considered a guaranteed API.
	// The value should be a CamelCase string.
	// This field may not be empty.
	Reason pulumi.StringPtrInput `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status pulumi.StringPtrInput `pulumi:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase.
	// ---
	// Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
	// useful (see .node.status.conditions), the ability to deconflict is important.
	// The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (HTTPRouteStatusParentsConditionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteStatusParentsConditions)(nil)).Elem()
}

func (i HTTPRouteStatusParentsConditionsArgs) ToHTTPRouteStatusParentsConditionsOutput() HTTPRouteStatusParentsConditionsOutput {
	return i.ToHTTPRouteStatusParentsConditionsOutputWithContext(context.Background())
}

func (i HTTPRouteStatusParentsConditionsArgs) ToHTTPRouteStatusParentsConditionsOutputWithContext(ctx context.Context) HTTPRouteStatusParentsConditionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteStatusParentsConditionsOutput)
}

// HTTPRouteStatusParentsConditionsArrayInput is an input type that accepts HTTPRouteStatusParentsConditionsArray and HTTPRouteStatusParentsConditionsArrayOutput values.
// You can construct a concrete instance of `HTTPRouteStatusParentsConditionsArrayInput` via:
//
//	HTTPRouteStatusParentsConditionsArray{ HTTPRouteStatusParentsConditionsArgs{...} }
type HTTPRouteStatusParentsConditionsArrayInput interface {
	pulumi.Input

	ToHTTPRouteStatusParentsConditionsArrayOutput() HTTPRouteStatusParentsConditionsArrayOutput
	ToHTTPRouteStatusParentsConditionsArrayOutputWithContext(context.Context) HTTPRouteStatusParentsConditionsArrayOutput
}

type HTTPRouteStatusParentsConditionsArray []HTTPRouteStatusParentsConditionsInput

func (HTTPRouteStatusParentsConditionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteStatusParentsConditions)(nil)).Elem()
}

func (i HTTPRouteStatusParentsConditionsArray) ToHTTPRouteStatusParentsConditionsArrayOutput() HTTPRouteStatusParentsConditionsArrayOutput {
	return i.ToHTTPRouteStatusParentsConditionsArrayOutputWithContext(context.Background())
}

func (i HTTPRouteStatusParentsConditionsArray) ToHTTPRouteStatusParentsConditionsArrayOutputWithContext(ctx context.Context) HTTPRouteStatusParentsConditionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteStatusParentsConditionsArrayOutput)
}

// Condition contains details for one aspect of the current state of this API Resource.
// ---
// This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{
//	    // Represents the observations of a foo's current state.
//	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
//	    // +patchMergeKey=type
//	    // +patchStrategy=merge
//	    // +listType=map
//	    // +listMapKey=type
//	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//
//
//	    // other fields
//	}
type HTTPRouteStatusParentsConditionsOutput struct{ *pulumi.OutputState }

func (HTTPRouteStatusParentsConditionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteStatusParentsConditions)(nil)).Elem()
}

func (o HTTPRouteStatusParentsConditionsOutput) ToHTTPRouteStatusParentsConditionsOutput() HTTPRouteStatusParentsConditionsOutput {
	return o
}

func (o HTTPRouteStatusParentsConditionsOutput) ToHTTPRouteStatusParentsConditionsOutputWithContext(ctx context.Context) HTTPRouteStatusParentsConditionsOutput {
	return o
}

// lastTransitionTime is the last time the condition transitioned from one status to another.
// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
func (o HTTPRouteStatusParentsConditionsOutput) LastTransitionTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteStatusParentsConditions) *string { return v.LastTransitionTime }).(pulumi.StringPtrOutput)
}

// message is a human readable message indicating details about the transition.
// This may be an empty string.
func (o HTTPRouteStatusParentsConditionsOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteStatusParentsConditions) *string { return v.Message }).(pulumi.StringPtrOutput)
}

// observedGeneration represents the .metadata.generation that the condition was set based upon.
// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
// with respect to the current state of the instance.
func (o HTTPRouteStatusParentsConditionsOutput) ObservedGeneration() pulumi.IntPtrOutput {
	return o.ApplyT(func(v HTTPRouteStatusParentsConditions) *int { return v.ObservedGeneration }).(pulumi.IntPtrOutput)
}

// reason contains a programmatic identifier indicating the reason for the condition's last transition.
// Producers of specific condition types may define expected values and meanings for this field,
// and whether the values are considered a guaranteed API.
// The value should be a CamelCase string.
// This field may not be empty.
func (o HTTPRouteStatusParentsConditionsOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteStatusParentsConditions) *string { return v.Reason }).(pulumi.StringPtrOutput)
}

// status of the condition, one of True, False, Unknown.
func (o HTTPRouteStatusParentsConditionsOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteStatusParentsConditions) *string { return v.Status }).(pulumi.StringPtrOutput)
}

// type of condition in CamelCase or in foo.example.com/CamelCase.
// ---
// Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
// useful (see .node.status.conditions), the ability to deconflict is important.
// The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
func (o HTTPRouteStatusParentsConditionsOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteStatusParentsConditions) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type HTTPRouteStatusParentsConditionsArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteStatusParentsConditionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteStatusParentsConditions)(nil)).Elem()
}

func (o HTTPRouteStatusParentsConditionsArrayOutput) ToHTTPRouteStatusParentsConditionsArrayOutput() HTTPRouteStatusParentsConditionsArrayOutput {
	return o
}

func (o HTTPRouteStatusParentsConditionsArrayOutput) ToHTTPRouteStatusParentsConditionsArrayOutputWithContext(ctx context.Context) HTTPRouteStatusParentsConditionsArrayOutput {
	return o
}

func (o HTTPRouteStatusParentsConditionsArrayOutput) Index(i pulumi.IntInput) HTTPRouteStatusParentsConditionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteStatusParentsConditions {
		return vs[0].([]HTTPRouteStatusParentsConditions)[vs[1].(int)]
	}).(HTTPRouteStatusParentsConditionsOutput)
}

// Condition contains details for one aspect of the current state of this API Resource.
// ---
// This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{
//	    // Represents the observations of a foo's current state.
//	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
//	    // +patchMergeKey=type
//	    // +patchStrategy=merge
//	    // +listType=map
//	    // +listMapKey=type
//	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//
//
//	    // other fields
//	}
type HTTPRouteStatusParentsConditionsPatch struct {
	// lastTransitionTime is the last time the condition transitioned from one status to another.
	// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	LastTransitionTime *string `pulumi:"lastTransitionTime"`
	// message is a human readable message indicating details about the transition.
	// This may be an empty string.
	Message *string `pulumi:"message"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon.
	// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
	// with respect to the current state of the instance.
	ObservedGeneration *int `pulumi:"observedGeneration"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition.
	// Producers of specific condition types may define expected values and meanings for this field,
	// and whether the values are considered a guaranteed API.
	// The value should be a CamelCase string.
	// This field may not be empty.
	Reason *string `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status *string `pulumi:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase.
	// ---
	// Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
	// useful (see .node.status.conditions), the ability to deconflict is important.
	// The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
	Type *string `pulumi:"type"`
}

// HTTPRouteStatusParentsConditionsPatchInput is an input type that accepts HTTPRouteStatusParentsConditionsPatchArgs and HTTPRouteStatusParentsConditionsPatchOutput values.
// You can construct a concrete instance of `HTTPRouteStatusParentsConditionsPatchInput` via:
//
//	HTTPRouteStatusParentsConditionsPatchArgs{...}
type HTTPRouteStatusParentsConditionsPatchInput interface {
	pulumi.Input

	ToHTTPRouteStatusParentsConditionsPatchOutput() HTTPRouteStatusParentsConditionsPatchOutput
	ToHTTPRouteStatusParentsConditionsPatchOutputWithContext(context.Context) HTTPRouteStatusParentsConditionsPatchOutput
}

// Condition contains details for one aspect of the current state of this API Resource.
// ---
// This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{
//	    // Represents the observations of a foo's current state.
//	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
//	    // +patchMergeKey=type
//	    // +patchStrategy=merge
//	    // +listType=map
//	    // +listMapKey=type
//	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//
//
//	    // other fields
//	}
type HTTPRouteStatusParentsConditionsPatchArgs struct {
	// lastTransitionTime is the last time the condition transitioned from one status to another.
	// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	LastTransitionTime pulumi.StringPtrInput `pulumi:"lastTransitionTime"`
	// message is a human readable message indicating details about the transition.
	// This may be an empty string.
	Message pulumi.StringPtrInput `pulumi:"message"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon.
	// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
	// with respect to the current state of the instance.
	ObservedGeneration pulumi.IntPtrInput `pulumi:"observedGeneration"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition.
	// Producers of specific condition types may define expected values and meanings for this field,
	// and whether the values are considered a guaranteed API.
	// The value should be a CamelCase string.
	// This field may not be empty.
	Reason pulumi.StringPtrInput `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status pulumi.StringPtrInput `pulumi:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase.
	// ---
	// Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
	// useful (see .node.status.conditions), the ability to deconflict is important.
	// The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (HTTPRouteStatusParentsConditionsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteStatusParentsConditionsPatch)(nil)).Elem()
}

func (i HTTPRouteStatusParentsConditionsPatchArgs) ToHTTPRouteStatusParentsConditionsPatchOutput() HTTPRouteStatusParentsConditionsPatchOutput {
	return i.ToHTTPRouteStatusParentsConditionsPatchOutputWithContext(context.Background())
}

func (i HTTPRouteStatusParentsConditionsPatchArgs) ToHTTPRouteStatusParentsConditionsPatchOutputWithContext(ctx context.Context) HTTPRouteStatusParentsConditionsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteStatusParentsConditionsPatchOutput)
}

// HTTPRouteStatusParentsConditionsPatchArrayInput is an input type that accepts HTTPRouteStatusParentsConditionsPatchArray and HTTPRouteStatusParentsConditionsPatchArrayOutput values.
// You can construct a concrete instance of `HTTPRouteStatusParentsConditionsPatchArrayInput` via:
//
//	HTTPRouteStatusParentsConditionsPatchArray{ HTTPRouteStatusParentsConditionsPatchArgs{...} }
type HTTPRouteStatusParentsConditionsPatchArrayInput interface {
	pulumi.Input

	ToHTTPRouteStatusParentsConditionsPatchArrayOutput() HTTPRouteStatusParentsConditionsPatchArrayOutput
	ToHTTPRouteStatusParentsConditionsPatchArrayOutputWithContext(context.Context) HTTPRouteStatusParentsConditionsPatchArrayOutput
}

type HTTPRouteStatusParentsConditionsPatchArray []HTTPRouteStatusParentsConditionsPatchInput

func (HTTPRouteStatusParentsConditionsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteStatusParentsConditionsPatch)(nil)).Elem()
}

func (i HTTPRouteStatusParentsConditionsPatchArray) ToHTTPRouteStatusParentsConditionsPatchArrayOutput() HTTPRouteStatusParentsConditionsPatchArrayOutput {
	return i.ToHTTPRouteStatusParentsConditionsPatchArrayOutputWithContext(context.Background())
}

func (i HTTPRouteStatusParentsConditionsPatchArray) ToHTTPRouteStatusParentsConditionsPatchArrayOutputWithContext(ctx context.Context) HTTPRouteStatusParentsConditionsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteStatusParentsConditionsPatchArrayOutput)
}

// Condition contains details for one aspect of the current state of this API Resource.
// ---
// This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{
//	    // Represents the observations of a foo's current state.
//	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
//	    // +patchMergeKey=type
//	    // +patchStrategy=merge
//	    // +listType=map
//	    // +listMapKey=type
//	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//
//
//	    // other fields
//	}
type HTTPRouteStatusParentsConditionsPatchOutput struct{ *pulumi.OutputState }

func (HTTPRouteStatusParentsConditionsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteStatusParentsConditionsPatch)(nil)).Elem()
}

func (o HTTPRouteStatusParentsConditionsPatchOutput) ToHTTPRouteStatusParentsConditionsPatchOutput() HTTPRouteStatusParentsConditionsPatchOutput {
	return o
}

func (o HTTPRouteStatusParentsConditionsPatchOutput) ToHTTPRouteStatusParentsConditionsPatchOutputWithContext(ctx context.Context) HTTPRouteStatusParentsConditionsPatchOutput {
	return o
}

// lastTransitionTime is the last time the condition transitioned from one status to another.
// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
func (o HTTPRouteStatusParentsConditionsPatchOutput) LastTransitionTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteStatusParentsConditionsPatch) *string { return v.LastTransitionTime }).(pulumi.StringPtrOutput)
}

// message is a human readable message indicating details about the transition.
// This may be an empty string.
func (o HTTPRouteStatusParentsConditionsPatchOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteStatusParentsConditionsPatch) *string { return v.Message }).(pulumi.StringPtrOutput)
}

// observedGeneration represents the .metadata.generation that the condition was set based upon.
// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
// with respect to the current state of the instance.
func (o HTTPRouteStatusParentsConditionsPatchOutput) ObservedGeneration() pulumi.IntPtrOutput {
	return o.ApplyT(func(v HTTPRouteStatusParentsConditionsPatch) *int { return v.ObservedGeneration }).(pulumi.IntPtrOutput)
}

// reason contains a programmatic identifier indicating the reason for the condition's last transition.
// Producers of specific condition types may define expected values and meanings for this field,
// and whether the values are considered a guaranteed API.
// The value should be a CamelCase string.
// This field may not be empty.
func (o HTTPRouteStatusParentsConditionsPatchOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteStatusParentsConditionsPatch) *string { return v.Reason }).(pulumi.StringPtrOutput)
}

// status of the condition, one of True, False, Unknown.
func (o HTTPRouteStatusParentsConditionsPatchOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteStatusParentsConditionsPatch) *string { return v.Status }).(pulumi.StringPtrOutput)
}

// type of condition in CamelCase or in foo.example.com/CamelCase.
// ---
// Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
// useful (see .node.status.conditions), the ability to deconflict is important.
// The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
func (o HTTPRouteStatusParentsConditionsPatchOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteStatusParentsConditionsPatch) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type HTTPRouteStatusParentsConditionsPatchArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteStatusParentsConditionsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteStatusParentsConditionsPatch)(nil)).Elem()
}

func (o HTTPRouteStatusParentsConditionsPatchArrayOutput) ToHTTPRouteStatusParentsConditionsPatchArrayOutput() HTTPRouteStatusParentsConditionsPatchArrayOutput {
	return o
}

func (o HTTPRouteStatusParentsConditionsPatchArrayOutput) ToHTTPRouteStatusParentsConditionsPatchArrayOutputWithContext(ctx context.Context) HTTPRouteStatusParentsConditionsPatchArrayOutput {
	return o
}

func (o HTTPRouteStatusParentsConditionsPatchArrayOutput) Index(i pulumi.IntInput) HTTPRouteStatusParentsConditionsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteStatusParentsConditionsPatch {
		return vs[0].([]HTTPRouteStatusParentsConditionsPatch)[vs[1].(int)]
	}).(HTTPRouteStatusParentsConditionsPatchOutput)
}

// ParentRef corresponds with a ParentRef in the spec that this
// RouteParentStatus struct describes the status of.
type HTTPRouteStatusParentsParentRef struct {
	// Group is the group of the referent.
	// When unspecified, "gateway.networking.k8s.io" is inferred.
	// To set the core API group (such as for a "Service" kind referent),
	// Group must be explicitly set to "" (empty string).
	//
	// Support: Core
	Group *string `pulumi:"group"`
	// Kind is kind of the referent.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// Support for other resources is Implementation-Specific.
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	//
	// Support: Core
	Name *string `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers
	// to the local namespace of the Route.
	//
	// Note that there are specific rules for ParentRefs which cross namespace
	// boundaries. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example:
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable any other kind of cross-namespace reference.
	//
	// Support: Core
	Namespace *string `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted
	// differently based on the type of parent resource.
	//
	// When the parent resource is a Gateway, this targets all listeners
	// listening on the specified port that also support this kind of Route(and
	// select this Route). It's not recommended to set `Port` unless the
	// networking behaviors specified in a Route must apply to a specific port
	// as opposed to a listener(s) whose port(s) may be changed. When both Port
	// and SectionName are specified, the name and port of the selected listener
	// must match both specified values.
	//
	// Implementations MAY choose to support other parent resources.
	// Implementations supporting other types of parent resources MUST clearly
	// document how/if Port is interpreted.
	//
	// For the purpose of status, an attachment is considered successful as
	// long as the parent resource accepts it partially. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
	// from the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route,
	// the Route MUST be considered detached from the Gateway.
	//
	// Support: Extended
	Port *int `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the
	// following resources, SectionName is interpreted as the following:
	//
	// * Gateway: Listener name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	// * Service: Port name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	//
	// Implementations MAY choose to support attaching Routes to other resources.
	// If that is the case, they MUST clearly document how SectionName is
	// interpreted.
	//
	// When unspecified (empty string), this will reference the entire resource.
	// For the purpose of status, an attachment is considered successful if at
	// least one section in the parent resource accepts it. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
	// the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route, the
	// Route MUST be considered detached from the Gateway.
	//
	// Support: Core
	SectionName *string `pulumi:"sectionName"`
}

// HTTPRouteStatusParentsParentRefInput is an input type that accepts HTTPRouteStatusParentsParentRefArgs and HTTPRouteStatusParentsParentRefOutput values.
// You can construct a concrete instance of `HTTPRouteStatusParentsParentRefInput` via:
//
//	HTTPRouteStatusParentsParentRefArgs{...}
type HTTPRouteStatusParentsParentRefInput interface {
	pulumi.Input

	ToHTTPRouteStatusParentsParentRefOutput() HTTPRouteStatusParentsParentRefOutput
	ToHTTPRouteStatusParentsParentRefOutputWithContext(context.Context) HTTPRouteStatusParentsParentRefOutput
}

// ParentRef corresponds with a ParentRef in the spec that this
// RouteParentStatus struct describes the status of.
type HTTPRouteStatusParentsParentRefArgs struct {
	// Group is the group of the referent.
	// When unspecified, "gateway.networking.k8s.io" is inferred.
	// To set the core API group (such as for a "Service" kind referent),
	// Group must be explicitly set to "" (empty string).
	//
	// Support: Core
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is kind of the referent.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// Support for other resources is Implementation-Specific.
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	//
	// Support: Core
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers
	// to the local namespace of the Route.
	//
	// Note that there are specific rules for ParentRefs which cross namespace
	// boundaries. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example:
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable any other kind of cross-namespace reference.
	//
	// Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted
	// differently based on the type of parent resource.
	//
	// When the parent resource is a Gateway, this targets all listeners
	// listening on the specified port that also support this kind of Route(and
	// select this Route). It's not recommended to set `Port` unless the
	// networking behaviors specified in a Route must apply to a specific port
	// as opposed to a listener(s) whose port(s) may be changed. When both Port
	// and SectionName are specified, the name and port of the selected listener
	// must match both specified values.
	//
	// Implementations MAY choose to support other parent resources.
	// Implementations supporting other types of parent resources MUST clearly
	// document how/if Port is interpreted.
	//
	// For the purpose of status, an attachment is considered successful as
	// long as the parent resource accepts it partially. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
	// from the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route,
	// the Route MUST be considered detached from the Gateway.
	//
	// Support: Extended
	Port pulumi.IntPtrInput `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the
	// following resources, SectionName is interpreted as the following:
	//
	// * Gateway: Listener name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	// * Service: Port name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	//
	// Implementations MAY choose to support attaching Routes to other resources.
	// If that is the case, they MUST clearly document how SectionName is
	// interpreted.
	//
	// When unspecified (empty string), this will reference the entire resource.
	// For the purpose of status, an attachment is considered successful if at
	// least one section in the parent resource accepts it. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
	// the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route, the
	// Route MUST be considered detached from the Gateway.
	//
	// Support: Core
	SectionName pulumi.StringPtrInput `pulumi:"sectionName"`
}

func (HTTPRouteStatusParentsParentRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteStatusParentsParentRef)(nil)).Elem()
}

func (i HTTPRouteStatusParentsParentRefArgs) ToHTTPRouteStatusParentsParentRefOutput() HTTPRouteStatusParentsParentRefOutput {
	return i.ToHTTPRouteStatusParentsParentRefOutputWithContext(context.Background())
}

func (i HTTPRouteStatusParentsParentRefArgs) ToHTTPRouteStatusParentsParentRefOutputWithContext(ctx context.Context) HTTPRouteStatusParentsParentRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteStatusParentsParentRefOutput)
}

func (i HTTPRouteStatusParentsParentRefArgs) ToHTTPRouteStatusParentsParentRefPtrOutput() HTTPRouteStatusParentsParentRefPtrOutput {
	return i.ToHTTPRouteStatusParentsParentRefPtrOutputWithContext(context.Background())
}

func (i HTTPRouteStatusParentsParentRefArgs) ToHTTPRouteStatusParentsParentRefPtrOutputWithContext(ctx context.Context) HTTPRouteStatusParentsParentRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteStatusParentsParentRefOutput).ToHTTPRouteStatusParentsParentRefPtrOutputWithContext(ctx)
}

// HTTPRouteStatusParentsParentRefPtrInput is an input type that accepts HTTPRouteStatusParentsParentRefArgs, HTTPRouteStatusParentsParentRefPtr and HTTPRouteStatusParentsParentRefPtrOutput values.
// You can construct a concrete instance of `HTTPRouteStatusParentsParentRefPtrInput` via:
//
//	        HTTPRouteStatusParentsParentRefArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteStatusParentsParentRefPtrInput interface {
	pulumi.Input

	ToHTTPRouteStatusParentsParentRefPtrOutput() HTTPRouteStatusParentsParentRefPtrOutput
	ToHTTPRouteStatusParentsParentRefPtrOutputWithContext(context.Context) HTTPRouteStatusParentsParentRefPtrOutput
}

type httprouteStatusParentsParentRefPtrType HTTPRouteStatusParentsParentRefArgs

func HTTPRouteStatusParentsParentRefPtr(v *HTTPRouteStatusParentsParentRefArgs) HTTPRouteStatusParentsParentRefPtrInput {
	return (*httprouteStatusParentsParentRefPtrType)(v)
}

func (*httprouteStatusParentsParentRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteStatusParentsParentRef)(nil)).Elem()
}

func (i *httprouteStatusParentsParentRefPtrType) ToHTTPRouteStatusParentsParentRefPtrOutput() HTTPRouteStatusParentsParentRefPtrOutput {
	return i.ToHTTPRouteStatusParentsParentRefPtrOutputWithContext(context.Background())
}

func (i *httprouteStatusParentsParentRefPtrType) ToHTTPRouteStatusParentsParentRefPtrOutputWithContext(ctx context.Context) HTTPRouteStatusParentsParentRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteStatusParentsParentRefPtrOutput)
}

// ParentRef corresponds with a ParentRef in the spec that this
// RouteParentStatus struct describes the status of.
type HTTPRouteStatusParentsParentRefOutput struct{ *pulumi.OutputState }

func (HTTPRouteStatusParentsParentRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteStatusParentsParentRef)(nil)).Elem()
}

func (o HTTPRouteStatusParentsParentRefOutput) ToHTTPRouteStatusParentsParentRefOutput() HTTPRouteStatusParentsParentRefOutput {
	return o
}

func (o HTTPRouteStatusParentsParentRefOutput) ToHTTPRouteStatusParentsParentRefOutputWithContext(ctx context.Context) HTTPRouteStatusParentsParentRefOutput {
	return o
}

func (o HTTPRouteStatusParentsParentRefOutput) ToHTTPRouteStatusParentsParentRefPtrOutput() HTTPRouteStatusParentsParentRefPtrOutput {
	return o.ToHTTPRouteStatusParentsParentRefPtrOutputWithContext(context.Background())
}

func (o HTTPRouteStatusParentsParentRefOutput) ToHTTPRouteStatusParentsParentRefPtrOutputWithContext(ctx context.Context) HTTPRouteStatusParentsParentRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteStatusParentsParentRef) *HTTPRouteStatusParentsParentRef {
		return &v
	}).(HTTPRouteStatusParentsParentRefPtrOutput)
}

// Group is the group of the referent.
// When unspecified, "gateway.networking.k8s.io" is inferred.
// To set the core API group (such as for a "Service" kind referent),
// Group must be explicitly set to "" (empty string).
//
// Support: Core
func (o HTTPRouteStatusParentsParentRefOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteStatusParentsParentRef) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent.
//
// There are two kinds of parent resources with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// Support for other resources is Implementation-Specific.
func (o HTTPRouteStatusParentsParentRefOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteStatusParentsParentRef) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
//
// Support: Core
func (o HTTPRouteStatusParentsParentRefOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteStatusParentsParentRef) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the referent. When unspecified, this refers
// to the local namespace of the Route.
//
// Note that there are specific rules for ParentRefs which cross namespace
// boundaries. Cross-namespace references are only valid if they are explicitly
// allowed by something in the namespace they are referring to. For example:
// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
// generic way to enable any other kind of cross-namespace reference.
//
// Support: Core
func (o HTTPRouteStatusParentsParentRefOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteStatusParentsParentRef) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Port is the network port this Route targets. It can be interpreted
// differently based on the type of parent resource.
//
// When the parent resource is a Gateway, this targets all listeners
// listening on the specified port that also support this kind of Route(and
// select this Route). It's not recommended to set `Port` unless the
// networking behaviors specified in a Route must apply to a specific port
// as opposed to a listener(s) whose port(s) may be changed. When both Port
// and SectionName are specified, the name and port of the selected listener
// must match both specified values.
//
// Implementations MAY choose to support other parent resources.
// Implementations supporting other types of parent resources MUST clearly
// document how/if Port is interpreted.
//
// For the purpose of status, an attachment is considered successful as
// long as the parent resource accepts it partially. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
// from the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route,
// the Route MUST be considered detached from the Gateway.
//
// Support: Extended
func (o HTTPRouteStatusParentsParentRefOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v HTTPRouteStatusParentsParentRef) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// SectionName is the name of a section within the target resource. In the
// following resources, SectionName is interpreted as the following:
//
//   - Gateway: Listener name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//   - Service: Port name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//
// Implementations MAY choose to support attaching Routes to other resources.
// If that is the case, they MUST clearly document how SectionName is
// interpreted.
//
// When unspecified (empty string), this will reference the entire resource.
// For the purpose of status, an attachment is considered successful if at
// least one section in the parent resource accepts it. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
// the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route, the
// Route MUST be considered detached from the Gateway.
//
// Support: Core
func (o HTTPRouteStatusParentsParentRefOutput) SectionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteStatusParentsParentRef) *string { return v.SectionName }).(pulumi.StringPtrOutput)
}

type HTTPRouteStatusParentsParentRefPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteStatusParentsParentRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteStatusParentsParentRef)(nil)).Elem()
}

func (o HTTPRouteStatusParentsParentRefPtrOutput) ToHTTPRouteStatusParentsParentRefPtrOutput() HTTPRouteStatusParentsParentRefPtrOutput {
	return o
}

func (o HTTPRouteStatusParentsParentRefPtrOutput) ToHTTPRouteStatusParentsParentRefPtrOutputWithContext(ctx context.Context) HTTPRouteStatusParentsParentRefPtrOutput {
	return o
}

func (o HTTPRouteStatusParentsParentRefPtrOutput) Elem() HTTPRouteStatusParentsParentRefOutput {
	return o.ApplyT(func(v *HTTPRouteStatusParentsParentRef) HTTPRouteStatusParentsParentRef {
		if v != nil {
			return *v
		}
		var ret HTTPRouteStatusParentsParentRef
		return ret
	}).(HTTPRouteStatusParentsParentRefOutput)
}

// Group is the group of the referent.
// When unspecified, "gateway.networking.k8s.io" is inferred.
// To set the core API group (such as for a "Service" kind referent),
// Group must be explicitly set to "" (empty string).
//
// Support: Core
func (o HTTPRouteStatusParentsParentRefPtrOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteStatusParentsParentRef) *string {
		if v == nil {
			return nil
		}
		return v.Group
	}).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent.
//
// There are two kinds of parent resources with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// Support for other resources is Implementation-Specific.
func (o HTTPRouteStatusParentsParentRefPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteStatusParentsParentRef) *string {
		if v == nil {
			return nil
		}
		return v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
//
// Support: Core
func (o HTTPRouteStatusParentsParentRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteStatusParentsParentRef) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the referent. When unspecified, this refers
// to the local namespace of the Route.
//
// Note that there are specific rules for ParentRefs which cross namespace
// boundaries. Cross-namespace references are only valid if they are explicitly
// allowed by something in the namespace they are referring to. For example:
// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
// generic way to enable any other kind of cross-namespace reference.
//
// Support: Core
func (o HTTPRouteStatusParentsParentRefPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteStatusParentsParentRef) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

// Port is the network port this Route targets. It can be interpreted
// differently based on the type of parent resource.
//
// When the parent resource is a Gateway, this targets all listeners
// listening on the specified port that also support this kind of Route(and
// select this Route). It's not recommended to set `Port` unless the
// networking behaviors specified in a Route must apply to a specific port
// as opposed to a listener(s) whose port(s) may be changed. When both Port
// and SectionName are specified, the name and port of the selected listener
// must match both specified values.
//
// Implementations MAY choose to support other parent resources.
// Implementations supporting other types of parent resources MUST clearly
// document how/if Port is interpreted.
//
// For the purpose of status, an attachment is considered successful as
// long as the parent resource accepts it partially. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
// from the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route,
// the Route MUST be considered detached from the Gateway.
//
// Support: Extended
func (o HTTPRouteStatusParentsParentRefPtrOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *HTTPRouteStatusParentsParentRef) *int {
		if v == nil {
			return nil
		}
		return v.Port
	}).(pulumi.IntPtrOutput)
}

// SectionName is the name of a section within the target resource. In the
// following resources, SectionName is interpreted as the following:
//
//   - Gateway: Listener name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//   - Service: Port name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//
// Implementations MAY choose to support attaching Routes to other resources.
// If that is the case, they MUST clearly document how SectionName is
// interpreted.
//
// When unspecified (empty string), this will reference the entire resource.
// For the purpose of status, an attachment is considered successful if at
// least one section in the parent resource accepts it. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
// the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route, the
// Route MUST be considered detached from the Gateway.
//
// Support: Core
func (o HTTPRouteStatusParentsParentRefPtrOutput) SectionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteStatusParentsParentRef) *string {
		if v == nil {
			return nil
		}
		return v.SectionName
	}).(pulumi.StringPtrOutput)
}

// ParentRef corresponds with a ParentRef in the spec that this
// RouteParentStatus struct describes the status of.
type HTTPRouteStatusParentsParentRefPatch struct {
	// Group is the group of the referent.
	// When unspecified, "gateway.networking.k8s.io" is inferred.
	// To set the core API group (such as for a "Service" kind referent),
	// Group must be explicitly set to "" (empty string).
	//
	// Support: Core
	Group *string `pulumi:"group"`
	// Kind is kind of the referent.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// Support for other resources is Implementation-Specific.
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	//
	// Support: Core
	Name *string `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers
	// to the local namespace of the Route.
	//
	// Note that there are specific rules for ParentRefs which cross namespace
	// boundaries. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example:
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable any other kind of cross-namespace reference.
	//
	// Support: Core
	Namespace *string `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted
	// differently based on the type of parent resource.
	//
	// When the parent resource is a Gateway, this targets all listeners
	// listening on the specified port that also support this kind of Route(and
	// select this Route). It's not recommended to set `Port` unless the
	// networking behaviors specified in a Route must apply to a specific port
	// as opposed to a listener(s) whose port(s) may be changed. When both Port
	// and SectionName are specified, the name and port of the selected listener
	// must match both specified values.
	//
	// Implementations MAY choose to support other parent resources.
	// Implementations supporting other types of parent resources MUST clearly
	// document how/if Port is interpreted.
	//
	// For the purpose of status, an attachment is considered successful as
	// long as the parent resource accepts it partially. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
	// from the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route,
	// the Route MUST be considered detached from the Gateway.
	//
	// Support: Extended
	Port *int `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the
	// following resources, SectionName is interpreted as the following:
	//
	// * Gateway: Listener name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	// * Service: Port name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	//
	// Implementations MAY choose to support attaching Routes to other resources.
	// If that is the case, they MUST clearly document how SectionName is
	// interpreted.
	//
	// When unspecified (empty string), this will reference the entire resource.
	// For the purpose of status, an attachment is considered successful if at
	// least one section in the parent resource accepts it. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
	// the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route, the
	// Route MUST be considered detached from the Gateway.
	//
	// Support: Core
	SectionName *string `pulumi:"sectionName"`
}

// HTTPRouteStatusParentsParentRefPatchInput is an input type that accepts HTTPRouteStatusParentsParentRefPatchArgs and HTTPRouteStatusParentsParentRefPatchOutput values.
// You can construct a concrete instance of `HTTPRouteStatusParentsParentRefPatchInput` via:
//
//	HTTPRouteStatusParentsParentRefPatchArgs{...}
type HTTPRouteStatusParentsParentRefPatchInput interface {
	pulumi.Input

	ToHTTPRouteStatusParentsParentRefPatchOutput() HTTPRouteStatusParentsParentRefPatchOutput
	ToHTTPRouteStatusParentsParentRefPatchOutputWithContext(context.Context) HTTPRouteStatusParentsParentRefPatchOutput
}

// ParentRef corresponds with a ParentRef in the spec that this
// RouteParentStatus struct describes the status of.
type HTTPRouteStatusParentsParentRefPatchArgs struct {
	// Group is the group of the referent.
	// When unspecified, "gateway.networking.k8s.io" is inferred.
	// To set the core API group (such as for a "Service" kind referent),
	// Group must be explicitly set to "" (empty string).
	//
	// Support: Core
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is kind of the referent.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// Support for other resources is Implementation-Specific.
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	//
	// Support: Core
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers
	// to the local namespace of the Route.
	//
	// Note that there are specific rules for ParentRefs which cross namespace
	// boundaries. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example:
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable any other kind of cross-namespace reference.
	//
	// Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted
	// differently based on the type of parent resource.
	//
	// When the parent resource is a Gateway, this targets all listeners
	// listening on the specified port that also support this kind of Route(and
	// select this Route). It's not recommended to set `Port` unless the
	// networking behaviors specified in a Route must apply to a specific port
	// as opposed to a listener(s) whose port(s) may be changed. When both Port
	// and SectionName are specified, the name and port of the selected listener
	// must match both specified values.
	//
	// Implementations MAY choose to support other parent resources.
	// Implementations supporting other types of parent resources MUST clearly
	// document how/if Port is interpreted.
	//
	// For the purpose of status, an attachment is considered successful as
	// long as the parent resource accepts it partially. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
	// from the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route,
	// the Route MUST be considered detached from the Gateway.
	//
	// Support: Extended
	Port pulumi.IntPtrInput `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the
	// following resources, SectionName is interpreted as the following:
	//
	// * Gateway: Listener name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	// * Service: Port name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	//
	// Implementations MAY choose to support attaching Routes to other resources.
	// If that is the case, they MUST clearly document how SectionName is
	// interpreted.
	//
	// When unspecified (empty string), this will reference the entire resource.
	// For the purpose of status, an attachment is considered successful if at
	// least one section in the parent resource accepts it. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
	// the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route, the
	// Route MUST be considered detached from the Gateway.
	//
	// Support: Core
	SectionName pulumi.StringPtrInput `pulumi:"sectionName"`
}

func (HTTPRouteStatusParentsParentRefPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteStatusParentsParentRefPatch)(nil)).Elem()
}

func (i HTTPRouteStatusParentsParentRefPatchArgs) ToHTTPRouteStatusParentsParentRefPatchOutput() HTTPRouteStatusParentsParentRefPatchOutput {
	return i.ToHTTPRouteStatusParentsParentRefPatchOutputWithContext(context.Background())
}

func (i HTTPRouteStatusParentsParentRefPatchArgs) ToHTTPRouteStatusParentsParentRefPatchOutputWithContext(ctx context.Context) HTTPRouteStatusParentsParentRefPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteStatusParentsParentRefPatchOutput)
}

func (i HTTPRouteStatusParentsParentRefPatchArgs) ToHTTPRouteStatusParentsParentRefPatchPtrOutput() HTTPRouteStatusParentsParentRefPatchPtrOutput {
	return i.ToHTTPRouteStatusParentsParentRefPatchPtrOutputWithContext(context.Background())
}

func (i HTTPRouteStatusParentsParentRefPatchArgs) ToHTTPRouteStatusParentsParentRefPatchPtrOutputWithContext(ctx context.Context) HTTPRouteStatusParentsParentRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteStatusParentsParentRefPatchOutput).ToHTTPRouteStatusParentsParentRefPatchPtrOutputWithContext(ctx)
}

// HTTPRouteStatusParentsParentRefPatchPtrInput is an input type that accepts HTTPRouteStatusParentsParentRefPatchArgs, HTTPRouteStatusParentsParentRefPatchPtr and HTTPRouteStatusParentsParentRefPatchPtrOutput values.
// You can construct a concrete instance of `HTTPRouteStatusParentsParentRefPatchPtrInput` via:
//
//	        HTTPRouteStatusParentsParentRefPatchArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteStatusParentsParentRefPatchPtrInput interface {
	pulumi.Input

	ToHTTPRouteStatusParentsParentRefPatchPtrOutput() HTTPRouteStatusParentsParentRefPatchPtrOutput
	ToHTTPRouteStatusParentsParentRefPatchPtrOutputWithContext(context.Context) HTTPRouteStatusParentsParentRefPatchPtrOutput
}

type httprouteStatusParentsParentRefPatchPtrType HTTPRouteStatusParentsParentRefPatchArgs

func HTTPRouteStatusParentsParentRefPatchPtr(v *HTTPRouteStatusParentsParentRefPatchArgs) HTTPRouteStatusParentsParentRefPatchPtrInput {
	return (*httprouteStatusParentsParentRefPatchPtrType)(v)
}

func (*httprouteStatusParentsParentRefPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteStatusParentsParentRefPatch)(nil)).Elem()
}

func (i *httprouteStatusParentsParentRefPatchPtrType) ToHTTPRouteStatusParentsParentRefPatchPtrOutput() HTTPRouteStatusParentsParentRefPatchPtrOutput {
	return i.ToHTTPRouteStatusParentsParentRefPatchPtrOutputWithContext(context.Background())
}

func (i *httprouteStatusParentsParentRefPatchPtrType) ToHTTPRouteStatusParentsParentRefPatchPtrOutputWithContext(ctx context.Context) HTTPRouteStatusParentsParentRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteStatusParentsParentRefPatchPtrOutput)
}

// ParentRef corresponds with a ParentRef in the spec that this
// RouteParentStatus struct describes the status of.
type HTTPRouteStatusParentsParentRefPatchOutput struct{ *pulumi.OutputState }

func (HTTPRouteStatusParentsParentRefPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteStatusParentsParentRefPatch)(nil)).Elem()
}

func (o HTTPRouteStatusParentsParentRefPatchOutput) ToHTTPRouteStatusParentsParentRefPatchOutput() HTTPRouteStatusParentsParentRefPatchOutput {
	return o
}

func (o HTTPRouteStatusParentsParentRefPatchOutput) ToHTTPRouteStatusParentsParentRefPatchOutputWithContext(ctx context.Context) HTTPRouteStatusParentsParentRefPatchOutput {
	return o
}

func (o HTTPRouteStatusParentsParentRefPatchOutput) ToHTTPRouteStatusParentsParentRefPatchPtrOutput() HTTPRouteStatusParentsParentRefPatchPtrOutput {
	return o.ToHTTPRouteStatusParentsParentRefPatchPtrOutputWithContext(context.Background())
}

func (o HTTPRouteStatusParentsParentRefPatchOutput) ToHTTPRouteStatusParentsParentRefPatchPtrOutputWithContext(ctx context.Context) HTTPRouteStatusParentsParentRefPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteStatusParentsParentRefPatch) *HTTPRouteStatusParentsParentRefPatch {
		return &v
	}).(HTTPRouteStatusParentsParentRefPatchPtrOutput)
}

// Group is the group of the referent.
// When unspecified, "gateway.networking.k8s.io" is inferred.
// To set the core API group (such as for a "Service" kind referent),
// Group must be explicitly set to "" (empty string).
//
// Support: Core
func (o HTTPRouteStatusParentsParentRefPatchOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteStatusParentsParentRefPatch) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent.
//
// There are two kinds of parent resources with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// Support for other resources is Implementation-Specific.
func (o HTTPRouteStatusParentsParentRefPatchOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteStatusParentsParentRefPatch) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
//
// Support: Core
func (o HTTPRouteStatusParentsParentRefPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteStatusParentsParentRefPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the referent. When unspecified, this refers
// to the local namespace of the Route.
//
// Note that there are specific rules for ParentRefs which cross namespace
// boundaries. Cross-namespace references are only valid if they are explicitly
// allowed by something in the namespace they are referring to. For example:
// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
// generic way to enable any other kind of cross-namespace reference.
//
// Support: Core
func (o HTTPRouteStatusParentsParentRefPatchOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteStatusParentsParentRefPatch) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Port is the network port this Route targets. It can be interpreted
// differently based on the type of parent resource.
//
// When the parent resource is a Gateway, this targets all listeners
// listening on the specified port that also support this kind of Route(and
// select this Route). It's not recommended to set `Port` unless the
// networking behaviors specified in a Route must apply to a specific port
// as opposed to a listener(s) whose port(s) may be changed. When both Port
// and SectionName are specified, the name and port of the selected listener
// must match both specified values.
//
// Implementations MAY choose to support other parent resources.
// Implementations supporting other types of parent resources MUST clearly
// document how/if Port is interpreted.
//
// For the purpose of status, an attachment is considered successful as
// long as the parent resource accepts it partially. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
// from the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route,
// the Route MUST be considered detached from the Gateway.
//
// Support: Extended
func (o HTTPRouteStatusParentsParentRefPatchOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v HTTPRouteStatusParentsParentRefPatch) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// SectionName is the name of a section within the target resource. In the
// following resources, SectionName is interpreted as the following:
//
//   - Gateway: Listener name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//   - Service: Port name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//
// Implementations MAY choose to support attaching Routes to other resources.
// If that is the case, they MUST clearly document how SectionName is
// interpreted.
//
// When unspecified (empty string), this will reference the entire resource.
// For the purpose of status, an attachment is considered successful if at
// least one section in the parent resource accepts it. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
// the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route, the
// Route MUST be considered detached from the Gateway.
//
// Support: Core
func (o HTTPRouteStatusParentsParentRefPatchOutput) SectionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteStatusParentsParentRefPatch) *string { return v.SectionName }).(pulumi.StringPtrOutput)
}

type HTTPRouteStatusParentsParentRefPatchPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteStatusParentsParentRefPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteStatusParentsParentRefPatch)(nil)).Elem()
}

func (o HTTPRouteStatusParentsParentRefPatchPtrOutput) ToHTTPRouteStatusParentsParentRefPatchPtrOutput() HTTPRouteStatusParentsParentRefPatchPtrOutput {
	return o
}

func (o HTTPRouteStatusParentsParentRefPatchPtrOutput) ToHTTPRouteStatusParentsParentRefPatchPtrOutputWithContext(ctx context.Context) HTTPRouteStatusParentsParentRefPatchPtrOutput {
	return o
}

func (o HTTPRouteStatusParentsParentRefPatchPtrOutput) Elem() HTTPRouteStatusParentsParentRefPatchOutput {
	return o.ApplyT(func(v *HTTPRouteStatusParentsParentRefPatch) HTTPRouteStatusParentsParentRefPatch {
		if v != nil {
			return *v
		}
		var ret HTTPRouteStatusParentsParentRefPatch
		return ret
	}).(HTTPRouteStatusParentsParentRefPatchOutput)
}

// Group is the group of the referent.
// When unspecified, "gateway.networking.k8s.io" is inferred.
// To set the core API group (such as for a "Service" kind referent),
// Group must be explicitly set to "" (empty string).
//
// Support: Core
func (o HTTPRouteStatusParentsParentRefPatchPtrOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteStatusParentsParentRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Group
	}).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent.
//
// There are two kinds of parent resources with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// Support for other resources is Implementation-Specific.
func (o HTTPRouteStatusParentsParentRefPatchPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteStatusParentsParentRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
//
// Support: Core
func (o HTTPRouteStatusParentsParentRefPatchPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteStatusParentsParentRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the referent. When unspecified, this refers
// to the local namespace of the Route.
//
// Note that there are specific rules for ParentRefs which cross namespace
// boundaries. Cross-namespace references are only valid if they are explicitly
// allowed by something in the namespace they are referring to. For example:
// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
// generic way to enable any other kind of cross-namespace reference.
//
// Support: Core
func (o HTTPRouteStatusParentsParentRefPatchPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteStatusParentsParentRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

// Port is the network port this Route targets. It can be interpreted
// differently based on the type of parent resource.
//
// When the parent resource is a Gateway, this targets all listeners
// listening on the specified port that also support this kind of Route(and
// select this Route). It's not recommended to set `Port` unless the
// networking behaviors specified in a Route must apply to a specific port
// as opposed to a listener(s) whose port(s) may be changed. When both Port
// and SectionName are specified, the name and port of the selected listener
// must match both specified values.
//
// Implementations MAY choose to support other parent resources.
// Implementations supporting other types of parent resources MUST clearly
// document how/if Port is interpreted.
//
// For the purpose of status, an attachment is considered successful as
// long as the parent resource accepts it partially. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
// from the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route,
// the Route MUST be considered detached from the Gateway.
//
// Support: Extended
func (o HTTPRouteStatusParentsParentRefPatchPtrOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *HTTPRouteStatusParentsParentRefPatch) *int {
		if v == nil {
			return nil
		}
		return v.Port
	}).(pulumi.IntPtrOutput)
}

// SectionName is the name of a section within the target resource. In the
// following resources, SectionName is interpreted as the following:
//
//   - Gateway: Listener name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//   - Service: Port name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//
// Implementations MAY choose to support attaching Routes to other resources.
// If that is the case, they MUST clearly document how SectionName is
// interpreted.
//
// When unspecified (empty string), this will reference the entire resource.
// For the purpose of status, an attachment is considered successful if at
// least one section in the parent resource accepts it. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
// the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route, the
// Route MUST be considered detached from the Gateway.
//
// Support: Core
func (o HTTPRouteStatusParentsParentRefPatchPtrOutput) SectionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPRouteStatusParentsParentRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.SectionName
	}).(pulumi.StringPtrOutput)
}

// RouteParentStatus describes the status of a route with respect to an
// associated Parent.
type HTTPRouteStatusParentsPatch struct {
	// Conditions describes the status of the route with respect to the Gateway.
	// Note that the route's availability is also subject to the Gateway's own
	// status conditions and listener status.
	//
	// If the Route's ParentRef specifies an existing Gateway that supports
	// Routes of this kind AND that Gateway's controller has sufficient access,
	// then that Gateway's controller MUST set the "Accepted" condition on the
	// Route, to indicate whether the route has been accepted or rejected by the
	// Gateway, and why.
	//
	// A Route MUST be considered "Accepted" if at least one of the Route's
	// rules is implemented by the Gateway.
	//
	// There are a number of cases where the "Accepted" condition may not be set
	// due to lack of controller visibility, that includes when:
	//
	// * The Route refers to a non-existent parent.
	// * The Route is of a type that the controller does not support.
	// * The Route is in a namespace the controller does not have access to.
	Conditions []HTTPRouteStatusParentsConditionsPatch `pulumi:"conditions"`
	// ControllerName is a domain/path string that indicates the name of the
	// controller that wrote this status. This corresponds with the
	// controllerName field on GatewayClass.
	//
	// Example: "example.net/gateway-controller".
	//
	// The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
	// valid Kubernetes names
	// (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
	//
	// Controllers MUST populate this field when writing status. Controllers should ensure that
	// entries to status populated with their ControllerName are cleaned up when they are no
	// longer necessary.
	ControllerName *string                               `pulumi:"controllerName"`
	ParentRef      *HTTPRouteStatusParentsParentRefPatch `pulumi:"parentRef"`
}

// HTTPRouteStatusParentsPatchInput is an input type that accepts HTTPRouteStatusParentsPatchArgs and HTTPRouteStatusParentsPatchOutput values.
// You can construct a concrete instance of `HTTPRouteStatusParentsPatchInput` via:
//
//	HTTPRouteStatusParentsPatchArgs{...}
type HTTPRouteStatusParentsPatchInput interface {
	pulumi.Input

	ToHTTPRouteStatusParentsPatchOutput() HTTPRouteStatusParentsPatchOutput
	ToHTTPRouteStatusParentsPatchOutputWithContext(context.Context) HTTPRouteStatusParentsPatchOutput
}

// RouteParentStatus describes the status of a route with respect to an
// associated Parent.
type HTTPRouteStatusParentsPatchArgs struct {
	// Conditions describes the status of the route with respect to the Gateway.
	// Note that the route's availability is also subject to the Gateway's own
	// status conditions and listener status.
	//
	// If the Route's ParentRef specifies an existing Gateway that supports
	// Routes of this kind AND that Gateway's controller has sufficient access,
	// then that Gateway's controller MUST set the "Accepted" condition on the
	// Route, to indicate whether the route has been accepted or rejected by the
	// Gateway, and why.
	//
	// A Route MUST be considered "Accepted" if at least one of the Route's
	// rules is implemented by the Gateway.
	//
	// There are a number of cases where the "Accepted" condition may not be set
	// due to lack of controller visibility, that includes when:
	//
	// * The Route refers to a non-existent parent.
	// * The Route is of a type that the controller does not support.
	// * The Route is in a namespace the controller does not have access to.
	Conditions HTTPRouteStatusParentsConditionsPatchArrayInput `pulumi:"conditions"`
	// ControllerName is a domain/path string that indicates the name of the
	// controller that wrote this status. This corresponds with the
	// controllerName field on GatewayClass.
	//
	// Example: "example.net/gateway-controller".
	//
	// The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
	// valid Kubernetes names
	// (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
	//
	// Controllers MUST populate this field when writing status. Controllers should ensure that
	// entries to status populated with their ControllerName are cleaned up when they are no
	// longer necessary.
	ControllerName pulumi.StringPtrInput                        `pulumi:"controllerName"`
	ParentRef      HTTPRouteStatusParentsParentRefPatchPtrInput `pulumi:"parentRef"`
}

func (HTTPRouteStatusParentsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteStatusParentsPatch)(nil)).Elem()
}

func (i HTTPRouteStatusParentsPatchArgs) ToHTTPRouteStatusParentsPatchOutput() HTTPRouteStatusParentsPatchOutput {
	return i.ToHTTPRouteStatusParentsPatchOutputWithContext(context.Background())
}

func (i HTTPRouteStatusParentsPatchArgs) ToHTTPRouteStatusParentsPatchOutputWithContext(ctx context.Context) HTTPRouteStatusParentsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteStatusParentsPatchOutput)
}

// HTTPRouteStatusParentsPatchArrayInput is an input type that accepts HTTPRouteStatusParentsPatchArray and HTTPRouteStatusParentsPatchArrayOutput values.
// You can construct a concrete instance of `HTTPRouteStatusParentsPatchArrayInput` via:
//
//	HTTPRouteStatusParentsPatchArray{ HTTPRouteStatusParentsPatchArgs{...} }
type HTTPRouteStatusParentsPatchArrayInput interface {
	pulumi.Input

	ToHTTPRouteStatusParentsPatchArrayOutput() HTTPRouteStatusParentsPatchArrayOutput
	ToHTTPRouteStatusParentsPatchArrayOutputWithContext(context.Context) HTTPRouteStatusParentsPatchArrayOutput
}

type HTTPRouteStatusParentsPatchArray []HTTPRouteStatusParentsPatchInput

func (HTTPRouteStatusParentsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteStatusParentsPatch)(nil)).Elem()
}

func (i HTTPRouteStatusParentsPatchArray) ToHTTPRouteStatusParentsPatchArrayOutput() HTTPRouteStatusParentsPatchArrayOutput {
	return i.ToHTTPRouteStatusParentsPatchArrayOutputWithContext(context.Background())
}

func (i HTTPRouteStatusParentsPatchArray) ToHTTPRouteStatusParentsPatchArrayOutputWithContext(ctx context.Context) HTTPRouteStatusParentsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteStatusParentsPatchArrayOutput)
}

// RouteParentStatus describes the status of a route with respect to an
// associated Parent.
type HTTPRouteStatusParentsPatchOutput struct{ *pulumi.OutputState }

func (HTTPRouteStatusParentsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteStatusParentsPatch)(nil)).Elem()
}

func (o HTTPRouteStatusParentsPatchOutput) ToHTTPRouteStatusParentsPatchOutput() HTTPRouteStatusParentsPatchOutput {
	return o
}

func (o HTTPRouteStatusParentsPatchOutput) ToHTTPRouteStatusParentsPatchOutputWithContext(ctx context.Context) HTTPRouteStatusParentsPatchOutput {
	return o
}

// Conditions describes the status of the route with respect to the Gateway.
// Note that the route's availability is also subject to the Gateway's own
// status conditions and listener status.
//
// If the Route's ParentRef specifies an existing Gateway that supports
// Routes of this kind AND that Gateway's controller has sufficient access,
// then that Gateway's controller MUST set the "Accepted" condition on the
// Route, to indicate whether the route has been accepted or rejected by the
// Gateway, and why.
//
// A Route MUST be considered "Accepted" if at least one of the Route's
// rules is implemented by the Gateway.
//
// There are a number of cases where the "Accepted" condition may not be set
// due to lack of controller visibility, that includes when:
//
// * The Route refers to a non-existent parent.
// * The Route is of a type that the controller does not support.
// * The Route is in a namespace the controller does not have access to.
func (o HTTPRouteStatusParentsPatchOutput) Conditions() HTTPRouteStatusParentsConditionsPatchArrayOutput {
	return o.ApplyT(func(v HTTPRouteStatusParentsPatch) []HTTPRouteStatusParentsConditionsPatch { return v.Conditions }).(HTTPRouteStatusParentsConditionsPatchArrayOutput)
}

// ControllerName is a domain/path string that indicates the name of the
// controller that wrote this status. This corresponds with the
// controllerName field on GatewayClass.
//
// Example: "example.net/gateway-controller".
//
// The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
// valid Kubernetes names
// (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
//
// Controllers MUST populate this field when writing status. Controllers should ensure that
// entries to status populated with their ControllerName are cleaned up when they are no
// longer necessary.
func (o HTTPRouteStatusParentsPatchOutput) ControllerName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPRouteStatusParentsPatch) *string { return v.ControllerName }).(pulumi.StringPtrOutput)
}

func (o HTTPRouteStatusParentsPatchOutput) ParentRef() HTTPRouteStatusParentsParentRefPatchPtrOutput {
	return o.ApplyT(func(v HTTPRouteStatusParentsPatch) *HTTPRouteStatusParentsParentRefPatch { return v.ParentRef }).(HTTPRouteStatusParentsParentRefPatchPtrOutput)
}

type HTTPRouteStatusParentsPatchArrayOutput struct{ *pulumi.OutputState }

func (HTTPRouteStatusParentsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPRouteStatusParentsPatch)(nil)).Elem()
}

func (o HTTPRouteStatusParentsPatchArrayOutput) ToHTTPRouteStatusParentsPatchArrayOutput() HTTPRouteStatusParentsPatchArrayOutput {
	return o
}

func (o HTTPRouteStatusParentsPatchArrayOutput) ToHTTPRouteStatusParentsPatchArrayOutputWithContext(ctx context.Context) HTTPRouteStatusParentsPatchArrayOutput {
	return o
}

func (o HTTPRouteStatusParentsPatchArrayOutput) Index(i pulumi.IntInput) HTTPRouteStatusParentsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPRouteStatusParentsPatch {
		return vs[0].([]HTTPRouteStatusParentsPatch)[vs[1].(int)]
	}).(HTTPRouteStatusParentsPatchOutput)
}

// Status defines the current state of HTTPRoute.
type HTTPRouteStatusPatch struct {
	// Parents is a list of parent resources (usually Gateways) that are
	// associated with the route, and the status of the route with respect to
	// each parent. When this route attaches to a parent, the controller that
	// manages the parent must add an entry to this list when the controller
	// first sees the route and should update the entry as appropriate when the
	// route or gateway is modified.
	//
	// Note that parent references that cannot be resolved by an implementation
	// of this API will not be added to this list. Implementations of this API
	// can only populate Route status for the Gateways/parent resources they are
	// responsible for.
	//
	// A maximum of 32 Gateways will be represented in this list. An empty list
	// means the route has not been attached to any Gateway.
	Parents []HTTPRouteStatusParentsPatch `pulumi:"parents"`
}

// HTTPRouteStatusPatchInput is an input type that accepts HTTPRouteStatusPatchArgs and HTTPRouteStatusPatchOutput values.
// You can construct a concrete instance of `HTTPRouteStatusPatchInput` via:
//
//	HTTPRouteStatusPatchArgs{...}
type HTTPRouteStatusPatchInput interface {
	pulumi.Input

	ToHTTPRouteStatusPatchOutput() HTTPRouteStatusPatchOutput
	ToHTTPRouteStatusPatchOutputWithContext(context.Context) HTTPRouteStatusPatchOutput
}

// Status defines the current state of HTTPRoute.
type HTTPRouteStatusPatchArgs struct {
	// Parents is a list of parent resources (usually Gateways) that are
	// associated with the route, and the status of the route with respect to
	// each parent. When this route attaches to a parent, the controller that
	// manages the parent must add an entry to this list when the controller
	// first sees the route and should update the entry as appropriate when the
	// route or gateway is modified.
	//
	// Note that parent references that cannot be resolved by an implementation
	// of this API will not be added to this list. Implementations of this API
	// can only populate Route status for the Gateways/parent resources they are
	// responsible for.
	//
	// A maximum of 32 Gateways will be represented in this list. An empty list
	// means the route has not been attached to any Gateway.
	Parents HTTPRouteStatusParentsPatchArrayInput `pulumi:"parents"`
}

func (HTTPRouteStatusPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteStatusPatch)(nil)).Elem()
}

func (i HTTPRouteStatusPatchArgs) ToHTTPRouteStatusPatchOutput() HTTPRouteStatusPatchOutput {
	return i.ToHTTPRouteStatusPatchOutputWithContext(context.Background())
}

func (i HTTPRouteStatusPatchArgs) ToHTTPRouteStatusPatchOutputWithContext(ctx context.Context) HTTPRouteStatusPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteStatusPatchOutput)
}

func (i HTTPRouteStatusPatchArgs) ToHTTPRouteStatusPatchPtrOutput() HTTPRouteStatusPatchPtrOutput {
	return i.ToHTTPRouteStatusPatchPtrOutputWithContext(context.Background())
}

func (i HTTPRouteStatusPatchArgs) ToHTTPRouteStatusPatchPtrOutputWithContext(ctx context.Context) HTTPRouteStatusPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteStatusPatchOutput).ToHTTPRouteStatusPatchPtrOutputWithContext(ctx)
}

// HTTPRouteStatusPatchPtrInput is an input type that accepts HTTPRouteStatusPatchArgs, HTTPRouteStatusPatchPtr and HTTPRouteStatusPatchPtrOutput values.
// You can construct a concrete instance of `HTTPRouteStatusPatchPtrInput` via:
//
//	        HTTPRouteStatusPatchArgs{...}
//
//	or:
//
//	        nil
type HTTPRouteStatusPatchPtrInput interface {
	pulumi.Input

	ToHTTPRouteStatusPatchPtrOutput() HTTPRouteStatusPatchPtrOutput
	ToHTTPRouteStatusPatchPtrOutputWithContext(context.Context) HTTPRouteStatusPatchPtrOutput
}

type httprouteStatusPatchPtrType HTTPRouteStatusPatchArgs

func HTTPRouteStatusPatchPtr(v *HTTPRouteStatusPatchArgs) HTTPRouteStatusPatchPtrInput {
	return (*httprouteStatusPatchPtrType)(v)
}

func (*httprouteStatusPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteStatusPatch)(nil)).Elem()
}

func (i *httprouteStatusPatchPtrType) ToHTTPRouteStatusPatchPtrOutput() HTTPRouteStatusPatchPtrOutput {
	return i.ToHTTPRouteStatusPatchPtrOutputWithContext(context.Background())
}

func (i *httprouteStatusPatchPtrType) ToHTTPRouteStatusPatchPtrOutputWithContext(ctx context.Context) HTTPRouteStatusPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPRouteStatusPatchPtrOutput)
}

// Status defines the current state of HTTPRoute.
type HTTPRouteStatusPatchOutput struct{ *pulumi.OutputState }

func (HTTPRouteStatusPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPRouteStatusPatch)(nil)).Elem()
}

func (o HTTPRouteStatusPatchOutput) ToHTTPRouteStatusPatchOutput() HTTPRouteStatusPatchOutput {
	return o
}

func (o HTTPRouteStatusPatchOutput) ToHTTPRouteStatusPatchOutputWithContext(ctx context.Context) HTTPRouteStatusPatchOutput {
	return o
}

func (o HTTPRouteStatusPatchOutput) ToHTTPRouteStatusPatchPtrOutput() HTTPRouteStatusPatchPtrOutput {
	return o.ToHTTPRouteStatusPatchPtrOutputWithContext(context.Background())
}

func (o HTTPRouteStatusPatchOutput) ToHTTPRouteStatusPatchPtrOutputWithContext(ctx context.Context) HTTPRouteStatusPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HTTPRouteStatusPatch) *HTTPRouteStatusPatch {
		return &v
	}).(HTTPRouteStatusPatchPtrOutput)
}

// Parents is a list of parent resources (usually Gateways) that are
// associated with the route, and the status of the route with respect to
// each parent. When this route attaches to a parent, the controller that
// manages the parent must add an entry to this list when the controller
// first sees the route and should update the entry as appropriate when the
// route or gateway is modified.
//
// Note that parent references that cannot be resolved by an implementation
// of this API will not be added to this list. Implementations of this API
// can only populate Route status for the Gateways/parent resources they are
// responsible for.
//
// A maximum of 32 Gateways will be represented in this list. An empty list
// means the route has not been attached to any Gateway.
func (o HTTPRouteStatusPatchOutput) Parents() HTTPRouteStatusParentsPatchArrayOutput {
	return o.ApplyT(func(v HTTPRouteStatusPatch) []HTTPRouteStatusParentsPatch { return v.Parents }).(HTTPRouteStatusParentsPatchArrayOutput)
}

type HTTPRouteStatusPatchPtrOutput struct{ *pulumi.OutputState }

func (HTTPRouteStatusPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPRouteStatusPatch)(nil)).Elem()
}

func (o HTTPRouteStatusPatchPtrOutput) ToHTTPRouteStatusPatchPtrOutput() HTTPRouteStatusPatchPtrOutput {
	return o
}

func (o HTTPRouteStatusPatchPtrOutput) ToHTTPRouteStatusPatchPtrOutputWithContext(ctx context.Context) HTTPRouteStatusPatchPtrOutput {
	return o
}

func (o HTTPRouteStatusPatchPtrOutput) Elem() HTTPRouteStatusPatchOutput {
	return o.ApplyT(func(v *HTTPRouteStatusPatch) HTTPRouteStatusPatch {
		if v != nil {
			return *v
		}
		var ret HTTPRouteStatusPatch
		return ret
	}).(HTTPRouteStatusPatchOutput)
}

// Parents is a list of parent resources (usually Gateways) that are
// associated with the route, and the status of the route with respect to
// each parent. When this route attaches to a parent, the controller that
// manages the parent must add an entry to this list when the controller
// first sees the route and should update the entry as appropriate when the
// route or gateway is modified.
//
// Note that parent references that cannot be resolved by an implementation
// of this API will not be added to this list. Implementations of this API
// can only populate Route status for the Gateways/parent resources they are
// responsible for.
//
// A maximum of 32 Gateways will be represented in this list. An empty list
// means the route has not been attached to any Gateway.
func (o HTTPRouteStatusPatchPtrOutput) Parents() HTTPRouteStatusParentsPatchArrayOutput {
	return o.ApplyT(func(v *HTTPRouteStatusPatch) []HTTPRouteStatusParentsPatch {
		if v == nil {
			return nil
		}
		return v.Parents
	}).(HTTPRouteStatusParentsPatchArrayOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteTypeInput)(nil)).Elem(), GRPCRouteTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteTypeArrayInput)(nil)).Elem(), GRPCRouteTypeArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteListTypeInput)(nil)).Elem(), GRPCRouteListTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRoutePatchTypeInput)(nil)).Elem(), GRPCRoutePatchTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecInput)(nil)).Elem(), GRPCRouteSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecPtrInput)(nil)).Elem(), GRPCRouteSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecParentRefsInput)(nil)).Elem(), GRPCRouteSpecParentRefsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecParentRefsArrayInput)(nil)).Elem(), GRPCRouteSpecParentRefsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecParentRefsPatchInput)(nil)).Elem(), GRPCRouteSpecParentRefsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecParentRefsPatchArrayInput)(nil)).Elem(), GRPCRouteSpecParentRefsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecPatchInput)(nil)).Elem(), GRPCRouteSpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecPatchPtrInput)(nil)).Elem(), GRPCRouteSpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesInput)(nil)).Elem(), GRPCRouteSpecRulesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesArrayInput)(nil)).Elem(), GRPCRouteSpecRulesArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsArrayInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsFiltersArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersArrayInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsFiltersArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersExtensionRefInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsFiltersExtensionRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsFiltersExtensionRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersPatchInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsFiltersPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersPatchArrayInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsFiltersPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsPatchInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsPatchArrayInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesFiltersInput)(nil)).Elem(), GRPCRouteSpecRulesFiltersArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesFiltersArrayInput)(nil)).Elem(), GRPCRouteSpecRulesFiltersArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesFiltersExtensionRefInput)(nil)).Elem(), GRPCRouteSpecRulesFiltersExtensionRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesFiltersExtensionRefPtrInput)(nil)).Elem(), GRPCRouteSpecRulesFiltersExtensionRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesFiltersExtensionRefPatchInput)(nil)).Elem(), GRPCRouteSpecRulesFiltersExtensionRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesFiltersExtensionRefPatchPtrInput)(nil)).Elem(), GRPCRouteSpecRulesFiltersExtensionRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesFiltersPatchInput)(nil)).Elem(), GRPCRouteSpecRulesFiltersPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesFiltersPatchArrayInput)(nil)).Elem(), GRPCRouteSpecRulesFiltersPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesFiltersRequestHeaderModifierInput)(nil)).Elem(), GRPCRouteSpecRulesFiltersRequestHeaderModifierArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrInput)(nil)).Elem(), GRPCRouteSpecRulesFiltersRequestHeaderModifierArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesFiltersRequestHeaderModifierAddInput)(nil)).Elem(), GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayInput)(nil)).Elem(), GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchInput)(nil)).Elem(), GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayInput)(nil)).Elem(), GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesFiltersRequestHeaderModifierPatchInput)(nil)).Elem(), GRPCRouteSpecRulesFiltersRequestHeaderModifierPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesFiltersRequestHeaderModifierPatchPtrInput)(nil)).Elem(), GRPCRouteSpecRulesFiltersRequestHeaderModifierPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesFiltersRequestHeaderModifierSetInput)(nil)).Elem(), GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayInput)(nil)).Elem(), GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchInput)(nil)).Elem(), GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayInput)(nil)).Elem(), GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesFiltersRequestMirrorInput)(nil)).Elem(), GRPCRouteSpecRulesFiltersRequestMirrorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesFiltersRequestMirrorPtrInput)(nil)).Elem(), GRPCRouteSpecRulesFiltersRequestMirrorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesFiltersRequestMirrorBackendRefInput)(nil)).Elem(), GRPCRouteSpecRulesFiltersRequestMirrorBackendRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrInput)(nil)).Elem(), GRPCRouteSpecRulesFiltersRequestMirrorBackendRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchInput)(nil)).Elem(), GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrInput)(nil)).Elem(), GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesFiltersRequestMirrorPatchInput)(nil)).Elem(), GRPCRouteSpecRulesFiltersRequestMirrorPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesFiltersRequestMirrorPatchPtrInput)(nil)).Elem(), GRPCRouteSpecRulesFiltersRequestMirrorPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesFiltersResponseHeaderModifierInput)(nil)).Elem(), GRPCRouteSpecRulesFiltersResponseHeaderModifierArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrInput)(nil)).Elem(), GRPCRouteSpecRulesFiltersResponseHeaderModifierArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesFiltersResponseHeaderModifierAddInput)(nil)).Elem(), GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayInput)(nil)).Elem(), GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchInput)(nil)).Elem(), GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayInput)(nil)).Elem(), GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesFiltersResponseHeaderModifierPatchInput)(nil)).Elem(), GRPCRouteSpecRulesFiltersResponseHeaderModifierPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesFiltersResponseHeaderModifierPatchPtrInput)(nil)).Elem(), GRPCRouteSpecRulesFiltersResponseHeaderModifierPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesFiltersResponseHeaderModifierSetInput)(nil)).Elem(), GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayInput)(nil)).Elem(), GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchInput)(nil)).Elem(), GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayInput)(nil)).Elem(), GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesMatchesInput)(nil)).Elem(), GRPCRouteSpecRulesMatchesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesMatchesArrayInput)(nil)).Elem(), GRPCRouteSpecRulesMatchesArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesMatchesHeadersInput)(nil)).Elem(), GRPCRouteSpecRulesMatchesHeadersArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesMatchesHeadersArrayInput)(nil)).Elem(), GRPCRouteSpecRulesMatchesHeadersArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesMatchesHeadersPatchInput)(nil)).Elem(), GRPCRouteSpecRulesMatchesHeadersPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesMatchesHeadersPatchArrayInput)(nil)).Elem(), GRPCRouteSpecRulesMatchesHeadersPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesMatchesMethodInput)(nil)).Elem(), GRPCRouteSpecRulesMatchesMethodArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesMatchesMethodPtrInput)(nil)).Elem(), GRPCRouteSpecRulesMatchesMethodArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesMatchesMethodPatchInput)(nil)).Elem(), GRPCRouteSpecRulesMatchesMethodPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesMatchesMethodPatchPtrInput)(nil)).Elem(), GRPCRouteSpecRulesMatchesMethodPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesMatchesPatchInput)(nil)).Elem(), GRPCRouteSpecRulesMatchesPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesMatchesPatchArrayInput)(nil)).Elem(), GRPCRouteSpecRulesMatchesPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesPatchInput)(nil)).Elem(), GRPCRouteSpecRulesPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesPatchArrayInput)(nil)).Elem(), GRPCRouteSpecRulesPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteStatusInput)(nil)).Elem(), GRPCRouteStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteStatusPtrInput)(nil)).Elem(), GRPCRouteStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteStatusParentsInput)(nil)).Elem(), GRPCRouteStatusParentsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteStatusParentsArrayInput)(nil)).Elem(), GRPCRouteStatusParentsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteStatusParentsConditionsInput)(nil)).Elem(), GRPCRouteStatusParentsConditionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteStatusParentsConditionsArrayInput)(nil)).Elem(), GRPCRouteStatusParentsConditionsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteStatusParentsConditionsPatchInput)(nil)).Elem(), GRPCRouteStatusParentsConditionsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteStatusParentsConditionsPatchArrayInput)(nil)).Elem(), GRPCRouteStatusParentsConditionsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteStatusParentsParentRefInput)(nil)).Elem(), GRPCRouteStatusParentsParentRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteStatusParentsParentRefPtrInput)(nil)).Elem(), GRPCRouteStatusParentsParentRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteStatusParentsParentRefPatchInput)(nil)).Elem(), GRPCRouteStatusParentsParentRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteStatusParentsParentRefPatchPtrInput)(nil)).Elem(), GRPCRouteStatusParentsParentRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteStatusParentsPatchInput)(nil)).Elem(), GRPCRouteStatusParentsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteStatusParentsPatchArrayInput)(nil)).Elem(), GRPCRouteStatusParentsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteStatusPatchInput)(nil)).Elem(), GRPCRouteStatusPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteStatusPatchPtrInput)(nil)).Elem(), GRPCRouteStatusPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayTypeInput)(nil)).Elem(), GatewayTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayTypeArrayInput)(nil)).Elem(), GatewayTypeArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayClassTypeInput)(nil)).Elem(), GatewayClassTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayClassTypeArrayInput)(nil)).Elem(), GatewayClassTypeArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayClassListTypeInput)(nil)).Elem(), GatewayClassListTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayClassPatchTypeInput)(nil)).Elem(), GatewayClassPatchTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayClassSpecInput)(nil)).Elem(), GatewayClassSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayClassSpecPtrInput)(nil)).Elem(), GatewayClassSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayClassSpecParametersRefInput)(nil)).Elem(), GatewayClassSpecParametersRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayClassSpecParametersRefPtrInput)(nil)).Elem(), GatewayClassSpecParametersRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayClassSpecParametersRefPatchInput)(nil)).Elem(), GatewayClassSpecParametersRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayClassSpecParametersRefPatchPtrInput)(nil)).Elem(), GatewayClassSpecParametersRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayClassSpecPatchInput)(nil)).Elem(), GatewayClassSpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayClassSpecPatchPtrInput)(nil)).Elem(), GatewayClassSpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayClassStatusInput)(nil)).Elem(), GatewayClassStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayClassStatusPtrInput)(nil)).Elem(), GatewayClassStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayClassStatusConditionsInput)(nil)).Elem(), GatewayClassStatusConditionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayClassStatusConditionsArrayInput)(nil)).Elem(), GatewayClassStatusConditionsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayClassStatusConditionsPatchInput)(nil)).Elem(), GatewayClassStatusConditionsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayClassStatusConditionsPatchArrayInput)(nil)).Elem(), GatewayClassStatusConditionsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayClassStatusPatchInput)(nil)).Elem(), GatewayClassStatusPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayClassStatusPatchPtrInput)(nil)).Elem(), GatewayClassStatusPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayListTypeInput)(nil)).Elem(), GatewayListTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayPatchTypeInput)(nil)).Elem(), GatewayPatchTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecInput)(nil)).Elem(), GatewaySpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecPtrInput)(nil)).Elem(), GatewaySpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecAddressesInput)(nil)).Elem(), GatewaySpecAddressesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecAddressesArrayInput)(nil)).Elem(), GatewaySpecAddressesArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecAddressesPatchInput)(nil)).Elem(), GatewaySpecAddressesPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecAddressesPatchArrayInput)(nil)).Elem(), GatewaySpecAddressesPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecListenersInput)(nil)).Elem(), GatewaySpecListenersArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecListenersArrayInput)(nil)).Elem(), GatewaySpecListenersArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecListenersAllowedRoutesInput)(nil)).Elem(), GatewaySpecListenersAllowedRoutesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecListenersAllowedRoutesPtrInput)(nil)).Elem(), GatewaySpecListenersAllowedRoutesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecListenersAllowedRoutesKindsInput)(nil)).Elem(), GatewaySpecListenersAllowedRoutesKindsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecListenersAllowedRoutesKindsArrayInput)(nil)).Elem(), GatewaySpecListenersAllowedRoutesKindsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecListenersAllowedRoutesKindsPatchInput)(nil)).Elem(), GatewaySpecListenersAllowedRoutesKindsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecListenersAllowedRoutesKindsPatchArrayInput)(nil)).Elem(), GatewaySpecListenersAllowedRoutesKindsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecListenersAllowedRoutesNamespacesInput)(nil)).Elem(), GatewaySpecListenersAllowedRoutesNamespacesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecListenersAllowedRoutesNamespacesPtrInput)(nil)).Elem(), GatewaySpecListenersAllowedRoutesNamespacesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecListenersAllowedRoutesNamespacesPatchInput)(nil)).Elem(), GatewaySpecListenersAllowedRoutesNamespacesPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecListenersAllowedRoutesNamespacesPatchPtrInput)(nil)).Elem(), GatewaySpecListenersAllowedRoutesNamespacesPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecListenersAllowedRoutesNamespacesSelectorInput)(nil)).Elem(), GatewaySpecListenersAllowedRoutesNamespacesSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrInput)(nil)).Elem(), GatewaySpecListenersAllowedRoutesNamespacesSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsInput)(nil)).Elem(), GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayInput)(nil)).Elem(), GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchInput)(nil)).Elem(), GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayInput)(nil)).Elem(), GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchInput)(nil)).Elem(), GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrInput)(nil)).Elem(), GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecListenersAllowedRoutesPatchInput)(nil)).Elem(), GatewaySpecListenersAllowedRoutesPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecListenersAllowedRoutesPatchPtrInput)(nil)).Elem(), GatewaySpecListenersAllowedRoutesPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecListenersPatchInput)(nil)).Elem(), GatewaySpecListenersPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecListenersPatchArrayInput)(nil)).Elem(), GatewaySpecListenersPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecListenersTlsInput)(nil)).Elem(), GatewaySpecListenersTlsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecListenersTlsPtrInput)(nil)).Elem(), GatewaySpecListenersTlsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecListenersTlsCertificateRefsInput)(nil)).Elem(), GatewaySpecListenersTlsCertificateRefsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecListenersTlsCertificateRefsArrayInput)(nil)).Elem(), GatewaySpecListenersTlsCertificateRefsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecListenersTlsCertificateRefsPatchInput)(nil)).Elem(), GatewaySpecListenersTlsCertificateRefsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecListenersTlsCertificateRefsPatchArrayInput)(nil)).Elem(), GatewaySpecListenersTlsCertificateRefsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecListenersTlsPatchInput)(nil)).Elem(), GatewaySpecListenersTlsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecListenersTlsPatchPtrInput)(nil)).Elem(), GatewaySpecListenersTlsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecPatchInput)(nil)).Elem(), GatewaySpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewaySpecPatchPtrInput)(nil)).Elem(), GatewaySpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayStatusInput)(nil)).Elem(), GatewayStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayStatusPtrInput)(nil)).Elem(), GatewayStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayStatusAddressesInput)(nil)).Elem(), GatewayStatusAddressesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayStatusAddressesArrayInput)(nil)).Elem(), GatewayStatusAddressesArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayStatusAddressesPatchInput)(nil)).Elem(), GatewayStatusAddressesPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayStatusAddressesPatchArrayInput)(nil)).Elem(), GatewayStatusAddressesPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayStatusConditionsInput)(nil)).Elem(), GatewayStatusConditionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayStatusConditionsArrayInput)(nil)).Elem(), GatewayStatusConditionsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayStatusConditionsPatchInput)(nil)).Elem(), GatewayStatusConditionsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayStatusConditionsPatchArrayInput)(nil)).Elem(), GatewayStatusConditionsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayStatusListenersInput)(nil)).Elem(), GatewayStatusListenersArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayStatusListenersArrayInput)(nil)).Elem(), GatewayStatusListenersArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayStatusListenersConditionsInput)(nil)).Elem(), GatewayStatusListenersConditionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayStatusListenersConditionsArrayInput)(nil)).Elem(), GatewayStatusListenersConditionsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayStatusListenersConditionsPatchInput)(nil)).Elem(), GatewayStatusListenersConditionsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayStatusListenersConditionsPatchArrayInput)(nil)).Elem(), GatewayStatusListenersConditionsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayStatusListenersPatchInput)(nil)).Elem(), GatewayStatusListenersPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayStatusListenersPatchArrayInput)(nil)).Elem(), GatewayStatusListenersPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayStatusListenersSupportedKindsInput)(nil)).Elem(), GatewayStatusListenersSupportedKindsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayStatusListenersSupportedKindsArrayInput)(nil)).Elem(), GatewayStatusListenersSupportedKindsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayStatusListenersSupportedKindsPatchInput)(nil)).Elem(), GatewayStatusListenersSupportedKindsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayStatusListenersSupportedKindsPatchArrayInput)(nil)).Elem(), GatewayStatusListenersSupportedKindsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayStatusPatchInput)(nil)).Elem(), GatewayStatusPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GatewayStatusPatchPtrInput)(nil)).Elem(), GatewayStatusPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteTypeInput)(nil)).Elem(), HTTPRouteTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteTypeArrayInput)(nil)).Elem(), HTTPRouteTypeArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteListTypeInput)(nil)).Elem(), HTTPRouteListTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRoutePatchTypeInput)(nil)).Elem(), HTTPRoutePatchTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecInput)(nil)).Elem(), HTTPRouteSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecPtrInput)(nil)).Elem(), HTTPRouteSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecParentRefsInput)(nil)).Elem(), HTTPRouteSpecParentRefsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecParentRefsArrayInput)(nil)).Elem(), HTTPRouteSpecParentRefsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecParentRefsPatchInput)(nil)).Elem(), HTTPRouteSpecParentRefsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecParentRefsPatchArrayInput)(nil)).Elem(), HTTPRouteSpecParentRefsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecPatchInput)(nil)).Elem(), HTTPRouteSpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecPatchPtrInput)(nil)).Elem(), HTTPRouteSpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesInput)(nil)).Elem(), HTTPRouteSpecRulesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesArrayInput)(nil)).Elem(), HTTPRouteSpecRulesArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsArrayInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersArrayInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersExtensionRefInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersExtensionRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersExtensionRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersPatchInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersPatchArrayInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsPatchInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesBackendRefsPatchArrayInput)(nil)).Elem(), HTTPRouteSpecRulesBackendRefsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersArrayInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersExtensionRefInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersExtensionRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersExtensionRefPtrInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersExtensionRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersExtensionRefPatchInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersExtensionRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersExtensionRefPatchPtrInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersExtensionRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersPatchInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersPatchArrayInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestHeaderModifierInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersRequestHeaderModifierArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersRequestHeaderModifierArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestHeaderModifierAddInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestHeaderModifierSetInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestMirrorInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersRequestMirrorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestMirrorPtrInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersRequestMirrorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestMirrorBackendRefInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersRequestMirrorBackendRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersRequestMirrorBackendRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestMirrorPatchInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersRequestMirrorPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestMirrorPatchPtrInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersRequestMirrorPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestRedirectInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersRequestRedirectArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestRedirectPtrInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersRequestRedirectArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestRedirectPatchInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersRequestRedirectPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestRedirectPatchPtrInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersRequestRedirectPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestRedirectPathInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersRequestRedirectPathArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestRedirectPathPtrInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersRequestRedirectPathArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestRedirectPathPatchInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersRequestRedirectPathPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersRequestRedirectPathPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersResponseHeaderModifierInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersResponseHeaderModifierArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersResponseHeaderModifierArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersResponseHeaderModifierAddInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersResponseHeaderModifierSetInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersUrlRewriteInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersUrlRewriteArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersUrlRewritePtrInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersUrlRewriteArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersUrlRewritePatchInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersUrlRewritePatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersUrlRewritePatchPtrInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersUrlRewritePatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersUrlRewritePathInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersUrlRewritePathArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersUrlRewritePathPtrInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersUrlRewritePathArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersUrlRewritePathPatchInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersUrlRewritePathPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrInput)(nil)).Elem(), HTTPRouteSpecRulesFiltersUrlRewritePathPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesMatchesInput)(nil)).Elem(), HTTPRouteSpecRulesMatchesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesMatchesArrayInput)(nil)).Elem(), HTTPRouteSpecRulesMatchesArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesMatchesHeadersInput)(nil)).Elem(), HTTPRouteSpecRulesMatchesHeadersArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesMatchesHeadersArrayInput)(nil)).Elem(), HTTPRouteSpecRulesMatchesHeadersArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesMatchesHeadersPatchInput)(nil)).Elem(), HTTPRouteSpecRulesMatchesHeadersPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesMatchesHeadersPatchArrayInput)(nil)).Elem(), HTTPRouteSpecRulesMatchesHeadersPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesMatchesPatchInput)(nil)).Elem(), HTTPRouteSpecRulesMatchesPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesMatchesPatchArrayInput)(nil)).Elem(), HTTPRouteSpecRulesMatchesPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesMatchesPathInput)(nil)).Elem(), HTTPRouteSpecRulesMatchesPathArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesMatchesPathPtrInput)(nil)).Elem(), HTTPRouteSpecRulesMatchesPathArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesMatchesPathPatchInput)(nil)).Elem(), HTTPRouteSpecRulesMatchesPathPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesMatchesPathPatchPtrInput)(nil)).Elem(), HTTPRouteSpecRulesMatchesPathPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesMatchesQueryParamsInput)(nil)).Elem(), HTTPRouteSpecRulesMatchesQueryParamsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesMatchesQueryParamsArrayInput)(nil)).Elem(), HTTPRouteSpecRulesMatchesQueryParamsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesMatchesQueryParamsPatchInput)(nil)).Elem(), HTTPRouteSpecRulesMatchesQueryParamsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesMatchesQueryParamsPatchArrayInput)(nil)).Elem(), HTTPRouteSpecRulesMatchesQueryParamsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesPatchInput)(nil)).Elem(), HTTPRouteSpecRulesPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteSpecRulesPatchArrayInput)(nil)).Elem(), HTTPRouteSpecRulesPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteStatusInput)(nil)).Elem(), HTTPRouteStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteStatusPtrInput)(nil)).Elem(), HTTPRouteStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteStatusParentsInput)(nil)).Elem(), HTTPRouteStatusParentsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteStatusParentsArrayInput)(nil)).Elem(), HTTPRouteStatusParentsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteStatusParentsConditionsInput)(nil)).Elem(), HTTPRouteStatusParentsConditionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteStatusParentsConditionsArrayInput)(nil)).Elem(), HTTPRouteStatusParentsConditionsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteStatusParentsConditionsPatchInput)(nil)).Elem(), HTTPRouteStatusParentsConditionsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteStatusParentsConditionsPatchArrayInput)(nil)).Elem(), HTTPRouteStatusParentsConditionsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteStatusParentsParentRefInput)(nil)).Elem(), HTTPRouteStatusParentsParentRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteStatusParentsParentRefPtrInput)(nil)).Elem(), HTTPRouteStatusParentsParentRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteStatusParentsParentRefPatchInput)(nil)).Elem(), HTTPRouteStatusParentsParentRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteStatusParentsParentRefPatchPtrInput)(nil)).Elem(), HTTPRouteStatusParentsParentRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteStatusParentsPatchInput)(nil)).Elem(), HTTPRouteStatusParentsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteStatusParentsPatchArrayInput)(nil)).Elem(), HTTPRouteStatusParentsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteStatusPatchInput)(nil)).Elem(), HTTPRouteStatusPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HTTPRouteStatusPatchPtrInput)(nil)).Elem(), HTTPRouteStatusPatchArgs{})
	pulumi.RegisterOutputType(GRPCRouteTypeOutput{})
	pulumi.RegisterOutputType(GRPCRouteTypeArrayOutput{})
	pulumi.RegisterOutputType(GRPCRouteListTypeOutput{})
	pulumi.RegisterOutputType(GRPCRoutePatchTypeOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecPtrOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecParentRefsOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecParentRefsArrayOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecParentRefsPatchOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecParentRefsPatchArrayOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecPatchOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecPatchPtrOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesArrayOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsArrayOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsFiltersOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsFiltersArrayOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsFiltersPatchOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsFiltersPatchArrayOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsPatchOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsPatchArrayOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesFiltersOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesFiltersArrayOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesFiltersExtensionRefOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesFiltersExtensionRefPtrOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesFiltersExtensionRefPatchOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesFiltersExtensionRefPatchPtrOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesFiltersPatchOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesFiltersPatchArrayOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesFiltersRequestHeaderModifierOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesFiltersRequestHeaderModifierAddOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesFiltersRequestHeaderModifierPatchOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesFiltersRequestHeaderModifierSetOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesFiltersRequestMirrorOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesFiltersRequestMirrorPtrOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesFiltersRequestMirrorPatchOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesFiltersRequestMirrorPatchPtrOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesFiltersResponseHeaderModifierOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesFiltersResponseHeaderModifierAddOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesFiltersResponseHeaderModifierPatchOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesFiltersResponseHeaderModifierSetOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesMatchesOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesMatchesArrayOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesMatchesHeadersOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesMatchesHeadersArrayOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesMatchesHeadersPatchOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesMatchesHeadersPatchArrayOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesMatchesMethodOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesMatchesMethodPtrOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesMatchesMethodPatchOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesMatchesMethodPatchPtrOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesMatchesPatchOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesMatchesPatchArrayOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesPatchOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesPatchArrayOutput{})
	pulumi.RegisterOutputType(GRPCRouteStatusOutput{})
	pulumi.RegisterOutputType(GRPCRouteStatusPtrOutput{})
	pulumi.RegisterOutputType(GRPCRouteStatusParentsOutput{})
	pulumi.RegisterOutputType(GRPCRouteStatusParentsArrayOutput{})
	pulumi.RegisterOutputType(GRPCRouteStatusParentsConditionsOutput{})
	pulumi.RegisterOutputType(GRPCRouteStatusParentsConditionsArrayOutput{})
	pulumi.RegisterOutputType(GRPCRouteStatusParentsConditionsPatchOutput{})
	pulumi.RegisterOutputType(GRPCRouteStatusParentsConditionsPatchArrayOutput{})
	pulumi.RegisterOutputType(GRPCRouteStatusParentsParentRefOutput{})
	pulumi.RegisterOutputType(GRPCRouteStatusParentsParentRefPtrOutput{})
	pulumi.RegisterOutputType(GRPCRouteStatusParentsParentRefPatchOutput{})
	pulumi.RegisterOutputType(GRPCRouteStatusParentsParentRefPatchPtrOutput{})
	pulumi.RegisterOutputType(GRPCRouteStatusParentsPatchOutput{})
	pulumi.RegisterOutputType(GRPCRouteStatusParentsPatchArrayOutput{})
	pulumi.RegisterOutputType(GRPCRouteStatusPatchOutput{})
	pulumi.RegisterOutputType(GRPCRouteStatusPatchPtrOutput{})
	pulumi.RegisterOutputType(GatewayTypeOutput{})
	pulumi.RegisterOutputType(GatewayTypeArrayOutput{})
	pulumi.RegisterOutputType(GatewayClassTypeOutput{})
	pulumi.RegisterOutputType(GatewayClassTypeArrayOutput{})
	pulumi.RegisterOutputType(GatewayClassListTypeOutput{})
	pulumi.RegisterOutputType(GatewayClassPatchTypeOutput{})
	pulumi.RegisterOutputType(GatewayClassSpecOutput{})
	pulumi.RegisterOutputType(GatewayClassSpecPtrOutput{})
	pulumi.RegisterOutputType(GatewayClassSpecParametersRefOutput{})
	pulumi.RegisterOutputType(GatewayClassSpecParametersRefPtrOutput{})
	pulumi.RegisterOutputType(GatewayClassSpecParametersRefPatchOutput{})
	pulumi.RegisterOutputType(GatewayClassSpecParametersRefPatchPtrOutput{})
	pulumi.RegisterOutputType(GatewayClassSpecPatchOutput{})
	pulumi.RegisterOutputType(GatewayClassSpecPatchPtrOutput{})
	pulumi.RegisterOutputType(GatewayClassStatusOutput{})
	pulumi.RegisterOutputType(GatewayClassStatusPtrOutput{})
	pulumi.RegisterOutputType(GatewayClassStatusConditionsOutput{})
	pulumi.RegisterOutputType(GatewayClassStatusConditionsArrayOutput{})
	pulumi.RegisterOutputType(GatewayClassStatusConditionsPatchOutput{})
	pulumi.RegisterOutputType(GatewayClassStatusConditionsPatchArrayOutput{})
	pulumi.RegisterOutputType(GatewayClassStatusPatchOutput{})
	pulumi.RegisterOutputType(GatewayClassStatusPatchPtrOutput{})
	pulumi.RegisterOutputType(GatewayListTypeOutput{})
	pulumi.RegisterOutputType(GatewayPatchTypeOutput{})
	pulumi.RegisterOutputType(GatewaySpecOutput{})
	pulumi.RegisterOutputType(GatewaySpecPtrOutput{})
	pulumi.RegisterOutputType(GatewaySpecAddressesOutput{})
	pulumi.RegisterOutputType(GatewaySpecAddressesArrayOutput{})
	pulumi.RegisterOutputType(GatewaySpecAddressesPatchOutput{})
	pulumi.RegisterOutputType(GatewaySpecAddressesPatchArrayOutput{})
	pulumi.RegisterOutputType(GatewaySpecListenersOutput{})
	pulumi.RegisterOutputType(GatewaySpecListenersArrayOutput{})
	pulumi.RegisterOutputType(GatewaySpecListenersAllowedRoutesOutput{})
	pulumi.RegisterOutputType(GatewaySpecListenersAllowedRoutesPtrOutput{})
	pulumi.RegisterOutputType(GatewaySpecListenersAllowedRoutesKindsOutput{})
	pulumi.RegisterOutputType(GatewaySpecListenersAllowedRoutesKindsArrayOutput{})
	pulumi.RegisterOutputType(GatewaySpecListenersAllowedRoutesKindsPatchOutput{})
	pulumi.RegisterOutputType(GatewaySpecListenersAllowedRoutesKindsPatchArrayOutput{})
	pulumi.RegisterOutputType(GatewaySpecListenersAllowedRoutesNamespacesOutput{})
	pulumi.RegisterOutputType(GatewaySpecListenersAllowedRoutesNamespacesPtrOutput{})
	pulumi.RegisterOutputType(GatewaySpecListenersAllowedRoutesNamespacesPatchOutput{})
	pulumi.RegisterOutputType(GatewaySpecListenersAllowedRoutesNamespacesPatchPtrOutput{})
	pulumi.RegisterOutputType(GatewaySpecListenersAllowedRoutesNamespacesSelectorOutput{})
	pulumi.RegisterOutputType(GatewaySpecListenersAllowedRoutesNamespacesSelectorPtrOutput{})
	pulumi.RegisterOutputType(GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput{})
	pulumi.RegisterOutputType(GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput{})
	pulumi.RegisterOutputType(GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchOutput{})
	pulumi.RegisterOutputType(GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayOutput{})
	pulumi.RegisterOutputType(GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchOutput{})
	pulumi.RegisterOutputType(GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput{})
	pulumi.RegisterOutputType(GatewaySpecListenersAllowedRoutesPatchOutput{})
	pulumi.RegisterOutputType(GatewaySpecListenersAllowedRoutesPatchPtrOutput{})
	pulumi.RegisterOutputType(GatewaySpecListenersPatchOutput{})
	pulumi.RegisterOutputType(GatewaySpecListenersPatchArrayOutput{})
	pulumi.RegisterOutputType(GatewaySpecListenersTlsOutput{})
	pulumi.RegisterOutputType(GatewaySpecListenersTlsPtrOutput{})
	pulumi.RegisterOutputType(GatewaySpecListenersTlsCertificateRefsOutput{})
	pulumi.RegisterOutputType(GatewaySpecListenersTlsCertificateRefsArrayOutput{})
	pulumi.RegisterOutputType(GatewaySpecListenersTlsCertificateRefsPatchOutput{})
	pulumi.RegisterOutputType(GatewaySpecListenersTlsCertificateRefsPatchArrayOutput{})
	pulumi.RegisterOutputType(GatewaySpecListenersTlsPatchOutput{})
	pulumi.RegisterOutputType(GatewaySpecListenersTlsPatchPtrOutput{})
	pulumi.RegisterOutputType(GatewaySpecPatchOutput{})
	pulumi.RegisterOutputType(GatewaySpecPatchPtrOutput{})
	pulumi.RegisterOutputType(GatewayStatusOutput{})
	pulumi.RegisterOutputType(GatewayStatusPtrOutput{})
	pulumi.RegisterOutputType(GatewayStatusAddressesOutput{})
	pulumi.RegisterOutputType(GatewayStatusAddressesArrayOutput{})
	pulumi.RegisterOutputType(GatewayStatusAddressesPatchOutput{})
	pulumi.RegisterOutputType(GatewayStatusAddressesPatchArrayOutput{})
	pulumi.RegisterOutputType(GatewayStatusConditionsOutput{})
	pulumi.RegisterOutputType(GatewayStatusConditionsArrayOutput{})
	pulumi.RegisterOutputType(GatewayStatusConditionsPatchOutput{})
	pulumi.RegisterOutputType(GatewayStatusConditionsPatchArrayOutput{})
	pulumi.RegisterOutputType(GatewayStatusListenersOutput{})
	pulumi.RegisterOutputType(GatewayStatusListenersArrayOutput{})
	pulumi.RegisterOutputType(GatewayStatusListenersConditionsOutput{})
	pulumi.RegisterOutputType(GatewayStatusListenersConditionsArrayOutput{})
	pulumi.RegisterOutputType(GatewayStatusListenersConditionsPatchOutput{})
	pulumi.RegisterOutputType(GatewayStatusListenersConditionsPatchArrayOutput{})
	pulumi.RegisterOutputType(GatewayStatusListenersPatchOutput{})
	pulumi.RegisterOutputType(GatewayStatusListenersPatchArrayOutput{})
	pulumi.RegisterOutputType(GatewayStatusListenersSupportedKindsOutput{})
	pulumi.RegisterOutputType(GatewayStatusListenersSupportedKindsArrayOutput{})
	pulumi.RegisterOutputType(GatewayStatusListenersSupportedKindsPatchOutput{})
	pulumi.RegisterOutputType(GatewayStatusListenersSupportedKindsPatchArrayOutput{})
	pulumi.RegisterOutputType(GatewayStatusPatchOutput{})
	pulumi.RegisterOutputType(GatewayStatusPatchPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteTypeOutput{})
	pulumi.RegisterOutputType(HTTPRouteTypeArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteListTypeOutput{})
	pulumi.RegisterOutputType(HTTPRoutePatchTypeOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecParentRefsOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecParentRefsArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecParentRefsPatchOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecParentRefsPatchArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecPatchOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecPatchPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersExtensionRefOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersPatchOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersPatchArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsPatchOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesBackendRefsPatchArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersExtensionRefOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersExtensionRefPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersExtensionRefPatchOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersExtensionRefPatchPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersPatchOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersPatchArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersRequestHeaderModifierOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersRequestHeaderModifierPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersRequestHeaderModifierAddOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersRequestHeaderModifierSetOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersRequestMirrorOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersRequestMirrorPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersRequestMirrorBackendRefOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersRequestMirrorPatchOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersRequestMirrorPatchPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersRequestRedirectOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersRequestRedirectPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersRequestRedirectPatchOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersRequestRedirectPatchPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersRequestRedirectPathOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersRequestRedirectPathPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersRequestRedirectPathPatchOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersRequestRedirectPathPatchPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersResponseHeaderModifierOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersResponseHeaderModifierPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersResponseHeaderModifierAddOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersResponseHeaderModifierSetOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersUrlRewriteOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersUrlRewritePtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersUrlRewritePatchOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersUrlRewritePatchPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersUrlRewritePathOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersUrlRewritePathPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersUrlRewritePathPatchOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesFiltersUrlRewritePathPatchPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesMatchesOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesMatchesArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesMatchesHeadersOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesMatchesHeadersArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesMatchesHeadersPatchOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesMatchesHeadersPatchArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesMatchesPatchOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesMatchesPatchArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesMatchesPathOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesMatchesPathPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesMatchesPathPatchOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesMatchesPathPatchPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesMatchesQueryParamsOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesMatchesQueryParamsArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesMatchesQueryParamsPatchOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesMatchesQueryParamsPatchArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesPatchOutput{})
	pulumi.RegisterOutputType(HTTPRouteSpecRulesPatchArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteStatusOutput{})
	pulumi.RegisterOutputType(HTTPRouteStatusPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteStatusParentsOutput{})
	pulumi.RegisterOutputType(HTTPRouteStatusParentsArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteStatusParentsConditionsOutput{})
	pulumi.RegisterOutputType(HTTPRouteStatusParentsConditionsArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteStatusParentsConditionsPatchOutput{})
	pulumi.RegisterOutputType(HTTPRouteStatusParentsConditionsPatchArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteStatusParentsParentRefOutput{})
	pulumi.RegisterOutputType(HTTPRouteStatusParentsParentRefPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteStatusParentsParentRefPatchOutput{})
	pulumi.RegisterOutputType(HTTPRouteStatusParentsParentRefPatchPtrOutput{})
	pulumi.RegisterOutputType(HTTPRouteStatusParentsPatchOutput{})
	pulumi.RegisterOutputType(HTTPRouteStatusParentsPatchArrayOutput{})
	pulumi.RegisterOutputType(HTTPRouteStatusPatchOutput{})
	pulumi.RegisterOutputType(HTTPRouteStatusPatchPtrOutput{})
}
