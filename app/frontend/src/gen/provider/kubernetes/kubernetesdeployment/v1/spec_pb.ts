// @generated by protoc-gen-es v2.2.2 with parameter "target=ts"
// @generated from file org/project_planton/provider/kubernetes/kubernetesdeployment/v1/spec.proto (package org.project_planton.provider.kubernetes.kubernetesdeployment.v1, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import { fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv1";
import { file_buf_validate_validate } from "../../../../../../buf/validate/validate_pb";
import type { Container, ContainerImage, ContainerResources } from "../../kubernetes_pb";
import { file_org_project_planton_provider_kubernetes_kubernetes } from "../../kubernetes_pb";
import { file_org_project_planton_provider_kubernetes_options } from "../../options_pb";
import type { Probe } from "../../probe_pb";
import { file_org_project_planton_provider_kubernetes_probe } from "../../probe_pb";
import type { KubernetesClusterSelector } from "../../target_cluster_pb";
import { file_org_project_planton_provider_kubernetes_target_cluster } from "../../target_cluster_pb";
import type { StringValueOrRef } from "../../../../shared/foreignkey/v1/foreign_key_pb";
import { file_org_project_planton_shared_foreignkey_v1_foreign_key } from "../../../../shared/foreignkey/v1/foreign_key_pb";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file org/project_planton/provider/kubernetes/kubernetesdeployment/v1/spec.proto.
 */
export const file_org_project_planton_provider_kubernetes_kubernetesdeployment_v1_spec: GenFile = /*@__PURE__*/
  fileDesc("CkpvcmcvcHJvamVjdF9wbGFudG9uL3Byb3ZpZGVyL2t1YmVybmV0ZXMva3ViZXJuZXRlc2RlcGxveW1lbnQvdjEvc3BlYy5wcm90bxI/b3JnLnByb2plY3RfcGxhbnRvbi5wcm92aWRlci5rdWJlcm5ldGVzLmt1YmVybmV0ZXNkZXBsb3ltZW50LnYxIqUGChhLdWJlcm5ldGVzRGVwbG95bWVudFNwZWMSWgoOdGFyZ2V0X2NsdXN0ZXIYASABKAsyQi5vcmcucHJvamVjdF9wbGFudG9uLnByb3ZpZGVyLmt1YmVybmV0ZXMuS3ViZXJuZXRlc0NsdXN0ZXJTZWxlY3RvchJnCgluYW1lc3BhY2UYAiABKAsyOi5vcmcucHJvamVjdF9wbGFudG9uLnNoYXJlZC5mb3JlaWdua2V5LnYxLlN0cmluZ1ZhbHVlT3JSZWZCGLpIA8gBAYjUYcQGktRhCXNwZWMubmFtZRLgAQoHdmVyc2lvbhgDIAEoCULOAbpIygG6AWwKEnNwZWMudmVyc2lvbi5jaGFycxI4T25seSBsb3dlcmNhc2UgbGV0dGVycywgbnVtYmVycywgYW5kIGh5cGhlbnMgYXJlIGFsbG93ZWQaHHRoaXMubWF0Y2hlcygnXlthLXowLTktXSskJym6AVIKHXNwZWMudmVyc2lvbi5uby1oeXBoZW4tZW5kaW5nEhpNdXN0IG5vdCBlbmQgd2l0aCBhIGh5cGhlbhoVdGhpcy5tYXRjaGVzKCdbXi1dJCcpcgQQARgeEnkKCWNvbnRhaW5lchgFIAEoCzJeLm9yZy5wcm9qZWN0X3BsYW50b24ucHJvdmlkZXIua3ViZXJuZXRlcy5rdWJlcm5ldGVzZGVwbG95bWVudC52MS5LdWJlcm5ldGVzRGVwbG95bWVudENvbnRhaW5lckIGukgDyAEBEm0KB2luZ3Jlc3MYBiABKAsyXC5vcmcucHJvamVjdF9wbGFudG9uLnByb3ZpZGVyLmt1YmVybmV0ZXMua3ViZXJuZXRlc2RlcGxveW1lbnQudjEuS3ViZXJuZXRlc0RlcGxveW1lbnRJbmdyZXNzEncKDGF2YWlsYWJpbGl0eRgHIAEoCzJhLm9yZy5wcm9qZWN0X3BsYW50b24ucHJvdmlkZXIua3ViZXJuZXRlcy5rdWJlcm5ldGVzZGVwbG95bWVudC52MS5LdWJlcm5ldGVzRGVwbG95bWVudEF2YWlsYWJpbGl0eSK/AQobS3ViZXJuZXRlc0RlcGxveW1lbnRJbmdyZXNzEg8KB2VuYWJsZWQYASABKAgSEAoIaG9zdG5hbWUYAiABKAk6fbpIehp4Ch5zcGVjLmluZ3Jlc3MuaG9zdG5hbWUucmVxdWlyZWQSLGhvc3RuYW1lIGlzIHJlcXVpcmVkIHdoZW4gaW5ncmVzcyBpcyBlbmFibGVkGighdGhpcy5lbmFibGVkIHx8IHNpemUodGhpcy5ob3N0bmFtZSkgPiAwIt0BCh1LdWJlcm5ldGVzRGVwbG95bWVudENvbnRhaW5lchJ2CgNhcHAYASABKAsyYS5vcmcucHJvamVjdF9wbGFudG9uLnByb3ZpZGVyLmt1YmVybmV0ZXMua3ViZXJuZXRlc2RlcGxveW1lbnQudjEuS3ViZXJuZXRlc0RlcGxveW1lbnRDb250YWluZXJBcHBCBrpIA8gBARJECghzaWRlY2FycxgCIAMoCzIyLm9yZy5wcm9qZWN0X3BsYW50b24ucHJvdmlkZXIua3ViZXJuZXRlcy5Db250YWluZXIi3wYKIEt1YmVybmV0ZXNEZXBsb3ltZW50Q29udGFpbmVyQXBwEoYCCgVpbWFnZRgBIAEoCzI3Lm9yZy5wcm9qZWN0X3BsYW50b24ucHJvdmlkZXIua3ViZXJuZXRlcy5Db250YWluZXJJbWFnZUK9AbpIuQG6AVoKHXNwZWMuY29udGFpbmVyLmFwcC5pbWFnZS5yZXBvEhZJbWFnZSByZXBvIGlzIHJlcXVpcmVkGiFoYXModGhpcy5yZXBvKSAmJiB0aGlzLnJlcG8gIT0gJye6AVYKHHNwZWMuY29udGFpbmVyLmFwcC5pbWFnZS50YWcSFUltYWdlIHRhZyBpcyByZXF1aXJlZBofaGFzKHRoaXMudGFnKSAmJiB0aGlzLnRhZyAhPSAnJ8gBARJxCglyZXNvdXJjZXMYAiABKAsyOy5vcmcucHJvamVjdF9wbGFudG9uLnByb3ZpZGVyLmt1YmVybmV0ZXMuQ29udGFpbmVyUmVzb3VyY2VzQiG6+6QCHAoMCgUxMDAwbRIDMUdpEgwKAzUwbRIFMTAwTWkScQoDZW52GAMgASgLMmQub3JnLnByb2plY3RfcGxhbnRvbi5wcm92aWRlci5rdWJlcm5ldGVzLmt1YmVybmV0ZXNkZXBsb3ltZW50LnYxLkt1YmVybmV0ZXNEZXBsb3ltZW50Q29udGFpbmVyQXBwRW52EnQKBXBvcnRzGAQgAygLMmUub3JnLnByb2plY3RfcGxhbnRvbi5wcm92aWRlci5rdWJlcm5ldGVzLmt1YmVybmV0ZXNkZXBsb3ltZW50LnYxLkt1YmVybmV0ZXNEZXBsb3ltZW50Q29udGFpbmVyQXBwUG9ydBJGCg5saXZlbmVzc19wcm9iZRgFIAEoCzIuLm9yZy5wcm9qZWN0X3BsYW50b24ucHJvdmlkZXIua3ViZXJuZXRlcy5Qcm9iZRJHCg9yZWFkaW5lc3NfcHJvYmUYBiABKAsyLi5vcmcucHJvamVjdF9wbGFudG9uLnByb3ZpZGVyLmt1YmVybmV0ZXMuUHJvYmUSRQoNc3RhcnR1cF9wcm9iZRgHIAEoCzIuLm9yZy5wcm9qZWN0X3BsYW50b24ucHJvdmlkZXIua3ViZXJuZXRlcy5Qcm9iZSKVAwojS3ViZXJuZXRlc0RlcGxveW1lbnRDb250YWluZXJBcHBFbnYShgEKCXZhcmlhYmxlcxgBIAMoCzJzLm9yZy5wcm9qZWN0X3BsYW50b24ucHJvdmlkZXIua3ViZXJuZXRlcy5rdWJlcm5ldGVzZGVwbG95bWVudC52MS5LdWJlcm5ldGVzRGVwbG95bWVudENvbnRhaW5lckFwcEVudi5WYXJpYWJsZXNFbnRyeRKCAQoHc2VjcmV0cxgCIAMoCzJxLm9yZy5wcm9qZWN0X3BsYW50b24ucHJvdmlkZXIua3ViZXJuZXRlcy5rdWJlcm5ldGVzZGVwbG95bWVudC52MS5LdWJlcm5ldGVzRGVwbG95bWVudENvbnRhaW5lckFwcEVudi5TZWNyZXRzRW50cnkaMAoOVmFyaWFibGVzRW50cnkSCwoDa2V5GAEgASgJEg0KBXZhbHVlGAIgASgJOgI4ARouCgxTZWNyZXRzRW50cnkSCwoDa2V5GAEgASgJEg0KBXZhbHVlGAIgASgJOgI4ASKaBQokS3ViZXJuZXRlc0RlcGxveW1lbnRDb250YWluZXJBcHBQb3J0EsoCCgRuYW1lGAEgASgJQrsCuki3AroBsAIKHXNwZWMuY29udGFpbmVyLmFwcC5wb3J0cy5uYW1lEuABTmFtZSBmb3IgcG9ydHMgbXVzdCBvbmx5IGNvbnRhaW4gbG93ZXJjYXNlIGFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzIGFuZCBoeXBoZW5zLiBQb3J0IG5hbWVzIG11c3QgYWxzbyBzdGFydCBhbmQgZW5kIHdpdGggYW4gYWxwaGFudW1lcmljIGNoYXJhY3Rlci4gRm9yIGV4YW1wbGUsICcxMjMtYWJjJyBhbmQgJ3dlYicgYXJlIHZhbGlkLCBidXQgJzEyM19hYmMnIGFuZCAnLXdlYicgYXJlIG5vdC4aLHRoaXMubWF0Y2hlcygnXlthLXowLTldW2EtejAtOS1dKlthLXowLTldJCcpyAEBEh4KDmNvbnRhaW5lcl9wb3J0GAIgASgFQga6SAPIAQESrwEKEG5ldHdvcmtfcHJvdG9jb2wYAyABKAlClAG6SJABugGJAQopc3BlYy5jb250YWluZXIuYXBwLnBvcnRzLm5ldHdvcmtfcHJvdG9jb2wSPFRoZSBuZXR3b3JrIHByb3RvY29sIG11c3QgYmUgb25lIG9mICJTQ1RQIiwgIlRDUCIsIG9yICJVRFAiLhoedGhpcyBpbiBbIlNDVFAiLCAiVENQIiwgIlVEUCJdyAEBEhwKDGFwcF9wcm90b2NvbBgEIAEoCUIGukgDyAEBEhwKDHNlcnZpY2VfcG9ydBgFIAEoBUIGukgDyAEBEhcKD2lzX2luZ3Jlc3NfcG9ydBgGIAEoCCLUAwogS3ViZXJuZXRlc0RlcGxveW1lbnRBdmFpbGFiaWxpdHkSFAoMbWluX3JlcGxpY2FzGAEgASgFEogBChpob3Jpem9udGFsX3BvZF9hdXRvc2NhbGluZxgCIAEoCzJkLm9yZy5wcm9qZWN0X3BsYW50b24ucHJvdmlkZXIua3ViZXJuZXRlcy5rdWJlcm5ldGVzZGVwbG95bWVudC52MS5LdWJlcm5ldGVzRGVwbG95bWVudEF2YWlsYWJpbGl0eUhwYRKEAQoTZGVwbG95bWVudF9zdHJhdGVneRgDIAEoCzJnLm9yZy5wcm9qZWN0X3BsYW50b24ucHJvdmlkZXIua3ViZXJuZXRlcy5rdWJlcm5ldGVzZGVwbG95bWVudC52MS5LdWJlcm5ldGVzRGVwbG95bWVudERlcGxveW1lbnRTdHJhdGVneRKHAQoVcG9kX2Rpc3J1cHRpb25fYnVkZ2V0GAQgASgLMmgub3JnLnByb2plY3RfcGxhbnRvbi5wcm92aWRlci5rdWJlcm5ldGVzLmt1YmVybmV0ZXNkZXBsb3ltZW50LnYxLkt1YmVybmV0ZXNEZXBsb3ltZW50UG9kRGlzcnVwdGlvbkJ1ZGdldCKEAQojS3ViZXJuZXRlc0RlcGxveW1lbnRBdmFpbGFiaWxpdHlIcGESEgoKaXNfZW5hYmxlZBgBIAEoCBImCh50YXJnZXRfY3B1X3V0aWxpemF0aW9uX3BlcmNlbnQYAiABKAESIQoZdGFyZ2V0X21lbW9yeV91dGlsaXphdGlvbhgDIAEoCSJUCiZLdWJlcm5ldGVzRGVwbG95bWVudERlcGxveW1lbnRTdHJhdGVneRIXCg9tYXhfdW5hdmFpbGFibGUYASABKAkSEQoJbWF4X3N1cmdlGAIgASgJImoKJ0t1YmVybmV0ZXNEZXBsb3ltZW50UG9kRGlzcnVwdGlvbkJ1ZGdldBIPCgdlbmFibGVkGAEgASgIEhUKDW1pbl9hdmFpbGFibGUYAiABKAkSFwoPbWF4X3VuYXZhaWxhYmxlGAMgASgJQvgDCkNjb20ub3JnLnByb2plY3RfcGxhbnRvbi5wcm92aWRlci5rdWJlcm5ldGVzLmt1YmVybmV0ZXNkZXBsb3ltZW50LnYxQglTcGVjUHJvdG9QAVqGAWdpdGh1Yi5jb20vcHJvamVjdC1wbGFudG9uL3Byb2plY3QtcGxhbnRvbi9hcGlzL29yZy9wcm9qZWN0X3BsYW50b24vcHJvdmlkZXIva3ViZXJuZXRlcy9rdWJlcm5ldGVzZGVwbG95bWVudC92MTtrdWJlcm5ldGVzZGVwbG95bWVudHYxogIFT1BQS0uqAj5PcmcuUHJvamVjdFBsYW50b24uUHJvdmlkZXIuS3ViZXJuZXRlcy5LdWJlcm5ldGVzZGVwbG95bWVudC5WMcoCPk9yZ1xQcm9qZWN0UGxhbnRvblxQcm92aWRlclxLdWJlcm5ldGVzXEt1YmVybmV0ZXNkZXBsb3ltZW50XFYx4gJKT3JnXFByb2plY3RQbGFudG9uXFByb3ZpZGVyXEt1YmVybmV0ZXNcS3ViZXJuZXRlc2RlcGxveW1lbnRcVjFcR1BCTWV0YWRhdGHqAkNPcmc6OlByb2plY3RQbGFudG9uOjpQcm92aWRlcjo6S3ViZXJuZXRlczo6S3ViZXJuZXRlc2RlcGxveW1lbnQ6OlYxYgZwcm90bzM", [file_buf_validate_validate, file_org_project_planton_provider_kubernetes_kubernetes, file_org_project_planton_provider_kubernetes_options, file_org_project_planton_provider_kubernetes_probe, file_org_project_planton_provider_kubernetes_target_cluster, file_org_project_planton_shared_foreignkey_v1_foreign_key]);

/**
 * *
 * **KubernetesDeploymentSpec** defines the configuration for deploying a microservice on a Kubernetes cluster.
 * This message includes specifications for the microservice version, container configurations, ingress settings,
 * and availability options for zero-downtime deployments.
 *
 * @generated from message org.project_planton.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentSpec
 */
export type KubernetesDeploymentSpec = Message<"org.project_planton.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentSpec"> & {
  /**
   * The Kubernetes cluster to install this microservice on.
   *
   * @generated from field: org.project_planton.provider.kubernetes.KubernetesClusterSelector target_cluster = 1;
   */
  targetCluster?: KubernetesClusterSelector;

  /**
   * Kubernetes namespace to install the microservice.
   *
   * @generated from field: org.project_planton.shared.foreignkey.v1.StringValueOrRef namespace = 2;
   */
  namespace?: StringValueOrRef;

  /**
   * The version of the microservice being deployed.
   * This is usually either "main" (the default git branch name) or "review-<id>" where <id> is the merge request number.
   * It must be between 1 and 30 characters and can only contain lowercase letters, numbers, and hyphens.
   *
   * @generated from field: string version = 3;
   */
  version: string;

  /**
   * The container specifications for the microservice deployment.
   * This includes configurations for the main application container and any sidecar containers.
   *
   * @generated from field: org.project_planton.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentContainer container = 5;
   */
  container?: KubernetesDeploymentContainer;

  /**
   * The ingress configuration for the microservice.
   * This defines how the microservice can be accessed externally.
   *
   * @generated from field: org.project_planton.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentIngress ingress = 6;
   */
  ingress?: KubernetesDeploymentIngress;

  /**
   * The availability configuration for the microservice.
   * This includes settings for replicas, autoscaling, deployment strategy, and pod disruption budgets.
   *
   * @generated from field: org.project_planton.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentAvailability availability = 7;
   */
  availability?: KubernetesDeploymentAvailability;
};

/**
 * Describes the message org.project_planton.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentSpec.
 * Use `create(KubernetesDeploymentSpecSchema)` to create a new message.
 */
export const KubernetesDeploymentSpecSchema: GenMessage<KubernetesDeploymentSpec> = /*@__PURE__*/
  messageDesc(file_org_project_planton_provider_kubernetes_kubernetesdeployment_v1_spec, 0);

/**
 * *
 * KubernetesDeploymentIngress defines ingress configuration for the deployment.
 *
 * @generated from message org.project_planton.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentIngress
 */
export type KubernetesDeploymentIngress = Message<"org.project_planton.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentIngress"> & {
  /**
   * Flag to enable or disable ingress.
   *
   * @generated from field: bool enabled = 1;
   */
  enabled: boolean;

  /**
   * The full hostname for external access (e.g., "myapp.example.com").
   * Required when enabled is true.
   *
   * @generated from field: string hostname = 2;
   */
  hostname: string;
};

/**
 * Describes the message org.project_planton.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentIngress.
 * Use `create(KubernetesDeploymentIngressSchema)` to create a new message.
 */
export const KubernetesDeploymentIngressSchema: GenMessage<KubernetesDeploymentIngress> = /*@__PURE__*/
  messageDesc(file_org_project_planton_provider_kubernetes_kubernetesdeployment_v1_spec, 1);

/**
 * *
 * **KubernetesDeploymentContainer** specifies the container configuration for the microservice.
 * It includes the main application container and any sidecar containers that need to run alongside it.
 *
 * @generated from message org.project_planton.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentContainer
 */
export type KubernetesDeploymentContainer = Message<"org.project_planton.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentContainer"> & {
  /**
   * The main application container specifications.
   *
   * @generated from field: org.project_planton.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentContainerApp app = 1;
   */
  app?: KubernetesDeploymentContainerApp;

  /**
   * A list of sidecar containers to be deployed alongside the main application container.
   *
   * @generated from field: repeated org.project_planton.provider.kubernetes.Container sidecars = 2;
   */
  sidecars: Container[];
};

/**
 * Describes the message org.project_planton.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentContainer.
 * Use `create(KubernetesDeploymentContainerSchema)` to create a new message.
 */
export const KubernetesDeploymentContainerSchema: GenMessage<KubernetesDeploymentContainer> = /*@__PURE__*/
  messageDesc(file_org_project_planton_provider_kubernetes_kubernetesdeployment_v1_spec, 2);

/**
 * *
 * **KubernetesDeploymentContainerApp** specifies the configuration for the main application container.
 * It includes the container image, resource allocations, environment variables, ports, and health probes.
 *
 * @generated from message org.project_planton.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentContainerApp
 */
export type KubernetesDeploymentContainerApp = Message<"org.project_planton.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentContainerApp"> & {
  /**
   * *
   * The container image to be used for the application.
   * This value is computed during creation but can be updated.
   * It is derived by combining the Docker repository of the artifact store configured for the environment and the code project path.
   * The `pull_secret_name` is the name of the image pull secret to be configured in the Kubernetes Deployment resource.
   * It is determined by looking up the `container_image_artifact_store_id` from the environment where the microservice is deployed.
   *
   * @generated from field: org.project_planton.provider.kubernetes.ContainerImage image = 1;
   */
  image?: ContainerImage;

  /**
   * The CPU and memory resources allocated to the application container.
   *
   * @generated from field: org.project_planton.provider.kubernetes.ContainerResources resources = 2;
   */
  resources?: ContainerResources;

  /**
   * *
   * The environment variables and secrets for the application container.
   *
   * @generated from field: org.project_planton.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentContainerAppEnv env = 3;
   */
  env?: KubernetesDeploymentContainerAppEnv;

  /**
   * *
   * A list of ports to be configured for the application container.
   *
   * @generated from field: repeated org.project_planton.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentContainerAppPort ports = 4;
   */
  ports: KubernetesDeploymentContainerAppPort[];

  /**
   * *
   * Liveness probe configuration.
   * Periodic probe of container liveness. Container will be restarted if the probe fails.
   * This helps detect and recover from deadlocks or unresponsive applications.
   * Reference: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
   *
   * @generated from field: org.project_planton.provider.kubernetes.Probe liveness_probe = 5;
   */
  livenessProbe?: Probe;

  /**
   * *
   * Readiness probe configuration.
   * Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails.
   * This ensures traffic is only routed to pods that are ready to handle requests.
   * Essential for zero-downtime deployments.
   * Reference: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
   *
   * @generated from field: org.project_planton.provider.kubernetes.Probe readiness_probe = 6;
   */
  readinessProbe?: Probe;

  /**
   * *
   * Startup probe configuration.
   * Indicates whether the application within the container is started.
   * All other probes are disabled if a startup probe is provided, until it succeeds.
   * Useful for slow-starting containers to avoid them getting killed by liveness probes before they are up.
   * Reference: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
   *
   * @generated from field: org.project_planton.provider.kubernetes.Probe startup_probe = 7;
   */
  startupProbe?: Probe;
};

/**
 * Describes the message org.project_planton.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentContainerApp.
 * Use `create(KubernetesDeploymentContainerAppSchema)` to create a new message.
 */
export const KubernetesDeploymentContainerAppSchema: GenMessage<KubernetesDeploymentContainerApp> = /*@__PURE__*/
  messageDesc(file_org_project_planton_provider_kubernetes_kubernetesdeployment_v1_spec, 3);

/**
 * *
 * **KubernetesDeploymentContainerAppEnv** defines the environment variables and secrets for the application container.
 *
 * @generated from message org.project_planton.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentContainerAppEnv
 */
export type KubernetesDeploymentContainerAppEnv = Message<"org.project_planton.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentContainerAppEnv"> & {
  /**
   * *
   * A map of environment variable names to their values.
   *
   * @generated from field: map<string, string> variables = 1;
   */
  variables: { [key: string]: string };

  /**
   * *
   * A map of secret names to their values.
   *
   * @generated from field: map<string, string> secrets = 2;
   */
  secrets: { [key: string]: string };
};

/**
 * Describes the message org.project_planton.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentContainerAppEnv.
 * Use `create(KubernetesDeploymentContainerAppEnvSchema)` to create a new message.
 */
export const KubernetesDeploymentContainerAppEnvSchema: GenMessage<KubernetesDeploymentContainerAppEnv> = /*@__PURE__*/
  messageDesc(file_org_project_planton_provider_kubernetes_kubernetesdeployment_v1_spec, 4);

/**
 * *
 * **KubernetesDeploymentContainerAppPort** specifies the port configuration for the application container.
 * It includes details such as the port name, container port, network protocol, application protocol, and service port.
 *
 * @generated from message org.project_planton.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentContainerAppPort
 */
export type KubernetesDeploymentContainerAppPort = Message<"org.project_planton.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentContainerAppPort"> & {
  /**
   * The name of the port (e.g., "http", "grpc").
   * The name must only contain lowercase alphanumeric characters and hyphens.
   * Port names must also start and end with an alphanumeric character.
   * For example, "123-abc" and "web" are valid, but "123_abc" and "-web" are not.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The port number on the container.
   *
   * @generated from field: int32 container_port = 2;
   */
  containerPort: number;

  /**
   * The network protocol used by the port (e.g., "TCP", "UDP", "SCTP").
   * Must be one of "TCP", "UDP", or "SCTP".
   *
   * @generated from field: string network_protocol = 3;
   */
  networkProtocol: string;

  /**
   * The application protocol for the microservice (e.g., "http").
   * This field is used for setting up the name of the service port in Kubernetes.
   * It is used during microservice deployment and is relevant for deployment and stateful set pod managers.
   * Refer to: https://kubernetes.io/docs/concepts/services-networking/service/#application-protocol
   *
   * @generated from field: string app_protocol = 4;
   */
  appProtocol: string;

  /**
   * The port number on the Kubernetes service.
   *
   * @generated from field: int32 service_port = 5;
   */
  servicePort: number;

  /**
   * A flag indicating whether this port should be exposed via ingress.
   *
   * @generated from field: bool is_ingress_port = 6;
   */
  isIngressPort: boolean;
};

/**
 * Describes the message org.project_planton.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentContainerAppPort.
 * Use `create(KubernetesDeploymentContainerAppPortSchema)` to create a new message.
 */
export const KubernetesDeploymentContainerAppPortSchema: GenMessage<KubernetesDeploymentContainerAppPort> = /*@__PURE__*/
  messageDesc(file_org_project_planton_provider_kubernetes_kubernetesdeployment_v1_spec, 5);

/**
 * *
 * **KubernetesDeploymentAvailability** specifies the availability configuration for the microservice.
 * Groups all settings related to high availability: replicas, autoscaling, deployment strategy, and disruption budgets.
 * Proper configuration of these fields enables zero-downtime deployments and resilient operations.
 *
 * @generated from message org.project_planton.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentAvailability
 */
export type KubernetesDeploymentAvailability = Message<"org.project_planton.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentAvailability"> & {
  /**
   * The minimum number of pod replicas to maintain.
   *
   * @generated from field: int32 min_replicas = 1;
   */
  minReplicas: number;

  /**
   * The configuration for horizontal pod autoscaling.
   *
   * @generated from field: org.project_planton.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentAvailabilityHpa horizontal_pod_autoscaling = 2;
   */
  horizontalPodAutoscaling?: KubernetesDeploymentAvailabilityHpa;

  /**
   * Deployment strategy configuration for rolling updates.
   * Controls how pod updates are rolled out to achieve zero-downtime deployments.
   * If not specified, uses Kubernetes default (maxUnavailable: 25%, maxSurge: 25%).
   *
   * @generated from field: org.project_planton.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentDeploymentStrategy deployment_strategy = 3;
   */
  deploymentStrategy?: KubernetesDeploymentDeploymentStrategy;

  /**
   * Pod disruption budget configuration.
   * Ensures minimum availability during voluntary disruptions (node maintenance, cluster upgrades).
   * Helps prevent service outages during infrastructure operations.
   *
   * @generated from field: org.project_planton.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentPodDisruptionBudget pod_disruption_budget = 4;
   */
  podDisruptionBudget?: KubernetesDeploymentPodDisruptionBudget;
};

/**
 * Describes the message org.project_planton.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentAvailability.
 * Use `create(KubernetesDeploymentAvailabilitySchema)` to create a new message.
 */
export const KubernetesDeploymentAvailabilitySchema: GenMessage<KubernetesDeploymentAvailability> = /*@__PURE__*/
  messageDesc(file_org_project_planton_provider_kubernetes_kubernetesdeployment_v1_spec, 6);

/**
 * *
 * **KubernetesDeploymentAvailabilityHpa** specifies the horizontal pod autoscaling configuration.
 * It includes settings to enable autoscaling based on CPU and memory utilization.
 *
 * @generated from message org.project_planton.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentAvailabilityHpa
 */
export type KubernetesDeploymentAvailabilityHpa = Message<"org.project_planton.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentAvailabilityHpa"> & {
  /**
   * A flag to enable or disable horizontal pod autoscaling.
   *
   * @generated from field: bool is_enabled = 1;
   */
  isEnabled: boolean;

  /**
   * The target CPU utilization percentage to trigger autoscaling (e.g., 60.0).
   *
   * @generated from field: double target_cpu_utilization_percent = 2;
   */
  targetCpuUtilizationPercent: number;

  /**
   * The target memory utilization to trigger autoscaling (e.g., "1Gi").
   *
   * @generated from field: string target_memory_utilization = 3;
   */
  targetMemoryUtilization: string;
};

/**
 * Describes the message org.project_planton.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentAvailabilityHpa.
 * Use `create(KubernetesDeploymentAvailabilityHpaSchema)` to create a new message.
 */
export const KubernetesDeploymentAvailabilityHpaSchema: GenMessage<KubernetesDeploymentAvailabilityHpa> = /*@__PURE__*/
  messageDesc(file_org_project_planton_provider_kubernetes_kubernetesdeployment_v1_spec, 7);

/**
 * *
 * **KubernetesDeploymentDeploymentStrategy** defines the deployment strategy for rolling updates.
 * This controls how Kubernetes replaces old pods with new ones during updates.
 * Proper configuration enables zero-downtime deployments.
 * Reference: https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#strategy
 *
 * @generated from message org.project_planton.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentDeploymentStrategy
 */
export type KubernetesDeploymentDeploymentStrategy = Message<"org.project_planton.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentDeploymentStrategy"> & {
  /**
   * *
   * The maximum number of pods that can be unavailable during the update.
   * Can be an absolute number (e.g., 0) or a percentage of desired pods (e.g., "25%").
   *
   * For zero-downtime deployments, set to 0 or "0%".
   * This ensures at least the desired number of pods are always available.
   *
   * Defaults to 25% if not specified.
   * Cannot be 0 if max_surge is also 0.
   *
   * @generated from field: string max_unavailable = 1;
   */
  maxUnavailable: string;

  /**
   * *
   * The maximum number of pods that can be created above the desired number of pods.
   * Can be an absolute number (e.g., 1) or a percentage of desired pods (e.g., "25%").
   *
   * For zero-downtime deployments with max_unavailable=0, set to at least 1 or "100%".
   * This allows new pods to be created before old ones are terminated.
   *
   * Defaults to 25% if not specified.
   * Cannot be 0 if max_unavailable is also 0.
   *
   * @generated from field: string max_surge = 2;
   */
  maxSurge: string;
};

/**
 * Describes the message org.project_planton.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentDeploymentStrategy.
 * Use `create(KubernetesDeploymentDeploymentStrategySchema)` to create a new message.
 */
export const KubernetesDeploymentDeploymentStrategySchema: GenMessage<KubernetesDeploymentDeploymentStrategy> = /*@__PURE__*/
  messageDesc(file_org_project_planton_provider_kubernetes_kubernetesdeployment_v1_spec, 8);

/**
 * *
 * **KubernetesDeploymentPodDisruptionBudget** configures a PodDisruptionBudget (PDB) to ensure
 * minimum availability during voluntary disruptions like node maintenance or cluster upgrades.
 * Reference: https://kubernetes.io/docs/concepts/workloads/pods/disruptions/
 *
 * @generated from message org.project_planton.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentPodDisruptionBudget
 */
export type KubernetesDeploymentPodDisruptionBudget = Message<"org.project_planton.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentPodDisruptionBudget"> & {
  /**
   * *
   * Enable or disable PodDisruptionBudget creation.
   * When disabled, no PDB is created and the cluster can evict pods freely.
   * When enabled, the cluster must respect the min_available constraint.
   *
   * @generated from field: bool enabled = 1;
   */
  enabled: boolean;

  /**
   * *
   * Minimum number of pods that must be available during voluntary disruptions.
   * Can be an absolute number (e.g., 1) or a percentage (e.g., "50%").
   *
   * For high availability, typically set to:
   * - 1 for single-replica services (ensures at least one pod always available)
   * - N-1 for N-replica services (allows one pod to be disrupted at a time)
   * - A percentage like "50%" for large replica counts
   *
   * Cannot be used together with max_unavailable.
   * If both min_available and max_unavailable are not set, defaults to 1.
   *
   * @generated from field: string min_available = 2;
   */
  minAvailable: string;

  /**
   * *
   * Maximum number of pods that can be unavailable during voluntary disruptions.
   * Can be an absolute number (e.g., 1) or a percentage (e.g., "50%").
   *
   * This is an alternative to min_available.
   * Cannot be used together with min_available.
   *
   * @generated from field: string max_unavailable = 3;
   */
  maxUnavailable: string;
};

/**
 * Describes the message org.project_planton.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentPodDisruptionBudget.
 * Use `create(KubernetesDeploymentPodDisruptionBudgetSchema)` to create a new message.
 */
export const KubernetesDeploymentPodDisruptionBudgetSchema: GenMessage<KubernetesDeploymentPodDisruptionBudget> = /*@__PURE__*/
  messageDesc(file_org_project_planton_provider_kubernetes_kubernetesdeployment_v1_spec, 9);

