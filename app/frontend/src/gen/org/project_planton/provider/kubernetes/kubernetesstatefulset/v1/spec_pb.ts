// @generated by protoc-gen-es v2.2.2 with parameter "target=ts"
// @generated from file org/project_planton/provider/kubernetes/kubernetesstatefulset/v1/spec.proto (package org.project_planton.provider.kubernetes.kubernetesstatefulset.v1, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import { fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv1";
import { file_buf_validate_validate } from "../../../../../../buf/validate/validate_pb";
import type { Container, ContainerImage, ContainerResources } from "../../kubernetes_pb";
import { file_org_project_planton_provider_kubernetes_kubernetes } from "../../kubernetes_pb";
import { file_org_project_planton_provider_kubernetes_options } from "../../options_pb";
import type { Probe } from "../../probe_pb";
import { file_org_project_planton_provider_kubernetes_probe } from "../../probe_pb";
import type { KubernetesClusterSelector } from "../../target_cluster_pb";
import { file_org_project_planton_provider_kubernetes_target_cluster } from "../../target_cluster_pb";
import type { StringValueOrRef } from "../../../../shared/foreignkey/v1/foreign_key_pb";
import { file_org_project_planton_shared_foreignkey_v1_foreign_key } from "../../../../shared/foreignkey/v1/foreign_key_pb";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file org/project_planton/provider/kubernetes/kubernetesstatefulset/v1/spec.proto.
 */
export const file_org_project_planton_provider_kubernetes_kubernetesstatefulset_v1_spec: GenFile = /*@__PURE__*/
  fileDesc("CktvcmcvcHJvamVjdF9wbGFudG9uL3Byb3ZpZGVyL2t1YmVybmV0ZXMva3ViZXJuZXRlc3N0YXRlZnVsc2V0L3YxL3NwZWMucHJvdG8SQG9yZy5wcm9qZWN0X3BsYW50b24ucHJvdmlkZXIua3ViZXJuZXRlcy5rdWJlcm5ldGVzc3RhdGVmdWxzZXQudjEiswcKGUt1YmVybmV0ZXNTdGF0ZWZ1bFNldFNwZWMSWgoOdGFyZ2V0X2NsdXN0ZXIYASABKAsyQi5vcmcucHJvamVjdF9wbGFudG9uLnByb3ZpZGVyLmt1YmVybmV0ZXMuS3ViZXJuZXRlc0NsdXN0ZXJTZWxlY3RvchJnCgluYW1lc3BhY2UYAiABKAsyOi5vcmcucHJvamVjdF9wbGFudG9uLnNoYXJlZC5mb3JlaWdua2V5LnYxLlN0cmluZ1ZhbHVlT3JSZWZCGLpIA8gBAYjUYcQGktRhCXNwZWMubmFtZRIYChBjcmVhdGVfbmFtZXNwYWNlGAMgASgIEnsKCWNvbnRhaW5lchgEIAEoCzJgLm9yZy5wcm9qZWN0X3BsYW50b24ucHJvdmlkZXIua3ViZXJuZXRlcy5rdWJlcm5ldGVzc3RhdGVmdWxzZXQudjEuS3ViZXJuZXRlc1N0YXRlZnVsU2V0Q29udGFpbmVyQga6SAPIAQESbwoHaW5ncmVzcxgFIAEoCzJeLm9yZy5wcm9qZWN0X3BsYW50b24ucHJvdmlkZXIua3ViZXJuZXRlcy5rdWJlcm5ldGVzc3RhdGVmdWxzZXQudjEuS3ViZXJuZXRlc1N0YXRlZnVsU2V0SW5ncmVzcxJ5CgxhdmFpbGFiaWxpdHkYBiABKAsyYy5vcmcucHJvamVjdF9wbGFudG9uLnByb3ZpZGVyLmt1YmVybmV0ZXMua3ViZXJuZXRlc3N0YXRlZnVsc2V0LnYxLkt1YmVybmV0ZXNTdGF0ZWZ1bFNldEF2YWlsYWJpbGl0eRKKAQoWdm9sdW1lX2NsYWltX3RlbXBsYXRlcxgHIAMoCzJqLm9yZy5wcm9qZWN0X3BsYW50b24ucHJvdmlkZXIua3ViZXJuZXRlcy5rdWJlcm5ldGVzc3RhdGVmdWxzZXQudjEuS3ViZXJuZXRlc1N0YXRlZnVsU2V0Vm9sdW1lQ2xhaW1UZW1wbGF0ZRLAAQoVcG9kX21hbmFnZW1lbnRfcG9saWN5GAggASgJQqABukicAboBmAEKGnNwZWMucG9kX21hbmFnZW1lbnRfcG9saWN5EkFQb2QgbWFuYWdlbWVudCBwb2xpY3kgbXVzdCBiZSBlaXRoZXIgIk9yZGVyZWRSZWFkeSIgb3IgIlBhcmFsbGVsIho3c2l6ZSh0aGlzKSA9PSAwIHx8IHRoaXMgaW4gWyJPcmRlcmVkUmVhZHkiLCAiUGFyYWxsZWwiXSLAAQocS3ViZXJuZXRlc1N0YXRlZnVsU2V0SW5ncmVzcxIPCgdlbmFibGVkGAEgASgIEhAKCGhvc3RuYW1lGAIgASgJOn26SHoaeAoec3BlYy5pbmdyZXNzLmhvc3RuYW1lLnJlcXVpcmVkEixob3N0bmFtZSBpcyByZXF1aXJlZCB3aGVuIGluZ3Jlc3MgaXMgZW5hYmxlZBooIXRoaXMuZW5hYmxlZCB8fCBzaXplKHRoaXMuaG9zdG5hbWUpID4gMCLgAQoeS3ViZXJuZXRlc1N0YXRlZnVsU2V0Q29udGFpbmVyEngKA2FwcBgBIAEoCzJjLm9yZy5wcm9qZWN0X3BsYW50b24ucHJvdmlkZXIua3ViZXJuZXRlcy5rdWJlcm5ldGVzc3RhdGVmdWxzZXQudjEuS3ViZXJuZXRlc1N0YXRlZnVsU2V0Q29udGFpbmVyQXBwQga6SAPIAQESRAoIc2lkZWNhcnMYAiADKAsyMi5vcmcucHJvamVjdF9wbGFudG9uLnByb3ZpZGVyLmt1YmVybmV0ZXMuQ29udGFpbmVyIogICiFLdWJlcm5ldGVzU3RhdGVmdWxTZXRDb250YWluZXJBcHAShgIKBWltYWdlGAEgASgLMjcub3JnLnByb2plY3RfcGxhbnRvbi5wcm92aWRlci5rdWJlcm5ldGVzLkNvbnRhaW5lckltYWdlQr0Buki5AboBWgodc3BlYy5jb250YWluZXIuYXBwLmltYWdlLnJlcG8SFkltYWdlIHJlcG8gaXMgcmVxdWlyZWQaIWhhcyh0aGlzLnJlcG8pICYmIHRoaXMucmVwbyAhPSAnJ7oBVgocc3BlYy5jb250YWluZXIuYXBwLmltYWdlLnRhZxIVSW1hZ2UgdGFnIGlzIHJlcXVpcmVkGh9oYXModGhpcy50YWcpICYmIHRoaXMudGFnICE9ICcnyAEBEnEKCXJlc291cmNlcxgCIAEoCzI7Lm9yZy5wcm9qZWN0X3BsYW50b24ucHJvdmlkZXIua3ViZXJuZXRlcy5Db250YWluZXJSZXNvdXJjZXNCIbr7pAIcCgwKBTEwMDBtEgMxR2kSDAoDNTBtEgUxMDBNaRJzCgNlbnYYAyABKAsyZi5vcmcucHJvamVjdF9wbGFudG9uLnByb3ZpZGVyLmt1YmVybmV0ZXMua3ViZXJuZXRlc3N0YXRlZnVsc2V0LnYxLkt1YmVybmV0ZXNTdGF0ZWZ1bFNldENvbnRhaW5lckFwcEVudhJ2CgVwb3J0cxgEIAMoCzJnLm9yZy5wcm9qZWN0X3BsYW50b24ucHJvdmlkZXIua3ViZXJuZXRlcy5rdWJlcm5ldGVzc3RhdGVmdWxzZXQudjEuS3ViZXJuZXRlc1N0YXRlZnVsU2V0Q29udGFpbmVyQXBwUG9ydBKCAQoNdm9sdW1lX21vdW50cxgFIAMoCzJrLm9yZy5wcm9qZWN0X3BsYW50b24ucHJvdmlkZXIua3ViZXJuZXRlcy5rdWJlcm5ldGVzc3RhdGVmdWxzZXQudjEuS3ViZXJuZXRlc1N0YXRlZnVsU2V0Q29udGFpbmVyVm9sdW1lTW91bnQSRgoObGl2ZW5lc3NfcHJvYmUYBiABKAsyLi5vcmcucHJvamVjdF9wbGFudG9uLnByb3ZpZGVyLmt1YmVybmV0ZXMuUHJvYmUSRwoPcmVhZGluZXNzX3Byb2JlGAcgASgLMi4ub3JnLnByb2plY3RfcGxhbnRvbi5wcm92aWRlci5rdWJlcm5ldGVzLlByb2JlEkUKDXN0YXJ0dXBfcHJvYmUYCCABKAsyLi5vcmcucHJvamVjdF9wbGFudG9uLnByb3ZpZGVyLmt1YmVybmV0ZXMuUHJvYmUSDwoHY29tbWFuZBgJIAMoCRIMCgRhcmdzGAogAygJIpoDCiRLdWJlcm5ldGVzU3RhdGVmdWxTZXRDb250YWluZXJBcHBFbnYSiAEKCXZhcmlhYmxlcxgBIAMoCzJ1Lm9yZy5wcm9qZWN0X3BsYW50b24ucHJvdmlkZXIua3ViZXJuZXRlcy5rdWJlcm5ldGVzc3RhdGVmdWxzZXQudjEuS3ViZXJuZXRlc1N0YXRlZnVsU2V0Q29udGFpbmVyQXBwRW52LlZhcmlhYmxlc0VudHJ5EoQBCgdzZWNyZXRzGAIgAygLMnMub3JnLnByb2plY3RfcGxhbnRvbi5wcm92aWRlci5rdWJlcm5ldGVzLmt1YmVybmV0ZXNzdGF0ZWZ1bHNldC52MS5LdWJlcm5ldGVzU3RhdGVmdWxTZXRDb250YWluZXJBcHBFbnYuU2VjcmV0c0VudHJ5GjAKDlZhcmlhYmxlc0VudHJ5EgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEoCToCOAEaLgoMU2VjcmV0c0VudHJ5EgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEoCToCOAEizQQKJUt1YmVybmV0ZXNTdGF0ZWZ1bFNldENvbnRhaW5lckFwcFBvcnQS/AEKBG5hbWUYASABKAlC7QG6SOkBugHiAQodc3BlYy5jb250YWluZXIuYXBwLnBvcnRzLm5hbWUSkgFOYW1lIGZvciBwb3J0cyBtdXN0IG9ubHkgY29udGFpbiBsb3dlcmNhc2UgYWxwaGFudW1lcmljIGNoYXJhY3RlcnMgYW5kIGh5cGhlbnMuIFBvcnQgbmFtZXMgbXVzdCBhbHNvIHN0YXJ0IGFuZCBlbmQgd2l0aCBhbiBhbHBoYW51bWVyaWMgY2hhcmFjdGVyLhosdGhpcy5tYXRjaGVzKCdeW2EtejAtOV1bYS16MC05LV0qW2EtejAtOV0kJynIAQESHgoOY29udGFpbmVyX3BvcnQYAiABKAVCBrpIA8gBARKvAQoQbmV0d29ya19wcm90b2NvbBgDIAEoCUKUAbpIkAG6AYkBCilzcGVjLmNvbnRhaW5lci5hcHAucG9ydHMubmV0d29ya19wcm90b2NvbBI8VGhlIG5ldHdvcmsgcHJvdG9jb2wgbXVzdCBiZSBvbmUgb2YgIlNDVFAiLCAiVENQIiwgb3IgIlVEUCIuGh50aGlzIGluIFsiU0NUUCIsICJUQ1AiLCAiVURQIl3IAQESHAoMYXBwX3Byb3RvY29sGAQgASgJQga6SAPIAQESHAoMc2VydmljZV9wb3J0GAUgASgFQga6SAPIAQESFwoPaXNfaW5ncmVzc19wb3J0GAYgASgIIoIBCilLdWJlcm5ldGVzU3RhdGVmdWxTZXRDb250YWluZXJWb2x1bWVNb3VudBIUCgRuYW1lGAEgASgJQga6SAPIAQESGgoKbW91bnRfcGF0aBgCIAEoCUIGukgDyAEBEhEKCXJlYWRfb25seRgDIAEoCBIQCghzdWJfcGF0aBgEIAEoCSLBAQohS3ViZXJuZXRlc1N0YXRlZnVsU2V0QXZhaWxhYmlsaXR5EhAKCHJlcGxpY2FzGAEgASgFEokBChVwb2RfZGlzcnVwdGlvbl9idWRnZXQYAiABKAsyai5vcmcucHJvamVjdF9wbGFudG9uLnByb3ZpZGVyLmt1YmVybmV0ZXMua3ViZXJuZXRlc3N0YXRlZnVsc2V0LnYxLkt1YmVybmV0ZXNTdGF0ZWZ1bFNldFBvZERpc3J1cHRpb25CdWRnZXQiawooS3ViZXJuZXRlc1N0YXRlZnVsU2V0UG9kRGlzcnVwdGlvbkJ1ZGdldBIPCgdlbmFibGVkGAEgASgIEhUKDW1pbl9hdmFpbGFibGUYAiABKAkSFwoPbWF4X3VuYXZhaWxhYmxlGAMgASgJIpYECihLdWJlcm5ldGVzU3RhdGVmdWxTZXRWb2x1bWVDbGFpbVRlbXBsYXRlEhQKBG5hbWUYASABKAlCBrpIA8gBARIVCg1zdG9yYWdlX2NsYXNzGAIgASgJEp4BCgRzaXplGAMgASgJQo8BukiLAboBhAEKIHNwZWMudm9sdW1lX2NsYWltX3RlbXBsYXRlcy5zaXplEjxTaXplIG11c3QgYmUgYSB2YWxpZCBLdWJlcm5ldGVzIHF1YW50aXR5IChlLmcuLCAxMEdpLCAxMDBNaSkaInRoaXMubWF0Y2hlcygnXlswLTldK1tFUFRHTUtdaT8kJynIAQESmwIKDGFjY2Vzc19tb2RlcxgEIAMoCUKEArpIgAK6AfwBCihzcGVjLnZvbHVtZV9jbGFpbV90ZW1wbGF0ZXMuYWNjZXNzX21vZGVzEmNBY2Nlc3MgbW9kZXMgbXVzdCBiZSBvbmUgb2YgIlJlYWRXcml0ZU9uY2UiLCAiUmVhZE9ubHlNYW55IiwgIlJlYWRXcml0ZU1hbnkiLCBvciAiUmVhZFdyaXRlT25jZVBvZCIaa3NpemUodGhpcykgPT0gMCB8fCB0aGlzLmFsbChtLCBtIGluIFsiUmVhZFdyaXRlT25jZSIsICJSZWFkT25seU1hbnkiLCAiUmVhZFdyaXRlTWFueSIsICJSZWFkV3JpdGVPbmNlUG9kIl0pQv8DCkRjb20ub3JnLnByb2plY3RfcGxhbnRvbi5wcm92aWRlci5rdWJlcm5ldGVzLmt1YmVybmV0ZXNzdGF0ZWZ1bHNldC52MUIJU3BlY1Byb3RvUAFaiAFnaXRodWIuY29tL3Byb2plY3QtcGxhbnRvbi9wcm9qZWN0LXBsYW50b24vYXBpcy9vcmcvcHJvamVjdF9wbGFudG9uL3Byb3ZpZGVyL2t1YmVybmV0ZXMva3ViZXJuZXRlc3N0YXRlZnVsc2V0L3YxO2t1YmVybmV0ZXNzdGF0ZWZ1bHNldHYxogIFT1BQS0uqAj9PcmcuUHJvamVjdFBsYW50b24uUHJvdmlkZXIuS3ViZXJuZXRlcy5LdWJlcm5ldGVzc3RhdGVmdWxzZXQuVjHKAj9PcmdcUHJvamVjdFBsYW50b25cUHJvdmlkZXJcS3ViZXJuZXRlc1xLdWJlcm5ldGVzc3RhdGVmdWxzZXRcVjHiAktPcmdcUHJvamVjdFBsYW50b25cUHJvdmlkZXJcS3ViZXJuZXRlc1xLdWJlcm5ldGVzc3RhdGVmdWxzZXRcVjFcR1BCTWV0YWRhdGHqAkRPcmc6OlByb2plY3RQbGFudG9uOjpQcm92aWRlcjo6S3ViZXJuZXRlczo6S3ViZXJuZXRlc3N0YXRlZnVsc2V0OjpWMWIGcHJvdG8z", [file_buf_validate_validate, file_org_project_planton_provider_kubernetes_kubernetes, file_org_project_planton_provider_kubernetes_options, file_org_project_planton_provider_kubernetes_probe, file_org_project_planton_provider_kubernetes_target_cluster, file_org_project_planton_shared_foreignkey_v1_foreign_key]);

/**
 * *
 * **KubernetesStatefulSetSpec** defines the configuration for deploying a stateful application on a Kubernetes cluster.
 * StatefulSets are designed for applications that require:
 * - Stable, unique network identifiers
 * - Stable, persistent storage
 * - Ordered, graceful deployment and scaling
 * - Ordered, automated rolling updates
 *
 * Use cases include databases, distributed systems, and any application requiring persistent identity.
 *
 * @generated from message org.project_planton.provider.kubernetes.kubernetesstatefulset.v1.KubernetesStatefulSetSpec
 */
export type KubernetesStatefulSetSpec = Message<"org.project_planton.provider.kubernetes.kubernetesstatefulset.v1.KubernetesStatefulSetSpec"> & {
  /**
   * Target Kubernetes Cluster
   *
   * @generated from field: org.project_planton.provider.kubernetes.KubernetesClusterSelector target_cluster = 1;
   */
  targetCluster?: KubernetesClusterSelector;

  /**
   * Kubernetes Namespace
   *
   * @generated from field: org.project_planton.shared.foreignkey.v1.StringValueOrRef namespace = 2;
   */
  namespace?: StringValueOrRef;

  /**
   * Flag to indicate if the namespace should be created
   *
   * @generated from field: bool create_namespace = 3;
   */
  createNamespace: boolean;

  /**
   * The container specifications for the stateful set.
   * This includes configurations for the main application container and any sidecar containers.
   *
   * @generated from field: org.project_planton.provider.kubernetes.kubernetesstatefulset.v1.KubernetesStatefulSetContainer container = 4;
   */
  container?: KubernetesStatefulSetContainer;

  /**
   * The ingress configuration for the stateful set.
   * This defines how the stateful set can be accessed externally.
   *
   * @generated from field: org.project_planton.provider.kubernetes.kubernetesstatefulset.v1.KubernetesStatefulSetIngress ingress = 5;
   */
  ingress?: KubernetesStatefulSetIngress;

  /**
   * The availability configuration for the stateful set.
   * This includes settings for replicas and pod management policy.
   *
   * @generated from field: org.project_planton.provider.kubernetes.kubernetesstatefulset.v1.KubernetesStatefulSetAvailability availability = 6;
   */
  availability?: KubernetesStatefulSetAvailability;

  /**
   * Persistent volume claims for the stateful set.
   * Each pod in the stateful set gets its own PVC based on these templates.
   *
   * @generated from field: repeated org.project_planton.provider.kubernetes.kubernetesstatefulset.v1.KubernetesStatefulSetVolumeClaimTemplate volume_claim_templates = 7;
   */
  volumeClaimTemplates: KubernetesStatefulSetVolumeClaimTemplate[];

  /**
   * Pod management policy for the stateful set.
   * "OrderedReady" (default): Pods are created in order and wait for previous pod to be ready.
   * "Parallel": All pods are created/deleted simultaneously.
   *
   * @generated from field: string pod_management_policy = 8;
   */
  podManagementPolicy: string;
};

/**
 * Describes the message org.project_planton.provider.kubernetes.kubernetesstatefulset.v1.KubernetesStatefulSetSpec.
 * Use `create(KubernetesStatefulSetSpecSchema)` to create a new message.
 */
export const KubernetesStatefulSetSpecSchema: GenMessage<KubernetesStatefulSetSpec> = /*@__PURE__*/
  messageDesc(file_org_project_planton_provider_kubernetes_kubernetesstatefulset_v1_spec, 0);

/**
 * *
 * KubernetesStatefulSetIngress defines ingress configuration for the stateful set.
 *
 * @generated from message org.project_planton.provider.kubernetes.kubernetesstatefulset.v1.KubernetesStatefulSetIngress
 */
export type KubernetesStatefulSetIngress = Message<"org.project_planton.provider.kubernetes.kubernetesstatefulset.v1.KubernetesStatefulSetIngress"> & {
  /**
   * Flag to enable or disable ingress.
   *
   * @generated from field: bool enabled = 1;
   */
  enabled: boolean;

  /**
   * The full hostname for external access (e.g., "myapp.example.com").
   * Required when enabled is true.
   *
   * @generated from field: string hostname = 2;
   */
  hostname: string;
};

/**
 * Describes the message org.project_planton.provider.kubernetes.kubernetesstatefulset.v1.KubernetesStatefulSetIngress.
 * Use `create(KubernetesStatefulSetIngressSchema)` to create a new message.
 */
export const KubernetesStatefulSetIngressSchema: GenMessage<KubernetesStatefulSetIngress> = /*@__PURE__*/
  messageDesc(file_org_project_planton_provider_kubernetes_kubernetesstatefulset_v1_spec, 1);

/**
 * *
 * **KubernetesStatefulSetContainer** specifies the container configuration for the stateful set.
 * It includes the main application container and any sidecar containers that need to run alongside it.
 *
 * @generated from message org.project_planton.provider.kubernetes.kubernetesstatefulset.v1.KubernetesStatefulSetContainer
 */
export type KubernetesStatefulSetContainer = Message<"org.project_planton.provider.kubernetes.kubernetesstatefulset.v1.KubernetesStatefulSetContainer"> & {
  /**
   * The main application container specifications.
   *
   * @generated from field: org.project_planton.provider.kubernetes.kubernetesstatefulset.v1.KubernetesStatefulSetContainerApp app = 1;
   */
  app?: KubernetesStatefulSetContainerApp;

  /**
   * A list of sidecar containers to be deployed alongside the main application container.
   *
   * @generated from field: repeated org.project_planton.provider.kubernetes.Container sidecars = 2;
   */
  sidecars: Container[];
};

/**
 * Describes the message org.project_planton.provider.kubernetes.kubernetesstatefulset.v1.KubernetesStatefulSetContainer.
 * Use `create(KubernetesStatefulSetContainerSchema)` to create a new message.
 */
export const KubernetesStatefulSetContainerSchema: GenMessage<KubernetesStatefulSetContainer> = /*@__PURE__*/
  messageDesc(file_org_project_planton_provider_kubernetes_kubernetesstatefulset_v1_spec, 2);

/**
 * *
 * **KubernetesStatefulSetContainerApp** specifies the configuration for the main application container.
 * It includes the container image, resource allocations, environment variables, ports, volume mounts, and health probes.
 *
 * @generated from message org.project_planton.provider.kubernetes.kubernetesstatefulset.v1.KubernetesStatefulSetContainerApp
 */
export type KubernetesStatefulSetContainerApp = Message<"org.project_planton.provider.kubernetes.kubernetesstatefulset.v1.KubernetesStatefulSetContainerApp"> & {
  /**
   * *
   * The container image to be used for the application.
   * The `pull_secret_name` is the name of the image pull secret to be configured in the Kubernetes StatefulSet resource.
   *
   * @generated from field: org.project_planton.provider.kubernetes.ContainerImage image = 1;
   */
  image?: ContainerImage;

  /**
   * The CPU and memory resources allocated to the application container.
   *
   * @generated from field: org.project_planton.provider.kubernetes.ContainerResources resources = 2;
   */
  resources?: ContainerResources;

  /**
   * *
   * The environment variables and secrets for the application container.
   *
   * @generated from field: org.project_planton.provider.kubernetes.kubernetesstatefulset.v1.KubernetesStatefulSetContainerAppEnv env = 3;
   */
  env?: KubernetesStatefulSetContainerAppEnv;

  /**
   * *
   * A list of ports to be configured for the application container.
   *
   * @generated from field: repeated org.project_planton.provider.kubernetes.kubernetesstatefulset.v1.KubernetesStatefulSetContainerAppPort ports = 4;
   */
  ports: KubernetesStatefulSetContainerAppPort[];

  /**
   * *
   * Volume mounts for the application container.
   * These mount the persistent volumes defined in volume_claim_templates.
   *
   * @generated from field: repeated org.project_planton.provider.kubernetes.kubernetesstatefulset.v1.KubernetesStatefulSetContainerVolumeMount volume_mounts = 5;
   */
  volumeMounts: KubernetesStatefulSetContainerVolumeMount[];

  /**
   * *
   * Liveness probe configuration.
   * Periodic probe of container liveness. Container will be restarted if the probe fails.
   * Reference: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
   *
   * @generated from field: org.project_planton.provider.kubernetes.Probe liveness_probe = 6;
   */
  livenessProbe?: Probe;

  /**
   * *
   * Readiness probe configuration.
   * Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails.
   * Reference: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
   *
   * @generated from field: org.project_planton.provider.kubernetes.Probe readiness_probe = 7;
   */
  readinessProbe?: Probe;

  /**
   * *
   * Startup probe configuration.
   * Indicates whether the application within the container is started.
   * Reference: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
   *
   * @generated from field: org.project_planton.provider.kubernetes.Probe startup_probe = 8;
   */
  startupProbe?: Probe;

  /**
   * *
   * Optional command to run instead of the image's default entrypoint.
   *
   * @generated from field: repeated string command = 9;
   */
  command: string[];

  /**
   * *
   * Optional arguments to pass to the command or the image's default entrypoint.
   *
   * @generated from field: repeated string args = 10;
   */
  args: string[];
};

/**
 * Describes the message org.project_planton.provider.kubernetes.kubernetesstatefulset.v1.KubernetesStatefulSetContainerApp.
 * Use `create(KubernetesStatefulSetContainerAppSchema)` to create a new message.
 */
export const KubernetesStatefulSetContainerAppSchema: GenMessage<KubernetesStatefulSetContainerApp> = /*@__PURE__*/
  messageDesc(file_org_project_planton_provider_kubernetes_kubernetesstatefulset_v1_spec, 3);

/**
 * *
 * **KubernetesStatefulSetContainerAppEnv** defines the environment variables and secrets for the application container.
 *
 * @generated from message org.project_planton.provider.kubernetes.kubernetesstatefulset.v1.KubernetesStatefulSetContainerAppEnv
 */
export type KubernetesStatefulSetContainerAppEnv = Message<"org.project_planton.provider.kubernetes.kubernetesstatefulset.v1.KubernetesStatefulSetContainerAppEnv"> & {
  /**
   * *
   * A map of environment variable names to their values.
   *
   * @generated from field: map<string, string> variables = 1;
   */
  variables: { [key: string]: string };

  /**
   * *
   * A map of secret names to their values.
   *
   * @generated from field: map<string, string> secrets = 2;
   */
  secrets: { [key: string]: string };
};

/**
 * Describes the message org.project_planton.provider.kubernetes.kubernetesstatefulset.v1.KubernetesStatefulSetContainerAppEnv.
 * Use `create(KubernetesStatefulSetContainerAppEnvSchema)` to create a new message.
 */
export const KubernetesStatefulSetContainerAppEnvSchema: GenMessage<KubernetesStatefulSetContainerAppEnv> = /*@__PURE__*/
  messageDesc(file_org_project_planton_provider_kubernetes_kubernetesstatefulset_v1_spec, 4);

/**
 * *
 * **KubernetesStatefulSetContainerAppPort** specifies the port configuration for the application container.
 *
 * @generated from message org.project_planton.provider.kubernetes.kubernetesstatefulset.v1.KubernetesStatefulSetContainerAppPort
 */
export type KubernetesStatefulSetContainerAppPort = Message<"org.project_planton.provider.kubernetes.kubernetesstatefulset.v1.KubernetesStatefulSetContainerAppPort"> & {
  /**
   * The name of the port (e.g., "http", "grpc").
   * The name must only contain lowercase alphanumeric characters and hyphens.
   * Port names must also start and end with an alphanumeric character.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The port number on the container.
   *
   * @generated from field: int32 container_port = 2;
   */
  containerPort: number;

  /**
   * The network protocol used by the port (e.g., "TCP", "UDP", "SCTP").
   *
   * @generated from field: string network_protocol = 3;
   */
  networkProtocol: string;

  /**
   * The application protocol for the service (e.g., "http").
   *
   * @generated from field: string app_protocol = 4;
   */
  appProtocol: string;

  /**
   * The port number on the Kubernetes service.
   *
   * @generated from field: int32 service_port = 5;
   */
  servicePort: number;

  /**
   * A flag indicating whether this port should be exposed via ingress.
   *
   * @generated from field: bool is_ingress_port = 6;
   */
  isIngressPort: boolean;
};

/**
 * Describes the message org.project_planton.provider.kubernetes.kubernetesstatefulset.v1.KubernetesStatefulSetContainerAppPort.
 * Use `create(KubernetesStatefulSetContainerAppPortSchema)` to create a new message.
 */
export const KubernetesStatefulSetContainerAppPortSchema: GenMessage<KubernetesStatefulSetContainerAppPort> = /*@__PURE__*/
  messageDesc(file_org_project_planton_provider_kubernetes_kubernetesstatefulset_v1_spec, 5);

/**
 * *
 * **KubernetesStatefulSetContainerVolumeMount** specifies a volume mount for the container.
 *
 * @generated from message org.project_planton.provider.kubernetes.kubernetesstatefulset.v1.KubernetesStatefulSetContainerVolumeMount
 */
export type KubernetesStatefulSetContainerVolumeMount = Message<"org.project_planton.provider.kubernetes.kubernetesstatefulset.v1.KubernetesStatefulSetContainerVolumeMount"> & {
  /**
   * The name of the volume to mount. Must match a volume_claim_template name.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The path within the container at which the volume should be mounted.
   *
   * @generated from field: string mount_path = 2;
   */
  mountPath: string;

  /**
   * Whether the volume should be read-only.
   *
   * @generated from field: bool read_only = 3;
   */
  readOnly: boolean;

  /**
   * Path within the volume from which the container's volume should be mounted.
   * Defaults to "" (volume's root).
   *
   * @generated from field: string sub_path = 4;
   */
  subPath: string;
};

/**
 * Describes the message org.project_planton.provider.kubernetes.kubernetesstatefulset.v1.KubernetesStatefulSetContainerVolumeMount.
 * Use `create(KubernetesStatefulSetContainerVolumeMountSchema)` to create a new message.
 */
export const KubernetesStatefulSetContainerVolumeMountSchema: GenMessage<KubernetesStatefulSetContainerVolumeMount> = /*@__PURE__*/
  messageDesc(file_org_project_planton_provider_kubernetes_kubernetesstatefulset_v1_spec, 6);

/**
 * *
 * **KubernetesStatefulSetAvailability** specifies the availability configuration for the stateful set.
 *
 * @generated from message org.project_planton.provider.kubernetes.kubernetesstatefulset.v1.KubernetesStatefulSetAvailability
 */
export type KubernetesStatefulSetAvailability = Message<"org.project_planton.provider.kubernetes.kubernetesstatefulset.v1.KubernetesStatefulSetAvailability"> & {
  /**
   * The number of pod replicas to maintain.
   * Default is 1.
   *
   * @generated from field: int32 replicas = 1;
   */
  replicas: number;

  /**
   * Pod disruption budget configuration.
   * Ensures minimum availability during voluntary disruptions.
   *
   * @generated from field: org.project_planton.provider.kubernetes.kubernetesstatefulset.v1.KubernetesStatefulSetPodDisruptionBudget pod_disruption_budget = 2;
   */
  podDisruptionBudget?: KubernetesStatefulSetPodDisruptionBudget;
};

/**
 * Describes the message org.project_planton.provider.kubernetes.kubernetesstatefulset.v1.KubernetesStatefulSetAvailability.
 * Use `create(KubernetesStatefulSetAvailabilitySchema)` to create a new message.
 */
export const KubernetesStatefulSetAvailabilitySchema: GenMessage<KubernetesStatefulSetAvailability> = /*@__PURE__*/
  messageDesc(file_org_project_planton_provider_kubernetes_kubernetesstatefulset_v1_spec, 7);

/**
 * *
 * **KubernetesStatefulSetPodDisruptionBudget** configures a PodDisruptionBudget for the stateful set.
 *
 * @generated from message org.project_planton.provider.kubernetes.kubernetesstatefulset.v1.KubernetesStatefulSetPodDisruptionBudget
 */
export type KubernetesStatefulSetPodDisruptionBudget = Message<"org.project_planton.provider.kubernetes.kubernetesstatefulset.v1.KubernetesStatefulSetPodDisruptionBudget"> & {
  /**
   * Enable or disable PodDisruptionBudget creation.
   *
   * @generated from field: bool enabled = 1;
   */
  enabled: boolean;

  /**
   * Minimum number of pods that must be available during voluntary disruptions.
   * Can be an absolute number (e.g., 1) or a percentage (e.g., "50%").
   *
   * @generated from field: string min_available = 2;
   */
  minAvailable: string;

  /**
   * Maximum number of pods that can be unavailable during voluntary disruptions.
   * Can be an absolute number (e.g., 1) or a percentage (e.g., "50%").
   * Cannot be used together with min_available.
   *
   * @generated from field: string max_unavailable = 3;
   */
  maxUnavailable: string;
};

/**
 * Describes the message org.project_planton.provider.kubernetes.kubernetesstatefulset.v1.KubernetesStatefulSetPodDisruptionBudget.
 * Use `create(KubernetesStatefulSetPodDisruptionBudgetSchema)` to create a new message.
 */
export const KubernetesStatefulSetPodDisruptionBudgetSchema: GenMessage<KubernetesStatefulSetPodDisruptionBudget> = /*@__PURE__*/
  messageDesc(file_org_project_planton_provider_kubernetes_kubernetesstatefulset_v1_spec, 8);

/**
 * *
 * **KubernetesStatefulSetVolumeClaimTemplate** defines a PVC template for persistent storage.
 * Each pod in the StatefulSet gets a unique PVC based on this template.
 *
 * @generated from message org.project_planton.provider.kubernetes.kubernetesstatefulset.v1.KubernetesStatefulSetVolumeClaimTemplate
 */
export type KubernetesStatefulSetVolumeClaimTemplate = Message<"org.project_planton.provider.kubernetes.kubernetesstatefulset.v1.KubernetesStatefulSetVolumeClaimTemplate"> & {
  /**
   * The name of the volume claim template.
   * This name is used to reference the volume in container volume mounts.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The storage class to use for the PVC.
   * If not specified, the default storage class is used.
   *
   * @generated from field: string storage_class = 2;
   */
  storageClass: string;

  /**
   * The requested storage size (e.g., "10Gi", "100Gi").
   *
   * @generated from field: string size = 3;
   */
  size: string;

  /**
   * Access modes for the PVC.
   * Common values: "ReadWriteOnce", "ReadOnlyMany", "ReadWriteMany", "ReadWriteOncePod"
   * Default: ["ReadWriteOnce"]
   *
   * @generated from field: repeated string access_modes = 4;
   */
  accessModes: string[];
};

/**
 * Describes the message org.project_planton.provider.kubernetes.kubernetesstatefulset.v1.KubernetesStatefulSetVolumeClaimTemplate.
 * Use `create(KubernetesStatefulSetVolumeClaimTemplateSchema)` to create a new message.
 */
export const KubernetesStatefulSetVolumeClaimTemplateSchema: GenMessage<KubernetesStatefulSetVolumeClaimTemplate> = /*@__PURE__*/
  messageDesc(file_org_project_planton_provider_kubernetes_kubernetesstatefulset_v1_spec, 9);

