// @generated by protoc-gen-es v2.2.2 with parameter "target=ts"
// @generated from file org/project_planton/provider/kubernetes/kubernetesdaemonset/v1/spec.proto (package org.project_planton.provider.kubernetes.kubernetesdaemonset.v1, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import { fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv1";
import { file_buf_validate_validate } from "../../../../../../buf/validate/validate_pb";
import type { Container, ContainerImage, ContainerResources } from "../../kubernetes_pb";
import { file_org_project_planton_provider_kubernetes_kubernetes } from "../../kubernetes_pb";
import type { KubernetesSensitiveValue } from "../../kubernetes_secret_pb";
import { file_org_project_planton_provider_kubernetes_kubernetes_secret } from "../../kubernetes_secret_pb";
import { file_org_project_planton_provider_kubernetes_options } from "../../options_pb";
import type { Probe } from "../../probe_pb";
import { file_org_project_planton_provider_kubernetes_probe } from "../../probe_pb";
import type { KubernetesClusterSelector } from "../../target_cluster_pb";
import { file_org_project_planton_provider_kubernetes_target_cluster } from "../../target_cluster_pb";
import type { VolumeMount } from "../../volume_mount_pb";
import { file_org_project_planton_provider_kubernetes_volume_mount } from "../../volume_mount_pb";
import type { StringValueOrRef } from "../../../../shared/foreignkey/v1/foreign_key_pb";
import { file_org_project_planton_shared_foreignkey_v1_foreign_key } from "../../../../shared/foreignkey/v1/foreign_key_pb";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file org/project_planton/provider/kubernetes/kubernetesdaemonset/v1/spec.proto.
 */
export const file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec: GenFile = /*@__PURE__*/
  fileDesc("CklvcmcvcHJvamVjdF9wbGFudG9uL3Byb3ZpZGVyL2t1YmVybmV0ZXMva3ViZXJuZXRlc2RhZW1vbnNldC92MS9zcGVjLnByb3RvEj5vcmcucHJvamVjdF9wbGFudG9uLnByb3ZpZGVyLmt1YmVybmV0ZXMua3ViZXJuZXRlc2RhZW1vbnNldC52MSKKCQoXS3ViZXJuZXRlc0RhZW1vblNldFNwZWMSWgoOdGFyZ2V0X2NsdXN0ZXIYASABKAsyQi5vcmcucHJvamVjdF9wbGFudG9uLnByb3ZpZGVyLmt1YmVybmV0ZXMuS3ViZXJuZXRlc0NsdXN0ZXJTZWxlY3RvchJnCgluYW1lc3BhY2UYAiABKAsyOi5vcmcucHJvamVjdF9wbGFudG9uLnNoYXJlZC5mb3JlaWdua2V5LnYxLlN0cmluZ1ZhbHVlT3JSZWZCGLpIA8gBAYjUYcQGktRhCXNwZWMubmFtZRIYChBjcmVhdGVfbmFtZXNwYWNlGAMgASgIEncKCWNvbnRhaW5lchgEIAEoCzJcLm9yZy5wcm9qZWN0X3BsYW50b24ucHJvdmlkZXIua3ViZXJuZXRlcy5rdWJlcm5ldGVzZGFlbW9uc2V0LnYxLkt1YmVybmV0ZXNEYWVtb25TZXRDb250YWluZXJCBrpIA8gBARKAAQoNbm9kZV9zZWxlY3RvchgFIAMoCzJpLm9yZy5wcm9qZWN0X3BsYW50b24ucHJvdmlkZXIua3ViZXJuZXRlcy5rdWJlcm5ldGVzZGFlbW9uc2V0LnYxLkt1YmVybmV0ZXNEYWVtb25TZXRTcGVjLk5vZGVTZWxlY3RvckVudHJ5EnIKC3RvbGVyYXRpb25zGAYgAygLMl0ub3JnLnByb2plY3RfcGxhbnRvbi5wcm92aWRlci5rdWJlcm5ldGVzLmt1YmVybmV0ZXNkYWVtb25zZXQudjEuS3ViZXJuZXRlc0RhZW1vblNldFRvbGVyYXRpb24SegoPdXBkYXRlX3N0cmF0ZWd5GAcgASgLMmEub3JnLnByb2plY3RfcGxhbnRvbi5wcm92aWRlci5rdWJlcm5ldGVzLmt1YmVybmV0ZXNkYWVtb25zZXQudjEuS3ViZXJuZXRlc0RhZW1vblNldFVwZGF0ZVN0cmF0ZWd5EhkKEW1pbl9yZWFkeV9zZWNvbmRzGAggASgFEh4KFmNyZWF0ZV9zZXJ2aWNlX2FjY291bnQYCSABKAgSHAoUc2VydmljZV9hY2NvdW50X25hbWUYCiABKAkSfAoLY29uZmlnX21hcHMYCyADKAsyZy5vcmcucHJvamVjdF9wbGFudG9uLnByb3ZpZGVyLmt1YmVybmV0ZXMua3ViZXJuZXRlc2RhZW1vbnNldC52MS5LdWJlcm5ldGVzRGFlbW9uU2V0U3BlYy5Db25maWdNYXBzRW50cnkSZQoEcmJhYxgMIAEoCzJXLm9yZy5wcm9qZWN0X3BsYW50b24ucHJvdmlkZXIua3ViZXJuZXRlcy5rdWJlcm5ldGVzZGFlbW9uc2V0LnYxLkt1YmVybmV0ZXNEYWVtb25TZXRSYmFjGjMKEU5vZGVTZWxlY3RvckVudHJ5EgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEoCToCOAEaMQoPQ29uZmlnTWFwc0VudHJ5EgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEoCToCOAEi2gEKHEt1YmVybmV0ZXNEYWVtb25TZXRDb250YWluZXISdAoDYXBwGAEgASgLMl8ub3JnLnByb2plY3RfcGxhbnRvbi5wcm92aWRlci5rdWJlcm5ldGVzLmt1YmVybmV0ZXNkYWVtb25zZXQudjEuS3ViZXJuZXRlc0RhZW1vblNldENvbnRhaW5lckFwcEIGukgDyAEBEkQKCHNpZGVjYXJzGAIgAygLMjIub3JnLnByb2plY3RfcGxhbnRvbi5wcm92aWRlci5rdWJlcm5ldGVzLkNvbnRhaW5lciLECAofS3ViZXJuZXRlc0RhZW1vblNldENvbnRhaW5lckFwcBKGAgoFaW1hZ2UYASABKAsyNy5vcmcucHJvamVjdF9wbGFudG9uLnByb3ZpZGVyLmt1YmVybmV0ZXMuQ29udGFpbmVySW1hZ2VCvQG6SLkBugFaCh1zcGVjLmNvbnRhaW5lci5hcHAuaW1hZ2UucmVwbxIWSW1hZ2UgcmVwbyBpcyByZXF1aXJlZBohaGFzKHRoaXMucmVwbykgJiYgdGhpcy5yZXBvICE9ICcnugFWChxzcGVjLmNvbnRhaW5lci5hcHAuaW1hZ2UudGFnEhVJbWFnZSB0YWcgaXMgcmVxdWlyZWQaH2hhcyh0aGlzLnRhZykgJiYgdGhpcy50YWcgIT0gJyfIAQEScQoJcmVzb3VyY2VzGAIgASgLMjsub3JnLnByb2plY3RfcGxhbnRvbi5wcm92aWRlci5rdWJlcm5ldGVzLkNvbnRhaW5lclJlc291cmNlc0IhuvukAhwKDAoFMTAwMG0SAzFHaRIMCgM1MG0SBTEwME1pEm8KA2VudhgDIAEoCzJiLm9yZy5wcm9qZWN0X3BsYW50b24ucHJvdmlkZXIua3ViZXJuZXRlcy5rdWJlcm5ldGVzZGFlbW9uc2V0LnYxLkt1YmVybmV0ZXNEYWVtb25TZXRDb250YWluZXJBcHBFbnYScgoFcG9ydHMYBCADKAsyYy5vcmcucHJvamVjdF9wbGFudG9uLnByb3ZpZGVyLmt1YmVybmV0ZXMua3ViZXJuZXRlc2RhZW1vbnNldC52MS5LdWJlcm5ldGVzRGFlbW9uU2V0Q29udGFpbmVyQXBwUG9ydBJLCg12b2x1bWVfbW91bnRzGAUgAygLMjQub3JnLnByb2plY3RfcGxhbnRvbi5wcm92aWRlci5rdWJlcm5ldGVzLlZvbHVtZU1vdW50EkYKDmxpdmVuZXNzX3Byb2JlGAYgASgLMi4ub3JnLnByb2plY3RfcGxhbnRvbi5wcm92aWRlci5rdWJlcm5ldGVzLlByb2JlEkcKD3JlYWRpbmVzc19wcm9iZRgHIAEoCzIuLm9yZy5wcm9qZWN0X3BsYW50b24ucHJvdmlkZXIua3ViZXJuZXRlcy5Qcm9iZRJFCg1zdGFydHVwX3Byb2JlGAggASgLMi4ub3JnLnByb2plY3RfcGxhbnRvbi5wcm92aWRlci5rdWJlcm5ldGVzLlByb2JlEg8KB2NvbW1hbmQYCSADKAkSDAoEYXJncxgKIAMoCRJ8ChBzZWN1cml0eV9jb250ZXh0GAsgASgLMmIub3JnLnByb2plY3RfcGxhbnRvbi5wcm92aWRlci5rdWJlcm5ldGVzLmt1YmVybmV0ZXNkYWVtb25zZXQudjEuS3ViZXJuZXRlc0RhZW1vblNldFNlY3VyaXR5Q29udGV4dCKPBAoiS3ViZXJuZXRlc0RhZW1vblNldENvbnRhaW5lckFwcEVudhKEAQoJdmFyaWFibGVzGAEgAygLMnEub3JnLnByb2plY3RfcGxhbnRvbi5wcm92aWRlci5rdWJlcm5ldGVzLmt1YmVybmV0ZXNkYWVtb25zZXQudjEuS3ViZXJuZXRlc0RhZW1vblNldENvbnRhaW5lckFwcEVudi5WYXJpYWJsZXNFbnRyeRKAAQoHc2VjcmV0cxgCIAMoCzJvLm9yZy5wcm9qZWN0X3BsYW50b24ucHJvdmlkZXIua3ViZXJuZXRlcy5rdWJlcm5ldGVzZGFlbW9uc2V0LnYxLkt1YmVybmV0ZXNEYWVtb25TZXRDb250YWluZXJBcHBFbnYuU2VjcmV0c0VudHJ5GmwKDlZhcmlhYmxlc0VudHJ5EgsKA2tleRgBIAEoCRJJCgV2YWx1ZRgCIAEoCzI6Lm9yZy5wcm9qZWN0X3BsYW50b24uc2hhcmVkLmZvcmVpZ25rZXkudjEuU3RyaW5nVmFsdWVPclJlZjoCOAEacQoMU2VjcmV0c0VudHJ5EgsKA2tleRgBIAEoCRJQCgV2YWx1ZRgCIAEoCzJBLm9yZy5wcm9qZWN0X3BsYW50b24ucHJvdmlkZXIua3ViZXJuZXRlcy5LdWJlcm5ldGVzU2Vuc2l0aXZlVmFsdWU6AjgBIokECiNLdWJlcm5ldGVzRGFlbW9uU2V0Q29udGFpbmVyQXBwUG9ydBL8AQoEbmFtZRgBIAEoCULtAbpI6QG6AeIBCh1zcGVjLmNvbnRhaW5lci5hcHAucG9ydHMubmFtZRKSAU5hbWUgZm9yIHBvcnRzIG11c3Qgb25seSBjb250YWluIGxvd2VyY2FzZSBhbHBoYW51bWVyaWMgY2hhcmFjdGVycyBhbmQgaHlwaGVucy4gUG9ydCBuYW1lcyBtdXN0IGFsc28gc3RhcnQgYW5kIGVuZCB3aXRoIGFuIGFscGhhbnVtZXJpYyBjaGFyYWN0ZXIuGix0aGlzLm1hdGNoZXMoJ15bYS16MC05XVthLXowLTktXSpbYS16MC05XSQnKcgBARIeCg5jb250YWluZXJfcG9ydBgCIAEoBUIGukgDyAEBEq8BChBuZXR3b3JrX3Byb3RvY29sGAMgASgJQpQBukiQAboBiQEKKXNwZWMuY29udGFpbmVyLmFwcC5wb3J0cy5uZXR3b3JrX3Byb3RvY29sEjxUaGUgbmV0d29yayBwcm90b2NvbCBtdXN0IGJlIG9uZSBvZiAiU0NUUCIsICJUQ1AiLCBvciAiVURQIi4aHnRoaXMgaW4gWyJTQ1RQIiwgIlRDUCIsICJVRFAiXcgBARIRCglob3N0X3BvcnQYBCABKAUiswMKHUt1YmVybmV0ZXNEYWVtb25TZXRUb2xlcmF0aW9uEgsKA2tleRgBIAEoCRKQAQoIb3BlcmF0b3IYAiABKAlCfrpIe7oBeAoZc3BlYy50b2xlcmF0aW9ucy5vcGVyYXRvchIwVGhlIG9wZXJhdG9yIG11c3QgYmUgb25lIG9mICJFeGlzdHMiIG9yICJFcXVhbCIuGil0aGlzID09ICIiIHx8IHRoaXMgaW4gWyJFeGlzdHMiLCAiRXF1YWwiXRINCgV2YWx1ZRgDIAEoCRLGAQoGZWZmZWN0GAQgASgJQrUBukixAboBrQEKF3NwZWMudG9sZXJhdGlvbnMuZWZmZWN0EktUaGUgZWZmZWN0IG11c3QgYmUgb25lIG9mICJOb1NjaGVkdWxlIiwgIlByZWZlck5vU2NoZWR1bGUiLCBvciAiTm9FeGVjdXRlIi4aRXRoaXMgPT0gIiIgfHwgdGhpcyBpbiBbIk5vU2NoZWR1bGUiLCAiUHJlZmVyTm9TY2hlZHVsZSIsICJOb0V4ZWN1dGUiXRIaChJ0b2xlcmF0aW9uX3NlY29uZHMYBSABKAMizwIKIUt1YmVybmV0ZXNEYWVtb25TZXRVcGRhdGVTdHJhdGVneRKvAQoEdHlwZRgBIAEoCUKgAbpInAG6AZgBChlzcGVjLnVwZGF0ZV9zdHJhdGVneS50eXBlEkZUaGUgdXBkYXRlIHN0cmF0ZWd5IHR5cGUgbXVzdCBiZSBvbmUgb2YgIlJvbGxpbmdVcGRhdGUiIG9yICJPbkRlbGV0ZSIuGjN0aGlzID09ICIiIHx8IHRoaXMgaW4gWyJSb2xsaW5nVXBkYXRlIiwgIk9uRGVsZXRlIl0SeAoOcm9sbGluZ191cGRhdGUYAiABKAsyYC5vcmcucHJvamVjdF9wbGFudG9uLnByb3ZpZGVyLmt1YmVybmV0ZXMua3ViZXJuZXRlc2RhZW1vbnNldC52MS5LdWJlcm5ldGVzRGFlbW9uU2V0Um9sbGluZ1VwZGF0ZSJOCiBLdWJlcm5ldGVzRGFlbW9uU2V0Um9sbGluZ1VwZGF0ZRIXCg9tYXhfdW5hdmFpbGFibGUYASABKAkSEQoJbWF4X3N1cmdlGAIgASgJIpYCCiJLdWJlcm5ldGVzRGFlbW9uU2V0U2VjdXJpdHlDb250ZXh0EhIKCnByaXZpbGVnZWQYASABKAgSEwoLcnVuX2FzX3VzZXIYAiABKAMSFAoMcnVuX2FzX2dyb3VwGAMgASgDEhcKD3J1bl9hc19ub25fcm9vdBgEIAEoCBIhChlyZWFkX29ubHlfcm9vdF9maWxlc3lzdGVtGAUgASgIEnUKDGNhcGFiaWxpdGllcxgGIAEoCzJfLm9yZy5wcm9qZWN0X3BsYW50b24ucHJvdmlkZXIua3ViZXJuZXRlcy5rdWJlcm5ldGVzZGFlbW9uc2V0LnYxLkt1YmVybmV0ZXNEYWVtb25TZXRDYXBhYmlsaXRpZXMiPAofS3ViZXJuZXRlc0RhZW1vblNldENhcGFiaWxpdGllcxILCgNhZGQYASADKAkSDAoEZHJvcBgCIAMoCSKDAgoXS3ViZXJuZXRlc0RhZW1vblNldFJiYWMScgoNY2x1c3Rlcl9ydWxlcxgBIAMoCzJbLm9yZy5wcm9qZWN0X3BsYW50b24ucHJvdmlkZXIua3ViZXJuZXRlcy5rdWJlcm5ldGVzZGFlbW9uc2V0LnYxLkt1YmVybmV0ZXNEYWVtb25TZXRSYmFjUnVsZRJ0Cg9uYW1lc3BhY2VfcnVsZXMYAiADKAsyWy5vcmcucHJvamVjdF9wbGFudG9uLnByb3ZpZGVyLmt1YmVybmV0ZXMua3ViZXJuZXRlc2RhZW1vbnNldC52MS5LdWJlcm5ldGVzRGFlbW9uU2V0UmJhY1J1bGUiiQEKG0t1YmVybmV0ZXNEYWVtb25TZXRSYmFjUnVsZRIcCgphcGlfZ3JvdXBzGAEgAygJQgi6SAWSAQIIARIbCglyZXNvdXJjZXMYAiADKAlCCLpIBZIBAggBEhcKBXZlcmJzGAMgAygJQgi6SAWSAQIIARIWCg5yZXNvdXJjZV9uYW1lcxgEIAMoCULqAwpCY29tLm9yZy5wcm9qZWN0X3BsYW50b24ucHJvdmlkZXIua3ViZXJuZXRlcy5rdWJlcm5ldGVzZGFlbW9uc2V0LnYxQglTcGVjUHJvdG9QAVp+Z2l0aHViLmNvbS9wbGFudG9uaHEvcHJvamVjdC1wbGFudG9uL2FwaXMvb3JnL3Byb2plY3RfcGxhbnRvbi9wcm92aWRlci9rdWJlcm5ldGVzL2t1YmVybmV0ZXNkYWVtb25zZXQvdjE7a3ViZXJuZXRlc2RhZW1vbnNldHYxogIFT1BQS0uqAj1PcmcuUHJvamVjdFBsYW50b24uUHJvdmlkZXIuS3ViZXJuZXRlcy5LdWJlcm5ldGVzZGFlbW9uc2V0LlYxygI9T3JnXFByb2plY3RQbGFudG9uXFByb3ZpZGVyXEt1YmVybmV0ZXNcS3ViZXJuZXRlc2RhZW1vbnNldFxWMeICSU9yZ1xQcm9qZWN0UGxhbnRvblxQcm92aWRlclxLdWJlcm5ldGVzXEt1YmVybmV0ZXNkYWVtb25zZXRcVjFcR1BCTWV0YWRhdGHqAkJPcmc6OlByb2plY3RQbGFudG9uOjpQcm92aWRlcjo6S3ViZXJuZXRlczo6S3ViZXJuZXRlc2RhZW1vbnNldDo6VjFiBnByb3RvMw", [file_buf_validate_validate, file_org_project_planton_provider_kubernetes_kubernetes, file_org_project_planton_provider_kubernetes_kubernetes_secret, file_org_project_planton_provider_kubernetes_options, file_org_project_planton_provider_kubernetes_probe, file_org_project_planton_provider_kubernetes_target_cluster, file_org_project_planton_provider_kubernetes_volume_mount, file_org_project_planton_shared_foreignkey_v1_foreign_key]);

/**
 * *
 * **KubernetesDaemonSetSpec** defines the configuration for deploying a DaemonSet on a Kubernetes cluster.
 * A DaemonSet ensures that all (or some) nodes run a copy of a pod. As nodes are added to the cluster,
 * pods are added to them. As nodes are removed from the cluster, those pods are garbage collected.
 * Common use cases include: cluster storage daemons, log collection daemons, and node monitoring daemons.
 *
 * @generated from message org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetSpec
 */
export type KubernetesDaemonSetSpec = Message<"org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetSpec"> & {
  /**
   * Target Kubernetes Cluster
   *
   * @generated from field: org.project_planton.provider.kubernetes.KubernetesClusterSelector target_cluster = 1;
   */
  targetCluster?: KubernetesClusterSelector;

  /**
   * Kubernetes Namespace
   *
   * @generated from field: org.project_planton.shared.foreignkey.v1.StringValueOrRef namespace = 2;
   */
  namespace?: StringValueOrRef;

  /**
   * Flag to indicate if the namespace should be created
   *
   * @generated from field: bool create_namespace = 3;
   */
  createNamespace: boolean;

  /**
   * The container specifications for the DaemonSet.
   * This includes configurations for the main application container and any sidecar containers.
   *
   * @generated from field: org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetContainer container = 4;
   */
  container?: KubernetesDaemonSetContainer;

  /**
   * Node selector for constraining the DaemonSet pods to run on specific nodes.
   * Key-value pairs that must match labels on nodes for the pod to be scheduled.
   *
   * @generated from field: map<string, string> node_selector = 5;
   */
  nodeSelector: { [key: string]: string };

  /**
   * Tolerations allow the DaemonSet pods to be scheduled on nodes with matching taints.
   * This is essential for running pods on master nodes or nodes with specific taints.
   *
   * @generated from field: repeated org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetToleration tolerations = 6;
   */
  tolerations: KubernetesDaemonSetToleration[];

  /**
   * The update strategy for the DaemonSet.
   * Controls how pods are updated when the DaemonSet specification changes.
   *
   * @generated from field: org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetUpdateStrategy update_strategy = 7;
   */
  updateStrategy?: KubernetesDaemonSetUpdateStrategy;

  /**
   * Minimum number of seconds for which a newly created DaemonSet pod should be ready
   * without any of its container crashing, for it to be considered available.
   * Defaults to 0 (pod will be considered available as soon as it is ready).
   *
   * @generated from field: int32 min_ready_seconds = 8;
   */
  minReadySeconds: number;

  /**
   * *
   * Flag to indicate if a ServiceAccount should be created for this DaemonSet.
   * If true, a ServiceAccount with the name specified in service_account_name
   * (or the DaemonSet name if not specified) will be created.
   * The DaemonSet pods will use this ServiceAccount.
   *
   * @generated from field: bool create_service_account = 9;
   */
  createServiceAccount: boolean;

  /**
   * *
   * Name of the ServiceAccount to use for the DaemonSet pods.
   * If create_service_account is true, a ServiceAccount with this name will be created.
   * If create_service_account is false, this references an existing ServiceAccount.
   * If not specified and create_service_account is true, uses the DaemonSet name.
   *
   * @generated from field: string service_account_name = 10;
   */
  serviceAccountName: string;

  /**
   * *
   * ConfigMaps to create alongside the DaemonSet.
   * Key is the ConfigMap name, value is the content.
   * These ConfigMaps can be referenced in volume mounts.
   *
   * Example:
   *   config_maps:
   *     vector-config: |
   *       data_dir: /var/lib/vector
   *       sources:
   *         kubernetes_logs:
   *           type: kubernetes_logs
   *
   * @generated from field: map<string, string> config_maps = 11;
   */
  configMaps: { [key: string]: string };

  /**
   * *
   * RBAC configuration for the DaemonSet ServiceAccount.
   * Allows defining ClusterRole and Role permissions.
   * Only used if create_service_account is true.
   *
   * @generated from field: org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetRbac rbac = 12;
   */
  rbac?: KubernetesDaemonSetRbac;
};

/**
 * Describes the message org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetSpec.
 * Use `create(KubernetesDaemonSetSpecSchema)` to create a new message.
 */
export const KubernetesDaemonSetSpecSchema: GenMessage<KubernetesDaemonSetSpec> = /*@__PURE__*/
  messageDesc(file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec, 0);

/**
 * *
 * **KubernetesDaemonSetContainer** specifies the container configuration for the DaemonSet.
 * It includes the main application container and any sidecar containers that need to run alongside it.
 *
 * @generated from message org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetContainer
 */
export type KubernetesDaemonSetContainer = Message<"org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetContainer"> & {
  /**
   * The main application container specifications.
   *
   * @generated from field: org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetContainerApp app = 1;
   */
  app?: KubernetesDaemonSetContainerApp;

  /**
   * A list of sidecar containers to be deployed alongside the main application container.
   *
   * @generated from field: repeated org.project_planton.provider.kubernetes.Container sidecars = 2;
   */
  sidecars: Container[];
};

/**
 * Describes the message org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetContainer.
 * Use `create(KubernetesDaemonSetContainerSchema)` to create a new message.
 */
export const KubernetesDaemonSetContainerSchema: GenMessage<KubernetesDaemonSetContainer> = /*@__PURE__*/
  messageDesc(file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec, 1);

/**
 * *
 * **KubernetesDaemonSetContainerApp** specifies the configuration for the main application container.
 * It includes the container image, resource allocations, environment variables, and health probes.
 *
 * @generated from message org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetContainerApp
 */
export type KubernetesDaemonSetContainerApp = Message<"org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetContainerApp"> & {
  /**
   * *
   * The container image to be used for the application.
   * The `pull_secret_name` is the name of the image pull secret to be configured in the Kubernetes DaemonSet resource.
   *
   * @generated from field: org.project_planton.provider.kubernetes.ContainerImage image = 1;
   */
  image?: ContainerImage;

  /**
   * The CPU and memory resources allocated to the application container.
   *
   * @generated from field: org.project_planton.provider.kubernetes.ContainerResources resources = 2;
   */
  resources?: ContainerResources;

  /**
   * *
   * The environment variables and secrets for the application container.
   *
   * @generated from field: org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetContainerAppEnv env = 3;
   */
  env?: KubernetesDaemonSetContainerAppEnv;

  /**
   * *
   * A list of ports to be configured for the application container.
   *
   * @generated from field: repeated org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetContainerAppPort ports = 4;
   */
  ports: KubernetesDaemonSetContainerAppPort[];

  /**
   * *
   * Volume mounts for the container.
   * Supports ConfigMap, Secret, HostPath, EmptyDir, and PVC volumes.
   * DaemonSets commonly need HostPath mounts for log collection, node monitoring, etc.
   *
   * @generated from field: repeated org.project_planton.provider.kubernetes.VolumeMount volume_mounts = 5;
   */
  volumeMounts: VolumeMount[];

  /**
   * *
   * Liveness probe configuration.
   * Periodic probe of container liveness. Container will be restarted if the probe fails.
   *
   * @generated from field: org.project_planton.provider.kubernetes.Probe liveness_probe = 6;
   */
  livenessProbe?: Probe;

  /**
   * *
   * Readiness probe configuration.
   * Periodic probe of container service readiness.
   *
   * @generated from field: org.project_planton.provider.kubernetes.Probe readiness_probe = 7;
   */
  readinessProbe?: Probe;

  /**
   * *
   * Startup probe configuration.
   * Indicates whether the application within the container is started.
   *
   * @generated from field: org.project_planton.provider.kubernetes.Probe startup_probe = 8;
   */
  startupProbe?: Probe;

  /**
   * *
   * Command to run in the container (overrides the container image's ENTRYPOINT).
   *
   * @generated from field: repeated string command = 9;
   */
  command: string[];

  /**
   * *
   * Arguments to pass to the command (overrides the container image's CMD).
   *
   * @generated from field: repeated string args = 10;
   */
  args: string[];

  /**
   * *
   * Security context for the container.
   * DaemonSets often need privileged access for node-level operations.
   *
   * @generated from field: org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetSecurityContext security_context = 11;
   */
  securityContext?: KubernetesDaemonSetSecurityContext;
};

/**
 * Describes the message org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetContainerApp.
 * Use `create(KubernetesDaemonSetContainerAppSchema)` to create a new message.
 */
export const KubernetesDaemonSetContainerAppSchema: GenMessage<KubernetesDaemonSetContainerApp> = /*@__PURE__*/
  messageDesc(file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec, 2);

/**
 * *
 * **KubernetesDaemonSetContainerAppEnv** defines the environment variables and secrets for the application container.
 *
 * @generated from message org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetContainerAppEnv
 */
export type KubernetesDaemonSetContainerAppEnv = Message<"org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetContainerAppEnv"> & {
  /**
   * *
   * A map of environment variable names to their values.
   * Each variable can be provided either as a literal string value or as a reference
   * to another Project Planton resource's field.
   *
   * **Option 1: Direct string value**
   * ```yaml
   * variables:
   *   LOG_LEVEL:
   *     value: "info"
   * ```
   *
   * **Option 2: Reference to another resource's field**
   * ```yaml
   * variables:
   *   CLUSTER_NAME:
   *     valueFrom:
   *       kind: GcpGkeCluster
   *       name: my-cluster
   *       fieldPath: "status.outputs.name"
   * ```
   *
   * When using valueFrom references, the orchestrator resolves the reference
   * and populates the value field before invoking the IaC modules.
   *
   * @generated from field: map<string, org.project_planton.shared.foreignkey.v1.StringValueOrRef> variables = 1;
   */
  variables: { [key: string]: StringValueOrRef };

  /**
   * *
   * A map of secret environment variable names to their values.
   * Each secret can be provided either as a literal string value or as a reference
   * to an existing Kubernetes Secret.
   *
   * Using secret references is recommended for production deployments.
   *
   * @generated from field: map<string, org.project_planton.provider.kubernetes.KubernetesSensitiveValue> secrets = 2;
   */
  secrets: { [key: string]: KubernetesSensitiveValue };
};

/**
 * Describes the message org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetContainerAppEnv.
 * Use `create(KubernetesDaemonSetContainerAppEnvSchema)` to create a new message.
 */
export const KubernetesDaemonSetContainerAppEnvSchema: GenMessage<KubernetesDaemonSetContainerAppEnv> = /*@__PURE__*/
  messageDesc(file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec, 3);

/**
 * *
 * **KubernetesDaemonSetContainerAppPort** specifies the port configuration for the application container.
 *
 * @generated from message org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetContainerAppPort
 */
export type KubernetesDaemonSetContainerAppPort = Message<"org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetContainerAppPort"> & {
  /**
   * The name of the port (e.g., "metrics", "health").
   * The name must only contain lowercase alphanumeric characters and hyphens.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The port number on the container.
   *
   * @generated from field: int32 container_port = 2;
   */
  containerPort: number;

  /**
   * The network protocol used by the port (e.g., "TCP", "UDP", "SCTP").
   *
   * @generated from field: string network_protocol = 3;
   */
  networkProtocol: string;

  /**
   * Host port to expose the container port on.
   * Use with caution as it limits where pods can be scheduled.
   *
   * @generated from field: int32 host_port = 4;
   */
  hostPort: number;
};

/**
 * Describes the message org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetContainerAppPort.
 * Use `create(KubernetesDaemonSetContainerAppPortSchema)` to create a new message.
 */
export const KubernetesDaemonSetContainerAppPortSchema: GenMessage<KubernetesDaemonSetContainerAppPort> = /*@__PURE__*/
  messageDesc(file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec, 4);

/**
 * *
 * **KubernetesDaemonSetToleration** defines a toleration for the DaemonSet pods.
 *
 * @generated from message org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetToleration
 */
export type KubernetesDaemonSetToleration = Message<"org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetToleration"> & {
  /**
   * Key is the taint key that the toleration applies to.
   *
   * @generated from field: string key = 1;
   */
  key: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   *
   * @generated from field: string operator = 2;
   */
  operator: string;

  /**
   * Value is the taint value the toleration matches to.
   *
   * @generated from field: string value = 3;
   */
  value: string;

  /**
   * Effect indicates the taint effect to match.
   * Valid effects are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @generated from field: string effect = 4;
   */
  effect: string;

  /**
   * TolerationSeconds represents the period of time the toleration tolerates the taint.
   * Only applicable when effect is NoExecute.
   *
   * @generated from field: int64 toleration_seconds = 5;
   */
  tolerationSeconds: bigint;
};

/**
 * Describes the message org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetToleration.
 * Use `create(KubernetesDaemonSetTolerationSchema)` to create a new message.
 */
export const KubernetesDaemonSetTolerationSchema: GenMessage<KubernetesDaemonSetToleration> = /*@__PURE__*/
  messageDesc(file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec, 5);

/**
 * *
 * **KubernetesDaemonSetUpdateStrategy** defines the update strategy for the DaemonSet.
 *
 * @generated from message org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetUpdateStrategy
 */
export type KubernetesDaemonSetUpdateStrategy = Message<"org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetUpdateStrategy"> & {
  /**
   * Type of update strategy.
   * Can be "RollingUpdate" or "OnDelete".
   * RollingUpdate: The DaemonSet controller creates new pods and deletes old ones progressively.
   * OnDelete: Pods are only updated when they are manually deleted.
   *
   * @generated from field: string type = 1;
   */
  type: string;

  /**
   * Rolling update config params. Present only if type = "RollingUpdate".
   *
   * @generated from field: org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetRollingUpdate rolling_update = 2;
   */
  rollingUpdate?: KubernetesDaemonSetRollingUpdate;
};

/**
 * Describes the message org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetUpdateStrategy.
 * Use `create(KubernetesDaemonSetUpdateStrategySchema)` to create a new message.
 */
export const KubernetesDaemonSetUpdateStrategySchema: GenMessage<KubernetesDaemonSetUpdateStrategy> = /*@__PURE__*/
  messageDesc(file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec, 6);

/**
 * *
 * **KubernetesDaemonSetRollingUpdate** defines the parameters for rolling update strategy.
 *
 * @generated from message org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetRollingUpdate
 */
export type KubernetesDaemonSetRollingUpdate = Message<"org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetRollingUpdate"> & {
  /**
   * The maximum number of DaemonSet pods that can be unavailable during the update.
   * Can be an absolute number or a percentage (e.g., "1" or "10%").
   * This cannot be 0 if maxSurge is 0.
   * Defaults to 1.
   *
   * @generated from field: string max_unavailable = 1;
   */
  maxUnavailable: string;

  /**
   * The maximum number of nodes with an existing available DaemonSet pod that can have
   * an updated DaemonSet pod during an update.
   * Can be an absolute number or a percentage (e.g., "1" or "10%").
   * Defaults to 0.
   *
   * @generated from field: string max_surge = 2;
   */
  maxSurge: string;
};

/**
 * Describes the message org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetRollingUpdate.
 * Use `create(KubernetesDaemonSetRollingUpdateSchema)` to create a new message.
 */
export const KubernetesDaemonSetRollingUpdateSchema: GenMessage<KubernetesDaemonSetRollingUpdate> = /*@__PURE__*/
  messageDesc(file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec, 7);

/**
 * *
 * **KubernetesDaemonSetSecurityContext** defines the security context for the container.
 *
 * @generated from message org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetSecurityContext
 */
export type KubernetesDaemonSetSecurityContext = Message<"org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetSecurityContext"> & {
  /**
   * Run as privileged container.
   * DaemonSets often need privileged access for node-level operations.
   *
   * @generated from field: bool privileged = 1;
   */
  privileged: boolean;

  /**
   * Run as a specific user ID.
   *
   * @generated from field: int64 run_as_user = 2;
   */
  runAsUser: bigint;

  /**
   * Run as a specific group ID.
   *
   * @generated from field: int64 run_as_group = 3;
   */
  runAsGroup: bigint;

  /**
   * Run as non-root user.
   *
   * @generated from field: bool run_as_non_root = 4;
   */
  runAsNonRoot: boolean;

  /**
   * Make the root filesystem read-only.
   *
   * @generated from field: bool read_only_root_filesystem = 5;
   */
  readOnlyRootFilesystem: boolean;

  /**
   * Capabilities to add or drop.
   *
   * @generated from field: org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetCapabilities capabilities = 6;
   */
  capabilities?: KubernetesDaemonSetCapabilities;
};

/**
 * Describes the message org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetSecurityContext.
 * Use `create(KubernetesDaemonSetSecurityContextSchema)` to create a new message.
 */
export const KubernetesDaemonSetSecurityContextSchema: GenMessage<KubernetesDaemonSetSecurityContext> = /*@__PURE__*/
  messageDesc(file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec, 8);

/**
 * *
 * **KubernetesDaemonSetCapabilities** defines Linux capabilities to add or drop.
 *
 * @generated from message org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetCapabilities
 */
export type KubernetesDaemonSetCapabilities = Message<"org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetCapabilities"> & {
  /**
   * List of capabilities to add.
   *
   * @generated from field: repeated string add = 1;
   */
  add: string[];

  /**
   * List of capabilities to drop.
   *
   * @generated from field: repeated string drop = 2;
   */
  drop: string[];
};

/**
 * Describes the message org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetCapabilities.
 * Use `create(KubernetesDaemonSetCapabilitiesSchema)` to create a new message.
 */
export const KubernetesDaemonSetCapabilitiesSchema: GenMessage<KubernetesDaemonSetCapabilities> = /*@__PURE__*/
  messageDesc(file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec, 9);

/**
 * *
 * KubernetesDaemonSetRbac defines RBAC permissions for the DaemonSet ServiceAccount.
 * Creates ClusterRole/ClusterRoleBinding for cluster-wide permissions
 * and Role/RoleBinding for namespace-scoped permissions.
 *
 * @generated from message org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetRbac
 */
export type KubernetesDaemonSetRbac = Message<"org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetRbac"> & {
  /**
   * *
   * Cluster-wide RBAC rules.
   * Creates a ClusterRole and ClusterRoleBinding.
   * Use for permissions that span across namespaces (e.g., reading all pods).
   *
   * @generated from field: repeated org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetRbacRule cluster_rules = 1;
   */
  clusterRules: KubernetesDaemonSetRbacRule[];

  /**
   * *
   * Namespace-scoped RBAC rules.
   * Creates a Role and RoleBinding in the DaemonSet's namespace.
   * Use for permissions limited to the deployment namespace.
   *
   * @generated from field: repeated org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetRbacRule namespace_rules = 2;
   */
  namespaceRules: KubernetesDaemonSetRbacRule[];
};

/**
 * Describes the message org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetRbac.
 * Use `create(KubernetesDaemonSetRbacSchema)` to create a new message.
 */
export const KubernetesDaemonSetRbacSchema: GenMessage<KubernetesDaemonSetRbac> = /*@__PURE__*/
  messageDesc(file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec, 10);

/**
 * *
 * KubernetesDaemonSetRbacRule defines a single RBAC policy rule.
 * Maps directly to Kubernetes RBAC PolicyRule.
 *
 * @generated from message org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetRbacRule
 */
export type KubernetesDaemonSetRbacRule = Message<"org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetRbacRule"> & {
  /**
   * *
   * API groups containing the resources.
   * Use "" for core API group.
   * Example: [""], ["apps"], ["batch"]
   *
   * @generated from field: repeated string api_groups = 1;
   */
  apiGroups: string[];

  /**
   * *
   * Resources this rule applies to.
   * Example: ["pods", "services"], ["deployments"], ["configmaps", "secrets"]
   *
   * @generated from field: repeated string resources = 2;
   */
  resources: string[];

  /**
   * *
   * Verbs specifying the actions allowed.
   * Example: ["get", "list", "watch"], ["create", "update", "delete"]
   *
   * @generated from field: repeated string verbs = 3;
   */
  verbs: string[];

  /**
   * *
   * Resource names to limit the rule to specific resources.
   * If empty, the rule applies to all resources of the specified type.
   * Example: ["my-configmap", "my-secret"]
   *
   * @generated from field: repeated string resource_names = 4;
   */
  resourceNames: string[];
};

/**
 * Describes the message org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetRbacRule.
 * Use `create(KubernetesDaemonSetRbacRuleSchema)` to create a new message.
 */
export const KubernetesDaemonSetRbacRuleSchema: GenMessage<KubernetesDaemonSetRbacRule> = /*@__PURE__*/
  messageDesc(file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec, 11);

