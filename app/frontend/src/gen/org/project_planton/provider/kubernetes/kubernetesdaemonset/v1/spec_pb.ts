// @generated by protoc-gen-es v2.2.2 with parameter "target=ts"
// @generated from file org/project_planton/provider/kubernetes/kubernetesdaemonset/v1/spec.proto (package org.project_planton.provider.kubernetes.kubernetesdaemonset.v1, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import { fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv1";
import { file_buf_validate_validate } from "../../../../../../buf/validate/validate_pb";
import type { Container, ContainerImage, ContainerResources } from "../../kubernetes_pb";
import { file_org_project_planton_provider_kubernetes_kubernetes } from "../../kubernetes_pb";
import { file_org_project_planton_provider_kubernetes_options } from "../../options_pb";
import type { Probe } from "../../probe_pb";
import { file_org_project_planton_provider_kubernetes_probe } from "../../probe_pb";
import type { KubernetesClusterSelector } from "../../target_cluster_pb";
import { file_org_project_planton_provider_kubernetes_target_cluster } from "../../target_cluster_pb";
import type { StringValueOrRef } from "../../../../shared/foreignkey/v1/foreign_key_pb";
import { file_org_project_planton_shared_foreignkey_v1_foreign_key } from "../../../../shared/foreignkey/v1/foreign_key_pb";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file org/project_planton/provider/kubernetes/kubernetesdaemonset/v1/spec.proto.
 */
export const file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec: GenFile = /*@__PURE__*/
  fileDesc("CklvcmcvcHJvamVjdF9wbGFudG9uL3Byb3ZpZGVyL2t1YmVybmV0ZXMva3ViZXJuZXRlc2RhZW1vbnNldC92MS9zcGVjLnByb3RvEj5vcmcucHJvamVjdF9wbGFudG9uLnByb3ZpZGVyLmt1YmVybmV0ZXMua3ViZXJuZXRlc2RhZW1vbnNldC52MSK0BgoXS3ViZXJuZXRlc0RhZW1vblNldFNwZWMSWgoOdGFyZ2V0X2NsdXN0ZXIYASABKAsyQi5vcmcucHJvamVjdF9wbGFudG9uLnByb3ZpZGVyLmt1YmVybmV0ZXMuS3ViZXJuZXRlc0NsdXN0ZXJTZWxlY3RvchJnCgluYW1lc3BhY2UYAiABKAsyOi5vcmcucHJvamVjdF9wbGFudG9uLnNoYXJlZC5mb3JlaWdua2V5LnYxLlN0cmluZ1ZhbHVlT3JSZWZCGLpIA8gBAYjUYcQGktRhCXNwZWMubmFtZRIYChBjcmVhdGVfbmFtZXNwYWNlGAMgASgIEncKCWNvbnRhaW5lchgEIAEoCzJcLm9yZy5wcm9qZWN0X3BsYW50b24ucHJvdmlkZXIua3ViZXJuZXRlcy5rdWJlcm5ldGVzZGFlbW9uc2V0LnYxLkt1YmVybmV0ZXNEYWVtb25TZXRDb250YWluZXJCBrpIA8gBARKAAQoNbm9kZV9zZWxlY3RvchgFIAMoCzJpLm9yZy5wcm9qZWN0X3BsYW50b24ucHJvdmlkZXIua3ViZXJuZXRlcy5rdWJlcm5ldGVzZGFlbW9uc2V0LnYxLkt1YmVybmV0ZXNEYWVtb25TZXRTcGVjLk5vZGVTZWxlY3RvckVudHJ5EnIKC3RvbGVyYXRpb25zGAYgAygLMl0ub3JnLnByb2plY3RfcGxhbnRvbi5wcm92aWRlci5rdWJlcm5ldGVzLmt1YmVybmV0ZXNkYWVtb25zZXQudjEuS3ViZXJuZXRlc0RhZW1vblNldFRvbGVyYXRpb24SegoPdXBkYXRlX3N0cmF0ZWd5GAcgASgLMmEub3JnLnByb2plY3RfcGxhbnRvbi5wcm92aWRlci5rdWJlcm5ldGVzLmt1YmVybmV0ZXNkYWVtb25zZXQudjEuS3ViZXJuZXRlc0RhZW1vblNldFVwZGF0ZVN0cmF0ZWd5EhkKEW1pbl9yZWFkeV9zZWNvbmRzGAggASgFGjMKEU5vZGVTZWxlY3RvckVudHJ5EgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEoCToCOAEi2gEKHEt1YmVybmV0ZXNEYWVtb25TZXRDb250YWluZXISdAoDYXBwGAEgASgLMl8ub3JnLnByb2plY3RfcGxhbnRvbi5wcm92aWRlci5rdWJlcm5ldGVzLmt1YmVybmV0ZXNkYWVtb25zZXQudjEuS3ViZXJuZXRlc0RhZW1vblNldENvbnRhaW5lckFwcEIGukgDyAEBEkQKCHNpZGVjYXJzGAIgAygLMjIub3JnLnByb2plY3RfcGxhbnRvbi5wcm92aWRlci5rdWJlcm5ldGVzLkNvbnRhaW5lciLuCAofS3ViZXJuZXRlc0RhZW1vblNldENvbnRhaW5lckFwcBKGAgoFaW1hZ2UYASABKAsyNy5vcmcucHJvamVjdF9wbGFudG9uLnByb3ZpZGVyLmt1YmVybmV0ZXMuQ29udGFpbmVySW1hZ2VCvQG6SLkBugFaCh1zcGVjLmNvbnRhaW5lci5hcHAuaW1hZ2UucmVwbxIWSW1hZ2UgcmVwbyBpcyByZXF1aXJlZBohaGFzKHRoaXMucmVwbykgJiYgdGhpcy5yZXBvICE9ICcnugFWChxzcGVjLmNvbnRhaW5lci5hcHAuaW1hZ2UudGFnEhVJbWFnZSB0YWcgaXMgcmVxdWlyZWQaH2hhcyh0aGlzLnRhZykgJiYgdGhpcy50YWcgIT0gJyfIAQEScQoJcmVzb3VyY2VzGAIgASgLMjsub3JnLnByb2plY3RfcGxhbnRvbi5wcm92aWRlci5rdWJlcm5ldGVzLkNvbnRhaW5lclJlc291cmNlc0IhuvukAhwKDAoFMTAwMG0SAzFHaRIMCgM1MG0SBTEwME1pEm8KA2VudhgDIAEoCzJiLm9yZy5wcm9qZWN0X3BsYW50b24ucHJvdmlkZXIua3ViZXJuZXRlcy5rdWJlcm5ldGVzZGFlbW9uc2V0LnYxLkt1YmVybmV0ZXNEYWVtb25TZXRDb250YWluZXJBcHBFbnYScgoFcG9ydHMYBCADKAsyYy5vcmcucHJvamVjdF9wbGFudG9uLnByb3ZpZGVyLmt1YmVybmV0ZXMua3ViZXJuZXRlc2RhZW1vbnNldC52MS5LdWJlcm5ldGVzRGFlbW9uU2V0Q29udGFpbmVyQXBwUG9ydBJ1Cg12b2x1bWVfbW91bnRzGAUgAygLMl4ub3JnLnByb2plY3RfcGxhbnRvbi5wcm92aWRlci5rdWJlcm5ldGVzLmt1YmVybmV0ZXNkYWVtb25zZXQudjEuS3ViZXJuZXRlc0RhZW1vblNldFZvbHVtZU1vdW50EkYKDmxpdmVuZXNzX3Byb2JlGAYgASgLMi4ub3JnLnByb2plY3RfcGxhbnRvbi5wcm92aWRlci5rdWJlcm5ldGVzLlByb2JlEkcKD3JlYWRpbmVzc19wcm9iZRgHIAEoCzIuLm9yZy5wcm9qZWN0X3BsYW50b24ucHJvdmlkZXIua3ViZXJuZXRlcy5Qcm9iZRJFCg1zdGFydHVwX3Byb2JlGAggASgLMi4ub3JnLnByb2plY3RfcGxhbnRvbi5wcm92aWRlci5rdWJlcm5ldGVzLlByb2JlEg8KB2NvbW1hbmQYCSADKAkSDAoEYXJncxgKIAMoCRJ8ChBzZWN1cml0eV9jb250ZXh0GAsgASgLMmIub3JnLnByb2plY3RfcGxhbnRvbi5wcm92aWRlci5rdWJlcm5ldGVzLmt1YmVybmV0ZXNkYWVtb25zZXQudjEuS3ViZXJuZXRlc0RhZW1vblNldFNlY3VyaXR5Q29udGV4dCKQAwoiS3ViZXJuZXRlc0RhZW1vblNldENvbnRhaW5lckFwcEVudhKEAQoJdmFyaWFibGVzGAEgAygLMnEub3JnLnByb2plY3RfcGxhbnRvbi5wcm92aWRlci5rdWJlcm5ldGVzLmt1YmVybmV0ZXNkYWVtb25zZXQudjEuS3ViZXJuZXRlc0RhZW1vblNldENvbnRhaW5lckFwcEVudi5WYXJpYWJsZXNFbnRyeRKAAQoHc2VjcmV0cxgCIAMoCzJvLm9yZy5wcm9qZWN0X3BsYW50b24ucHJvdmlkZXIua3ViZXJuZXRlcy5rdWJlcm5ldGVzZGFlbW9uc2V0LnYxLkt1YmVybmV0ZXNEYWVtb25TZXRDb250YWluZXJBcHBFbnYuU2VjcmV0c0VudHJ5GjAKDlZhcmlhYmxlc0VudHJ5EgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEoCToCOAEaLgoMU2VjcmV0c0VudHJ5EgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEoCToCOAEiiQQKI0t1YmVybmV0ZXNEYWVtb25TZXRDb250YWluZXJBcHBQb3J0EvwBCgRuYW1lGAEgASgJQu0BukjpAboB4gEKHXNwZWMuY29udGFpbmVyLmFwcC5wb3J0cy5uYW1lEpIBTmFtZSBmb3IgcG9ydHMgbXVzdCBvbmx5IGNvbnRhaW4gbG93ZXJjYXNlIGFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzIGFuZCBoeXBoZW5zLiBQb3J0IG5hbWVzIG11c3QgYWxzbyBzdGFydCBhbmQgZW5kIHdpdGggYW4gYWxwaGFudW1lcmljIGNoYXJhY3Rlci4aLHRoaXMubWF0Y2hlcygnXlthLXowLTldW2EtejAtOS1dKlthLXowLTldJCcpyAEBEh4KDmNvbnRhaW5lcl9wb3J0GAIgASgFQga6SAPIAQESrwEKEG5ldHdvcmtfcHJvdG9jb2wYAyABKAlClAG6SJABugGJAQopc3BlYy5jb250YWluZXIuYXBwLnBvcnRzLm5ldHdvcmtfcHJvdG9jb2wSPFRoZSBuZXR3b3JrIHByb3RvY29sIG11c3QgYmUgb25lIG9mICJTQ1RQIiwgIlRDUCIsIG9yICJVRFAiLhoedGhpcyBpbiBbIlNDVFAiLCAiVENQIiwgIlVEUCJdyAEBEhEKCWhvc3RfcG9ydBgEIAEoBSKQAQoeS3ViZXJuZXRlc0RhZW1vblNldFZvbHVtZU1vdW50EhQKBG5hbWUYASABKAlCBrpIA8gBARIaCgptb3VudF9wYXRoGAIgASgJQga6SAPIAQESEQoJaG9zdF9wYXRoGAMgASgJEhYKDmhvc3RfcGF0aF90eXBlGAQgASgJEhEKCXJlYWRfb25seRgFIAEoCCKzAwodS3ViZXJuZXRlc0RhZW1vblNldFRvbGVyYXRpb24SCwoDa2V5GAEgASgJEpABCghvcGVyYXRvchgCIAEoCUJ+ukh7ugF4ChlzcGVjLnRvbGVyYXRpb25zLm9wZXJhdG9yEjBUaGUgb3BlcmF0b3IgbXVzdCBiZSBvbmUgb2YgIkV4aXN0cyIgb3IgIkVxdWFsIi4aKXRoaXMgPT0gIiIgfHwgdGhpcyBpbiBbIkV4aXN0cyIsICJFcXVhbCJdEg0KBXZhbHVlGAMgASgJEsYBCgZlZmZlY3QYBCABKAlCtQG6SLEBugGtAQoXc3BlYy50b2xlcmF0aW9ucy5lZmZlY3QSS1RoZSBlZmZlY3QgbXVzdCBiZSBvbmUgb2YgIk5vU2NoZWR1bGUiLCAiUHJlZmVyTm9TY2hlZHVsZSIsIG9yICJOb0V4ZWN1dGUiLhpFdGhpcyA9PSAiIiB8fCB0aGlzIGluIFsiTm9TY2hlZHVsZSIsICJQcmVmZXJOb1NjaGVkdWxlIiwgIk5vRXhlY3V0ZSJdEhoKEnRvbGVyYXRpb25fc2Vjb25kcxgFIAEoAyLPAgohS3ViZXJuZXRlc0RhZW1vblNldFVwZGF0ZVN0cmF0ZWd5Eq8BCgR0eXBlGAEgASgJQqABukicAboBmAEKGXNwZWMudXBkYXRlX3N0cmF0ZWd5LnR5cGUSRlRoZSB1cGRhdGUgc3RyYXRlZ3kgdHlwZSBtdXN0IGJlIG9uZSBvZiAiUm9sbGluZ1VwZGF0ZSIgb3IgIk9uRGVsZXRlIi4aM3RoaXMgPT0gIiIgfHwgdGhpcyBpbiBbIlJvbGxpbmdVcGRhdGUiLCAiT25EZWxldGUiXRJ4Cg5yb2xsaW5nX3VwZGF0ZRgCIAEoCzJgLm9yZy5wcm9qZWN0X3BsYW50b24ucHJvdmlkZXIua3ViZXJuZXRlcy5rdWJlcm5ldGVzZGFlbW9uc2V0LnYxLkt1YmVybmV0ZXNEYWVtb25TZXRSb2xsaW5nVXBkYXRlIk4KIEt1YmVybmV0ZXNEYWVtb25TZXRSb2xsaW5nVXBkYXRlEhcKD21heF91bmF2YWlsYWJsZRgBIAEoCRIRCgltYXhfc3VyZ2UYAiABKAkilgIKIkt1YmVybmV0ZXNEYWVtb25TZXRTZWN1cml0eUNvbnRleHQSEgoKcHJpdmlsZWdlZBgBIAEoCBITCgtydW5fYXNfdXNlchgCIAEoAxIUCgxydW5fYXNfZ3JvdXAYAyABKAMSFwoPcnVuX2FzX25vbl9yb290GAQgASgIEiEKGXJlYWRfb25seV9yb290X2ZpbGVzeXN0ZW0YBSABKAgSdQoMY2FwYWJpbGl0aWVzGAYgASgLMl8ub3JnLnByb2plY3RfcGxhbnRvbi5wcm92aWRlci5rdWJlcm5ldGVzLmt1YmVybmV0ZXNkYWVtb25zZXQudjEuS3ViZXJuZXRlc0RhZW1vblNldENhcGFiaWxpdGllcyI8Ch9LdWJlcm5ldGVzRGFlbW9uU2V0Q2FwYWJpbGl0aWVzEgsKA2FkZBgBIAMoCRIMCgRkcm9wGAIgAygJQvEDCkJjb20ub3JnLnByb2plY3RfcGxhbnRvbi5wcm92aWRlci5rdWJlcm5ldGVzLmt1YmVybmV0ZXNkYWVtb25zZXQudjFCCVNwZWNQcm90b1ABWoQBZ2l0aHViLmNvbS9wcm9qZWN0LXBsYW50b24vcHJvamVjdC1wbGFudG9uL2FwaXMvb3JnL3Byb2plY3RfcGxhbnRvbi9wcm92aWRlci9rdWJlcm5ldGVzL2t1YmVybmV0ZXNkYWVtb25zZXQvdjE7a3ViZXJuZXRlc2RhZW1vbnNldHYxogIFT1BQS0uqAj1PcmcuUHJvamVjdFBsYW50b24uUHJvdmlkZXIuS3ViZXJuZXRlcy5LdWJlcm5ldGVzZGFlbW9uc2V0LlYxygI9T3JnXFByb2plY3RQbGFudG9uXFByb3ZpZGVyXEt1YmVybmV0ZXNcS3ViZXJuZXRlc2RhZW1vbnNldFxWMeICSU9yZ1xQcm9qZWN0UGxhbnRvblxQcm92aWRlclxLdWJlcm5ldGVzXEt1YmVybmV0ZXNkYWVtb25zZXRcVjFcR1BCTWV0YWRhdGHqAkJPcmc6OlByb2plY3RQbGFudG9uOjpQcm92aWRlcjo6S3ViZXJuZXRlczo6S3ViZXJuZXRlc2RhZW1vbnNldDo6VjFiBnByb3RvMw", [file_buf_validate_validate, file_org_project_planton_provider_kubernetes_kubernetes, file_org_project_planton_provider_kubernetes_options, file_org_project_planton_provider_kubernetes_probe, file_org_project_planton_provider_kubernetes_target_cluster, file_org_project_planton_shared_foreignkey_v1_foreign_key]);

/**
 * *
 * **KubernetesDaemonSetSpec** defines the configuration for deploying a DaemonSet on a Kubernetes cluster.
 * A DaemonSet ensures that all (or some) nodes run a copy of a pod. As nodes are added to the cluster,
 * pods are added to them. As nodes are removed from the cluster, those pods are garbage collected.
 * Common use cases include: cluster storage daemons, log collection daemons, and node monitoring daemons.
 *
 * @generated from message org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetSpec
 */
export type KubernetesDaemonSetSpec = Message<"org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetSpec"> & {
  /**
   * Target Kubernetes Cluster
   *
   * @generated from field: org.project_planton.provider.kubernetes.KubernetesClusterSelector target_cluster = 1;
   */
  targetCluster?: KubernetesClusterSelector;

  /**
   * Kubernetes Namespace
   *
   * @generated from field: org.project_planton.shared.foreignkey.v1.StringValueOrRef namespace = 2;
   */
  namespace?: StringValueOrRef;

  /**
   * Flag to indicate if the namespace should be created
   *
   * @generated from field: bool create_namespace = 3;
   */
  createNamespace: boolean;

  /**
   * The container specifications for the DaemonSet.
   * This includes configurations for the main application container and any sidecar containers.
   *
   * @generated from field: org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetContainer container = 4;
   */
  container?: KubernetesDaemonSetContainer;

  /**
   * Node selector for constraining the DaemonSet pods to run on specific nodes.
   * Key-value pairs that must match labels on nodes for the pod to be scheduled.
   *
   * @generated from field: map<string, string> node_selector = 5;
   */
  nodeSelector: { [key: string]: string };

  /**
   * Tolerations allow the DaemonSet pods to be scheduled on nodes with matching taints.
   * This is essential for running pods on master nodes or nodes with specific taints.
   *
   * @generated from field: repeated org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetToleration tolerations = 6;
   */
  tolerations: KubernetesDaemonSetToleration[];

  /**
   * The update strategy for the DaemonSet.
   * Controls how pods are updated when the DaemonSet specification changes.
   *
   * @generated from field: org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetUpdateStrategy update_strategy = 7;
   */
  updateStrategy?: KubernetesDaemonSetUpdateStrategy;

  /**
   * Minimum number of seconds for which a newly created DaemonSet pod should be ready
   * without any of its container crashing, for it to be considered available.
   * Defaults to 0 (pod will be considered available as soon as it is ready).
   *
   * @generated from field: int32 min_ready_seconds = 8;
   */
  minReadySeconds: number;
};

/**
 * Describes the message org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetSpec.
 * Use `create(KubernetesDaemonSetSpecSchema)` to create a new message.
 */
export const KubernetesDaemonSetSpecSchema: GenMessage<KubernetesDaemonSetSpec> = /*@__PURE__*/
  messageDesc(file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec, 0);

/**
 * *
 * **KubernetesDaemonSetContainer** specifies the container configuration for the DaemonSet.
 * It includes the main application container and any sidecar containers that need to run alongside it.
 *
 * @generated from message org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetContainer
 */
export type KubernetesDaemonSetContainer = Message<"org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetContainer"> & {
  /**
   * The main application container specifications.
   *
   * @generated from field: org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetContainerApp app = 1;
   */
  app?: KubernetesDaemonSetContainerApp;

  /**
   * A list of sidecar containers to be deployed alongside the main application container.
   *
   * @generated from field: repeated org.project_planton.provider.kubernetes.Container sidecars = 2;
   */
  sidecars: Container[];
};

/**
 * Describes the message org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetContainer.
 * Use `create(KubernetesDaemonSetContainerSchema)` to create a new message.
 */
export const KubernetesDaemonSetContainerSchema: GenMessage<KubernetesDaemonSetContainer> = /*@__PURE__*/
  messageDesc(file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec, 1);

/**
 * *
 * **KubernetesDaemonSetContainerApp** specifies the configuration for the main application container.
 * It includes the container image, resource allocations, environment variables, and health probes.
 *
 * @generated from message org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetContainerApp
 */
export type KubernetesDaemonSetContainerApp = Message<"org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetContainerApp"> & {
  /**
   * *
   * The container image to be used for the application.
   * The `pull_secret_name` is the name of the image pull secret to be configured in the Kubernetes DaemonSet resource.
   *
   * @generated from field: org.project_planton.provider.kubernetes.ContainerImage image = 1;
   */
  image?: ContainerImage;

  /**
   * The CPU and memory resources allocated to the application container.
   *
   * @generated from field: org.project_planton.provider.kubernetes.ContainerResources resources = 2;
   */
  resources?: ContainerResources;

  /**
   * *
   * The environment variables and secrets for the application container.
   *
   * @generated from field: org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetContainerAppEnv env = 3;
   */
  env?: KubernetesDaemonSetContainerAppEnv;

  /**
   * *
   * A list of ports to be configured for the application container.
   *
   * @generated from field: repeated org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetContainerAppPort ports = 4;
   */
  ports: KubernetesDaemonSetContainerAppPort[];

  /**
   * *
   * Volume mounts for the container.
   * DaemonSets commonly need to mount host paths for log collection, node monitoring, etc.
   *
   * @generated from field: repeated org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetVolumeMount volume_mounts = 5;
   */
  volumeMounts: KubernetesDaemonSetVolumeMount[];

  /**
   * *
   * Liveness probe configuration.
   * Periodic probe of container liveness. Container will be restarted if the probe fails.
   *
   * @generated from field: org.project_planton.provider.kubernetes.Probe liveness_probe = 6;
   */
  livenessProbe?: Probe;

  /**
   * *
   * Readiness probe configuration.
   * Periodic probe of container service readiness.
   *
   * @generated from field: org.project_planton.provider.kubernetes.Probe readiness_probe = 7;
   */
  readinessProbe?: Probe;

  /**
   * *
   * Startup probe configuration.
   * Indicates whether the application within the container is started.
   *
   * @generated from field: org.project_planton.provider.kubernetes.Probe startup_probe = 8;
   */
  startupProbe?: Probe;

  /**
   * *
   * Command to run in the container (overrides the container image's ENTRYPOINT).
   *
   * @generated from field: repeated string command = 9;
   */
  command: string[];

  /**
   * *
   * Arguments to pass to the command (overrides the container image's CMD).
   *
   * @generated from field: repeated string args = 10;
   */
  args: string[];

  /**
   * *
   * Security context for the container.
   * DaemonSets often need privileged access for node-level operations.
   *
   * @generated from field: org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetSecurityContext security_context = 11;
   */
  securityContext?: KubernetesDaemonSetSecurityContext;
};

/**
 * Describes the message org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetContainerApp.
 * Use `create(KubernetesDaemonSetContainerAppSchema)` to create a new message.
 */
export const KubernetesDaemonSetContainerAppSchema: GenMessage<KubernetesDaemonSetContainerApp> = /*@__PURE__*/
  messageDesc(file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec, 2);

/**
 * *
 * **KubernetesDaemonSetContainerAppEnv** defines the environment variables and secrets for the application container.
 *
 * @generated from message org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetContainerAppEnv
 */
export type KubernetesDaemonSetContainerAppEnv = Message<"org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetContainerAppEnv"> & {
  /**
   * *
   * A map of environment variable names to their values.
   *
   * @generated from field: map<string, string> variables = 1;
   */
  variables: { [key: string]: string };

  /**
   * *
   * A map of secret names to their values.
   *
   * @generated from field: map<string, string> secrets = 2;
   */
  secrets: { [key: string]: string };
};

/**
 * Describes the message org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetContainerAppEnv.
 * Use `create(KubernetesDaemonSetContainerAppEnvSchema)` to create a new message.
 */
export const KubernetesDaemonSetContainerAppEnvSchema: GenMessage<KubernetesDaemonSetContainerAppEnv> = /*@__PURE__*/
  messageDesc(file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec, 3);

/**
 * *
 * **KubernetesDaemonSetContainerAppPort** specifies the port configuration for the application container.
 *
 * @generated from message org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetContainerAppPort
 */
export type KubernetesDaemonSetContainerAppPort = Message<"org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetContainerAppPort"> & {
  /**
   * The name of the port (e.g., "metrics", "health").
   * The name must only contain lowercase alphanumeric characters and hyphens.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The port number on the container.
   *
   * @generated from field: int32 container_port = 2;
   */
  containerPort: number;

  /**
   * The network protocol used by the port (e.g., "TCP", "UDP", "SCTP").
   *
   * @generated from field: string network_protocol = 3;
   */
  networkProtocol: string;

  /**
   * Host port to expose the container port on.
   * Use with caution as it limits where pods can be scheduled.
   *
   * @generated from field: int32 host_port = 4;
   */
  hostPort: number;
};

/**
 * Describes the message org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetContainerAppPort.
 * Use `create(KubernetesDaemonSetContainerAppPortSchema)` to create a new message.
 */
export const KubernetesDaemonSetContainerAppPortSchema: GenMessage<KubernetesDaemonSetContainerAppPort> = /*@__PURE__*/
  messageDesc(file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec, 4);

/**
 * *
 * **KubernetesDaemonSetVolumeMount** defines a volume mount for the DaemonSet container.
 *
 * @generated from message org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetVolumeMount
 */
export type KubernetesDaemonSetVolumeMount = Message<"org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetVolumeMount"> & {
  /**
   * Name of the volume.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Path within the container at which the volume should be mounted.
   *
   * @generated from field: string mount_path = 2;
   */
  mountPath: string;

  /**
   * Host path to mount into the container.
   * Used for accessing node-level files/directories.
   *
   * @generated from field: string host_path = 3;
   */
  hostPath: string;

  /**
   * Type of host path (DirectoryOrCreate, Directory, FileOrCreate, File, Socket, CharDevice, BlockDevice).
   *
   * @generated from field: string host_path_type = 4;
   */
  hostPathType: string;

  /**
   * Whether the volume should be mounted read-only.
   *
   * @generated from field: bool read_only = 5;
   */
  readOnly: boolean;
};

/**
 * Describes the message org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetVolumeMount.
 * Use `create(KubernetesDaemonSetVolumeMountSchema)` to create a new message.
 */
export const KubernetesDaemonSetVolumeMountSchema: GenMessage<KubernetesDaemonSetVolumeMount> = /*@__PURE__*/
  messageDesc(file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec, 5);

/**
 * *
 * **KubernetesDaemonSetToleration** defines a toleration for the DaemonSet pods.
 *
 * @generated from message org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetToleration
 */
export type KubernetesDaemonSetToleration = Message<"org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetToleration"> & {
  /**
   * Key is the taint key that the toleration applies to.
   *
   * @generated from field: string key = 1;
   */
  key: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   *
   * @generated from field: string operator = 2;
   */
  operator: string;

  /**
   * Value is the taint value the toleration matches to.
   *
   * @generated from field: string value = 3;
   */
  value: string;

  /**
   * Effect indicates the taint effect to match.
   * Valid effects are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @generated from field: string effect = 4;
   */
  effect: string;

  /**
   * TolerationSeconds represents the period of time the toleration tolerates the taint.
   * Only applicable when effect is NoExecute.
   *
   * @generated from field: int64 toleration_seconds = 5;
   */
  tolerationSeconds: bigint;
};

/**
 * Describes the message org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetToleration.
 * Use `create(KubernetesDaemonSetTolerationSchema)` to create a new message.
 */
export const KubernetesDaemonSetTolerationSchema: GenMessage<KubernetesDaemonSetToleration> = /*@__PURE__*/
  messageDesc(file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec, 6);

/**
 * *
 * **KubernetesDaemonSetUpdateStrategy** defines the update strategy for the DaemonSet.
 *
 * @generated from message org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetUpdateStrategy
 */
export type KubernetesDaemonSetUpdateStrategy = Message<"org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetUpdateStrategy"> & {
  /**
   * Type of update strategy.
   * Can be "RollingUpdate" or "OnDelete".
   * RollingUpdate: The DaemonSet controller creates new pods and deletes old ones progressively.
   * OnDelete: Pods are only updated when they are manually deleted.
   *
   * @generated from field: string type = 1;
   */
  type: string;

  /**
   * Rolling update config params. Present only if type = "RollingUpdate".
   *
   * @generated from field: org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetRollingUpdate rolling_update = 2;
   */
  rollingUpdate?: KubernetesDaemonSetRollingUpdate;
};

/**
 * Describes the message org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetUpdateStrategy.
 * Use `create(KubernetesDaemonSetUpdateStrategySchema)` to create a new message.
 */
export const KubernetesDaemonSetUpdateStrategySchema: GenMessage<KubernetesDaemonSetUpdateStrategy> = /*@__PURE__*/
  messageDesc(file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec, 7);

/**
 * *
 * **KubernetesDaemonSetRollingUpdate** defines the parameters for rolling update strategy.
 *
 * @generated from message org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetRollingUpdate
 */
export type KubernetesDaemonSetRollingUpdate = Message<"org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetRollingUpdate"> & {
  /**
   * The maximum number of DaemonSet pods that can be unavailable during the update.
   * Can be an absolute number or a percentage (e.g., "1" or "10%").
   * This cannot be 0 if maxSurge is 0.
   * Defaults to 1.
   *
   * @generated from field: string max_unavailable = 1;
   */
  maxUnavailable: string;

  /**
   * The maximum number of nodes with an existing available DaemonSet pod that can have
   * an updated DaemonSet pod during an update.
   * Can be an absolute number or a percentage (e.g., "1" or "10%").
   * Defaults to 0.
   *
   * @generated from field: string max_surge = 2;
   */
  maxSurge: string;
};

/**
 * Describes the message org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetRollingUpdate.
 * Use `create(KubernetesDaemonSetRollingUpdateSchema)` to create a new message.
 */
export const KubernetesDaemonSetRollingUpdateSchema: GenMessage<KubernetesDaemonSetRollingUpdate> = /*@__PURE__*/
  messageDesc(file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec, 8);

/**
 * *
 * **KubernetesDaemonSetSecurityContext** defines the security context for the container.
 *
 * @generated from message org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetSecurityContext
 */
export type KubernetesDaemonSetSecurityContext = Message<"org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetSecurityContext"> & {
  /**
   * Run as privileged container.
   * DaemonSets often need privileged access for node-level operations.
   *
   * @generated from field: bool privileged = 1;
   */
  privileged: boolean;

  /**
   * Run as a specific user ID.
   *
   * @generated from field: int64 run_as_user = 2;
   */
  runAsUser: bigint;

  /**
   * Run as a specific group ID.
   *
   * @generated from field: int64 run_as_group = 3;
   */
  runAsGroup: bigint;

  /**
   * Run as non-root user.
   *
   * @generated from field: bool run_as_non_root = 4;
   */
  runAsNonRoot: boolean;

  /**
   * Make the root filesystem read-only.
   *
   * @generated from field: bool read_only_root_filesystem = 5;
   */
  readOnlyRootFilesystem: boolean;

  /**
   * Capabilities to add or drop.
   *
   * @generated from field: org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetCapabilities capabilities = 6;
   */
  capabilities?: KubernetesDaemonSetCapabilities;
};

/**
 * Describes the message org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetSecurityContext.
 * Use `create(KubernetesDaemonSetSecurityContextSchema)` to create a new message.
 */
export const KubernetesDaemonSetSecurityContextSchema: GenMessage<KubernetesDaemonSetSecurityContext> = /*@__PURE__*/
  messageDesc(file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec, 9);

/**
 * *
 * **KubernetesDaemonSetCapabilities** defines Linux capabilities to add or drop.
 *
 * @generated from message org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetCapabilities
 */
export type KubernetesDaemonSetCapabilities = Message<"org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetCapabilities"> & {
  /**
   * List of capabilities to add.
   *
   * @generated from field: repeated string add = 1;
   */
  add: string[];

  /**
   * List of capabilities to drop.
   *
   * @generated from field: repeated string drop = 2;
   */
  drop: string[];
};

/**
 * Describes the message org.project_planton.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetCapabilities.
 * Use `create(KubernetesDaemonSetCapabilitiesSchema)` to create a new message.
 */
export const KubernetesDaemonSetCapabilitiesSchema: GenMessage<KubernetesDaemonSetCapabilities> = /*@__PURE__*/
  messageDesc(file_org_project_planton_provider_kubernetes_kubernetesdaemonset_v1_spec, 10);

