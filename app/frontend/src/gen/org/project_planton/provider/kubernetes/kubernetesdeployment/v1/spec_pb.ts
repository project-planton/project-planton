// @generated by protoc-gen-es v2.2.2 with parameter "target=ts"
// @generated from file org/project_planton/provider/kubernetes/kubernetesdeployment/v1/spec.proto (package org.project_planton.provider.kubernetes.kubernetesdeployment.v1, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import { fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv1";
import { file_buf_validate_validate } from "../../../../../../buf/validate/validate_pb";
import type { Container, ContainerImage, ContainerResources } from "../../kubernetes_pb";
import { file_org_project_planton_provider_kubernetes_kubernetes } from "../../kubernetes_pb";
import { file_org_project_planton_provider_kubernetes_options } from "../../options_pb";
import type { Probe } from "../../probe_pb";
import { file_org_project_planton_provider_kubernetes_probe } from "../../probe_pb";
import type { KubernetesClusterSelector } from "../../target_cluster_pb";
import { file_org_project_planton_provider_kubernetes_target_cluster } from "../../target_cluster_pb";
import type { VolumeMount } from "../../volume_mount_pb";
import { file_org_project_planton_provider_kubernetes_volume_mount } from "../../volume_mount_pb";
import type { StringValueOrRef } from "../../../../shared/foreignkey/v1/foreign_key_pb";
import { file_org_project_planton_shared_foreignkey_v1_foreign_key } from "../../../../shared/foreignkey/v1/foreign_key_pb";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file org/project_planton/provider/kubernetes/kubernetesdeployment/v1/spec.proto.
 */
export const file_org_project_planton_provider_kubernetes_kubernetesdeployment_v1_spec: GenFile = /*@__PURE__*/
  fileDesc("CkpvcmcvcHJvamVjdF9wbGFudG9uL3Byb3ZpZGVyL2t1YmVybmV0ZXMva3ViZXJuZXRlc2RlcGxveW1lbnQvdjEvc3BlYy5wcm90bxI/b3JnLnByb2plY3RfcGxhbnRvbi5wcm92aWRlci5rdWJlcm5ldGVzLmt1YmVybmV0ZXNkZXBsb3ltZW50LnYxIvIHChhLdWJlcm5ldGVzRGVwbG95bWVudFNwZWMSWgoOdGFyZ2V0X2NsdXN0ZXIYASABKAsyQi5vcmcucHJvamVjdF9wbGFudG9uLnByb3ZpZGVyLmt1YmVybmV0ZXMuS3ViZXJuZXRlc0NsdXN0ZXJTZWxlY3RvchJnCgluYW1lc3BhY2UYAiABKAsyOi5vcmcucHJvamVjdF9wbGFudG9uLnNoYXJlZC5mb3JlaWdua2V5LnYxLlN0cmluZ1ZhbHVlT3JSZWZCGLpIA8gBAYjUYcQGktRhCXNwZWMubmFtZRIYChBjcmVhdGVfbmFtZXNwYWNlGAMgASgIEuABCgd2ZXJzaW9uGAQgASgJQs4BukjKAboBbAoSc3BlYy52ZXJzaW9uLmNoYXJzEjhPbmx5IGxvd2VyY2FzZSBsZXR0ZXJzLCBudW1iZXJzLCBhbmQgaHlwaGVucyBhcmUgYWxsb3dlZBocdGhpcy5tYXRjaGVzKCdeW2EtejAtOS1dKyQnKboBUgodc3BlYy52ZXJzaW9uLm5vLWh5cGhlbi1lbmRpbmcSGk11c3Qgbm90IGVuZCB3aXRoIGEgaHlwaGVuGhV0aGlzLm1hdGNoZXMoJ1teLV0kJylyBBABGB4SeQoJY29udGFpbmVyGAUgASgLMl4ub3JnLnByb2plY3RfcGxhbnRvbi5wcm92aWRlci5rdWJlcm5ldGVzLmt1YmVybmV0ZXNkZXBsb3ltZW50LnYxLkt1YmVybmV0ZXNEZXBsb3ltZW50Q29udGFpbmVyQga6SAPIAQESbQoHaW5ncmVzcxgGIAEoCzJcLm9yZy5wcm9qZWN0X3BsYW50b24ucHJvdmlkZXIua3ViZXJuZXRlcy5rdWJlcm5ldGVzZGVwbG95bWVudC52MS5LdWJlcm5ldGVzRGVwbG95bWVudEluZ3Jlc3MSdwoMYXZhaWxhYmlsaXR5GAcgASgLMmEub3JnLnByb2plY3RfcGxhbnRvbi5wcm92aWRlci5rdWJlcm5ldGVzLmt1YmVybmV0ZXNkZXBsb3ltZW50LnYxLkt1YmVybmV0ZXNEZXBsb3ltZW50QXZhaWxhYmlsaXR5En4KC2NvbmZpZ19tYXBzGAggAygLMmkub3JnLnByb2plY3RfcGxhbnRvbi5wcm92aWRlci5rdWJlcm5ldGVzLmt1YmVybmV0ZXNkZXBsb3ltZW50LnYxLkt1YmVybmV0ZXNEZXBsb3ltZW50U3BlYy5Db25maWdNYXBzRW50cnkaMQoPQ29uZmlnTWFwc0VudHJ5EgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEoCToCOAEivwEKG0t1YmVybmV0ZXNEZXBsb3ltZW50SW5ncmVzcxIPCgdlbmFibGVkGAEgASgIEhAKCGhvc3RuYW1lGAIgASgJOn26SHoaeAoec3BlYy5pbmdyZXNzLmhvc3RuYW1lLnJlcXVpcmVkEixob3N0bmFtZSBpcyByZXF1aXJlZCB3aGVuIGluZ3Jlc3MgaXMgZW5hYmxlZBooIXRoaXMuZW5hYmxlZCB8fCBzaXplKHRoaXMuaG9zdG5hbWUpID4gMCLdAQodS3ViZXJuZXRlc0RlcGxveW1lbnRDb250YWluZXISdgoDYXBwGAEgASgLMmEub3JnLnByb2plY3RfcGxhbnRvbi5wcm92aWRlci5rdWJlcm5ldGVzLmt1YmVybmV0ZXNkZXBsb3ltZW50LnYxLkt1YmVybmV0ZXNEZXBsb3ltZW50Q29udGFpbmVyQXBwQga6SAPIAQESRAoIc2lkZWNhcnMYAiADKAsyMi5vcmcucHJvamVjdF9wbGFudG9uLnByb3ZpZGVyLmt1YmVybmV0ZXMuQ29udGFpbmVyIssHCiBLdWJlcm5ldGVzRGVwbG95bWVudENvbnRhaW5lckFwcBKGAgoFaW1hZ2UYASABKAsyNy5vcmcucHJvamVjdF9wbGFudG9uLnByb3ZpZGVyLmt1YmVybmV0ZXMuQ29udGFpbmVySW1hZ2VCvQG6SLkBugFaCh1zcGVjLmNvbnRhaW5lci5hcHAuaW1hZ2UucmVwbxIWSW1hZ2UgcmVwbyBpcyByZXF1aXJlZBohaGFzKHRoaXMucmVwbykgJiYgdGhpcy5yZXBvICE9ICcnugFWChxzcGVjLmNvbnRhaW5lci5hcHAuaW1hZ2UudGFnEhVJbWFnZSB0YWcgaXMgcmVxdWlyZWQaH2hhcyh0aGlzLnRhZykgJiYgdGhpcy50YWcgIT0gJyfIAQEScQoJcmVzb3VyY2VzGAIgASgLMjsub3JnLnByb2plY3RfcGxhbnRvbi5wcm92aWRlci5rdWJlcm5ldGVzLkNvbnRhaW5lclJlc291cmNlc0IhuvukAhwKDAoFMTAwMG0SAzFHaRIMCgM1MG0SBTEwME1pEnEKA2VudhgDIAEoCzJkLm9yZy5wcm9qZWN0X3BsYW50b24ucHJvdmlkZXIua3ViZXJuZXRlcy5rdWJlcm5ldGVzZGVwbG95bWVudC52MS5LdWJlcm5ldGVzRGVwbG95bWVudENvbnRhaW5lckFwcEVudhJ0CgVwb3J0cxgEIAMoCzJlLm9yZy5wcm9qZWN0X3BsYW50b24ucHJvdmlkZXIua3ViZXJuZXRlcy5rdWJlcm5ldGVzZGVwbG95bWVudC52MS5LdWJlcm5ldGVzRGVwbG95bWVudENvbnRhaW5lckFwcFBvcnQSRgoObGl2ZW5lc3NfcHJvYmUYBSABKAsyLi5vcmcucHJvamVjdF9wbGFudG9uLnByb3ZpZGVyLmt1YmVybmV0ZXMuUHJvYmUSRwoPcmVhZGluZXNzX3Byb2JlGAYgASgLMi4ub3JnLnByb2plY3RfcGxhbnRvbi5wcm92aWRlci5rdWJlcm5ldGVzLlByb2JlEkUKDXN0YXJ0dXBfcHJvYmUYByABKAsyLi5vcmcucHJvamVjdF9wbGFudG9uLnByb3ZpZGVyLmt1YmVybmV0ZXMuUHJvYmUSSwoNdm9sdW1lX21vdW50cxgIIAMoCzI0Lm9yZy5wcm9qZWN0X3BsYW50b24ucHJvdmlkZXIua3ViZXJuZXRlcy5Wb2x1bWVNb3VudBIPCgdjb21tYW5kGAkgAygJEgwKBGFyZ3MYCiADKAkilQMKI0t1YmVybmV0ZXNEZXBsb3ltZW50Q29udGFpbmVyQXBwRW52EoYBCgl2YXJpYWJsZXMYASADKAsycy5vcmcucHJvamVjdF9wbGFudG9uLnByb3ZpZGVyLmt1YmVybmV0ZXMua3ViZXJuZXRlc2RlcGxveW1lbnQudjEuS3ViZXJuZXRlc0RlcGxveW1lbnRDb250YWluZXJBcHBFbnYuVmFyaWFibGVzRW50cnkSggEKB3NlY3JldHMYAiADKAsycS5vcmcucHJvamVjdF9wbGFudG9uLnByb3ZpZGVyLmt1YmVybmV0ZXMua3ViZXJuZXRlc2RlcGxveW1lbnQudjEuS3ViZXJuZXRlc0RlcGxveW1lbnRDb250YWluZXJBcHBFbnYuU2VjcmV0c0VudHJ5GjAKDlZhcmlhYmxlc0VudHJ5EgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEoCToCOAEaLgoMU2VjcmV0c0VudHJ5EgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEoCToCOAEimgUKJEt1YmVybmV0ZXNEZXBsb3ltZW50Q29udGFpbmVyQXBwUG9ydBLKAgoEbmFtZRgBIAEoCUK7ArpItwK6AbACCh1zcGVjLmNvbnRhaW5lci5hcHAucG9ydHMubmFtZRLgAU5hbWUgZm9yIHBvcnRzIG11c3Qgb25seSBjb250YWluIGxvd2VyY2FzZSBhbHBoYW51bWVyaWMgY2hhcmFjdGVycyBhbmQgaHlwaGVucy4gUG9ydCBuYW1lcyBtdXN0IGFsc28gc3RhcnQgYW5kIGVuZCB3aXRoIGFuIGFscGhhbnVtZXJpYyBjaGFyYWN0ZXIuIEZvciBleGFtcGxlLCAnMTIzLWFiYycgYW5kICd3ZWInIGFyZSB2YWxpZCwgYnV0ICcxMjNfYWJjJyBhbmQgJy13ZWInIGFyZSBub3QuGix0aGlzLm1hdGNoZXMoJ15bYS16MC05XVthLXowLTktXSpbYS16MC05XSQnKcgBARIeCg5jb250YWluZXJfcG9ydBgCIAEoBUIGukgDyAEBEq8BChBuZXR3b3JrX3Byb3RvY29sGAMgASgJQpQBukiQAboBiQEKKXNwZWMuY29udGFpbmVyLmFwcC5wb3J0cy5uZXR3b3JrX3Byb3RvY29sEjxUaGUgbmV0d29yayBwcm90b2NvbCBtdXN0IGJlIG9uZSBvZiAiU0NUUCIsICJUQ1AiLCBvciAiVURQIi4aHnRoaXMgaW4gWyJTQ1RQIiwgIlRDUCIsICJVRFAiXcgBARIcCgxhcHBfcHJvdG9jb2wYBCABKAlCBrpIA8gBARIcCgxzZXJ2aWNlX3BvcnQYBSABKAVCBrpIA8gBARIXCg9pc19pbmdyZXNzX3BvcnQYBiABKAgi1AMKIEt1YmVybmV0ZXNEZXBsb3ltZW50QXZhaWxhYmlsaXR5EhQKDG1pbl9yZXBsaWNhcxgBIAEoBRKIAQoaaG9yaXpvbnRhbF9wb2RfYXV0b3NjYWxpbmcYAiABKAsyZC5vcmcucHJvamVjdF9wbGFudG9uLnByb3ZpZGVyLmt1YmVybmV0ZXMua3ViZXJuZXRlc2RlcGxveW1lbnQudjEuS3ViZXJuZXRlc0RlcGxveW1lbnRBdmFpbGFiaWxpdHlIcGEShAEKE2RlcGxveW1lbnRfc3RyYXRlZ3kYAyABKAsyZy5vcmcucHJvamVjdF9wbGFudG9uLnByb3ZpZGVyLmt1YmVybmV0ZXMua3ViZXJuZXRlc2RlcGxveW1lbnQudjEuS3ViZXJuZXRlc0RlcGxveW1lbnREZXBsb3ltZW50U3RyYXRlZ3kShwEKFXBvZF9kaXNydXB0aW9uX2J1ZGdldBgEIAEoCzJoLm9yZy5wcm9qZWN0X3BsYW50b24ucHJvdmlkZXIua3ViZXJuZXRlcy5rdWJlcm5ldGVzZGVwbG95bWVudC52MS5LdWJlcm5ldGVzRGVwbG95bWVudFBvZERpc3J1cHRpb25CdWRnZXQihAEKI0t1YmVybmV0ZXNEZXBsb3ltZW50QXZhaWxhYmlsaXR5SHBhEhIKCmlzX2VuYWJsZWQYASABKAgSJgoedGFyZ2V0X2NwdV91dGlsaXphdGlvbl9wZXJjZW50GAIgASgBEiEKGXRhcmdldF9tZW1vcnlfdXRpbGl6YXRpb24YAyABKAkiVAomS3ViZXJuZXRlc0RlcGxveW1lbnREZXBsb3ltZW50U3RyYXRlZ3kSFwoPbWF4X3VuYXZhaWxhYmxlGAEgASgJEhEKCW1heF9zdXJnZRgCIAEoCSJqCidLdWJlcm5ldGVzRGVwbG95bWVudFBvZERpc3J1cHRpb25CdWRnZXQSDwoHZW5hYmxlZBgBIAEoCBIVCg1taW5fYXZhaWxhYmxlGAIgASgJEhcKD21heF91bmF2YWlsYWJsZRgDIAEoCUL4AwpDY29tLm9yZy5wcm9qZWN0X3BsYW50b24ucHJvdmlkZXIua3ViZXJuZXRlcy5rdWJlcm5ldGVzZGVwbG95bWVudC52MUIJU3BlY1Byb3RvUAFahgFnaXRodWIuY29tL3Byb2plY3QtcGxhbnRvbi9wcm9qZWN0LXBsYW50b24vYXBpcy9vcmcvcHJvamVjdF9wbGFudG9uL3Byb3ZpZGVyL2t1YmVybmV0ZXMva3ViZXJuZXRlc2RlcGxveW1lbnQvdjE7a3ViZXJuZXRlc2RlcGxveW1lbnR2MaICBU9QUEtLqgI+T3JnLlByb2plY3RQbGFudG9uLlByb3ZpZGVyLkt1YmVybmV0ZXMuS3ViZXJuZXRlc2RlcGxveW1lbnQuVjHKAj5PcmdcUHJvamVjdFBsYW50b25cUHJvdmlkZXJcS3ViZXJuZXRlc1xLdWJlcm5ldGVzZGVwbG95bWVudFxWMeICSk9yZ1xQcm9qZWN0UGxhbnRvblxQcm92aWRlclxLdWJlcm5ldGVzXEt1YmVybmV0ZXNkZXBsb3ltZW50XFYxXEdQQk1ldGFkYXRh6gJDT3JnOjpQcm9qZWN0UGxhbnRvbjo6UHJvdmlkZXI6Okt1YmVybmV0ZXM6Okt1YmVybmV0ZXNkZXBsb3ltZW50OjpWMWIGcHJvdG8z", [file_buf_validate_validate, file_org_project_planton_provider_kubernetes_kubernetes, file_org_project_planton_provider_kubernetes_options, file_org_project_planton_provider_kubernetes_probe, file_org_project_planton_provider_kubernetes_target_cluster, file_org_project_planton_provider_kubernetes_volume_mount, file_org_project_planton_shared_foreignkey_v1_foreign_key]);

/**
 * *
 * **KubernetesDeploymentSpec** defines the configuration for deploying a microservice on a Kubernetes cluster.
 * This message includes specifications for the microservice version, container configurations, ingress settings,
 * and availability options for zero-downtime deployments.
 *
 * @generated from message org.project_planton.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentSpec
 */
export type KubernetesDeploymentSpec = Message<"org.project_planton.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentSpec"> & {
  /**
   * Target Kubernetes Cluster
   *
   * @generated from field: org.project_planton.provider.kubernetes.KubernetesClusterSelector target_cluster = 1;
   */
  targetCluster?: KubernetesClusterSelector;

  /**
   * Kubernetes Namespace
   *
   * @generated from field: org.project_planton.shared.foreignkey.v1.StringValueOrRef namespace = 2;
   */
  namespace?: StringValueOrRef;

  /**
   * flag to indicate if the namespace should be created
   *
   * @generated from field: bool create_namespace = 3;
   */
  createNamespace: boolean;

  /**
   * The version of the microservice being deployed.
   * This is usually either "main" (the default git branch name) or "review-<id>" where <id> is the merge request number.
   * It must be between 1 and 30 characters and can only contain lowercase letters, numbers, and hyphens.
   *
   * @generated from field: string version = 4;
   */
  version: string;

  /**
   * The container specifications for the microservice deployment.
   * This includes configurations for the main application container and any sidecar containers.
   *
   * @generated from field: org.project_planton.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentContainer container = 5;
   */
  container?: KubernetesDeploymentContainer;

  /**
   * The ingress configuration for the microservice.
   * This defines how the microservice can be accessed externally.
   *
   * @generated from field: org.project_planton.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentIngress ingress = 6;
   */
  ingress?: KubernetesDeploymentIngress;

  /**
   * The availability configuration for the microservice.
   * This includes settings for replicas, autoscaling, deployment strategy, and pod disruption budgets.
   *
   * @generated from field: org.project_planton.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentAvailability availability = 7;
   */
  availability?: KubernetesDeploymentAvailability;

  /**
   * *
   * ConfigMaps to create alongside the deployment.
   * Key is the ConfigMap name, value is the content.
   * For multi-key ConfigMaps, use YAML format in the value.
   * These ConfigMaps can be referenced in volume mounts.
   *
   * Example:
   *   config_maps:
   *     app-config: |
   *       key1: value1
   *       key2: value2
   *     nginx-conf: |
   *       server {
   *         listen 80;
   *       }
   *
   * @generated from field: map<string, string> config_maps = 8;
   */
  configMaps: { [key: string]: string };
};

/**
 * Describes the message org.project_planton.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentSpec.
 * Use `create(KubernetesDeploymentSpecSchema)` to create a new message.
 */
export const KubernetesDeploymentSpecSchema: GenMessage<KubernetesDeploymentSpec> = /*@__PURE__*/
  messageDesc(file_org_project_planton_provider_kubernetes_kubernetesdeployment_v1_spec, 0);

/**
 * *
 * KubernetesDeploymentIngress defines ingress configuration for the deployment.
 *
 * @generated from message org.project_planton.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentIngress
 */
export type KubernetesDeploymentIngress = Message<"org.project_planton.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentIngress"> & {
  /**
   * Flag to enable or disable ingress.
   *
   * @generated from field: bool enabled = 1;
   */
  enabled: boolean;

  /**
   * The full hostname for external access (e.g., "myapp.example.com").
   * Required when enabled is true.
   *
   * @generated from field: string hostname = 2;
   */
  hostname: string;
};

/**
 * Describes the message org.project_planton.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentIngress.
 * Use `create(KubernetesDeploymentIngressSchema)` to create a new message.
 */
export const KubernetesDeploymentIngressSchema: GenMessage<KubernetesDeploymentIngress> = /*@__PURE__*/
  messageDesc(file_org_project_planton_provider_kubernetes_kubernetesdeployment_v1_spec, 1);

/**
 * *
 * **KubernetesDeploymentContainer** specifies the container configuration for the microservice.
 * It includes the main application container and any sidecar containers that need to run alongside it.
 *
 * @generated from message org.project_planton.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentContainer
 */
export type KubernetesDeploymentContainer = Message<"org.project_planton.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentContainer"> & {
  /**
   * The main application container specifications.
   *
   * @generated from field: org.project_planton.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentContainerApp app = 1;
   */
  app?: KubernetesDeploymentContainerApp;

  /**
   * A list of sidecar containers to be deployed alongside the main application container.
   *
   * @generated from field: repeated org.project_planton.provider.kubernetes.Container sidecars = 2;
   */
  sidecars: Container[];
};

/**
 * Describes the message org.project_planton.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentContainer.
 * Use `create(KubernetesDeploymentContainerSchema)` to create a new message.
 */
export const KubernetesDeploymentContainerSchema: GenMessage<KubernetesDeploymentContainer> = /*@__PURE__*/
  messageDesc(file_org_project_planton_provider_kubernetes_kubernetesdeployment_v1_spec, 2);

/**
 * *
 * **KubernetesDeploymentContainerApp** specifies the configuration for the main application container.
 * It includes the container image, resource allocations, environment variables, ports, and health probes.
 *
 * @generated from message org.project_planton.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentContainerApp
 */
export type KubernetesDeploymentContainerApp = Message<"org.project_planton.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentContainerApp"> & {
  /**
   * *
   * The container image to be used for the application.
   * This value is computed during creation but can be updated.
   * It is derived by combining the Docker repository of the artifact store configured for the environment and the code project path.
   * The `pull_secret_name` is the name of the image pull secret to be configured in the Kubernetes Deployment resource.
   * It is determined by looking up the `container_image_artifact_store_id` from the environment where the microservice is deployed.
   *
   * @generated from field: org.project_planton.provider.kubernetes.ContainerImage image = 1;
   */
  image?: ContainerImage;

  /**
   * The CPU and memory resources allocated to the application container.
   *
   * @generated from field: org.project_planton.provider.kubernetes.ContainerResources resources = 2;
   */
  resources?: ContainerResources;

  /**
   * *
   * The environment variables and secrets for the application container.
   *
   * @generated from field: org.project_planton.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentContainerAppEnv env = 3;
   */
  env?: KubernetesDeploymentContainerAppEnv;

  /**
   * *
   * A list of ports to be configured for the application container.
   *
   * @generated from field: repeated org.project_planton.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentContainerAppPort ports = 4;
   */
  ports: KubernetesDeploymentContainerAppPort[];

  /**
   * *
   * Liveness probe configuration.
   * Periodic probe of container liveness. Container will be restarted if the probe fails.
   * This helps detect and recover from deadlocks or unresponsive applications.
   * Reference: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
   *
   * @generated from field: org.project_planton.provider.kubernetes.Probe liveness_probe = 5;
   */
  livenessProbe?: Probe;

  /**
   * *
   * Readiness probe configuration.
   * Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails.
   * This ensures traffic is only routed to pods that are ready to handle requests.
   * Essential for zero-downtime deployments.
   * Reference: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
   *
   * @generated from field: org.project_planton.provider.kubernetes.Probe readiness_probe = 6;
   */
  readinessProbe?: Probe;

  /**
   * *
   * Startup probe configuration.
   * Indicates whether the application within the container is started.
   * All other probes are disabled if a startup probe is provided, until it succeeds.
   * Useful for slow-starting containers to avoid them getting killed by liveness probes before they are up.
   * Reference: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
   *
   * @generated from field: org.project_planton.provider.kubernetes.Probe startup_probe = 7;
   */
  startupProbe?: Probe;

  /**
   * *
   * Volume mounts for the application container.
   * Supports mounting ConfigMaps, Secrets, HostPaths, EmptyDirs, and PVCs.
   * ConfigMaps defined in spec.config_maps can be referenced here.
   *
   * Example:
   *   volume_mounts:
   *     - name: config-volume
   *       mount_path: /etc/app/config.yaml
   *       config_map:
   *         name: app-config
   *         key: app-config
   *
   * @generated from field: repeated org.project_planton.provider.kubernetes.VolumeMount volume_mounts = 8;
   */
  volumeMounts: VolumeMount[];

  /**
   * *
   * Command to run in the container (overrides the container image's ENTRYPOINT).
   * Example: ["/bin/sh", "-c"]
   *
   * @generated from field: repeated string command = 9;
   */
  command: string[];

  /**
   * *
   * Arguments to pass to the command (overrides the container image's CMD).
   * Example: ["echo hello"]
   *
   * @generated from field: repeated string args = 10;
   */
  args: string[];
};

/**
 * Describes the message org.project_planton.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentContainerApp.
 * Use `create(KubernetesDeploymentContainerAppSchema)` to create a new message.
 */
export const KubernetesDeploymentContainerAppSchema: GenMessage<KubernetesDeploymentContainerApp> = /*@__PURE__*/
  messageDesc(file_org_project_planton_provider_kubernetes_kubernetesdeployment_v1_spec, 3);

/**
 * *
 * **KubernetesDeploymentContainerAppEnv** defines the environment variables and secrets for the application container.
 *
 * @generated from message org.project_planton.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentContainerAppEnv
 */
export type KubernetesDeploymentContainerAppEnv = Message<"org.project_planton.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentContainerAppEnv"> & {
  /**
   * *
   * A map of environment variable names to their values.
   *
   * @generated from field: map<string, string> variables = 1;
   */
  variables: { [key: string]: string };

  /**
   * *
   * A map of secret names to their values.
   *
   * @generated from field: map<string, string> secrets = 2;
   */
  secrets: { [key: string]: string };
};

/**
 * Describes the message org.project_planton.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentContainerAppEnv.
 * Use `create(KubernetesDeploymentContainerAppEnvSchema)` to create a new message.
 */
export const KubernetesDeploymentContainerAppEnvSchema: GenMessage<KubernetesDeploymentContainerAppEnv> = /*@__PURE__*/
  messageDesc(file_org_project_planton_provider_kubernetes_kubernetesdeployment_v1_spec, 4);

/**
 * *
 * **KubernetesDeploymentContainerAppPort** specifies the port configuration for the application container.
 * It includes details such as the port name, container port, network protocol, application protocol, and service port.
 *
 * @generated from message org.project_planton.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentContainerAppPort
 */
export type KubernetesDeploymentContainerAppPort = Message<"org.project_planton.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentContainerAppPort"> & {
  /**
   * The name of the port (e.g., "http", "grpc").
   * The name must only contain lowercase alphanumeric characters and hyphens.
   * Port names must also start and end with an alphanumeric character.
   * For example, "123-abc" and "web" are valid, but "123_abc" and "-web" are not.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The port number on the container.
   *
   * @generated from field: int32 container_port = 2;
   */
  containerPort: number;

  /**
   * The network protocol used by the port (e.g., "TCP", "UDP", "SCTP").
   * Must be one of "TCP", "UDP", or "SCTP".
   *
   * @generated from field: string network_protocol = 3;
   */
  networkProtocol: string;

  /**
   * The application protocol for the microservice (e.g., "http").
   * This field is used for setting up the name of the service port in Kubernetes.
   * It is used during microservice deployment and is relevant for deployment and stateful set pod managers.
   * Refer to: https://kubernetes.io/docs/concepts/services-networking/service/#application-protocol
   *
   * @generated from field: string app_protocol = 4;
   */
  appProtocol: string;

  /**
   * The port number on the Kubernetes service.
   *
   * @generated from field: int32 service_port = 5;
   */
  servicePort: number;

  /**
   * A flag indicating whether this port should be exposed via ingress.
   *
   * @generated from field: bool is_ingress_port = 6;
   */
  isIngressPort: boolean;
};

/**
 * Describes the message org.project_planton.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentContainerAppPort.
 * Use `create(KubernetesDeploymentContainerAppPortSchema)` to create a new message.
 */
export const KubernetesDeploymentContainerAppPortSchema: GenMessage<KubernetesDeploymentContainerAppPort> = /*@__PURE__*/
  messageDesc(file_org_project_planton_provider_kubernetes_kubernetesdeployment_v1_spec, 5);

/**
 * *
 * **KubernetesDeploymentAvailability** specifies the availability configuration for the microservice.
 * Groups all settings related to high availability: replicas, autoscaling, deployment strategy, and disruption budgets.
 * Proper configuration of these fields enables zero-downtime deployments and resilient operations.
 *
 * @generated from message org.project_planton.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentAvailability
 */
export type KubernetesDeploymentAvailability = Message<"org.project_planton.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentAvailability"> & {
  /**
   * The minimum number of pod replicas to maintain.
   *
   * @generated from field: int32 min_replicas = 1;
   */
  minReplicas: number;

  /**
   * The configuration for horizontal pod autoscaling.
   *
   * @generated from field: org.project_planton.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentAvailabilityHpa horizontal_pod_autoscaling = 2;
   */
  horizontalPodAutoscaling?: KubernetesDeploymentAvailabilityHpa;

  /**
   * Deployment strategy configuration for rolling updates.
   * Controls how pod updates are rolled out to achieve zero-downtime deployments.
   * If not specified, uses Kubernetes default (maxUnavailable: 25%, maxSurge: 25%).
   *
   * @generated from field: org.project_planton.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentDeploymentStrategy deployment_strategy = 3;
   */
  deploymentStrategy?: KubernetesDeploymentDeploymentStrategy;

  /**
   * Pod disruption budget configuration.
   * Ensures minimum availability during voluntary disruptions (node maintenance, cluster upgrades).
   * Helps prevent service outages during infrastructure operations.
   *
   * @generated from field: org.project_planton.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentPodDisruptionBudget pod_disruption_budget = 4;
   */
  podDisruptionBudget?: KubernetesDeploymentPodDisruptionBudget;
};

/**
 * Describes the message org.project_planton.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentAvailability.
 * Use `create(KubernetesDeploymentAvailabilitySchema)` to create a new message.
 */
export const KubernetesDeploymentAvailabilitySchema: GenMessage<KubernetesDeploymentAvailability> = /*@__PURE__*/
  messageDesc(file_org_project_planton_provider_kubernetes_kubernetesdeployment_v1_spec, 6);

/**
 * *
 * **KubernetesDeploymentAvailabilityHpa** specifies the horizontal pod autoscaling configuration.
 * It includes settings to enable autoscaling based on CPU and memory utilization.
 *
 * @generated from message org.project_planton.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentAvailabilityHpa
 */
export type KubernetesDeploymentAvailabilityHpa = Message<"org.project_planton.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentAvailabilityHpa"> & {
  /**
   * A flag to enable or disable horizontal pod autoscaling.
   *
   * @generated from field: bool is_enabled = 1;
   */
  isEnabled: boolean;

  /**
   * The target CPU utilization percentage to trigger autoscaling (e.g., 60.0).
   *
   * @generated from field: double target_cpu_utilization_percent = 2;
   */
  targetCpuUtilizationPercent: number;

  /**
   * The target memory utilization to trigger autoscaling (e.g., "1Gi").
   *
   * @generated from field: string target_memory_utilization = 3;
   */
  targetMemoryUtilization: string;
};

/**
 * Describes the message org.project_planton.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentAvailabilityHpa.
 * Use `create(KubernetesDeploymentAvailabilityHpaSchema)` to create a new message.
 */
export const KubernetesDeploymentAvailabilityHpaSchema: GenMessage<KubernetesDeploymentAvailabilityHpa> = /*@__PURE__*/
  messageDesc(file_org_project_planton_provider_kubernetes_kubernetesdeployment_v1_spec, 7);

/**
 * *
 * **KubernetesDeploymentDeploymentStrategy** defines the deployment strategy for rolling updates.
 * This controls how Kubernetes replaces old pods with new ones during updates.
 * Proper configuration enables zero-downtime deployments.
 * Reference: https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#strategy
 *
 * @generated from message org.project_planton.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentDeploymentStrategy
 */
export type KubernetesDeploymentDeploymentStrategy = Message<"org.project_planton.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentDeploymentStrategy"> & {
  /**
   * *
   * The maximum number of pods that can be unavailable during the update.
   * Can be an absolute number (e.g., 0) or a percentage of desired pods (e.g., "25%").
   *
   * For zero-downtime deployments, set to 0 or "0%".
   * This ensures at least the desired number of pods are always available.
   *
   * Defaults to 25% if not specified.
   * Cannot be 0 if max_surge is also 0.
   *
   * @generated from field: string max_unavailable = 1;
   */
  maxUnavailable: string;

  /**
   * *
   * The maximum number of pods that can be created above the desired number of pods.
   * Can be an absolute number (e.g., 1) or a percentage of desired pods (e.g., "25%").
   *
   * For zero-downtime deployments with max_unavailable=0, set to at least 1 or "100%".
   * This allows new pods to be created before old ones are terminated.
   *
   * Defaults to 25% if not specified.
   * Cannot be 0 if max_unavailable is also 0.
   *
   * @generated from field: string max_surge = 2;
   */
  maxSurge: string;
};

/**
 * Describes the message org.project_planton.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentDeploymentStrategy.
 * Use `create(KubernetesDeploymentDeploymentStrategySchema)` to create a new message.
 */
export const KubernetesDeploymentDeploymentStrategySchema: GenMessage<KubernetesDeploymentDeploymentStrategy> = /*@__PURE__*/
  messageDesc(file_org_project_planton_provider_kubernetes_kubernetesdeployment_v1_spec, 8);

/**
 * *
 * **KubernetesDeploymentPodDisruptionBudget** configures a PodDisruptionBudget (PDB) to ensure
 * minimum availability during voluntary disruptions like node maintenance or cluster upgrades.
 * Reference: https://kubernetes.io/docs/concepts/workloads/pods/disruptions/
 *
 * @generated from message org.project_planton.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentPodDisruptionBudget
 */
export type KubernetesDeploymentPodDisruptionBudget = Message<"org.project_planton.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentPodDisruptionBudget"> & {
  /**
   * *
   * Enable or disable PodDisruptionBudget creation.
   * When disabled, no PDB is created and the cluster can evict pods freely.
   * When enabled, the cluster must respect the min_available constraint.
   *
   * @generated from field: bool enabled = 1;
   */
  enabled: boolean;

  /**
   * *
   * Minimum number of pods that must be available during voluntary disruptions.
   * Can be an absolute number (e.g., 1) or a percentage (e.g., "50%").
   *
   * For high availability, typically set to:
   * - 1 for single-replica services (ensures at least one pod always available)
   * - N-1 for N-replica services (allows one pod to be disrupted at a time)
   * - A percentage like "50%" for large replica counts
   *
   * Cannot be used together with max_unavailable.
   * If both min_available and max_unavailable are not set, defaults to 1.
   *
   * @generated from field: string min_available = 2;
   */
  minAvailable: string;

  /**
   * *
   * Maximum number of pods that can be unavailable during voluntary disruptions.
   * Can be an absolute number (e.g., 1) or a percentage (e.g., "50%").
   *
   * This is an alternative to min_available.
   * Cannot be used together with min_available.
   *
   * @generated from field: string max_unavailable = 3;
   */
  maxUnavailable: string;
};

/**
 * Describes the message org.project_planton.provider.kubernetes.kubernetesdeployment.v1.KubernetesDeploymentPodDisruptionBudget.
 * Use `create(KubernetesDeploymentPodDisruptionBudgetSchema)` to create a new message.
 */
export const KubernetesDeploymentPodDisruptionBudgetSchema: GenMessage<KubernetesDeploymentPodDisruptionBudget> = /*@__PURE__*/
  messageDesc(file_org_project_planton_provider_kubernetes_kubernetesdeployment_v1_spec, 9);

